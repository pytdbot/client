from typing import Union, Literal, List
from base64 import b64decode
from .bound_methods import (
    MessageBoundMethods,
    FileBoundMethods,
    CallbackQueryBoundMethods,
)
import pytdbot


class TlObject:
    """Base class for TL Objects"""

    def __getitem__(self, item):
        if item == "@type":
            return self.getType()

        return self.__dict__[item]

    def __setitem__(self, item, value):
        self.__dict__[item] = value

    def __bool__(self):
        return not isinstance(self, Error)

    @property
    def is_error(self):  # for backward compatibility
        return isinstance(self, Error)

    @property
    def limited_seconds(self):
        if self.is_error and self.code == 429:
            return pytdbot.utils.get_retry_after_time(self.message)
        else:
            return 0

    def getType(self):
        raise NotImplementedError

    def getClass(self):
        raise NotImplementedError

    def to_dict(self) -> dict:
        raise NotImplementedError

    @classmethod
    def from_dict(cls, data: dict):
        raise NotImplementedError


class AuthenticationCodeType:
    r"""Provides information about the method by which an authentication code is delivered to the user"""

    pass


class EmailAddressAuthentication:
    r"""Contains authentication data for an email address"""

    pass


class EmailAddressResetState:
    r"""Describes reset state of an email address"""

    pass


class AuthorizationState:
    r"""Represents the current authorization state of the TDLib client"""

    pass


class FirebaseDeviceVerificationParameters:
    r"""Describes parameters to be used for device verification"""

    pass


class InputFile:
    r"""Points to a file"""

    pass


class ThumbnailFormat:
    r"""Describes format of a thumbnail"""

    pass


class MaskPoint:
    r"""Part of the face, relative to which a mask is placed"""

    pass


class StickerFormat:
    r"""Describes format of a sticker"""

    pass


class StickerType:
    r"""Describes type of sticker"""

    pass


class StickerFullType:
    r"""Contains full information about sticker type"""

    pass


class PollType:
    r"""Describes the type of poll"""

    pass


class UserType:
    r"""Represents the type of user\. The following types are possible: regular users, deleted users and bots"""

    pass


class BusinessAwayMessageSchedule:
    r"""Describes conditions for sending of away messages by a Telegram Business account"""

    pass


class ChatPhotoStickerType:
    r"""Describes type of sticker, which was used to create a chat photo"""

    pass


class InputChatPhoto:
    r"""Describes a photo to be set as a user profile or chat photo"""

    pass


class StarSubscriptionType:
    r"""Describes type of subscription paid in Telegram Stars"""

    pass


class AffiliateType:
    r"""Describes type of affiliate for an affiliate program"""

    pass


class AffiliateProgramSortOrder:
    r"""Describes the order of the found affiliate programs"""

    pass


class SentGift:
    r"""Represents content of a gift received by a user or a channel chat"""

    pass


class StarTransactionDirection:
    r"""Describes direction of a transaction with Telegram Stars"""

    pass


class StarTransactionType:
    r"""Describes type of transaction with Telegram Stars"""

    pass


class GiveawayParticipantStatus:
    r"""Contains information about status of a user in a giveaway"""

    pass


class GiveawayInfo:
    r"""Contains information about a giveaway"""

    pass


class GiveawayPrize:
    r"""Contains information about a giveaway prize"""

    pass


class EmojiStatusType:
    r"""Describes type of emoji status"""

    pass


class ChatMemberStatus:
    r"""Provides information about the status of a member in a chat"""

    pass


class ChatMembersFilter:
    r"""Specifies the kind of chat members to return in searchChatMembers"""

    pass


class SupergroupMembersFilter:
    r"""Specifies the kind of chat members to return in getSupergroupMembers"""

    pass


class InviteLinkChatType:
    r"""Describes the type of chat to which points an invite link"""

    pass


class SecretChatState:
    r"""Describes the current secret chat state"""

    pass


class MessageSender:
    r"""Contains information about the sender of a message"""

    pass


class MessageReadDate:
    r"""Describes read date of a recent outgoing message in a private chat"""

    pass


class MessageOrigin:
    r"""Contains information about the origin of a message"""

    pass


class ReactionType:
    r"""Describes type of message reaction"""

    pass


class PaidReactionType:
    r"""Describes type of paid message reaction"""

    pass


class MessageEffectType:
    r"""Describes type of emoji effect"""

    pass


class MessageSendingState:
    r"""Contains information about the sending state of the message"""

    pass


class MessageReplyTo:
    r"""Contains information about the message or the story a message is replying to"""

    pass


class InputMessageReplyTo:
    r"""Contains information about the message or the story to be replied"""

    pass


class MessageSource:
    r"""Describes source of a message"""

    pass


class ReportSponsoredResult:
    r"""Describes result of sponsored message or chat report"""

    pass


class NotificationSettingsScope:
    r"""Describes the types of chats to which notification settings are relevant"""

    pass


class ReactionNotificationSource:
    r"""Describes sources of reactions for which notifications will be shown"""

    pass


class ChatType:
    r"""Describes the type of chat"""

    pass


class ChatList:
    r"""Describes a list of chats"""

    pass


class ChatSource:
    r"""Describes a reason why an external chat is shown in a chat list"""

    pass


class ChatAvailableReactions:
    r"""Describes reactions available in the chat"""

    pass


class PublicChatType:
    r"""Describes type of public chat"""

    pass


class ChatActionBar:
    r"""Describes actions which must be possible to do through a chat action bar"""

    pass


class KeyboardButtonType:
    r"""Describes a keyboard button type"""

    pass


class InlineKeyboardButtonType:
    r"""Describes the type of inline keyboard button"""

    pass


class ReplyMarkup:
    r"""Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots"""

    pass


class LoginUrlInfo:
    r"""Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl"""

    pass


class WebAppOpenMode:
    r"""Describes mode in which a Web App is opened"""

    pass


class SavedMessagesTopicType:
    r"""Describes type of Saved Messages topic"""

    pass


class RichText:
    r"""Describes a formatted text object"""

    pass


class PageBlockHorizontalAlignment:
    r"""Describes a horizontal alignment of a table cell content"""

    pass


class PageBlockVerticalAlignment:
    r"""Describes a Vertical alignment of a table cell content"""

    pass


class PageBlock:
    r"""Describes a block of an instant view for a web page"""

    pass


class LinkPreviewAlbumMedia:
    r"""Describes a media from a link preview album"""

    pass


class LinkPreviewType:
    r"""Describes type of link preview"""

    pass


class CollectibleItemType:
    r"""Describes a collectible item that can be purchased at https://fragment\.com"""

    pass


class InputCredentials:
    r"""Contains information about the payment method chosen by the user"""

    pass


class PaymentProvider:
    r"""Contains information about a payment provider"""

    pass


class PaymentFormType:
    r"""Describes type of payment form"""

    pass


class PaymentReceiptType:
    r"""Describes type of successful payment"""

    pass


class InputInvoice:
    r"""Describes an invoice to process"""

    pass


class PaidMedia:
    r"""Describes a paid media"""

    pass


class PassportElementType:
    r"""Contains the type of Telegram Passport element"""

    pass


class PassportElement:
    r"""Contains information about a Telegram Passport element"""

    pass


class InputPassportElement:
    r"""Contains information about a Telegram Passport element to be saved"""

    pass


class PassportElementErrorSource:
    r"""Contains the description of an error in a Telegram Passport element"""

    pass


class InputPassportElementErrorSource:
    r"""Contains the description of an error in a Telegram Passport element; for bots only"""

    pass


class MessageContent:
    r"""Contains the content of a message"""

    pass


class TextEntityType:
    r"""Represents a part of the text which must be formatted differently"""

    pass


class InputPaidMediaType:
    r"""Describes type of paid media to sent"""

    pass


class MessageSchedulingState:
    r"""Contains information about the time when a scheduled message will be sent"""

    pass


class MessageSelfDestructType:
    r"""Describes when a message will be self\-destructed"""

    pass


class InputMessageContent:
    r"""The content of a message to send"""

    pass


class SearchMessagesFilter:
    r"""Represents a filter for message search results"""

    pass


class SearchMessagesChatTypeFilter:
    r"""Represents a filter for type of the chats in which to search messages"""

    pass


class ChatAction:
    r"""Describes the different types of activity in a chat"""

    pass


class UserStatus:
    r"""Describes the last time the user was online"""

    pass


class EmojiCategorySource:
    r"""Describes source of stickers for an emoji category"""

    pass


class EmojiCategoryType:
    r"""Describes type of emoji category"""

    pass


class StoryAreaType:
    r"""Describes type of clickable area on a story media"""

    pass


class InputStoryAreaType:
    r"""Describes type of clickable area on a story media to be added"""

    pass


class StoryContent:
    r"""Contains the content of a story"""

    pass


class InputStoryContent:
    r"""The content of a story to send"""

    pass


class StoryList:
    r"""Describes a list of stories"""

    pass


class StoryOrigin:
    r"""Contains information about the origin of a story that was reposted"""

    pass


class StoryInteractionType:
    r"""Describes type of interaction with a story"""

    pass


class PublicForward:
    r"""Describes a public forward or repost of a story"""

    pass


class ChatBoostSource:
    r"""Describes source of a chat boost"""

    pass


class ResendCodeReason:
    r"""Describes the reason why a code needs to be re\-sent"""

    pass


class CallDiscardReason:
    r"""Describes the reason why a call was discarded"""

    pass


class CallServerType:
    r"""Describes the type of call server"""

    pass


class CallState:
    r"""Describes the current call state"""

    pass


class GroupCallVideoQuality:
    r"""Describes the quality of a group call video"""

    pass


class CallProblem:
    r"""Describes the exact type of problem with a call"""

    pass


class FirebaseAuthenticationSettings:
    r"""Contains settings for Firebase Authentication in the official applications"""

    pass


class ReactionUnavailabilityReason:
    r"""Describes why the current user can't add reactions to the message, despite some other users can"""

    pass


class DiceStickers:
    r"""Contains animated stickers which must be used for dice animation rendering"""

    pass


class SpeechRecognitionResult:
    r"""Describes result of speech recognition in a voice note"""

    pass


class BotWriteAccessAllowReason:
    r"""Describes a reason why a bot was allowed to write messages to the current user"""

    pass


class TargetChat:
    r"""Describes the target chat to be opened"""

    pass


class InputInlineQueryResult:
    r"""Represents a single result of an inline query; for bots only"""

    pass


class InlineQueryResult:
    r"""Represents a single result of an inline query"""

    pass


class InlineQueryResultsButtonType:
    r"""Represents type of button in results of inline query"""

    pass


class CallbackQueryPayload:
    r"""Represents a payload of a callback query"""

    pass


class ChatEventAction:
    r"""Represents a chat event"""

    pass


class LanguagePackStringValue:
    r"""Represents the value of a string in a language pack"""

    pass


class PremiumLimitType:
    r"""Describes type of limit, increased for Premium users"""

    pass


class PremiumFeature:
    r"""Describes a feature available to Premium users"""

    pass


class BusinessFeature:
    r"""Describes a feature available to Business user accounts"""

    pass


class PremiumStoryFeature:
    r"""Describes a story feature available to Premium users"""

    pass


class PremiumSource:
    r"""Describes a source from which the Premium features screen is opened"""

    pass


class StorePaymentPurpose:
    r"""Describes a purpose of an in\-store payment"""

    pass


class StoreTransaction:
    r"""Describes an in\-store transaction"""

    pass


class TelegramPaymentPurpose:
    r"""Describes a purpose of a payment toward Telegram"""

    pass


class DeviceToken:
    r"""Represents a data needed to subscribe for push notifications through registerDevice method\. To use specific push notification service, the correct application platform must be specified and a valid server authentication data must be uploaded at https://my\.telegram\.org"""

    pass


class BackgroundFill:
    r"""Describes a fill of a background"""

    pass


class BackgroundType:
    r"""Describes the type of background"""

    pass


class InputBackground:
    r"""Contains information about background to set"""

    pass


class CanSendStoryResult:
    r"""Represents result of checking whether the current user can send a story in the specific chat"""

    pass


class CanTransferOwnershipResult:
    r"""Represents result of checking whether the current session can be used to transfer a chat ownership to another user"""

    pass


class CheckChatUsernameResult:
    r"""Represents result of checking whether a username can be set for a chat"""

    pass


class CheckStickerSetNameResult:
    r"""Represents result of checking whether a name can be used for a new sticker set"""

    pass


class ResetPasswordResult:
    r"""Represents result of 2\-step verification password reset"""

    pass


class MessageFileType:
    r"""Contains information about a file with messages exported from another app"""

    pass


class PushMessageContent:
    r"""Contains content of a push message notification"""

    pass


class NotificationType:
    r"""Contains detailed information about a notification"""

    pass


class NotificationGroupType:
    r"""Describes the type of notifications in a notification group"""

    pass


class OptionValue:
    r"""Represents the value of an option"""

    pass


class JsonValue:
    r"""Represents a JSON value"""

    pass


class StoryPrivacySettings:
    r"""Describes privacy settings of a story"""

    pass


class UserPrivacySettingRule:
    r"""Represents a single rule for managing user privacy settings"""

    pass


class UserPrivacySetting:
    r"""Describes available user privacy settings"""

    pass


class CanSendMessageToUserResult:
    r"""Describes result of canSendMessageToUser"""

    pass


class SessionType:
    r"""Represents the type of session"""

    pass


class ReportReason:
    r"""Describes the reason why a chat is reported"""

    pass


class ReportChatResult:
    r"""Describes result of chat report"""

    pass


class ReportStoryResult:
    r"""Describes result of story report"""

    pass


class InternalLinkType:
    r"""Describes an internal https://t\.me or tg: link, which must be processed by the application in a special way"""

    pass


class BlockList:
    r"""Describes type of block list"""

    pass


class FileType:
    r"""Represents the type of file"""

    pass


class NetworkType:
    r"""Represents the type of network"""

    pass


class NetworkStatisticsEntry:
    r"""Contains statistics about network usage"""

    pass


class AutosaveSettingsScope:
    r"""Describes scope of autosave settings"""

    pass


class ConnectionState:
    r"""Describes the current state of the connection to Telegram servers"""

    pass


class TopChatCategory:
    r"""Represents the categories of chats for which a list of frequently used chats can be retrieved"""

    pass


class TMeUrlType:
    r"""Describes the type of URL linking to an internal Telegram entity"""

    pass


class SuggestedAction:
    r"""Describes an action suggested to the current user"""

    pass


class TextParseMode:
    r"""Describes the way the text needs to be parsed for text entities"""

    pass


class ProxyType:
    r"""Describes the type of proxy server"""

    pass


class StatisticalGraph:
    r"""Describes a statistical graph"""

    pass


class ChatStatisticsObjectType:
    r"""Describes type of object, for which statistics are provided"""

    pass


class ChatStatistics:
    r"""Contains a detailed statistics about a chat"""

    pass


class RevenueWithdrawalState:
    r"""Describes state of a revenue withdrawal"""

    pass


class ChatRevenueTransactionType:
    r"""Describes type of transaction for revenue earned from sponsored messages in a chat"""

    pass


class VectorPathCommand:
    r"""Represents a vector path command"""

    pass


class BotCommandScope:
    r"""Represents the scope to which bot commands are relevant"""

    pass


class PhoneNumberCodeType:
    r"""Describes type of the request for which a code is sent to a phone number"""

    pass


class Update:
    r"""Contains notifications about data changes"""

    pass


class LogStream:
    r"""Describes a stream to which TDLib internal log is written"""

    pass


class Error(TlObject):
    r"""An object of this type can be returned on every function call, in case of an error

    Parameters:
        code (:class:`int`):
            Error code; subject to future changes\. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user

        message (:class:`str`):
            Error message; subject to future changes

    """

    def __init__(self, code: int = 0, message: str = "") -> None:
        self.code: int = int(code)
        r"""Error code; subject to future changes\. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user"""
        self.message: Union[str, None] = message
        r"""Error message; subject to future changes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["error"]:
        return "error"

    def getClass(self) -> Literal["Error"]:
        return "Error"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "code": self.code, "message": self.message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Error", None]:
        if data:
            data_class = cls()
            data_class.code = int(data.get("code", 0))
            data_class.message = data.get("message", "")

        return data_class


class Ok(TlObject):
    r"""An object of this type is returned on a successful function call for certain functions"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["ok"]:
        return "ok"

    def getClass(self) -> Literal["Ok"]:
        return "Ok"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Ok", None]:
        if data:
            data_class = cls()

        return data_class


class AuthenticationCodeTypeTelegramMessage(TlObject, AuthenticationCodeType):
    r"""A digit\-only authentication code is delivered via a private Telegram message, which can be viewed from another active session

    Parameters:
        length (:class:`int`):
            Length of the code

    """

    def __init__(self, length: int = 0) -> None:
        self.length: int = int(length)
        r"""Length of the code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeTelegramMessage"]:
        return "authenticationCodeTypeTelegramMessage"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "length": self.length}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["AuthenticationCodeTypeTelegramMessage", None]:
        if data:
            data_class = cls()
            data_class.length = int(data.get("length", 0))

        return data_class


class AuthenticationCodeTypeSms(TlObject, AuthenticationCodeType):
    r"""A digit\-only authentication code is delivered via an SMS message to the specified phone number; non\-official applications may not receive this type of code

    Parameters:
        length (:class:`int`):
            Length of the code

    """

    def __init__(self, length: int = 0) -> None:
        self.length: int = int(length)
        r"""Length of the code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeSms"]:
        return "authenticationCodeTypeSms"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "length": self.length}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeSms", None]:
        if data:
            data_class = cls()
            data_class.length = int(data.get("length", 0))

        return data_class


class AuthenticationCodeTypeSmsWord(TlObject, AuthenticationCodeType):
    r"""An authentication code is a word delivered via an SMS message to the specified phone number; non\-official applications may not receive this type of code

    Parameters:
        first_letter (:class:`str`):
            The first letters of the word if known

    """

    def __init__(self, first_letter: str = "") -> None:
        self.first_letter: Union[str, None] = first_letter
        r"""The first letters of the word if known"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeSmsWord"]:
        return "authenticationCodeTypeSmsWord"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "first_letter": self.first_letter}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeSmsWord", None]:
        if data:
            data_class = cls()
            data_class.first_letter = data.get("first_letter", "")

        return data_class


class AuthenticationCodeTypeSmsPhrase(TlObject, AuthenticationCodeType):
    r"""An authentication code is a phrase from multiple words delivered via an SMS message to the specified phone number; non\-official applications may not receive this type of code

    Parameters:
        first_word (:class:`str`):
            The first word of the phrase if known

    """

    def __init__(self, first_word: str = "") -> None:
        self.first_word: Union[str, None] = first_word
        r"""The first word of the phrase if known"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeSmsPhrase"]:
        return "authenticationCodeTypeSmsPhrase"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "first_word": self.first_word}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeSmsPhrase", None]:
        if data:
            data_class = cls()
            data_class.first_word = data.get("first_word", "")

        return data_class


class AuthenticationCodeTypeCall(TlObject, AuthenticationCodeType):
    r"""A digit\-only authentication code is delivered via a phone call to the specified phone number

    Parameters:
        length (:class:`int`):
            Length of the code

    """

    def __init__(self, length: int = 0) -> None:
        self.length: int = int(length)
        r"""Length of the code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeCall"]:
        return "authenticationCodeTypeCall"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "length": self.length}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeCall", None]:
        if data:
            data_class = cls()
            data_class.length = int(data.get("length", 0))

        return data_class


class AuthenticationCodeTypeFlashCall(TlObject, AuthenticationCodeType):
    r"""An authentication code is delivered by an immediately canceled call to the specified phone number\. The phone number that calls is the code that must be entered automatically

    Parameters:
        pattern (:class:`str`):
            Pattern of the phone number from which the call will be made

    """

    def __init__(self, pattern: str = "") -> None:
        self.pattern: Union[str, None] = pattern
        r"""Pattern of the phone number from which the call will be made"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeFlashCall"]:
        return "authenticationCodeTypeFlashCall"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "pattern": self.pattern}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeFlashCall", None]:
        if data:
            data_class = cls()
            data_class.pattern = data.get("pattern", "")

        return data_class


class AuthenticationCodeTypeMissedCall(TlObject, AuthenticationCodeType):
    r"""An authentication code is delivered by an immediately canceled call to the specified phone number\. The last digits of the phone number that calls are the code that must be entered manually by the user

    Parameters:
        phone_number_prefix (:class:`str`):
            Prefix of the phone number from which the call will be made

        length (:class:`int`):
            Number of digits in the code, excluding the prefix

    """

    def __init__(self, phone_number_prefix: str = "", length: int = 0) -> None:
        self.phone_number_prefix: Union[str, None] = phone_number_prefix
        r"""Prefix of the phone number from which the call will be made"""
        self.length: int = int(length)
        r"""Number of digits in the code, excluding the prefix"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeMissedCall"]:
        return "authenticationCodeTypeMissedCall"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "phone_number_prefix": self.phone_number_prefix,
            "length": self.length,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeMissedCall", None]:
        if data:
            data_class = cls()
            data_class.phone_number_prefix = data.get("phone_number_prefix", "")
            data_class.length = int(data.get("length", 0))

        return data_class


class AuthenticationCodeTypeFragment(TlObject, AuthenticationCodeType):
    r"""A digit\-only authentication code is delivered to https://fragment\.com\. The user must be logged in there via a wallet owning the phone number's NFT

    Parameters:
        url (:class:`str`):
            URL to open to receive the code

        length (:class:`int`):
            Length of the code

    """

    def __init__(self, url: str = "", length: int = 0) -> None:
        self.url: Union[str, None] = url
        r"""URL to open to receive the code"""
        self.length: int = int(length)
        r"""Length of the code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeFragment"]:
        return "authenticationCodeTypeFragment"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url, "length": self.length}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeFragment", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.length = int(data.get("length", 0))

        return data_class


class AuthenticationCodeTypeFirebaseAndroid(TlObject, AuthenticationCodeType):
    r"""A digit\-only authentication code is delivered via Firebase Authentication to the official Android application

    Parameters:
        device_verification_parameters (:class:`"types.FirebaseDeviceVerificationParameters"`):
            Parameters to be used for device verification

        length (:class:`int`):
            Length of the code

    """

    def __init__(
        self,
        device_verification_parameters: FirebaseDeviceVerificationParameters = None,
        length: int = 0,
    ) -> None:
        self.device_verification_parameters: Union[
            FirebaseDeviceVerificationParametersSafetyNet,
            FirebaseDeviceVerificationParametersPlayIntegrity,
            None,
        ] = device_verification_parameters
        r"""Parameters to be used for device verification"""
        self.length: int = int(length)
        r"""Length of the code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeFirebaseAndroid"]:
        return "authenticationCodeTypeFirebaseAndroid"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "device_verification_parameters": self.device_verification_parameters,
            "length": self.length,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["AuthenticationCodeTypeFirebaseAndroid", None]:
        if data:
            data_class = cls()
            data_class.device_verification_parameters = data.get(
                "device_verification_parameters", None
            )
            data_class.length = int(data.get("length", 0))

        return data_class


class AuthenticationCodeTypeFirebaseIos(TlObject, AuthenticationCodeType):
    r"""A digit\-only authentication code is delivered via Firebase Authentication to the official iOS application

    Parameters:
        receipt (:class:`str`):
            Receipt of successful application token validation to compare with receipt from push notification

        push_timeout (:class:`int`):
            Time after the next authentication method is expected to be used if verification push notification isn't received, in seconds

        length (:class:`int`):
            Length of the code

    """

    def __init__(
        self, receipt: str = "", push_timeout: int = 0, length: int = 0
    ) -> None:
        self.receipt: Union[str, None] = receipt
        r"""Receipt of successful application token validation to compare with receipt from push notification"""
        self.push_timeout: int = int(push_timeout)
        r"""Time after the next authentication method is expected to be used if verification push notification isn't received, in seconds"""
        self.length: int = int(length)
        r"""Length of the code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeTypeFirebaseIos"]:
        return "authenticationCodeTypeFirebaseIos"

    def getClass(self) -> Literal["AuthenticationCodeType"]:
        return "AuthenticationCodeType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "receipt": self.receipt,
            "push_timeout": self.push_timeout,
            "length": self.length,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeTypeFirebaseIos", None]:
        if data:
            data_class = cls()
            data_class.receipt = data.get("receipt", "")
            data_class.push_timeout = int(data.get("push_timeout", 0))
            data_class.length = int(data.get("length", 0))

        return data_class


class AuthenticationCodeInfo(TlObject):
    r"""Information about the authentication code that was sent

    Parameters:
        phone_number (:class:`str`):
            A phone number that is being authenticated

        type (:class:`"types.AuthenticationCodeType"`):
            The way the code was sent to the user

        next_type (:class:`"types.AuthenticationCodeType"`):
            The way the next code will be sent to the user; may be null

        timeout (:class:`int`):
            Timeout before the code can be re\-sent, in seconds

    """

    def __init__(
        self,
        phone_number: str = "",
        type: AuthenticationCodeType = None,
        next_type: AuthenticationCodeType = None,
        timeout: int = 0,
    ) -> None:
        self.phone_number: Union[str, None] = phone_number
        r"""A phone number that is being authenticated"""
        self.type: Union[
            AuthenticationCodeTypeTelegramMessage,
            AuthenticationCodeTypeSms,
            AuthenticationCodeTypeSmsWord,
            AuthenticationCodeTypeSmsPhrase,
            AuthenticationCodeTypeCall,
            AuthenticationCodeTypeFlashCall,
            AuthenticationCodeTypeMissedCall,
            AuthenticationCodeTypeFragment,
            AuthenticationCodeTypeFirebaseAndroid,
            AuthenticationCodeTypeFirebaseIos,
            None,
        ] = type
        r"""The way the code was sent to the user"""
        self.next_type: Union[
            AuthenticationCodeTypeTelegramMessage,
            AuthenticationCodeTypeSms,
            AuthenticationCodeTypeSmsWord,
            AuthenticationCodeTypeSmsPhrase,
            AuthenticationCodeTypeCall,
            AuthenticationCodeTypeFlashCall,
            AuthenticationCodeTypeMissedCall,
            AuthenticationCodeTypeFragment,
            AuthenticationCodeTypeFirebaseAndroid,
            AuthenticationCodeTypeFirebaseIos,
            None,
        ] = next_type
        r"""The way the next code will be sent to the user; may be null"""
        self.timeout: int = int(timeout)
        r"""Timeout before the code can be re\-sent, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authenticationCodeInfo"]:
        return "authenticationCodeInfo"

    def getClass(self) -> Literal["AuthenticationCodeInfo"]:
        return "AuthenticationCodeInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "phone_number": self.phone_number,
            "type": self.type,
            "next_type": self.next_type,
            "timeout": self.timeout,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthenticationCodeInfo", None]:
        if data:
            data_class = cls()
            data_class.phone_number = data.get("phone_number", "")
            data_class.type = data.get("type", None)
            data_class.next_type = data.get("next_type", None)
            data_class.timeout = int(data.get("timeout", 0))

        return data_class


class EmailAddressAuthenticationCodeInfo(TlObject):
    r"""Information about the email address authentication code that was sent

    Parameters:
        email_address_pattern (:class:`str`):
            Pattern of the email address to which an authentication code was sent

        length (:class:`int`):
            Length of the code; 0 if unknown

    """

    def __init__(self, email_address_pattern: str = "", length: int = 0) -> None:
        self.email_address_pattern: Union[str, None] = email_address_pattern
        r"""Pattern of the email address to which an authentication code was sent"""
        self.length: int = int(length)
        r"""Length of the code; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emailAddressAuthenticationCodeInfo"]:
        return "emailAddressAuthenticationCodeInfo"

    def getClass(self) -> Literal["EmailAddressAuthenticationCodeInfo"]:
        return "EmailAddressAuthenticationCodeInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "email_address_pattern": self.email_address_pattern,
            "length": self.length,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmailAddressAuthenticationCodeInfo", None]:
        if data:
            data_class = cls()
            data_class.email_address_pattern = data.get("email_address_pattern", "")
            data_class.length = int(data.get("length", 0))

        return data_class


class EmailAddressAuthenticationCode(TlObject, EmailAddressAuthentication):
    r"""An authentication code delivered to a user's email address

    Parameters:
        code (:class:`str`):
            The code

    """

    def __init__(self, code: str = "") -> None:
        self.code: Union[str, None] = code
        r"""The code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emailAddressAuthenticationCode"]:
        return "emailAddressAuthenticationCode"

    def getClass(self) -> Literal["EmailAddressAuthentication"]:
        return "EmailAddressAuthentication"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "code": self.code}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmailAddressAuthenticationCode", None]:
        if data:
            data_class = cls()
            data_class.code = data.get("code", "")

        return data_class


class EmailAddressAuthenticationAppleId(TlObject, EmailAddressAuthentication):
    r"""An authentication token received through Apple ID

    Parameters:
        token (:class:`str`):
            The token

    """

    def __init__(self, token: str = "") -> None:
        self.token: Union[str, None] = token
        r"""The token"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emailAddressAuthenticationAppleId"]:
        return "emailAddressAuthenticationAppleId"

    def getClass(self) -> Literal["EmailAddressAuthentication"]:
        return "EmailAddressAuthentication"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmailAddressAuthenticationAppleId", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")

        return data_class


class EmailAddressAuthenticationGoogleId(TlObject, EmailAddressAuthentication):
    r"""An authentication token received through Google ID

    Parameters:
        token (:class:`str`):
            The token

    """

    def __init__(self, token: str = "") -> None:
        self.token: Union[str, None] = token
        r"""The token"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emailAddressAuthenticationGoogleId"]:
        return "emailAddressAuthenticationGoogleId"

    def getClass(self) -> Literal["EmailAddressAuthentication"]:
        return "EmailAddressAuthentication"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmailAddressAuthenticationGoogleId", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")

        return data_class


class EmailAddressResetStateAvailable(TlObject, EmailAddressResetState):
    r"""Email address can be reset after the given period\. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number

    Parameters:
        wait_period (:class:`int`):
            Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium

    """

    def __init__(self, wait_period: int = 0) -> None:
        self.wait_period: int = int(wait_period)
        r"""Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emailAddressResetStateAvailable"]:
        return "emailAddressResetStateAvailable"

    def getClass(self) -> Literal["EmailAddressResetState"]:
        return "EmailAddressResetState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "wait_period": self.wait_period}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmailAddressResetStateAvailable", None]:
        if data:
            data_class = cls()
            data_class.wait_period = int(data.get("wait_period", 0))

        return data_class


class EmailAddressResetStatePending(TlObject, EmailAddressResetState):
    r"""Email address reset has already been requested\. Call resetAuthenticationEmailAddress to check whether immediate reset is possible

    Parameters:
        reset_in (:class:`int`):
            Left time before the email address will be reset, in seconds\. updateAuthorizationState is not sent when this field changes

    """

    def __init__(self, reset_in: int = 0) -> None:
        self.reset_in: int = int(reset_in)
        r"""Left time before the email address will be reset, in seconds\. updateAuthorizationState is not sent when this field changes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emailAddressResetStatePending"]:
        return "emailAddressResetStatePending"

    def getClass(self) -> Literal["EmailAddressResetState"]:
        return "EmailAddressResetState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "reset_in": self.reset_in}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmailAddressResetStatePending", None]:
        if data:
            data_class = cls()
            data_class.reset_in = int(data.get("reset_in", 0))

        return data_class


class TextEntity(TlObject):
    r"""Represents a part of the text that needs to be formatted in some unusual way

    Parameters:
        offset (:class:`int`):
            Offset of the entity, in UTF\-16 code units

        length (:class:`int`):
            Length of the entity, in UTF\-16 code units

        type (:class:`"types.TextEntityType"`):
            Type of the entity

    """

    def __init__(
        self, offset: int = 0, length: int = 0, type: TextEntityType = None
    ) -> None:
        self.offset: int = int(offset)
        r"""Offset of the entity, in UTF\-16 code units"""
        self.length: int = int(length)
        r"""Length of the entity, in UTF\-16 code units"""
        self.type: Union[
            TextEntityTypeMention,
            TextEntityTypeHashtag,
            TextEntityTypeCashtag,
            TextEntityTypeBotCommand,
            TextEntityTypeUrl,
            TextEntityTypeEmailAddress,
            TextEntityTypePhoneNumber,
            TextEntityTypeBankCardNumber,
            TextEntityTypeBold,
            TextEntityTypeItalic,
            TextEntityTypeUnderline,
            TextEntityTypeStrikethrough,
            TextEntityTypeSpoiler,
            TextEntityTypeCode,
            TextEntityTypePre,
            TextEntityTypePreCode,
            TextEntityTypeBlockQuote,
            TextEntityTypeExpandableBlockQuote,
            TextEntityTypeTextUrl,
            TextEntityTypeMentionName,
            TextEntityTypeCustomEmoji,
            TextEntityTypeMediaTimestamp,
            None,
        ] = type
        r"""Type of the entity"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntity"]:
        return "textEntity"

    def getClass(self) -> Literal["TextEntity"]:
        return "TextEntity"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "offset": self.offset,
            "length": self.length,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntity", None]:
        if data:
            data_class = cls()
            data_class.offset = int(data.get("offset", 0))
            data_class.length = int(data.get("length", 0))
            data_class.type = data.get("type", None)

        return data_class


class TextEntities(TlObject):
    r"""Contains a list of text entities

    Parameters:
        entities (:class:`List["types.TextEntity"]`):
            List of text entities

    """

    def __init__(self, entities: List[TextEntity] = None) -> None:
        self.entities: List[TextEntity] = entities or []
        r"""List of text entities"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntities"]:
        return "textEntities"

    def getClass(self) -> Literal["TextEntities"]:
        return "TextEntities"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "entities": self.entities}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntities", None]:
        if data:
            data_class = cls()
            data_class.entities = data.get("entities", None)

        return data_class


class FormattedText(TlObject):
    r"""A text with some entities

    Parameters:
        text (:class:`str`):
            The text

        entities (:class:`List["types.TextEntity"]`):
            Entities contained in the text\. Entities can be nested, but must not mutually intersect with each other\. Pre, Code and PreCode entities can't contain other entities\. BlockQuote entities can't contain other BlockQuote entities\. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities\. All other entities can't contain each other

    """

    def __init__(self, text: str = "", entities: List[TextEntity] = None) -> None:
        self.text: Union[str, None] = text
        r"""The text"""
        self.entities: List[TextEntity] = entities or []
        r"""Entities contained in the text\. Entities can be nested, but must not mutually intersect with each other\. Pre, Code and PreCode entities can't contain other entities\. BlockQuote entities can't contain other BlockQuote entities\. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities\. All other entities can't contain each other"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["formattedText"]:
        return "formattedText"

    def getClass(self) -> Literal["FormattedText"]:
        return "FormattedText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "entities": self.entities}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FormattedText", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.entities = data.get("entities", None)

        return data_class


class TermsOfService(TlObject):
    r"""Contains Telegram terms of service

    Parameters:
        text (:class:`"types.FormattedText"`):
            Text of the terms of service

        min_user_age (:class:`int`):
            The minimum age of a user to be able to accept the terms; 0 if age isn't restricted

        show_popup (:class:`bool`):
            True, if a blocking popup with terms of service must be shown to the user

    """

    def __init__(
        self,
        text: FormattedText = None,
        min_user_age: int = 0,
        show_popup: bool = False,
    ) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Text of the terms of service"""
        self.min_user_age: int = int(min_user_age)
        r"""The minimum age of a user to be able to accept the terms; 0 if age isn't restricted"""
        self.show_popup: bool = bool(show_popup)
        r"""True, if a blocking popup with terms of service must be shown to the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["termsOfService"]:
        return "termsOfService"

    def getClass(self) -> Literal["TermsOfService"]:
        return "TermsOfService"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "min_user_age": self.min_user_age,
            "show_popup": self.show_popup,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TermsOfService", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.min_user_age = int(data.get("min_user_age", 0))
            data_class.show_popup = data.get("show_popup", False)

        return data_class


class AuthorizationStateWaitTdlibParameters(TlObject, AuthorizationState):
    r"""Initialization parameters are needed\. Call setTdlibParameters to provide them"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitTdlibParameters"]:
        return "authorizationStateWaitTdlibParameters"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["AuthorizationStateWaitTdlibParameters", None]:
        if data:
            data_class = cls()

        return data_class


class AuthorizationStateWaitPhoneNumber(TlObject, AuthorizationState):
    r"""TDLib needs the user's phone number to authorize\. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitPhoneNumber"]:
        return "authorizationStateWaitPhoneNumber"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateWaitPhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class AuthorizationStateWaitPremiumPurchase(TlObject, AuthorizationState):
    r"""The user must buy Telegram Premium as an in\-store purchase to log in\. Call checkAuthenticationPremiumPurchase and then setAuthenticationPremiumPurchaseTransaction

    Parameters:
        store_product_id (:class:`str`):
            Identifier of the store product that must be bought

    """

    def __init__(self, store_product_id: str = "") -> None:
        self.store_product_id: Union[str, None] = store_product_id
        r"""Identifier of the store product that must be bought"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitPremiumPurchase"]:
        return "authorizationStateWaitPremiumPurchase"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "store_product_id": self.store_product_id}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["AuthorizationStateWaitPremiumPurchase", None]:
        if data:
            data_class = cls()
            data_class.store_product_id = data.get("store_product_id", "")

        return data_class


class AuthorizationStateWaitEmailAddress(TlObject, AuthorizationState):
    r"""TDLib needs the user's email address to authorize\. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed

    Parameters:
        allow_apple_id (:class:`bool`):
            True, if authorization through Apple ID is allowed

        allow_google_id (:class:`bool`):
            True, if authorization through Google ID is allowed

    """

    def __init__(
        self, allow_apple_id: bool = False, allow_google_id: bool = False
    ) -> None:
        self.allow_apple_id: bool = bool(allow_apple_id)
        r"""True, if authorization through Apple ID is allowed"""
        self.allow_google_id: bool = bool(allow_google_id)
        r"""True, if authorization through Google ID is allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitEmailAddress"]:
        return "authorizationStateWaitEmailAddress"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "allow_apple_id": self.allow_apple_id,
            "allow_google_id": self.allow_google_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateWaitEmailAddress", None]:
        if data:
            data_class = cls()
            data_class.allow_apple_id = data.get("allow_apple_id", False)
            data_class.allow_google_id = data.get("allow_google_id", False)

        return data_class


class AuthorizationStateWaitEmailCode(TlObject, AuthorizationState):
    r"""TDLib needs the user's authentication code sent to an email address to authorize\. Call checkAuthenticationEmailCode to provide the code

    Parameters:
        allow_apple_id (:class:`bool`):
            True, if authorization through Apple ID is allowed

        allow_google_id (:class:`bool`):
            True, if authorization through Google ID is allowed

        code_info (:class:`"types.EmailAddressAuthenticationCodeInfo"`):
            Information about the sent authentication code

        email_address_reset_state (:class:`"types.EmailAddressResetState"`):
            Reset state of the email address; may be null if the email address can't be reset

    """

    def __init__(
        self,
        allow_apple_id: bool = False,
        allow_google_id: bool = False,
        code_info: EmailAddressAuthenticationCodeInfo = None,
        email_address_reset_state: EmailAddressResetState = None,
    ) -> None:
        self.allow_apple_id: bool = bool(allow_apple_id)
        r"""True, if authorization through Apple ID is allowed"""
        self.allow_google_id: bool = bool(allow_google_id)
        r"""True, if authorization through Google ID is allowed"""
        self.code_info: Union[EmailAddressAuthenticationCodeInfo, None] = code_info
        r"""Information about the sent authentication code"""
        self.email_address_reset_state: Union[
            EmailAddressResetStateAvailable, EmailAddressResetStatePending, None
        ] = email_address_reset_state
        r"""Reset state of the email address; may be null if the email address can't be reset"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitEmailCode"]:
        return "authorizationStateWaitEmailCode"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "allow_apple_id": self.allow_apple_id,
            "allow_google_id": self.allow_google_id,
            "code_info": self.code_info,
            "email_address_reset_state": self.email_address_reset_state,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateWaitEmailCode", None]:
        if data:
            data_class = cls()
            data_class.allow_apple_id = data.get("allow_apple_id", False)
            data_class.allow_google_id = data.get("allow_google_id", False)
            data_class.code_info = data.get("code_info", None)
            data_class.email_address_reset_state = data.get(
                "email_address_reset_state", None
            )

        return data_class


class AuthorizationStateWaitCode(TlObject, AuthorizationState):
    r"""TDLib needs the user's authentication code to authorize\. Call checkAuthenticationCode to check the code

    Parameters:
        code_info (:class:`"types.AuthenticationCodeInfo"`):
            Information about the authorization code that was sent

    """

    def __init__(self, code_info: AuthenticationCodeInfo = None) -> None:
        self.code_info: Union[AuthenticationCodeInfo, None] = code_info
        r"""Information about the authorization code that was sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitCode"]:
        return "authorizationStateWaitCode"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "code_info": self.code_info}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateWaitCode", None]:
        if data:
            data_class = cls()
            data_class.code_info = data.get("code_info", None)

        return data_class


class AuthorizationStateWaitOtherDeviceConfirmation(TlObject, AuthorizationState):
    r"""The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link

    Parameters:
        link (:class:`str`):
            A tg:// URL for the QR code\. The link will be updated frequently

    """

    def __init__(self, link: str = "") -> None:
        self.link: Union[str, None] = link
        r"""A tg:// URL for the QR code\. The link will be updated frequently"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitOtherDeviceConfirmation"]:
        return "authorizationStateWaitOtherDeviceConfirmation"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "link": self.link}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["AuthorizationStateWaitOtherDeviceConfirmation", None]:
        if data:
            data_class = cls()
            data_class.link = data.get("link", "")

        return data_class


class AuthorizationStateWaitRegistration(TlObject, AuthorizationState):
    r"""The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration\. Call registerUser to accept the terms of service and provide the data

    Parameters:
        terms_of_service (:class:`"types.TermsOfService"`):
            Telegram terms of service

    """

    def __init__(self, terms_of_service: TermsOfService = None) -> None:
        self.terms_of_service: Union[TermsOfService, None] = terms_of_service
        r"""Telegram terms of service"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitRegistration"]:
        return "authorizationStateWaitRegistration"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "terms_of_service": self.terms_of_service}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateWaitRegistration", None]:
        if data:
            data_class = cls()
            data_class.terms_of_service = data.get("terms_of_service", None)

        return data_class


class AuthorizationStateWaitPassword(TlObject, AuthorizationState):
    r"""The user has been authorized, but needs to enter a 2\-step verification password to start using the application\. Call checkAuthenticationPassword to provide the password, or requestAuthenticationPasswordRecovery to recover the password, or deleteAccount to delete the account after a week

    Parameters:
        password_hint (:class:`str`):
            Hint for the password; may be empty

        has_recovery_email_address (:class:`bool`):
            True, if a recovery email address has been set up

        has_passport_data (:class:`bool`):
            True, if some Telegram Passport elements were saved

        recovery_email_address_pattern (:class:`str`):
            Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent

    """

    def __init__(
        self,
        password_hint: str = "",
        has_recovery_email_address: bool = False,
        has_passport_data: bool = False,
        recovery_email_address_pattern: str = "",
    ) -> None:
        self.password_hint: Union[str, None] = password_hint
        r"""Hint for the password; may be empty"""
        self.has_recovery_email_address: bool = bool(has_recovery_email_address)
        r"""True, if a recovery email address has been set up"""
        self.has_passport_data: bool = bool(has_passport_data)
        r"""True, if some Telegram Passport elements were saved"""
        self.recovery_email_address_pattern: Union[str, None] = (
            recovery_email_address_pattern
        )
        r"""Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateWaitPassword"]:
        return "authorizationStateWaitPassword"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "password_hint": self.password_hint,
            "has_recovery_email_address": self.has_recovery_email_address,
            "has_passport_data": self.has_passport_data,
            "recovery_email_address_pattern": self.recovery_email_address_pattern,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateWaitPassword", None]:
        if data:
            data_class = cls()
            data_class.password_hint = data.get("password_hint", "")
            data_class.has_recovery_email_address = data.get(
                "has_recovery_email_address", False
            )
            data_class.has_passport_data = data.get("has_passport_data", False)
            data_class.recovery_email_address_pattern = data.get(
                "recovery_email_address_pattern", ""
            )

        return data_class


class AuthorizationStateReady(TlObject, AuthorizationState):
    r"""The user has been successfully authorized\. TDLib is now ready to answer general requests"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateReady"]:
        return "authorizationStateReady"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateReady", None]:
        if data:
            data_class = cls()

        return data_class


class AuthorizationStateLoggingOut(TlObject, AuthorizationState):
    r"""The user is currently logging out"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateLoggingOut"]:
        return "authorizationStateLoggingOut"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateLoggingOut", None]:
        if data:
            data_class = cls()

        return data_class


class AuthorizationStateClosing(TlObject, AuthorizationState):
    r"""TDLib is closing, all subsequent queries will be answered with the error 500\. Note that closing TDLib can take a while\. All resources will be freed only after authorizationStateClosed has been received"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateClosing"]:
        return "authorizationStateClosing"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateClosing", None]:
        if data:
            data_class = cls()

        return data_class


class AuthorizationStateClosed(TlObject, AuthorizationState):
    r"""TDLib client is in its final state\. All databases are closed and all resources are released\. No other updates will be received after this\. All queries will be responded to with error code 500\. To continue working, one must create a new instance of the TDLib client"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["authorizationStateClosed"]:
        return "authorizationStateClosed"

    def getClass(self) -> Literal["AuthorizationState"]:
        return "AuthorizationState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AuthorizationStateClosed", None]:
        if data:
            data_class = cls()

        return data_class


class FirebaseDeviceVerificationParametersSafetyNet(
    TlObject, FirebaseDeviceVerificationParameters
):
    r"""Device verification must be performed with the SafetyNet Attestation API

    Parameters:
        nonce (:class:`bytes`):
            Nonce to pass to the SafetyNet Attestation API

    """

    def __init__(self, nonce: bytes = b"") -> None:
        self.nonce: Union[bytes, None] = nonce
        r"""Nonce to pass to the SafetyNet Attestation API"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["firebaseDeviceVerificationParametersSafetyNet"]:
        return "firebaseDeviceVerificationParametersSafetyNet"

    def getClass(self) -> Literal["FirebaseDeviceVerificationParameters"]:
        return "FirebaseDeviceVerificationParameters"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "nonce": self.nonce}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["FirebaseDeviceVerificationParametersSafetyNet", None]:
        if data:
            data_class = cls()
            data_class.nonce = b64decode(data.get("nonce", b""))

        return data_class


class FirebaseDeviceVerificationParametersPlayIntegrity(
    TlObject, FirebaseDeviceVerificationParameters
):
    r"""Device verification must be performed with the classic Play Integrity verification \(https://developer\.android\.com/google/play/integrity/classic\)

    Parameters:
        nonce (:class:`str`):
            Base64url\-encoded nonce to pass to the Play Integrity API

        cloud_project_number (:class:`int`):
            Cloud project number to pass to the Play Integrity API

    """

    def __init__(self, nonce: str = "", cloud_project_number: int = 0) -> None:
        self.nonce: Union[str, None] = nonce
        r"""Base64url\-encoded nonce to pass to the Play Integrity API"""
        self.cloud_project_number: int = int(cloud_project_number)
        r"""Cloud project number to pass to the Play Integrity API"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["firebaseDeviceVerificationParametersPlayIntegrity"]:
        return "firebaseDeviceVerificationParametersPlayIntegrity"

    def getClass(self) -> Literal["FirebaseDeviceVerificationParameters"]:
        return "FirebaseDeviceVerificationParameters"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "nonce": self.nonce,
            "cloud_project_number": self.cloud_project_number,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["FirebaseDeviceVerificationParametersPlayIntegrity", None]:
        if data:
            data_class = cls()
            data_class.nonce = data.get("nonce", "")
            data_class.cloud_project_number = int(data.get("cloud_project_number", 0))

        return data_class


class PasswordState(TlObject):
    r"""Represents the current state of 2\-step verification

    Parameters:
        has_password (:class:`bool`):
            True, if a 2\-step verification password is set

        password_hint (:class:`str`):
            Hint for the password; may be empty

        has_recovery_email_address (:class:`bool`):
            True, if a recovery email is set

        has_passport_data (:class:`bool`):
            True, if some Telegram Passport elements were saved

        recovery_email_address_code_info (:class:`"types.EmailAddressAuthenticationCodeInfo"`):
            Information about the recovery email address to which the confirmation email was sent; may be null

        login_email_address_pattern (:class:`str`):
            Pattern of the email address set up for logging in

        pending_reset_date (:class:`int`):
            If not 0, point in time \(Unix timestamp\) after which the 2\-step verification password can be reset immediately using resetPassword

    """

    def __init__(
        self,
        has_password: bool = False,
        password_hint: str = "",
        has_recovery_email_address: bool = False,
        has_passport_data: bool = False,
        recovery_email_address_code_info: EmailAddressAuthenticationCodeInfo = None,
        login_email_address_pattern: str = "",
        pending_reset_date: int = 0,
    ) -> None:
        self.has_password: bool = bool(has_password)
        r"""True, if a 2\-step verification password is set"""
        self.password_hint: Union[str, None] = password_hint
        r"""Hint for the password; may be empty"""
        self.has_recovery_email_address: bool = bool(has_recovery_email_address)
        r"""True, if a recovery email is set"""
        self.has_passport_data: bool = bool(has_passport_data)
        r"""True, if some Telegram Passport elements were saved"""
        self.recovery_email_address_code_info: Union[
            EmailAddressAuthenticationCodeInfo, None
        ] = recovery_email_address_code_info
        r"""Information about the recovery email address to which the confirmation email was sent; may be null"""
        self.login_email_address_pattern: Union[str, None] = login_email_address_pattern
        r"""Pattern of the email address set up for logging in"""
        self.pending_reset_date: int = int(pending_reset_date)
        r"""If not 0, point in time \(Unix timestamp\) after which the 2\-step verification password can be reset immediately using resetPassword"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passwordState"]:
        return "passwordState"

    def getClass(self) -> Literal["PasswordState"]:
        return "PasswordState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "has_password": self.has_password,
            "password_hint": self.password_hint,
            "has_recovery_email_address": self.has_recovery_email_address,
            "has_passport_data": self.has_passport_data,
            "recovery_email_address_code_info": self.recovery_email_address_code_info,
            "login_email_address_pattern": self.login_email_address_pattern,
            "pending_reset_date": self.pending_reset_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PasswordState", None]:
        if data:
            data_class = cls()
            data_class.has_password = data.get("has_password", False)
            data_class.password_hint = data.get("password_hint", "")
            data_class.has_recovery_email_address = data.get(
                "has_recovery_email_address", False
            )
            data_class.has_passport_data = data.get("has_passport_data", False)
            data_class.recovery_email_address_code_info = data.get(
                "recovery_email_address_code_info", None
            )
            data_class.login_email_address_pattern = data.get(
                "login_email_address_pattern", ""
            )
            data_class.pending_reset_date = int(data.get("pending_reset_date", 0))

        return data_class


class RecoveryEmailAddress(TlObject):
    r"""Contains information about the current recovery email address

    Parameters:
        recovery_email_address (:class:`str`):
            Recovery email address

    """

    def __init__(self, recovery_email_address: str = "") -> None:
        self.recovery_email_address: Union[str, None] = recovery_email_address
        r"""Recovery email address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["recoveryEmailAddress"]:
        return "recoveryEmailAddress"

    def getClass(self) -> Literal["RecoveryEmailAddress"]:
        return "RecoveryEmailAddress"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "recovery_email_address": self.recovery_email_address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RecoveryEmailAddress", None]:
        if data:
            data_class = cls()
            data_class.recovery_email_address = data.get("recovery_email_address", "")

        return data_class


class TemporaryPasswordState(TlObject):
    r"""Returns information about the availability of a temporary password, which can be used for payments

    Parameters:
        has_password (:class:`bool`):
            True, if a temporary password is available

        valid_for (:class:`int`):
            Time left before the temporary password expires, in seconds

    """

    def __init__(self, has_password: bool = False, valid_for: int = 0) -> None:
        self.has_password: bool = bool(has_password)
        r"""True, if a temporary password is available"""
        self.valid_for: int = int(valid_for)
        r"""Time left before the temporary password expires, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["temporaryPasswordState"]:
        return "temporaryPasswordState"

    def getClass(self) -> Literal["TemporaryPasswordState"]:
        return "TemporaryPasswordState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "has_password": self.has_password,
            "valid_for": self.valid_for,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TemporaryPasswordState", None]:
        if data:
            data_class = cls()
            data_class.has_password = data.get("has_password", False)
            data_class.valid_for = int(data.get("valid_for", 0))

        return data_class


class LocalFile(TlObject):
    r"""Represents a local file

    Parameters:
        path (:class:`str`):
            Local path to the locally available file part; may be empty

        can_be_downloaded (:class:`bool`):
            True, if it is possible to download or generate the file

        can_be_deleted (:class:`bool`):
            True, if the file can be deleted

        is_downloading_active (:class:`bool`):
            True, if the file is currently being downloaded \(or a local copy is being generated by some other means\)

        is_downloading_completed (:class:`bool`):
            True, if the local copy is fully available

        download_offset (:class:`int`):
            Download will be started from this offset\. downloaded\_prefix\_size is calculated from this offset

        downloaded_prefix_size (:class:`int`):
            If is\_downloading\_completed is false, then only some prefix of the file starting from download\_offset is ready to be read\. downloaded\_prefix\_size is the size of that prefix in bytes

        downloaded_size (:class:`int`):
            Total downloaded file size, in bytes\. Can be used only for calculating download progress\. The actual file size may be bigger, and some parts of it may contain garbage

    """

    def __init__(
        self,
        path: str = "",
        can_be_downloaded: bool = False,
        can_be_deleted: bool = False,
        is_downloading_active: bool = False,
        is_downloading_completed: bool = False,
        download_offset: int = 0,
        downloaded_prefix_size: int = 0,
        downloaded_size: int = 0,
    ) -> None:
        self.path: Union[str, None] = path
        r"""Local path to the locally available file part; may be empty"""
        self.can_be_downloaded: bool = bool(can_be_downloaded)
        r"""True, if it is possible to download or generate the file"""
        self.can_be_deleted: bool = bool(can_be_deleted)
        r"""True, if the file can be deleted"""
        self.is_downloading_active: bool = bool(is_downloading_active)
        r"""True, if the file is currently being downloaded \(or a local copy is being generated by some other means\)"""
        self.is_downloading_completed: bool = bool(is_downloading_completed)
        r"""True, if the local copy is fully available"""
        self.download_offset: int = int(download_offset)
        r"""Download will be started from this offset\. downloaded\_prefix\_size is calculated from this offset"""
        self.downloaded_prefix_size: int = int(downloaded_prefix_size)
        r"""If is\_downloading\_completed is false, then only some prefix of the file starting from download\_offset is ready to be read\. downloaded\_prefix\_size is the size of that prefix in bytes"""
        self.downloaded_size: int = int(downloaded_size)
        r"""Total downloaded file size, in bytes\. Can be used only for calculating download progress\. The actual file size may be bigger, and some parts of it may contain garbage"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["localFile"]:
        return "localFile"

    def getClass(self) -> Literal["LocalFile"]:
        return "LocalFile"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "path": self.path,
            "can_be_downloaded": self.can_be_downloaded,
            "can_be_deleted": self.can_be_deleted,
            "is_downloading_active": self.is_downloading_active,
            "is_downloading_completed": self.is_downloading_completed,
            "download_offset": self.download_offset,
            "downloaded_prefix_size": self.downloaded_prefix_size,
            "downloaded_size": self.downloaded_size,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LocalFile", None]:
        if data:
            data_class = cls()
            data_class.path = data.get("path", "")
            data_class.can_be_downloaded = data.get("can_be_downloaded", False)
            data_class.can_be_deleted = data.get("can_be_deleted", False)
            data_class.is_downloading_active = data.get("is_downloading_active", False)
            data_class.is_downloading_completed = data.get(
                "is_downloading_completed", False
            )
            data_class.download_offset = int(data.get("download_offset", 0))
            data_class.downloaded_prefix_size = int(
                data.get("downloaded_prefix_size", 0)
            )
            data_class.downloaded_size = int(data.get("downloaded_size", 0))

        return data_class


class RemoteFile(TlObject, FileBoundMethods):
    r"""Represents a remote file

    Parameters:
        id (:class:`str`):
            Remote file identifier; may be empty\. Can be used by the current user across application restarts or even from other devices\. Uniquely identifies a file, but a file can have a lot of different valid identifiers\. If the identifier starts with \"http://\" or \"https://\", it represents the HTTP URL of the file\. TDLib is currently unable to download files if only their URL is known\. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original\_path and \"\#url\#\" as the conversion string\. Application must generate the file by downloading it to the specified location

        unique_id (:class:`str`):
            Unique file identifier; may be empty if unknown\. The unique file identifier which is the same for the same file even for different users and is persistent over time

        is_uploading_active (:class:`bool`):
            True, if the file is currently being uploaded \(or a remote copy is being generated by some other means\)

        is_uploading_completed (:class:`bool`):
            True, if a remote copy is fully available

        uploaded_size (:class:`int`):
            Size of the remote available part of the file, in bytes; 0 if unknown

    """

    def __init__(
        self,
        id: str = "",
        unique_id: str = "",
        is_uploading_active: bool = False,
        is_uploading_completed: bool = False,
        uploaded_size: int = 0,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Remote file identifier; may be empty\. Can be used by the current user across application restarts or even from other devices\. Uniquely identifies a file, but a file can have a lot of different valid identifiers\. If the identifier starts with \"http://\" or \"https://\", it represents the HTTP URL of the file\. TDLib is currently unable to download files if only their URL is known\. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original\_path and \"\#url\#\" as the conversion string\. Application must generate the file by downloading it to the specified location"""
        self.unique_id: Union[str, None] = unique_id
        r"""Unique file identifier; may be empty if unknown\. The unique file identifier which is the same for the same file even for different users and is persistent over time"""
        self.is_uploading_active: bool = bool(is_uploading_active)
        r"""True, if the file is currently being uploaded \(or a remote copy is being generated by some other means\)"""
        self.is_uploading_completed: bool = bool(is_uploading_completed)
        r"""True, if a remote copy is fully available"""
        self.uploaded_size: int = int(uploaded_size)
        r"""Size of the remote available part of the file, in bytes; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["remoteFile"]:
        return "remoteFile"

    def getClass(self) -> Literal["RemoteFile"]:
        return "RemoteFile"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "unique_id": self.unique_id,
            "is_uploading_active": self.is_uploading_active,
            "is_uploading_completed": self.is_uploading_completed,
            "uploaded_size": self.uploaded_size,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RemoteFile", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.unique_id = data.get("unique_id", "")
            data_class.is_uploading_active = data.get("is_uploading_active", False)
            data_class.is_uploading_completed = data.get(
                "is_uploading_completed", False
            )
            data_class.uploaded_size = int(data.get("uploaded_size", 0))

        return data_class


class File(TlObject, FileBoundMethods):
    r"""Represents a file

    Parameters:
        id (:class:`int`):
            Unique file identifier

        size (:class:`int`):
            File size, in bytes; 0 if unknown

        expected_size (:class:`int`):
            Approximate file size in bytes in case the exact file size is unknown\. Can be used to show download/upload progress

        local (:class:`"types.LocalFile"`):
            Information about the local copy of the file

        remote (:class:`"types.RemoteFile"`):
            Information about the remote copy of the file

    """

    def __init__(
        self,
        id: int = 0,
        size: int = 0,
        expected_size: int = 0,
        local: LocalFile = None,
        remote: RemoteFile = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique file identifier"""
        self.size: int = int(size)
        r"""File size, in bytes; 0 if unknown"""
        self.expected_size: int = int(expected_size)
        r"""Approximate file size in bytes in case the exact file size is unknown\. Can be used to show download/upload progress"""
        self.local: Union[LocalFile, None] = local
        r"""Information about the local copy of the file"""
        self.remote: Union[RemoteFile, None] = remote
        r"""Information about the remote copy of the file"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["file"]:
        return "file"

    def getClass(self) -> Literal["File"]:
        return "File"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "size": self.size,
            "expected_size": self.expected_size,
            "local": self.local,
            "remote": self.remote,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["File", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.size = int(data.get("size", 0))
            data_class.expected_size = int(data.get("expected_size", 0))
            data_class.local = data.get("local", None)
            data_class.remote = data.get("remote", None)

        return data_class


class InputFileId(TlObject, InputFile):
    r"""A file defined by its unique identifier

    Parameters:
        id (:class:`int`):
            Unique file identifier

    """

    def __init__(self, id: int = 0) -> None:
        self.id: int = int(id)
        r"""Unique file identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputFileId"]:
        return "inputFileId"

    def getClass(self) -> Literal["InputFile"]:
        return "InputFile"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputFileId", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))

        return data_class


class InputFileRemote(TlObject, InputFile):
    r"""A file defined by its remote identifier\. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib\. For example, if the file is from a message, then the message must be not deleted and accessible to the user\. If the file database is disabled, then the corresponding object with the file must be preloaded by the application

    Parameters:
        id (:class:`str`):
            Remote file identifier

    """

    def __init__(self, id: str = "") -> None:
        self.id: Union[str, None] = id
        r"""Remote file identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputFileRemote"]:
        return "inputFileRemote"

    def getClass(self) -> Literal["InputFile"]:
        return "InputFile"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputFileRemote", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")

        return data_class


class InputFileLocal(TlObject, InputFile):
    r"""A file defined by a local path

    Parameters:
        path (:class:`str`):
            Local path to the file

    """

    def __init__(self, path: str = "") -> None:
        self.path: Union[str, None] = path
        r"""Local path to the file"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputFileLocal"]:
        return "inputFileLocal"

    def getClass(self) -> Literal["InputFile"]:
        return "InputFile"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "path": self.path}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputFileLocal", None]:
        if data:
            data_class = cls()
            data_class.path = data.get("path", "")

        return data_class


class InputFileGenerated(TlObject, InputFile):
    r"""A file generated by the application\. The application must handle updates updateFileGenerationStart and updateFileGenerationStop to generate the file when asked by TDLib

    Parameters:
        original_path (:class:`str`):
            Local path to a file from which the file is generated\. The path doesn't have to be a valid path and is used by TDLib only to detect name and MIME type of the generated file

        conversion (:class:`str`):
            String specifying the conversion applied to the original file; must be persistent across application restarts\. Conversions beginning with '\#' are reserved for internal TDLib usage

        expected_size (:class:`int`):
            Expected size of the generated file, in bytes; pass 0 if unknown

    """

    def __init__(
        self, original_path: str = "", conversion: str = "", expected_size: int = 0
    ) -> None:
        self.original_path: Union[str, None] = original_path
        r"""Local path to a file from which the file is generated\. The path doesn't have to be a valid path and is used by TDLib only to detect name and MIME type of the generated file"""
        self.conversion: Union[str, None] = conversion
        r"""String specifying the conversion applied to the original file; must be persistent across application restarts\. Conversions beginning with '\#' are reserved for internal TDLib usage"""
        self.expected_size: int = int(expected_size)
        r"""Expected size of the generated file, in bytes; pass 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputFileGenerated"]:
        return "inputFileGenerated"

    def getClass(self) -> Literal["InputFile"]:
        return "InputFile"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "original_path": self.original_path,
            "conversion": self.conversion,
            "expected_size": self.expected_size,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputFileGenerated", None]:
        if data:
            data_class = cls()
            data_class.original_path = data.get("original_path", "")
            data_class.conversion = data.get("conversion", "")
            data_class.expected_size = int(data.get("expected_size", 0))

        return data_class


class PhotoSize(TlObject):
    r"""Describes an image in JPEG format

    Parameters:
        type (:class:`str`):
            Image type \(see https://core\.telegram\.org/constructor/photoSize\)

        photo (:class:`"types.File"`):
            Information about the image file

        width (:class:`int`):
            Image width

        height (:class:`int`):
            Image height

        progressive_sizes (:class:`List[int]`):
            Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes

    """

    def __init__(
        self,
        type: str = "",
        photo: File = None,
        width: int = 0,
        height: int = 0,
        progressive_sizes: List[int] = None,
    ) -> None:
        self.type: Union[str, None] = type
        r"""Image type \(see https://core\.telegram\.org/constructor/photoSize\)"""
        self.photo: Union[File, None] = photo
        r"""Information about the image file"""
        self.width: int = int(width)
        r"""Image width"""
        self.height: int = int(height)
        r"""Image height"""
        self.progressive_sizes: List[int] = progressive_sizes or []
        r"""Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["photoSize"]:
        return "photoSize"

    def getClass(self) -> Literal["PhotoSize"]:
        return "PhotoSize"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "photo": self.photo,
            "width": self.width,
            "height": self.height,
            "progressive_sizes": self.progressive_sizes,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PhotoSize", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", "")
            data_class.photo = data.get("photo", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.progressive_sizes = data.get("progressive_sizes", None)

        return data_class


class Minithumbnail(TlObject):
    r"""Thumbnail image of a very poor quality and low resolution

    Parameters:
        width (:class:`int`):
            Thumbnail width, usually doesn't exceed 40

        height (:class:`int`):
            Thumbnail height, usually doesn't exceed 40

        data (:class:`bytes`):
            The thumbnail in JPEG format

    """

    def __init__(self, width: int = 0, height: int = 0, data: bytes = b"") -> None:
        self.width: int = int(width)
        r"""Thumbnail width, usually doesn't exceed 40"""
        self.height: int = int(height)
        r"""Thumbnail height, usually doesn't exceed 40"""
        self.data: Union[bytes, None] = data
        r"""The thumbnail in JPEG format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["minithumbnail"]:
        return "minithumbnail"

    def getClass(self) -> Literal["Minithumbnail"]:
        return "Minithumbnail"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "width": self.width,
            "height": self.height,
            "data": self.data,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Minithumbnail", None]:
        if data:
            data_class = cls()
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.data = b64decode(data.get("data", b""))

        return data_class


class ThumbnailFormatJpeg(TlObject, ThumbnailFormat):
    r"""The thumbnail is in JPEG format"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnailFormatJpeg"]:
        return "thumbnailFormatJpeg"

    def getClass(self) -> Literal["ThumbnailFormat"]:
        return "ThumbnailFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThumbnailFormatJpeg", None]:
        if data:
            data_class = cls()

        return data_class


class ThumbnailFormatGif(TlObject, ThumbnailFormat):
    r"""The thumbnail is in static GIF format\. It will be used only for some bot inline query results"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnailFormatGif"]:
        return "thumbnailFormatGif"

    def getClass(self) -> Literal["ThumbnailFormat"]:
        return "ThumbnailFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThumbnailFormatGif", None]:
        if data:
            data_class = cls()

        return data_class


class ThumbnailFormatMpeg4(TlObject, ThumbnailFormat):
    r"""The thumbnail is in MPEG4 format\. It will be used only for some animations and videos"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnailFormatMpeg4"]:
        return "thumbnailFormatMpeg4"

    def getClass(self) -> Literal["ThumbnailFormat"]:
        return "ThumbnailFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThumbnailFormatMpeg4", None]:
        if data:
            data_class = cls()

        return data_class


class ThumbnailFormatPng(TlObject, ThumbnailFormat):
    r"""The thumbnail is in PNG format\. It will be used only for background patterns"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnailFormatPng"]:
        return "thumbnailFormatPng"

    def getClass(self) -> Literal["ThumbnailFormat"]:
        return "ThumbnailFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThumbnailFormatPng", None]:
        if data:
            data_class = cls()

        return data_class


class ThumbnailFormatTgs(TlObject, ThumbnailFormat):
    r"""The thumbnail is in TGS format\. It will be used only for sticker sets"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnailFormatTgs"]:
        return "thumbnailFormatTgs"

    def getClass(self) -> Literal["ThumbnailFormat"]:
        return "ThumbnailFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThumbnailFormatTgs", None]:
        if data:
            data_class = cls()

        return data_class


class ThumbnailFormatWebm(TlObject, ThumbnailFormat):
    r"""The thumbnail is in WEBM format\. It will be used only for sticker sets"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnailFormatWebm"]:
        return "thumbnailFormatWebm"

    def getClass(self) -> Literal["ThumbnailFormat"]:
        return "ThumbnailFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThumbnailFormatWebm", None]:
        if data:
            data_class = cls()

        return data_class


class ThumbnailFormatWebp(TlObject, ThumbnailFormat):
    r"""The thumbnail is in WEBP format\. It will be used only for some stickers and sticker sets"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnailFormatWebp"]:
        return "thumbnailFormatWebp"

    def getClass(self) -> Literal["ThumbnailFormat"]:
        return "ThumbnailFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThumbnailFormatWebp", None]:
        if data:
            data_class = cls()

        return data_class


class Thumbnail(TlObject):
    r"""Represents a thumbnail

    Parameters:
        format (:class:`"types.ThumbnailFormat"`):
            Thumbnail format

        width (:class:`int`):
            Thumbnail width

        height (:class:`int`):
            Thumbnail height

        file (:class:`"types.File"`):
            The thumbnail

    """

    def __init__(
        self,
        format: ThumbnailFormat = None,
        width: int = 0,
        height: int = 0,
        file: File = None,
    ) -> None:
        self.format: Union[
            ThumbnailFormatJpeg,
            ThumbnailFormatGif,
            ThumbnailFormatMpeg4,
            ThumbnailFormatPng,
            ThumbnailFormatTgs,
            ThumbnailFormatWebm,
            ThumbnailFormatWebp,
            None,
        ] = format
        r"""Thumbnail format"""
        self.width: int = int(width)
        r"""Thumbnail width"""
        self.height: int = int(height)
        r"""Thumbnail height"""
        self.file: Union[File, None] = file
        r"""The thumbnail"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["thumbnail"]:
        return "thumbnail"

    def getClass(self) -> Literal["Thumbnail"]:
        return "Thumbnail"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "format": self.format,
            "width": self.width,
            "height": self.height,
            "file": self.file,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Thumbnail", None]:
        if data:
            data_class = cls()
            data_class.format = data.get("format", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.file = data.get("file", None)

        return data_class


class MaskPointForehead(TlObject, MaskPoint):
    r"""The mask is placed relatively to the forehead"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["maskPointForehead"]:
        return "maskPointForehead"

    def getClass(self) -> Literal["MaskPoint"]:
        return "MaskPoint"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MaskPointForehead", None]:
        if data:
            data_class = cls()

        return data_class


class MaskPointEyes(TlObject, MaskPoint):
    r"""The mask is placed relatively to the eyes"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["maskPointEyes"]:
        return "maskPointEyes"

    def getClass(self) -> Literal["MaskPoint"]:
        return "MaskPoint"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MaskPointEyes", None]:
        if data:
            data_class = cls()

        return data_class


class MaskPointMouth(TlObject, MaskPoint):
    r"""The mask is placed relatively to the mouth"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["maskPointMouth"]:
        return "maskPointMouth"

    def getClass(self) -> Literal["MaskPoint"]:
        return "MaskPoint"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MaskPointMouth", None]:
        if data:
            data_class = cls()

        return data_class


class MaskPointChin(TlObject, MaskPoint):
    r"""The mask is placed relatively to the chin"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["maskPointChin"]:
        return "maskPointChin"

    def getClass(self) -> Literal["MaskPoint"]:
        return "MaskPoint"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MaskPointChin", None]:
        if data:
            data_class = cls()

        return data_class


class MaskPosition(TlObject):
    r"""Position on a photo where a mask is placed

    Parameters:
        point (:class:`"types.MaskPoint"`):
            Part of the face, relative to which the mask is placed

        x_shift (:class:`float`):
            Shift by X\-axis measured in widths of the mask scaled to the face size, from left to right\. \(For example, \-1\.0 will place the mask just to the left of the default mask position\)

        y_shift (:class:`float`):
            Shift by Y\-axis measured in heights of the mask scaled to the face size, from top to bottom\. \(For example, 1\.0 will place the mask just below the default mask position\)

        scale (:class:`float`):
            Mask scaling coefficient\. \(For example, 2\.0 means a doubled size\)

    """

    def __init__(
        self,
        point: MaskPoint = None,
        x_shift: float = 0.0,
        y_shift: float = 0.0,
        scale: float = 0.0,
    ) -> None:
        self.point: Union[
            MaskPointForehead, MaskPointEyes, MaskPointMouth, MaskPointChin, None
        ] = point
        r"""Part of the face, relative to which the mask is placed"""
        self.x_shift: float = float(x_shift)
        r"""Shift by X\-axis measured in widths of the mask scaled to the face size, from left to right\. \(For example, \-1\.0 will place the mask just to the left of the default mask position\)"""
        self.y_shift: float = float(y_shift)
        r"""Shift by Y\-axis measured in heights of the mask scaled to the face size, from top to bottom\. \(For example, 1\.0 will place the mask just below the default mask position\)"""
        self.scale: float = float(scale)
        r"""Mask scaling coefficient\. \(For example, 2\.0 means a doubled size\)"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["maskPosition"]:
        return "maskPosition"

    def getClass(self) -> Literal["MaskPosition"]:
        return "MaskPosition"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "point": self.point,
            "x_shift": self.x_shift,
            "y_shift": self.y_shift,
            "scale": self.scale,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MaskPosition", None]:
        if data:
            data_class = cls()
            data_class.point = data.get("point", None)
            data_class.x_shift = data.get("x_shift", 0.0)
            data_class.y_shift = data.get("y_shift", 0.0)
            data_class.scale = data.get("scale", 0.0)

        return data_class


class StickerFormatWebp(TlObject, StickerFormat):
    r"""The sticker is an image in WEBP format"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerFormatWebp"]:
        return "stickerFormatWebp"

    def getClass(self) -> Literal["StickerFormat"]:
        return "StickerFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerFormatWebp", None]:
        if data:
            data_class = cls()

        return data_class


class StickerFormatTgs(TlObject, StickerFormat):
    r"""The sticker is an animation in TGS format"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerFormatTgs"]:
        return "stickerFormatTgs"

    def getClass(self) -> Literal["StickerFormat"]:
        return "StickerFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerFormatTgs", None]:
        if data:
            data_class = cls()

        return data_class


class StickerFormatWebm(TlObject, StickerFormat):
    r"""The sticker is a video in WEBM format"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerFormatWebm"]:
        return "stickerFormatWebm"

    def getClass(self) -> Literal["StickerFormat"]:
        return "StickerFormat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerFormatWebm", None]:
        if data:
            data_class = cls()

        return data_class


class StickerTypeRegular(TlObject, StickerType):
    r"""The sticker is a regular sticker"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerTypeRegular"]:
        return "stickerTypeRegular"

    def getClass(self) -> Literal["StickerType"]:
        return "StickerType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerTypeRegular", None]:
        if data:
            data_class = cls()

        return data_class


class StickerTypeMask(TlObject, StickerType):
    r"""The sticker is a mask in WEBP format to be placed on photos or videos"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerTypeMask"]:
        return "stickerTypeMask"

    def getClass(self) -> Literal["StickerType"]:
        return "StickerType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerTypeMask", None]:
        if data:
            data_class = cls()

        return data_class


class StickerTypeCustomEmoji(TlObject, StickerType):
    r"""The sticker is a custom emoji to be used inside message text and caption"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerTypeCustomEmoji"]:
        return "stickerTypeCustomEmoji"

    def getClass(self) -> Literal["StickerType"]:
        return "StickerType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerTypeCustomEmoji", None]:
        if data:
            data_class = cls()

        return data_class


class StickerFullTypeRegular(TlObject, StickerFullType):
    r"""The sticker is a regular sticker

    Parameters:
        premium_animation (:class:`"types.File"`):
            Premium animation of the sticker; may be null\. If present, only Telegram Premium users can use the sticker

    """

    def __init__(self, premium_animation: File = None) -> None:
        self.premium_animation: Union[File, None] = premium_animation
        r"""Premium animation of the sticker; may be null\. If present, only Telegram Premium users can use the sticker"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerFullTypeRegular"]:
        return "stickerFullTypeRegular"

    def getClass(self) -> Literal["StickerFullType"]:
        return "StickerFullType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "premium_animation": self.premium_animation}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerFullTypeRegular", None]:
        if data:
            data_class = cls()
            data_class.premium_animation = data.get("premium_animation", None)

        return data_class


class StickerFullTypeMask(TlObject, StickerFullType):
    r"""The sticker is a mask in WEBP format to be placed on photos or videos

    Parameters:
        mask_position (:class:`"types.MaskPosition"`):
            Position where the mask is placed; may be null

    """

    def __init__(self, mask_position: MaskPosition = None) -> None:
        self.mask_position: Union[MaskPosition, None] = mask_position
        r"""Position where the mask is placed; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerFullTypeMask"]:
        return "stickerFullTypeMask"

    def getClass(self) -> Literal["StickerFullType"]:
        return "StickerFullType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "mask_position": self.mask_position}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerFullTypeMask", None]:
        if data:
            data_class = cls()
            data_class.mask_position = data.get("mask_position", None)

        return data_class


class StickerFullTypeCustomEmoji(TlObject, StickerFullType):
    r"""The sticker is a custom emoji to be used inside message text and caption\. Currently, only Telegram Premium users can use custom emoji

    Parameters:
        custom_emoji_id (:class:`int`):
            Identifier of the custom emoji

        needs_repainting (:class:`bool`):
            True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places

    """

    def __init__(
        self, custom_emoji_id: int = 0, needs_repainting: bool = False
    ) -> None:
        self.custom_emoji_id: int = int(custom_emoji_id)
        r"""Identifier of the custom emoji"""
        self.needs_repainting: bool = bool(needs_repainting)
        r"""True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerFullTypeCustomEmoji"]:
        return "stickerFullTypeCustomEmoji"

    def getClass(self) -> Literal["StickerFullType"]:
        return "StickerFullType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "custom_emoji_id": self.custom_emoji_id,
            "needs_repainting": self.needs_repainting,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerFullTypeCustomEmoji", None]:
        if data:
            data_class = cls()
            data_class.custom_emoji_id = int(data.get("custom_emoji_id", 0))
            data_class.needs_repainting = data.get("needs_repainting", False)

        return data_class


class ClosedVectorPath(TlObject):
    r"""Represents a closed vector path\. The path begins at the end point of the last command\. The coordinate system origin is in the upper\-left corner

    Parameters:
        commands (:class:`List["types.VectorPathCommand"]`):
            List of vector path commands

    """

    def __init__(self, commands: List[VectorPathCommand] = None) -> None:
        self.commands: List[VectorPathCommand] = commands or []
        r"""List of vector path commands"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["closedVectorPath"]:
        return "closedVectorPath"

    def getClass(self) -> Literal["ClosedVectorPath"]:
        return "ClosedVectorPath"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "commands": self.commands}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ClosedVectorPath", None]:
        if data:
            data_class = cls()
            data_class.commands = data.get("commands", None)

        return data_class


class Outline(TlObject):
    r"""Represents outline of an image

    Parameters:
        paths (:class:`List["types.ClosedVectorPath"]`):
            The list of closed vector paths

    """

    def __init__(self, paths: List[ClosedVectorPath] = None) -> None:
        self.paths: List[ClosedVectorPath] = paths or []
        r"""The list of closed vector paths"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["outline"]:
        return "outline"

    def getClass(self) -> Literal["Outline"]:
        return "Outline"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "paths": self.paths}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Outline", None]:
        if data:
            data_class = cls()
            data_class.paths = data.get("paths", None)

        return data_class


class PollOption(TlObject):
    r"""Describes one answer option of a poll

    Parameters:
        text (:class:`"types.FormattedText"`):
            Option text; 1\-100 characters\. Only custom emoji entities are allowed

        voter_count (:class:`int`):
            Number of voters for this option, available only for closed or voted polls

        vote_percentage (:class:`int`):
            The percentage of votes for this option; 0\-100

        is_chosen (:class:`bool`):
            True, if the option was chosen by the user

        is_being_chosen (:class:`bool`):
            True, if the option is being chosen by a pending setPollAnswer request

    """

    def __init__(
        self,
        text: FormattedText = None,
        voter_count: int = 0,
        vote_percentage: int = 0,
        is_chosen: bool = False,
        is_being_chosen: bool = False,
    ) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Option text; 1\-100 characters\. Only custom emoji entities are allowed"""
        self.voter_count: int = int(voter_count)
        r"""Number of voters for this option, available only for closed or voted polls"""
        self.vote_percentage: int = int(vote_percentage)
        r"""The percentage of votes for this option; 0\-100"""
        self.is_chosen: bool = bool(is_chosen)
        r"""True, if the option was chosen by the user"""
        self.is_being_chosen: bool = bool(is_being_chosen)
        r"""True, if the option is being chosen by a pending setPollAnswer request"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pollOption"]:
        return "pollOption"

    def getClass(self) -> Literal["PollOption"]:
        return "PollOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "voter_count": self.voter_count,
            "vote_percentage": self.vote_percentage,
            "is_chosen": self.is_chosen,
            "is_being_chosen": self.is_being_chosen,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PollOption", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.voter_count = int(data.get("voter_count", 0))
            data_class.vote_percentage = int(data.get("vote_percentage", 0))
            data_class.is_chosen = data.get("is_chosen", False)
            data_class.is_being_chosen = data.get("is_being_chosen", False)

        return data_class


class PollTypeRegular(TlObject, PollType):
    r"""A regular poll

    Parameters:
        allow_multiple_answers (:class:`bool`):
            True, if multiple answer options can be chosen simultaneously

    """

    def __init__(self, allow_multiple_answers: bool = False) -> None:
        self.allow_multiple_answers: bool = bool(allow_multiple_answers)
        r"""True, if multiple answer options can be chosen simultaneously"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pollTypeRegular"]:
        return "pollTypeRegular"

    def getClass(self) -> Literal["PollType"]:
        return "PollType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "allow_multiple_answers": self.allow_multiple_answers,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PollTypeRegular", None]:
        if data:
            data_class = cls()
            data_class.allow_multiple_answers = data.get(
                "allow_multiple_answers", False
            )

        return data_class


class PollTypeQuiz(TlObject, PollType):
    r"""A poll in quiz mode, which has exactly one correct answer option and can be answered only once

    Parameters:
        correct_option_id (:class:`int`):
            0\-based identifier of the correct answer option; \-1 for a yet unanswered poll

        explanation (:class:`"types.FormattedText"`):
            Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0\-200 characters with at most 2 line feeds; empty for a yet unanswered poll

    """

    def __init__(
        self, correct_option_id: int = 0, explanation: FormattedText = None
    ) -> None:
        self.correct_option_id: int = int(correct_option_id)
        r"""0\-based identifier of the correct answer option; \-1 for a yet unanswered poll"""
        self.explanation: Union[FormattedText, None] = explanation
        r"""Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0\-200 characters with at most 2 line feeds; empty for a yet unanswered poll"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pollTypeQuiz"]:
        return "pollTypeQuiz"

    def getClass(self) -> Literal["PollType"]:
        return "PollType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "correct_option_id": self.correct_option_id,
            "explanation": self.explanation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PollTypeQuiz", None]:
        if data:
            data_class = cls()
            data_class.correct_option_id = int(data.get("correct_option_id", 0))
            data_class.explanation = data.get("explanation", None)

        return data_class


class Animation(TlObject):
    r"""Describes an animation file\. The animation must be encoded in GIF or MPEG4 format

    Parameters:
        duration (:class:`int`):
            Duration of the animation, in seconds; as defined by the sender

        width (:class:`int`):
            Width of the animation

        height (:class:`int`):
            Height of the animation

        file_name (:class:`str`):
            Original name of the file; as defined by the sender

        mime_type (:class:`str`):
            MIME type of the file, usually \"image/gif\" or \"video/mp4\"

        has_stickers (:class:`bool`):
            True, if stickers were added to the animation\. The list of corresponding sticker set can be received using getAttachedStickerSets

        minithumbnail (:class:`"types.Minithumbnail"`):
            Animation minithumbnail; may be null

        thumbnail (:class:`"types.Thumbnail"`):
            Animation thumbnail in JPEG or MPEG4 format; may be null

        animation (:class:`"types.File"`):
            File containing the animation

    """

    def __init__(
        self,
        duration: int = 0,
        width: int = 0,
        height: int = 0,
        file_name: str = "",
        mime_type: str = "",
        has_stickers: bool = False,
        minithumbnail: Minithumbnail = None,
        thumbnail: Thumbnail = None,
        animation: File = None,
    ) -> None:
        self.duration: int = int(duration)
        r"""Duration of the animation, in seconds; as defined by the sender"""
        self.width: int = int(width)
        r"""Width of the animation"""
        self.height: int = int(height)
        r"""Height of the animation"""
        self.file_name: Union[str, None] = file_name
        r"""Original name of the file; as defined by the sender"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the file, usually \"image/gif\" or \"video/mp4\""""
        self.has_stickers: bool = bool(has_stickers)
        r"""True, if stickers were added to the animation\. The list of corresponding sticker set can be received using getAttachedStickerSets"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Animation minithumbnail; may be null"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Animation thumbnail in JPEG or MPEG4 format; may be null"""
        self.animation: Union[File, None] = animation
        r"""File containing the animation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["animation"]:
        return "animation"

    def getClass(self) -> Literal["Animation"]:
        return "Animation"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
            "file_name": self.file_name,
            "mime_type": self.mime_type,
            "has_stickers": self.has_stickers,
            "minithumbnail": self.minithumbnail,
            "thumbnail": self.thumbnail,
            "animation": self.animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Animation", None]:
        if data:
            data_class = cls()
            data_class.duration = int(data.get("duration", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.file_name = data.get("file_name", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.has_stickers = data.get("has_stickers", False)
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.animation = data.get("animation", None)

        return data_class


class Audio(TlObject):
    r"""Describes an audio file\. Audio is usually in MP3 or M4A format

    Parameters:
        duration (:class:`int`):
            Duration of the audio, in seconds; as defined by the sender

        title (:class:`str`):
            Title of the audio; as defined by the sender

        performer (:class:`str`):
            Performer of the audio; as defined by the sender

        file_name (:class:`str`):
            Original name of the file; as defined by the sender

        mime_type (:class:`str`):
            The MIME type of the file; as defined by the sender

        album_cover_minithumbnail (:class:`"types.Minithumbnail"`):
            The minithumbnail of the album cover; may be null

        album_cover_thumbnail (:class:`"types.Thumbnail"`):
            The thumbnail of the album cover in JPEG format; as defined by the sender\. The full size thumbnail is expected to be extracted from the downloaded audio file; may be null

        external_album_covers (:class:`List["types.Thumbnail"]`):
            Album cover variants to use if the downloaded audio file contains no album cover\. Provided thumbnail dimensions are approximate

        audio (:class:`"types.File"`):
            File containing the audio

    """

    def __init__(
        self,
        duration: int = 0,
        title: str = "",
        performer: str = "",
        file_name: str = "",
        mime_type: str = "",
        album_cover_minithumbnail: Minithumbnail = None,
        album_cover_thumbnail: Thumbnail = None,
        external_album_covers: List[Thumbnail] = None,
        audio: File = None,
    ) -> None:
        self.duration: int = int(duration)
        r"""Duration of the audio, in seconds; as defined by the sender"""
        self.title: Union[str, None] = title
        r"""Title of the audio; as defined by the sender"""
        self.performer: Union[str, None] = performer
        r"""Performer of the audio; as defined by the sender"""
        self.file_name: Union[str, None] = file_name
        r"""Original name of the file; as defined by the sender"""
        self.mime_type: Union[str, None] = mime_type
        r"""The MIME type of the file; as defined by the sender"""
        self.album_cover_minithumbnail: Union[Minithumbnail, None] = (
            album_cover_minithumbnail
        )
        r"""The minithumbnail of the album cover; may be null"""
        self.album_cover_thumbnail: Union[Thumbnail, None] = album_cover_thumbnail
        r"""The thumbnail of the album cover in JPEG format; as defined by the sender\. The full size thumbnail is expected to be extracted from the downloaded audio file; may be null"""
        self.external_album_covers: List[Thumbnail] = external_album_covers or []
        r"""Album cover variants to use if the downloaded audio file contains no album cover\. Provided thumbnail dimensions are approximate"""
        self.audio: Union[File, None] = audio
        r"""File containing the audio"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["audio"]:
        return "audio"

    def getClass(self) -> Literal["Audio"]:
        return "Audio"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "duration": self.duration,
            "title": self.title,
            "performer": self.performer,
            "file_name": self.file_name,
            "mime_type": self.mime_type,
            "album_cover_minithumbnail": self.album_cover_minithumbnail,
            "album_cover_thumbnail": self.album_cover_thumbnail,
            "external_album_covers": self.external_album_covers,
            "audio": self.audio,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Audio", None]:
        if data:
            data_class = cls()
            data_class.duration = int(data.get("duration", 0))
            data_class.title = data.get("title", "")
            data_class.performer = data.get("performer", "")
            data_class.file_name = data.get("file_name", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.album_cover_minithumbnail = data.get(
                "album_cover_minithumbnail", None
            )
            data_class.album_cover_thumbnail = data.get("album_cover_thumbnail", None)
            data_class.external_album_covers = data.get("external_album_covers", None)
            data_class.audio = data.get("audio", None)

        return data_class


class Document(TlObject):
    r"""Describes a document of any type

    Parameters:
        file_name (:class:`str`):
            Original name of the file; as defined by the sender

        mime_type (:class:`str`):
            MIME type of the file; as defined by the sender

        minithumbnail (:class:`"types.Minithumbnail"`):
            Document minithumbnail; may be null

        thumbnail (:class:`"types.Thumbnail"`):
            Document thumbnail in JPEG or PNG format \(PNG will be used only for background patterns\); as defined by the sender; may be null

        document (:class:`"types.File"`):
            File containing the document

    """

    def __init__(
        self,
        file_name: str = "",
        mime_type: str = "",
        minithumbnail: Minithumbnail = None,
        thumbnail: Thumbnail = None,
        document: File = None,
    ) -> None:
        self.file_name: Union[str, None] = file_name
        r"""Original name of the file; as defined by the sender"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the file; as defined by the sender"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Document minithumbnail; may be null"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Document thumbnail in JPEG or PNG format \(PNG will be used only for background patterns\); as defined by the sender; may be null"""
        self.document: Union[File, None] = document
        r"""File containing the document"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["document"]:
        return "document"

    def getClass(self) -> Literal["Document"]:
        return "Document"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "file_name": self.file_name,
            "mime_type": self.mime_type,
            "minithumbnail": self.minithumbnail,
            "thumbnail": self.thumbnail,
            "document": self.document,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Document", None]:
        if data:
            data_class = cls()
            data_class.file_name = data.get("file_name", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.document = data.get("document", None)

        return data_class


class Photo(TlObject):
    r"""Describes a photo

    Parameters:
        has_stickers (:class:`bool`):
            True, if stickers were added to the photo\. The list of corresponding sticker sets can be received using getAttachedStickerSets

        minithumbnail (:class:`"types.Minithumbnail"`):
            Photo minithumbnail; may be null

        sizes (:class:`List["types.PhotoSize"]`):
            Available variants of the photo, in different sizes

    """

    def __init__(
        self,
        has_stickers: bool = False,
        minithumbnail: Minithumbnail = None,
        sizes: List[PhotoSize] = None,
    ) -> None:
        self.has_stickers: bool = bool(has_stickers)
        r"""True, if stickers were added to the photo\. The list of corresponding sticker sets can be received using getAttachedStickerSets"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Photo minithumbnail; may be null"""
        self.sizes: List[PhotoSize] = sizes or []
        r"""Available variants of the photo, in different sizes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["photo"]:
        return "photo"

    def getClass(self) -> Literal["Photo"]:
        return "Photo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "has_stickers": self.has_stickers,
            "minithumbnail": self.minithumbnail,
            "sizes": self.sizes,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Photo", None]:
        if data:
            data_class = cls()
            data_class.has_stickers = data.get("has_stickers", False)
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.sizes = data.get("sizes", None)

        return data_class


class Sticker(TlObject):
    r"""Describes a sticker

    Parameters:
        id (:class:`int`):
            Unique sticker identifier within the set; 0 if none

        set_id (:class:`int`):
            Identifier of the sticker set to which the sticker belongs; 0 if none

        width (:class:`int`):
            Sticker width; as defined by the sender

        height (:class:`int`):
            Sticker height; as defined by the sender

        emoji (:class:`str`):
            Emoji corresponding to the sticker

        format (:class:`"types.StickerFormat"`):
            Sticker format

        full_type (:class:`"types.StickerFullType"`):
            Sticker's full type

        thumbnail (:class:`"types.Thumbnail"`):
            Sticker thumbnail in WEBP or JPEG format; may be null

        sticker (:class:`"types.File"`):
            File containing the sticker

    """

    def __init__(
        self,
        id: int = 0,
        set_id: int = 0,
        width: int = 0,
        height: int = 0,
        emoji: str = "",
        format: StickerFormat = None,
        full_type: StickerFullType = None,
        thumbnail: Thumbnail = None,
        sticker: File = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique sticker identifier within the set; 0 if none"""
        self.set_id: int = int(set_id)
        r"""Identifier of the sticker set to which the sticker belongs; 0 if none"""
        self.width: int = int(width)
        r"""Sticker width; as defined by the sender"""
        self.height: int = int(height)
        r"""Sticker height; as defined by the sender"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji corresponding to the sticker"""
        self.format: Union[
            StickerFormatWebp, StickerFormatTgs, StickerFormatWebm, None
        ] = format
        r"""Sticker format"""
        self.full_type: Union[
            StickerFullTypeRegular,
            StickerFullTypeMask,
            StickerFullTypeCustomEmoji,
            None,
        ] = full_type
        r"""Sticker's full type"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Sticker thumbnail in WEBP or JPEG format; may be null"""
        self.sticker: Union[File, None] = sticker
        r"""File containing the sticker"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sticker"]:
        return "sticker"

    def getClass(self) -> Literal["Sticker"]:
        return "Sticker"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "set_id": self.set_id,
            "width": self.width,
            "height": self.height,
            "emoji": self.emoji,
            "format": self.format,
            "full_type": self.full_type,
            "thumbnail": self.thumbnail,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Sticker", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.set_id = int(data.get("set_id", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.emoji = data.get("emoji", "")
            data_class.format = data.get("format", None)
            data_class.full_type = data.get("full_type", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.sticker = data.get("sticker", None)

        return data_class


class Video(TlObject):
    r"""Describes a video file

    Parameters:
        duration (:class:`int`):
            Duration of the video, in seconds; as defined by the sender

        width (:class:`int`):
            Video width; as defined by the sender

        height (:class:`int`):
            Video height; as defined by the sender

        file_name (:class:`str`):
            Original name of the file; as defined by the sender

        mime_type (:class:`str`):
            MIME type of the file; as defined by the sender

        has_stickers (:class:`bool`):
            True, if stickers were added to the video\. The list of corresponding sticker sets can be received using getAttachedStickerSets

        supports_streaming (:class:`bool`):
            True, if the video is expected to be streamed

        minithumbnail (:class:`"types.Minithumbnail"`):
            Video minithumbnail; may be null

        thumbnail (:class:`"types.Thumbnail"`):
            Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null

        video (:class:`"types.File"`):
            File containing the video

    """

    def __init__(
        self,
        duration: int = 0,
        width: int = 0,
        height: int = 0,
        file_name: str = "",
        mime_type: str = "",
        has_stickers: bool = False,
        supports_streaming: bool = False,
        minithumbnail: Minithumbnail = None,
        thumbnail: Thumbnail = None,
        video: File = None,
    ) -> None:
        self.duration: int = int(duration)
        r"""Duration of the video, in seconds; as defined by the sender"""
        self.width: int = int(width)
        r"""Video width; as defined by the sender"""
        self.height: int = int(height)
        r"""Video height; as defined by the sender"""
        self.file_name: Union[str, None] = file_name
        r"""Original name of the file; as defined by the sender"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the file; as defined by the sender"""
        self.has_stickers: bool = bool(has_stickers)
        r"""True, if stickers were added to the video\. The list of corresponding sticker sets can be received using getAttachedStickerSets"""
        self.supports_streaming: bool = bool(supports_streaming)
        r"""True, if the video is expected to be streamed"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Video minithumbnail; may be null"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null"""
        self.video: Union[File, None] = video
        r"""File containing the video"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["video"]:
        return "video"

    def getClass(self) -> Literal["Video"]:
        return "Video"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
            "file_name": self.file_name,
            "mime_type": self.mime_type,
            "has_stickers": self.has_stickers,
            "supports_streaming": self.supports_streaming,
            "minithumbnail": self.minithumbnail,
            "thumbnail": self.thumbnail,
            "video": self.video,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Video", None]:
        if data:
            data_class = cls()
            data_class.duration = int(data.get("duration", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.file_name = data.get("file_name", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.has_stickers = data.get("has_stickers", False)
            data_class.supports_streaming = data.get("supports_streaming", False)
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.video = data.get("video", None)

        return data_class


class VideoNote(TlObject):
    r"""Describes a video note\. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format

    Parameters:
        duration (:class:`int`):
            Duration of the video, in seconds; as defined by the sender

        waveform (:class:`bytes`):
            A waveform representation of the video note's audio in 5\-bit format; may be empty if unknown

        length (:class:`int`):
            Video width and height; as defined by the sender

        minithumbnail (:class:`"types.Minithumbnail"`):
            Video minithumbnail; may be null

        thumbnail (:class:`"types.Thumbnail"`):
            Video thumbnail in JPEG format; as defined by the sender; may be null

        speech_recognition_result (:class:`"types.SpeechRecognitionResult"`):
            Result of speech recognition in the video note; may be null

        video (:class:`"types.File"`):
            File containing the video

    """

    def __init__(
        self,
        duration: int = 0,
        waveform: bytes = b"",
        length: int = 0,
        minithumbnail: Minithumbnail = None,
        thumbnail: Thumbnail = None,
        speech_recognition_result: SpeechRecognitionResult = None,
        video: File = None,
    ) -> None:
        self.duration: int = int(duration)
        r"""Duration of the video, in seconds; as defined by the sender"""
        self.waveform: Union[bytes, None] = waveform
        r"""A waveform representation of the video note's audio in 5\-bit format; may be empty if unknown"""
        self.length: int = int(length)
        r"""Video width and height; as defined by the sender"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Video minithumbnail; may be null"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Video thumbnail in JPEG format; as defined by the sender; may be null"""
        self.speech_recognition_result: Union[
            SpeechRecognitionResultPending,
            SpeechRecognitionResultText,
            SpeechRecognitionResultError,
            None,
        ] = speech_recognition_result
        r"""Result of speech recognition in the video note; may be null"""
        self.video: Union[File, None] = video
        r"""File containing the video"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["videoNote"]:
        return "videoNote"

    def getClass(self) -> Literal["VideoNote"]:
        return "VideoNote"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "duration": self.duration,
            "waveform": self.waveform,
            "length": self.length,
            "minithumbnail": self.minithumbnail,
            "thumbnail": self.thumbnail,
            "speech_recognition_result": self.speech_recognition_result,
            "video": self.video,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["VideoNote", None]:
        if data:
            data_class = cls()
            data_class.duration = int(data.get("duration", 0))
            data_class.waveform = b64decode(data.get("waveform", b""))
            data_class.length = int(data.get("length", 0))
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.speech_recognition_result = data.get(
                "speech_recognition_result", None
            )
            data_class.video = data.get("video", None)

        return data_class


class VoiceNote(TlObject):
    r"""Describes a voice note

    Parameters:
        duration (:class:`int`):
            Duration of the voice note, in seconds; as defined by the sender

        waveform (:class:`bytes`):
            A waveform representation of the voice note in 5\-bit format

        mime_type (:class:`str`):
            MIME type of the file; as defined by the sender\. Usually, one of \"audio/ogg\" for Opus in an OGG container, \"audio/mpeg\" for an MP3 audio, or \"audio/mp4\" for an M4A audio

        speech_recognition_result (:class:`"types.SpeechRecognitionResult"`):
            Result of speech recognition in the voice note; may be null

        voice (:class:`"types.File"`):
            File containing the voice note

    """

    def __init__(
        self,
        duration: int = 0,
        waveform: bytes = b"",
        mime_type: str = "",
        speech_recognition_result: SpeechRecognitionResult = None,
        voice: File = None,
    ) -> None:
        self.duration: int = int(duration)
        r"""Duration of the voice note, in seconds; as defined by the sender"""
        self.waveform: Union[bytes, None] = waveform
        r"""A waveform representation of the voice note in 5\-bit format"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the file; as defined by the sender\. Usually, one of \"audio/ogg\" for Opus in an OGG container, \"audio/mpeg\" for an MP3 audio, or \"audio/mp4\" for an M4A audio"""
        self.speech_recognition_result: Union[
            SpeechRecognitionResultPending,
            SpeechRecognitionResultText,
            SpeechRecognitionResultError,
            None,
        ] = speech_recognition_result
        r"""Result of speech recognition in the voice note; may be null"""
        self.voice: Union[File, None] = voice
        r"""File containing the voice note"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["voiceNote"]:
        return "voiceNote"

    def getClass(self) -> Literal["VoiceNote"]:
        return "VoiceNote"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "duration": self.duration,
            "waveform": self.waveform,
            "mime_type": self.mime_type,
            "speech_recognition_result": self.speech_recognition_result,
            "voice": self.voice,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["VoiceNote", None]:
        if data:
            data_class = cls()
            data_class.duration = int(data.get("duration", 0))
            data_class.waveform = b64decode(data.get("waveform", b""))
            data_class.mime_type = data.get("mime_type", "")
            data_class.speech_recognition_result = data.get(
                "speech_recognition_result", None
            )
            data_class.voice = data.get("voice", None)

        return data_class


class AnimatedEmoji(TlObject):
    r"""Describes an animated or custom representation of an emoji

    Parameters:
        sticker (:class:`"types.Sticker"`):
            Sticker for the emoji; may be null if yet unknown for a custom emoji\. If the sticker is a custom emoji, then it can have arbitrary format

        sticker_width (:class:`int`):
            Expected width of the sticker, which can be used if the sticker is null

        sticker_height (:class:`int`):
            Expected height of the sticker, which can be used if the sticker is null

        fitzpatrick_type (:class:`int`):
            Emoji modifier fitzpatrick type; 0\-6; 0 if none

        sound (:class:`"types.File"`):
            File containing the sound to be played when the sticker is clicked; may be null\. The sound is encoded with the Opus codec, and stored inside an OGG container

    """

    def __init__(
        self,
        sticker: Sticker = None,
        sticker_width: int = 0,
        sticker_height: int = 0,
        fitzpatrick_type: int = 0,
        sound: File = None,
    ) -> None:
        self.sticker: Union[Sticker, None] = sticker
        r"""Sticker for the emoji; may be null if yet unknown for a custom emoji\. If the sticker is a custom emoji, then it can have arbitrary format"""
        self.sticker_width: int = int(sticker_width)
        r"""Expected width of the sticker, which can be used if the sticker is null"""
        self.sticker_height: int = int(sticker_height)
        r"""Expected height of the sticker, which can be used if the sticker is null"""
        self.fitzpatrick_type: int = int(fitzpatrick_type)
        r"""Emoji modifier fitzpatrick type; 0\-6; 0 if none"""
        self.sound: Union[File, None] = sound
        r"""File containing the sound to be played when the sticker is clicked; may be null\. The sound is encoded with the Opus codec, and stored inside an OGG container"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["animatedEmoji"]:
        return "animatedEmoji"

    def getClass(self) -> Literal["AnimatedEmoji"]:
        return "AnimatedEmoji"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker": self.sticker,
            "sticker_width": self.sticker_width,
            "sticker_height": self.sticker_height,
            "fitzpatrick_type": self.fitzpatrick_type,
            "sound": self.sound,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AnimatedEmoji", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)
            data_class.sticker_width = int(data.get("sticker_width", 0))
            data_class.sticker_height = int(data.get("sticker_height", 0))
            data_class.fitzpatrick_type = int(data.get("fitzpatrick_type", 0))
            data_class.sound = data.get("sound", None)

        return data_class


class Contact(TlObject):
    r"""Describes a user contact

    Parameters:
        phone_number (:class:`str`):
            Phone number of the user

        first_name (:class:`str`):
            First name of the user; 1\-255 characters in length

        last_name (:class:`str`):
            Last name of the user

        vcard (:class:`str`):
            Additional data about the user in a form of vCard; 0\-2048 bytes in length

        user_id (:class:`int`):
            Identifier of the user, if known; 0 otherwise

    """

    def __init__(
        self,
        phone_number: str = "",
        first_name: str = "",
        last_name: str = "",
        vcard: str = "",
        user_id: int = 0,
    ) -> None:
        self.phone_number: Union[str, None] = phone_number
        r"""Phone number of the user"""
        self.first_name: Union[str, None] = first_name
        r"""First name of the user; 1\-255 characters in length"""
        self.last_name: Union[str, None] = last_name
        r"""Last name of the user"""
        self.vcard: Union[str, None] = vcard
        r"""Additional data about the user in a form of vCard; 0\-2048 bytes in length"""
        self.user_id: int = int(user_id)
        r"""Identifier of the user, if known; 0 otherwise"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["contact"]:
        return "contact"

    def getClass(self) -> Literal["Contact"]:
        return "Contact"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "phone_number": self.phone_number,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "vcard": self.vcard,
            "user_id": self.user_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Contact", None]:
        if data:
            data_class = cls()
            data_class.phone_number = data.get("phone_number", "")
            data_class.first_name = data.get("first_name", "")
            data_class.last_name = data.get("last_name", "")
            data_class.vcard = data.get("vcard", "")
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class Location(TlObject):
    r"""Describes a location on planet Earth

    Parameters:
        latitude (:class:`float`):
            Latitude of the location in degrees; as defined by the sender

        longitude (:class:`float`):
            Longitude of the location, in degrees; as defined by the sender

        horizontal_accuracy (:class:`float`):
            The estimated horizontal accuracy of the location, in meters; as defined by the sender\. 0 if unknown

    """

    def __init__(
        self,
        latitude: float = 0.0,
        longitude: float = 0.0,
        horizontal_accuracy: float = 0.0,
    ) -> None:
        self.latitude: float = float(latitude)
        r"""Latitude of the location in degrees; as defined by the sender"""
        self.longitude: float = float(longitude)
        r"""Longitude of the location, in degrees; as defined by the sender"""
        self.horizontal_accuracy: float = float(horizontal_accuracy)
        r"""The estimated horizontal accuracy of the location, in meters; as defined by the sender\. 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["location"]:
        return "location"

    def getClass(self) -> Literal["Location"]:
        return "Location"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "latitude": self.latitude,
            "longitude": self.longitude,
            "horizontal_accuracy": self.horizontal_accuracy,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Location", None]:
        if data:
            data_class = cls()
            data_class.latitude = data.get("latitude", 0.0)
            data_class.longitude = data.get("longitude", 0.0)
            data_class.horizontal_accuracy = data.get("horizontal_accuracy", 0.0)

        return data_class


class Venue(TlObject):
    r"""Describes a venue

    Parameters:
        location (:class:`"types.Location"`):
            Venue location; as defined by the sender

        title (:class:`str`):
            Venue name; as defined by the sender

        address (:class:`str`):
            Venue address; as defined by the sender

        provider (:class:`str`):
            Provider of the venue database; as defined by the sender\. Currently, only \"foursquare\" and \"gplaces\" \(Google Places\) need to be supported

        id (:class:`str`):
            Identifier of the venue in the provider database; as defined by the sender

        type (:class:`str`):
            Type of the venue in the provider database; as defined by the sender

    """

    def __init__(
        self,
        location: Location = None,
        title: str = "",
        address: str = "",
        provider: str = "",
        id: str = "",
        type: str = "",
    ) -> None:
        self.location: Union[Location, None] = location
        r"""Venue location; as defined by the sender"""
        self.title: Union[str, None] = title
        r"""Venue name; as defined by the sender"""
        self.address: Union[str, None] = address
        r"""Venue address; as defined by the sender"""
        self.provider: Union[str, None] = provider
        r"""Provider of the venue database; as defined by the sender\. Currently, only \"foursquare\" and \"gplaces\" \(Google Places\) need to be supported"""
        self.id: Union[str, None] = id
        r"""Identifier of the venue in the provider database; as defined by the sender"""
        self.type: Union[str, None] = type
        r"""Type of the venue in the provider database; as defined by the sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["venue"]:
        return "venue"

    def getClass(self) -> Literal["Venue"]:
        return "Venue"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "title": self.title,
            "address": self.address,
            "provider": self.provider,
            "id": self.id,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Venue", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.title = data.get("title", "")
            data_class.address = data.get("address", "")
            data_class.provider = data.get("provider", "")
            data_class.id = data.get("id", "")
            data_class.type = data.get("type", "")

        return data_class


class Game(TlObject):
    r"""Describes a game\. Use getInternalLink with internalLinkTypeGame to share the game

    Parameters:
        id (:class:`int`):
            Unique game identifier

        short_name (:class:`str`):
            Game short name

        title (:class:`str`):
            Game title

        text (:class:`"types.FormattedText"`):
            Game text, usually containing scoreboards for a game

        description (:class:`str`):
            Game description

        photo (:class:`"types.Photo"`):
            Game photo

        animation (:class:`"types.Animation"`):
            Game animation; may be null

    """

    def __init__(
        self,
        id: int = 0,
        short_name: str = "",
        title: str = "",
        text: FormattedText = None,
        description: str = "",
        photo: Photo = None,
        animation: Animation = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique game identifier"""
        self.short_name: Union[str, None] = short_name
        r"""Game short name"""
        self.title: Union[str, None] = title
        r"""Game title"""
        self.text: Union[FormattedText, None] = text
        r"""Game text, usually containing scoreboards for a game"""
        self.description: Union[str, None] = description
        r"""Game description"""
        self.photo: Union[Photo, None] = photo
        r"""Game photo"""
        self.animation: Union[Animation, None] = animation
        r"""Game animation; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["game"]:
        return "game"

    def getClass(self) -> Literal["Game"]:
        return "Game"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "short_name": self.short_name,
            "title": self.title,
            "text": self.text,
            "description": self.description,
            "photo": self.photo,
            "animation": self.animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Game", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.short_name = data.get("short_name", "")
            data_class.title = data.get("title", "")
            data_class.text = data.get("text", None)
            data_class.description = data.get("description", "")
            data_class.photo = data.get("photo", None)
            data_class.animation = data.get("animation", None)

        return data_class


class WebApp(TlObject):
    r"""Describes a Web App\. Use getInternalLink with internalLinkTypeWebApp to share the Web App

    Parameters:
        short_name (:class:`str`):
            Web App short name

        title (:class:`str`):
            Web App title

        description (:class:`str`):
            Web App description

        photo (:class:`"types.Photo"`):
            Web App photo

        animation (:class:`"types.Animation"`):
            Web App animation; may be null

    """

    def __init__(
        self,
        short_name: str = "",
        title: str = "",
        description: str = "",
        photo: Photo = None,
        animation: Animation = None,
    ) -> None:
        self.short_name: Union[str, None] = short_name
        r"""Web App short name"""
        self.title: Union[str, None] = title
        r"""Web App title"""
        self.description: Union[str, None] = description
        r"""Web App description"""
        self.photo: Union[Photo, None] = photo
        r"""Web App photo"""
        self.animation: Union[Animation, None] = animation
        r"""Web App animation; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["webApp"]:
        return "webApp"

    def getClass(self) -> Literal["WebApp"]:
        return "WebApp"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "short_name": self.short_name,
            "title": self.title,
            "description": self.description,
            "photo": self.photo,
            "animation": self.animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["WebApp", None]:
        if data:
            data_class = cls()
            data_class.short_name = data.get("short_name", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.photo = data.get("photo", None)
            data_class.animation = data.get("animation", None)

        return data_class


class Poll(TlObject):
    r"""Describes a poll

    Parameters:
        id (:class:`int`):
            Unique poll identifier

        question (:class:`"types.FormattedText"`):
            Poll question; 1\-300 characters\. Only custom emoji entities are allowed

        options (:class:`List["types.PollOption"]`):
            List of poll answer options

        total_voter_count (:class:`int`):
            Total number of voters, participating in the poll

        recent_voter_ids (:class:`List["types.MessageSender"]`):
            Identifiers of recent voters, if the poll is non\-anonymous

        is_anonymous (:class:`bool`):
            True, if the poll is anonymous

        type (:class:`"types.PollType"`):
            Type of the poll

        open_period (:class:`int`):
            Amount of time the poll will be active after creation, in seconds

        close_date (:class:`int`):
            Point in time \(Unix timestamp\) when the poll will automatically be closed

        is_closed (:class:`bool`):
            True, if the poll is closed

    """

    def __init__(
        self,
        id: int = 0,
        question: FormattedText = None,
        options: List[PollOption] = None,
        total_voter_count: int = 0,
        recent_voter_ids: List[MessageSender] = None,
        is_anonymous: bool = False,
        type: PollType = None,
        open_period: int = 0,
        close_date: int = 0,
        is_closed: bool = False,
    ) -> None:
        self.id: int = int(id)
        r"""Unique poll identifier"""
        self.question: Union[FormattedText, None] = question
        r"""Poll question; 1\-300 characters\. Only custom emoji entities are allowed"""
        self.options: List[PollOption] = options or []
        r"""List of poll answer options"""
        self.total_voter_count: int = int(total_voter_count)
        r"""Total number of voters, participating in the poll"""
        self.recent_voter_ids: List[MessageSender] = recent_voter_ids or []
        r"""Identifiers of recent voters, if the poll is non\-anonymous"""
        self.is_anonymous: bool = bool(is_anonymous)
        r"""True, if the poll is anonymous"""
        self.type: Union[PollTypeRegular, PollTypeQuiz, None] = type
        r"""Type of the poll"""
        self.open_period: int = int(open_period)
        r"""Amount of time the poll will be active after creation, in seconds"""
        self.close_date: int = int(close_date)
        r"""Point in time \(Unix timestamp\) when the poll will automatically be closed"""
        self.is_closed: bool = bool(is_closed)
        r"""True, if the poll is closed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["poll"]:
        return "poll"

    def getClass(self) -> Literal["Poll"]:
        return "Poll"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "question": self.question,
            "options": self.options,
            "total_voter_count": self.total_voter_count,
            "recent_voter_ids": self.recent_voter_ids,
            "is_anonymous": self.is_anonymous,
            "type": self.type,
            "open_period": self.open_period,
            "close_date": self.close_date,
            "is_closed": self.is_closed,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Poll", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.question = data.get("question", None)
            data_class.options = data.get("options", None)
            data_class.total_voter_count = int(data.get("total_voter_count", 0))
            data_class.recent_voter_ids = data.get("recent_voter_ids", None)
            data_class.is_anonymous = data.get("is_anonymous", False)
            data_class.type = data.get("type", None)
            data_class.open_period = int(data.get("open_period", 0))
            data_class.close_date = int(data.get("close_date", 0))
            data_class.is_closed = data.get("is_closed", False)

        return data_class


class AlternativeVideo(TlObject):
    r"""Describes an alternative re\-encoded quality of a video file

    Parameters:
        id (:class:`int`):
            Unique identifier of the alternative video, which is used in the HLS file

        width (:class:`int`):
            Video width

        height (:class:`int`):
            Video height

        codec (:class:`str`):
            Codec used for video file encoding, for example, \"h264\", \"h265\", or \"av1\"

        hls_file (:class:`"types.File"`):
            HLS file describing the video

        video (:class:`"types.File"`):
            File containing the video

    """

    def __init__(
        self,
        id: int = 0,
        width: int = 0,
        height: int = 0,
        codec: str = "",
        hls_file: File = None,
        video: File = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the alternative video, which is used in the HLS file"""
        self.width: int = int(width)
        r"""Video width"""
        self.height: int = int(height)
        r"""Video height"""
        self.codec: Union[str, None] = codec
        r"""Codec used for video file encoding, for example, \"h264\", \"h265\", or \"av1\""""
        self.hls_file: Union[File, None] = hls_file
        r"""HLS file describing the video"""
        self.video: Union[File, None] = video
        r"""File containing the video"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["alternativeVideo"]:
        return "alternativeVideo"

    def getClass(self) -> Literal["AlternativeVideo"]:
        return "AlternativeVideo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "width": self.width,
            "height": self.height,
            "codec": self.codec,
            "hls_file": self.hls_file,
            "video": self.video,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AlternativeVideo", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.codec = data.get("codec", "")
            data_class.hls_file = data.get("hls_file", None)
            data_class.video = data.get("video", None)

        return data_class


class Background(TlObject):
    r"""Describes a chat background

    Parameters:
        id (:class:`int`):
            Unique background identifier

        is_default (:class:`bool`):
            True, if this is one of default backgrounds

        is_dark (:class:`bool`):
            True, if the background is dark and is recommended to be used with dark theme

        name (:class:`str`):
            Unique background name

        document (:class:`"types.Document"`):
            Document with the background; may be null\. Null only for filled and chat theme backgrounds

        type (:class:`"types.BackgroundType"`):
            Type of the background

    """

    def __init__(
        self,
        id: int = 0,
        is_default: bool = False,
        is_dark: bool = False,
        name: str = "",
        document: Document = None,
        type: BackgroundType = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique background identifier"""
        self.is_default: bool = bool(is_default)
        r"""True, if this is one of default backgrounds"""
        self.is_dark: bool = bool(is_dark)
        r"""True, if the background is dark and is recommended to be used with dark theme"""
        self.name: Union[str, None] = name
        r"""Unique background name"""
        self.document: Union[Document, None] = document
        r"""Document with the background; may be null\. Null only for filled and chat theme backgrounds"""
        self.type: Union[
            BackgroundTypeWallpaper,
            BackgroundTypePattern,
            BackgroundTypeFill,
            BackgroundTypeChatTheme,
            None,
        ] = type
        r"""Type of the background"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["background"]:
        return "background"

    def getClass(self) -> Literal["Background"]:
        return "Background"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "is_default": self.is_default,
            "is_dark": self.is_dark,
            "name": self.name,
            "document": self.document,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Background", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.is_default = data.get("is_default", False)
            data_class.is_dark = data.get("is_dark", False)
            data_class.name = data.get("name", "")
            data_class.document = data.get("document", None)
            data_class.type = data.get("type", None)

        return data_class


class Backgrounds(TlObject):
    r"""Contains a list of backgrounds

    Parameters:
        backgrounds (:class:`List["types.Background"]`):
            A list of backgrounds

    """

    def __init__(self, backgrounds: List[Background] = None) -> None:
        self.backgrounds: List[Background] = backgrounds or []
        r"""A list of backgrounds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgrounds"]:
        return "backgrounds"

    def getClass(self) -> Literal["Backgrounds"]:
        return "Backgrounds"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "backgrounds": self.backgrounds}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Backgrounds", None]:
        if data:
            data_class = cls()
            data_class.backgrounds = data.get("backgrounds", None)

        return data_class


class ChatBackground(TlObject):
    r"""Describes a background set for a specific chat

    Parameters:
        background (:class:`"types.Background"`):
            The background

        dark_theme_dimming (:class:`int`):
            Dimming of the background in dark themes, as a percentage; 0\-100\. Applied only to Wallpaper and Fill types of background

    """

    def __init__(
        self, background: Background = None, dark_theme_dimming: int = 0
    ) -> None:
        self.background: Union[Background, None] = background
        r"""The background"""
        self.dark_theme_dimming: int = int(dark_theme_dimming)
        r"""Dimming of the background in dark themes, as a percentage; 0\-100\. Applied only to Wallpaper and Fill types of background"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBackground"]:
        return "chatBackground"

    def getClass(self) -> Literal["ChatBackground"]:
        return "ChatBackground"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "background": self.background,
            "dark_theme_dimming": self.dark_theme_dimming,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBackground", None]:
        if data:
            data_class = cls()
            data_class.background = data.get("background", None)
            data_class.dark_theme_dimming = int(data.get("dark_theme_dimming", 0))

        return data_class


class ProfilePhoto(TlObject):
    r"""Describes a user profile photo

    Parameters:
        id (:class:`int`):
            Photo identifier; 0 for an empty photo\. Can be used to find a photo in a list of user profile photos

        small (:class:`"types.File"`):
            A small \(160x160\) user profile photo\. The file can be downloaded only before the photo is changed

        big (:class:`"types.File"`):
            A big \(640x640\) user profile photo\. The file can be downloaded only before the photo is changed

        minithumbnail (:class:`"types.Minithumbnail"`):
            User profile photo minithumbnail; may be null

        has_animation (:class:`bool`):
            True, if the photo has animated variant

        is_personal (:class:`bool`):
            True, if the photo is visible only for the current user

    """

    def __init__(
        self,
        id: int = 0,
        small: File = None,
        big: File = None,
        minithumbnail: Minithumbnail = None,
        has_animation: bool = False,
        is_personal: bool = False,
    ) -> None:
        self.id: int = int(id)
        r"""Photo identifier; 0 for an empty photo\. Can be used to find a photo in a list of user profile photos"""
        self.small: Union[File, None] = small
        r"""A small \(160x160\) user profile photo\. The file can be downloaded only before the photo is changed"""
        self.big: Union[File, None] = big
        r"""A big \(640x640\) user profile photo\. The file can be downloaded only before the photo is changed"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""User profile photo minithumbnail; may be null"""
        self.has_animation: bool = bool(has_animation)
        r"""True, if the photo has animated variant"""
        self.is_personal: bool = bool(is_personal)
        r"""True, if the photo is visible only for the current user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["profilePhoto"]:
        return "profilePhoto"

    def getClass(self) -> Literal["ProfilePhoto"]:
        return "ProfilePhoto"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "small": self.small,
            "big": self.big,
            "minithumbnail": self.minithumbnail,
            "has_animation": self.has_animation,
            "is_personal": self.is_personal,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ProfilePhoto", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.small = data.get("small", None)
            data_class.big = data.get("big", None)
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.has_animation = data.get("has_animation", False)
            data_class.is_personal = data.get("is_personal", False)

        return data_class


class ChatPhotoInfo(TlObject):
    r"""Contains basic information about the photo of a chat

    Parameters:
        small (:class:`"types.File"`):
            A small \(160x160\) chat photo variant in JPEG format\. The file can be downloaded only before the photo is changed

        big (:class:`"types.File"`):
            A big \(640x640\) chat photo variant in JPEG format\. The file can be downloaded only before the photo is changed

        minithumbnail (:class:`"types.Minithumbnail"`):
            Chat photo minithumbnail; may be null

        has_animation (:class:`bool`):
            True, if the photo has animated variant

        is_personal (:class:`bool`):
            True, if the photo is visible only for the current user

    """

    def __init__(
        self,
        small: File = None,
        big: File = None,
        minithumbnail: Minithumbnail = None,
        has_animation: bool = False,
        is_personal: bool = False,
    ) -> None:
        self.small: Union[File, None] = small
        r"""A small \(160x160\) chat photo variant in JPEG format\. The file can be downloaded only before the photo is changed"""
        self.big: Union[File, None] = big
        r"""A big \(640x640\) chat photo variant in JPEG format\. The file can be downloaded only before the photo is changed"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Chat photo minithumbnail; may be null"""
        self.has_animation: bool = bool(has_animation)
        r"""True, if the photo has animated variant"""
        self.is_personal: bool = bool(is_personal)
        r"""True, if the photo is visible only for the current user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPhotoInfo"]:
        return "chatPhotoInfo"

    def getClass(self) -> Literal["ChatPhotoInfo"]:
        return "ChatPhotoInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "small": self.small,
            "big": self.big,
            "minithumbnail": self.minithumbnail,
            "has_animation": self.has_animation,
            "is_personal": self.is_personal,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPhotoInfo", None]:
        if data:
            data_class = cls()
            data_class.small = data.get("small", None)
            data_class.big = data.get("big", None)
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.has_animation = data.get("has_animation", False)
            data_class.is_personal = data.get("is_personal", False)

        return data_class


class UserTypeRegular(TlObject, UserType):
    r"""A regular user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userTypeRegular"]:
        return "userTypeRegular"

    def getClass(self) -> Literal["UserType"]:
        return "UserType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserTypeRegular", None]:
        if data:
            data_class = cls()

        return data_class


class UserTypeDeleted(TlObject, UserType):
    r"""A deleted user or deleted bot\. No information on the user besides the user identifier is available\. It is not possible to perform any active actions on this type of user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userTypeDeleted"]:
        return "userTypeDeleted"

    def getClass(self) -> Literal["UserType"]:
        return "UserType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserTypeDeleted", None]:
        if data:
            data_class = cls()

        return data_class


class UserTypeBot(TlObject, UserType):
    r"""A bot \(see https://core\.telegram\.org/bots\)

    Parameters:
        can_be_edited (:class:`bool`):
            True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription

        can_join_groups (:class:`bool`):
            True, if the bot can be invited to basic group and supergroup chats

        can_read_all_group_messages (:class:`bool`):
            True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot\. In private and channel chats a bot can always read all messages

        has_main_web_app (:class:`bool`):
            True, if the bot has the main Web App

        is_inline (:class:`bool`):
            True, if the bot supports inline queries

        inline_query_placeholder (:class:`str`):
            Placeholder for inline queries \(displayed on the application input field\)

        need_location (:class:`bool`):
            True, if the location of the user is expected to be sent with every inline query to this bot

        can_connect_to_business (:class:`bool`):
            True, if the bot supports connection to Telegram Business accounts

        can_be_added_to_attachment_menu (:class:`bool`):
            True, if the bot can be added to attachment or side menu

        active_user_count (:class:`int`):
            The number of recently active users of the bot

    """

    def __init__(
        self,
        can_be_edited: bool = False,
        can_join_groups: bool = False,
        can_read_all_group_messages: bool = False,
        has_main_web_app: bool = False,
        is_inline: bool = False,
        inline_query_placeholder: str = "",
        need_location: bool = False,
        can_connect_to_business: bool = False,
        can_be_added_to_attachment_menu: bool = False,
        active_user_count: int = 0,
    ) -> None:
        self.can_be_edited: bool = bool(can_be_edited)
        r"""True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription"""
        self.can_join_groups: bool = bool(can_join_groups)
        r"""True, if the bot can be invited to basic group and supergroup chats"""
        self.can_read_all_group_messages: bool = bool(can_read_all_group_messages)
        r"""True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot\. In private and channel chats a bot can always read all messages"""
        self.has_main_web_app: bool = bool(has_main_web_app)
        r"""True, if the bot has the main Web App"""
        self.is_inline: bool = bool(is_inline)
        r"""True, if the bot supports inline queries"""
        self.inline_query_placeholder: Union[str, None] = inline_query_placeholder
        r"""Placeholder for inline queries \(displayed on the application input field\)"""
        self.need_location: bool = bool(need_location)
        r"""True, if the location of the user is expected to be sent with every inline query to this bot"""
        self.can_connect_to_business: bool = bool(can_connect_to_business)
        r"""True, if the bot supports connection to Telegram Business accounts"""
        self.can_be_added_to_attachment_menu: bool = bool(
            can_be_added_to_attachment_menu
        )
        r"""True, if the bot can be added to attachment or side menu"""
        self.active_user_count: int = int(active_user_count)
        r"""The number of recently active users of the bot"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userTypeBot"]:
        return "userTypeBot"

    def getClass(self) -> Literal["UserType"]:
        return "UserType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "can_be_edited": self.can_be_edited,
            "can_join_groups": self.can_join_groups,
            "can_read_all_group_messages": self.can_read_all_group_messages,
            "has_main_web_app": self.has_main_web_app,
            "is_inline": self.is_inline,
            "inline_query_placeholder": self.inline_query_placeholder,
            "need_location": self.need_location,
            "can_connect_to_business": self.can_connect_to_business,
            "can_be_added_to_attachment_menu": self.can_be_added_to_attachment_menu,
            "active_user_count": self.active_user_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserTypeBot", None]:
        if data:
            data_class = cls()
            data_class.can_be_edited = data.get("can_be_edited", False)
            data_class.can_join_groups = data.get("can_join_groups", False)
            data_class.can_read_all_group_messages = data.get(
                "can_read_all_group_messages", False
            )
            data_class.has_main_web_app = data.get("has_main_web_app", False)
            data_class.is_inline = data.get("is_inline", False)
            data_class.inline_query_placeholder = data.get(
                "inline_query_placeholder", ""
            )
            data_class.need_location = data.get("need_location", False)
            data_class.can_connect_to_business = data.get(
                "can_connect_to_business", False
            )
            data_class.can_be_added_to_attachment_menu = data.get(
                "can_be_added_to_attachment_menu", False
            )
            data_class.active_user_count = int(data.get("active_user_count", 0))

        return data_class


class UserTypeUnknown(TlObject, UserType):
    r"""No information on the user besides the user identifier is available, yet this user has not been deleted\. This object is extremely rare and must be handled like a deleted user\. It is not possible to perform any actions on users of this type"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userTypeUnknown"]:
        return "userTypeUnknown"

    def getClass(self) -> Literal["UserType"]:
        return "UserType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserTypeUnknown", None]:
        if data:
            data_class = cls()

        return data_class


class BotCommand(TlObject):
    r"""Represents a command supported by a bot

    Parameters:
        command (:class:`str`):
            Text of the bot command

        description (:class:`str`):
            Description of the bot command

    """

    def __init__(self, command: str = "", description: str = "") -> None:
        self.command: Union[str, None] = command
        r"""Text of the bot command"""
        self.description: Union[str, None] = description
        r"""Description of the bot command"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommand"]:
        return "botCommand"

    def getClass(self) -> Literal["BotCommand"]:
        return "BotCommand"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "command": self.command,
            "description": self.description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommand", None]:
        if data:
            data_class = cls()
            data_class.command = data.get("command", "")
            data_class.description = data.get("description", "")

        return data_class


class BotCommands(TlObject):
    r"""Contains a list of bot commands

    Parameters:
        bot_user_id (:class:`int`):
            Bot's user identifier

        commands (:class:`List["types.BotCommand"]`):
            List of bot commands

    """

    def __init__(self, bot_user_id: int = 0, commands: List[BotCommand] = None) -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""Bot's user identifier"""
        self.commands: List[BotCommand] = commands or []
        r"""List of bot commands"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommands"]:
        return "botCommands"

    def getClass(self) -> Literal["BotCommands"]:
        return "BotCommands"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "commands": self.commands,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommands", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.commands = data.get("commands", None)

        return data_class


class BotMenuButton(TlObject):
    r"""Describes a button to be shown instead of bot commands menu button

    Parameters:
        text (:class:`str`):
            Text of the button

        url (:class:`str`):
            URL of a Web App to open when the button is pressed\. If the link is of the type internalLinkTypeWebApp, then it must be processed accordingly\. Otherwise, the link must be passed to openWebApp

    """

    def __init__(self, text: str = "", url: str = "") -> None:
        self.text: Union[str, None] = text
        r"""Text of the button"""
        self.url: Union[str, None] = url
        r"""URL of a Web App to open when the button is pressed\. If the link is of the type internalLinkTypeWebApp, then it must be processed accordingly\. Otherwise, the link must be passed to openWebApp"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botMenuButton"]:
        return "botMenuButton"

    def getClass(self) -> Literal["BotMenuButton"]:
        return "BotMenuButton"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotMenuButton", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.url = data.get("url", "")

        return data_class


class BotVerificationParameters(TlObject):
    r"""Describes parameters of verification that is provided by a bot

    Parameters:
        icon_custom_emoji_id (:class:`int`):
            Identifier of the custom emoji that is used as the verification sign

        organization_name (:class:`str`):
            Name of the organization that provides verification

        default_custom_description (:class:`"types.FormattedText"`):
            Default custom description of verification reason to be used as placeholder in setMessageSenderBotVerification; may be null if none

        can_set_custom_description (:class:`bool`):
            True, if the bot is allowed to provide custom description for verified entities

    """

    def __init__(
        self,
        icon_custom_emoji_id: int = 0,
        organization_name: str = "",
        default_custom_description: FormattedText = None,
        can_set_custom_description: bool = False,
    ) -> None:
        self.icon_custom_emoji_id: int = int(icon_custom_emoji_id)
        r"""Identifier of the custom emoji that is used as the verification sign"""
        self.organization_name: Union[str, None] = organization_name
        r"""Name of the organization that provides verification"""
        self.default_custom_description: Union[FormattedText, None] = (
            default_custom_description
        )
        r"""Default custom description of verification reason to be used as placeholder in setMessageSenderBotVerification; may be null if none"""
        self.can_set_custom_description: bool = bool(can_set_custom_description)
        r"""True, if the bot is allowed to provide custom description for verified entities"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botVerificationParameters"]:
        return "botVerificationParameters"

    def getClass(self) -> Literal["BotVerificationParameters"]:
        return "BotVerificationParameters"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "icon_custom_emoji_id": self.icon_custom_emoji_id,
            "organization_name": self.organization_name,
            "default_custom_description": self.default_custom_description,
            "can_set_custom_description": self.can_set_custom_description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotVerificationParameters", None]:
        if data:
            data_class = cls()
            data_class.icon_custom_emoji_id = int(data.get("icon_custom_emoji_id", 0))
            data_class.organization_name = data.get("organization_name", "")
            data_class.default_custom_description = data.get(
                "default_custom_description", None
            )
            data_class.can_set_custom_description = data.get(
                "can_set_custom_description", False
            )

        return data_class


class BotVerification(TlObject):
    r"""Describes verification status provided by a bot

    Parameters:
        bot_user_id (:class:`int`):
            Identifier of the bot that provided the verification

        icon_custom_emoji_id (:class:`int`):
            Identifier of the custom emoji that is used as the verification sign

        custom_description (:class:`"types.FormattedText"`):
            Custom description of verification reason set by the bot\. Can contain only Mention, Hashtag, Cashtag, PhoneNumber, BankCardNumber, Url, and EmailAddress entities

    """

    def __init__(
        self,
        bot_user_id: int = 0,
        icon_custom_emoji_id: int = 0,
        custom_description: FormattedText = None,
    ) -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""Identifier of the bot that provided the verification"""
        self.icon_custom_emoji_id: int = int(icon_custom_emoji_id)
        r"""Identifier of the custom emoji that is used as the verification sign"""
        self.custom_description: Union[FormattedText, None] = custom_description
        r"""Custom description of verification reason set by the bot\. Can contain only Mention, Hashtag, Cashtag, PhoneNumber, BankCardNumber, Url, and EmailAddress entities"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botVerification"]:
        return "botVerification"

    def getClass(self) -> Literal["BotVerification"]:
        return "BotVerification"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "icon_custom_emoji_id": self.icon_custom_emoji_id,
            "custom_description": self.custom_description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotVerification", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.icon_custom_emoji_id = int(data.get("icon_custom_emoji_id", 0))
            data_class.custom_description = data.get("custom_description", None)

        return data_class


class VerificationStatus(TlObject):
    r"""Contains information about verification status of a chat or a user

    Parameters:
        is_verified (:class:`bool`):
            True, if the chat or the user is verified by Telegram

        is_scam (:class:`bool`):
            True, if the chat or the user is marked as scam by Telegram

        is_fake (:class:`bool`):
            True, if the chat or the user is marked as fake by Telegram

        bot_verification_icon_custom_emoji_id (:class:`int`):
            Identifier of the custom emoji to be shown as verification sign provided by a bot for the user; 0 if none

    """

    def __init__(
        self,
        is_verified: bool = False,
        is_scam: bool = False,
        is_fake: bool = False,
        bot_verification_icon_custom_emoji_id: int = 0,
    ) -> None:
        self.is_verified: bool = bool(is_verified)
        r"""True, if the chat or the user is verified by Telegram"""
        self.is_scam: bool = bool(is_scam)
        r"""True, if the chat or the user is marked as scam by Telegram"""
        self.is_fake: bool = bool(is_fake)
        r"""True, if the chat or the user is marked as fake by Telegram"""
        self.bot_verification_icon_custom_emoji_id: int = int(
            bot_verification_icon_custom_emoji_id
        )
        r"""Identifier of the custom emoji to be shown as verification sign provided by a bot for the user; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["verificationStatus"]:
        return "verificationStatus"

    def getClass(self) -> Literal["VerificationStatus"]:
        return "VerificationStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_verified": self.is_verified,
            "is_scam": self.is_scam,
            "is_fake": self.is_fake,
            "bot_verification_icon_custom_emoji_id": self.bot_verification_icon_custom_emoji_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["VerificationStatus", None]:
        if data:
            data_class = cls()
            data_class.is_verified = data.get("is_verified", False)
            data_class.is_scam = data.get("is_scam", False)
            data_class.is_fake = data.get("is_fake", False)
            data_class.bot_verification_icon_custom_emoji_id = int(
                data.get("bot_verification_icon_custom_emoji_id", 0)
            )

        return data_class


class ChatLocation(TlObject):
    r"""Represents a location to which a chat is connected

    Parameters:
        location (:class:`"types.Location"`):
            The location

        address (:class:`str`):
            Location address; 1\-64 characters, as defined by the chat owner

    """

    def __init__(self, location: Location = None, address: str = "") -> None:
        self.location: Union[Location, None] = location
        r"""The location"""
        self.address: Union[str, None] = address
        r"""Location address; 1\-64 characters, as defined by the chat owner"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatLocation"]:
        return "chatLocation"

    def getClass(self) -> Literal["ChatLocation"]:
        return "ChatLocation"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "address": self.address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatLocation", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.address = data.get("address", "")

        return data_class


class Birthdate(TlObject):
    r"""Represents a birthdate of a user

    Parameters:
        day (:class:`int`):
            Day of the month; 1\-31

        month (:class:`int`):
            Month of the year; 1\-12

        year (:class:`int`):
            Birth year; 0 if unknown

    """

    def __init__(self, day: int = 0, month: int = 0, year: int = 0) -> None:
        self.day: int = int(day)
        r"""Day of the month; 1\-31"""
        self.month: int = int(month)
        r"""Month of the year; 1\-12"""
        self.year: int = int(year)
        r"""Birth year; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["birthdate"]:
        return "birthdate"

    def getClass(self) -> Literal["Birthdate"]:
        return "Birthdate"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "day": self.day,
            "month": self.month,
            "year": self.year,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Birthdate", None]:
        if data:
            data_class = cls()
            data_class.day = int(data.get("day", 0))
            data_class.month = int(data.get("month", 0))
            data_class.year = int(data.get("year", 0))

        return data_class


class CloseBirthdayUser(TlObject):
    r"""Describes a user that had or will have a birthday soon

    Parameters:
        user_id (:class:`int`):
            User identifier

        birthdate (:class:`"types.Birthdate"`):
            Birthdate of the user

    """

    def __init__(self, user_id: int = 0, birthdate: Birthdate = None) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.birthdate: Union[Birthdate, None] = birthdate
        r"""Birthdate of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["closeBirthdayUser"]:
        return "closeBirthdayUser"

    def getClass(self) -> Literal["CloseBirthdayUser"]:
        return "CloseBirthdayUser"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "birthdate": self.birthdate,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CloseBirthdayUser", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.birthdate = data.get("birthdate", None)

        return data_class


class BusinessAwayMessageScheduleAlways(TlObject, BusinessAwayMessageSchedule):
    r"""Send away messages always"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessAwayMessageScheduleAlways"]:
        return "businessAwayMessageScheduleAlways"

    def getClass(self) -> Literal["BusinessAwayMessageSchedule"]:
        return "BusinessAwayMessageSchedule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessAwayMessageScheduleAlways", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessAwayMessageScheduleOutsideOfOpeningHours(
    TlObject, BusinessAwayMessageSchedule
):
    r"""Send away messages outside of the business opening hours"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessAwayMessageScheduleOutsideOfOpeningHours"]:
        return "businessAwayMessageScheduleOutsideOfOpeningHours"

    def getClass(self) -> Literal["BusinessAwayMessageSchedule"]:
        return "BusinessAwayMessageSchedule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["BusinessAwayMessageScheduleOutsideOfOpeningHours", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessAwayMessageScheduleCustom(TlObject, BusinessAwayMessageSchedule):
    r"""Send away messages only in the specified time span

    Parameters:
        start_date (:class:`int`):
            Point in time \(Unix timestamp\) when the away messages will start to be sent

        end_date (:class:`int`):
            Point in time \(Unix timestamp\) when the away messages will stop to be sent

    """

    def __init__(self, start_date: int = 0, end_date: int = 0) -> None:
        self.start_date: int = int(start_date)
        r"""Point in time \(Unix timestamp\) when the away messages will start to be sent"""
        self.end_date: int = int(end_date)
        r"""Point in time \(Unix timestamp\) when the away messages will stop to be sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessAwayMessageScheduleCustom"]:
        return "businessAwayMessageScheduleCustom"

    def getClass(self) -> Literal["BusinessAwayMessageSchedule"]:
        return "BusinessAwayMessageSchedule"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "start_date": self.start_date,
            "end_date": self.end_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessAwayMessageScheduleCustom", None]:
        if data:
            data_class = cls()
            data_class.start_date = int(data.get("start_date", 0))
            data_class.end_date = int(data.get("end_date", 0))

        return data_class


class BusinessLocation(TlObject):
    r"""Represents a location of a business

    Parameters:
        location (:class:`"types.Location"`):
            The location; may be null if not specified

        address (:class:`str`):
            Location address; 1\-96 characters

    """

    def __init__(self, location: Location = None, address: str = "") -> None:
        self.location: Union[Location, None] = location
        r"""The location; may be null if not specified"""
        self.address: Union[str, None] = address
        r"""Location address; 1\-96 characters"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessLocation"]:
        return "businessLocation"

    def getClass(self) -> Literal["BusinessLocation"]:
        return "BusinessLocation"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "address": self.address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessLocation", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.address = data.get("address", "")

        return data_class


class BusinessRecipients(TlObject):
    r"""Describes private chats chosen for automatic interaction with a business

    Parameters:
        chat_ids (:class:`List[int]`):
            Identifiers of selected private chats

        excluded_chat_ids (:class:`List[int]`):
            Identifiers of private chats that are always excluded; for businessConnectedBot only

        select_existing_chats (:class:`bool`):
            True, if all existing private chats are selected

        select_new_chats (:class:`bool`):
            True, if all new private chats are selected

        select_contacts (:class:`bool`):
            True, if all private chats with contacts are selected

        select_non_contacts (:class:`bool`):
            True, if all private chats with non\-contacts are selected

        exclude_selected (:class:`bool`):
            If true, then all private chats except the selected are chosen\. Otherwise, only the selected chats are chosen

    """

    def __init__(
        self,
        chat_ids: List[int] = None,
        excluded_chat_ids: List[int] = None,
        select_existing_chats: bool = False,
        select_new_chats: bool = False,
        select_contacts: bool = False,
        select_non_contacts: bool = False,
        exclude_selected: bool = False,
    ) -> None:
        self.chat_ids: List[int] = chat_ids or []
        r"""Identifiers of selected private chats"""
        self.excluded_chat_ids: List[int] = excluded_chat_ids or []
        r"""Identifiers of private chats that are always excluded; for businessConnectedBot only"""
        self.select_existing_chats: bool = bool(select_existing_chats)
        r"""True, if all existing private chats are selected"""
        self.select_new_chats: bool = bool(select_new_chats)
        r"""True, if all new private chats are selected"""
        self.select_contacts: bool = bool(select_contacts)
        r"""True, if all private chats with contacts are selected"""
        self.select_non_contacts: bool = bool(select_non_contacts)
        r"""True, if all private chats with non\-contacts are selected"""
        self.exclude_selected: bool = bool(exclude_selected)
        r"""If true, then all private chats except the selected are chosen\. Otherwise, only the selected chats are chosen"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessRecipients"]:
        return "businessRecipients"

    def getClass(self) -> Literal["BusinessRecipients"]:
        return "BusinessRecipients"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_ids": self.chat_ids,
            "excluded_chat_ids": self.excluded_chat_ids,
            "select_existing_chats": self.select_existing_chats,
            "select_new_chats": self.select_new_chats,
            "select_contacts": self.select_contacts,
            "select_non_contacts": self.select_non_contacts,
            "exclude_selected": self.exclude_selected,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessRecipients", None]:
        if data:
            data_class = cls()
            data_class.chat_ids = data.get("chat_ids", None)
            data_class.excluded_chat_ids = data.get("excluded_chat_ids", None)
            data_class.select_existing_chats = data.get("select_existing_chats", False)
            data_class.select_new_chats = data.get("select_new_chats", False)
            data_class.select_contacts = data.get("select_contacts", False)
            data_class.select_non_contacts = data.get("select_non_contacts", False)
            data_class.exclude_selected = data.get("exclude_selected", False)

        return data_class


class BusinessAwayMessageSettings(TlObject):
    r"""Describes settings for messages that are automatically sent by a Telegram Business account when it is away

    Parameters:
        shortcut_id (:class:`int`):
            Unique quick reply shortcut identifier for the away messages

        recipients (:class:`"types.BusinessRecipients"`):
            Chosen recipients of the away messages

        schedule (:class:`"types.BusinessAwayMessageSchedule"`):
            Settings used to check whether the current user is away

        offline_only (:class:`bool`):
            True, if the messages must not be sent if the account was online in the last 10 minutes

    """

    def __init__(
        self,
        shortcut_id: int = 0,
        recipients: BusinessRecipients = None,
        schedule: BusinessAwayMessageSchedule = None,
        offline_only: bool = False,
    ) -> None:
        self.shortcut_id: int = int(shortcut_id)
        r"""Unique quick reply shortcut identifier for the away messages"""
        self.recipients: Union[BusinessRecipients, None] = recipients
        r"""Chosen recipients of the away messages"""
        self.schedule: Union[
            BusinessAwayMessageScheduleAlways,
            BusinessAwayMessageScheduleOutsideOfOpeningHours,
            BusinessAwayMessageScheduleCustom,
            None,
        ] = schedule
        r"""Settings used to check whether the current user is away"""
        self.offline_only: bool = bool(offline_only)
        r"""True, if the messages must not be sent if the account was online in the last 10 minutes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessAwayMessageSettings"]:
        return "businessAwayMessageSettings"

    def getClass(self) -> Literal["BusinessAwayMessageSettings"]:
        return "BusinessAwayMessageSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "shortcut_id": self.shortcut_id,
            "recipients": self.recipients,
            "schedule": self.schedule,
            "offline_only": self.offline_only,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessAwayMessageSettings", None]:
        if data:
            data_class = cls()
            data_class.shortcut_id = int(data.get("shortcut_id", 0))
            data_class.recipients = data.get("recipients", None)
            data_class.schedule = data.get("schedule", None)
            data_class.offline_only = data.get("offline_only", False)

        return data_class


class BusinessGreetingMessageSettings(TlObject):
    r"""Describes settings for greeting messages that are automatically sent by a Telegram Business account as response to incoming messages in an inactive private chat

    Parameters:
        shortcut_id (:class:`int`):
            Unique quick reply shortcut identifier for the greeting messages

        recipients (:class:`"types.BusinessRecipients"`):
            Chosen recipients of the greeting messages

        inactivity_days (:class:`int`):
            The number of days after which a chat will be considered as inactive; currently, must be on of 7, 14, 21, or 28

    """

    def __init__(
        self,
        shortcut_id: int = 0,
        recipients: BusinessRecipients = None,
        inactivity_days: int = 0,
    ) -> None:
        self.shortcut_id: int = int(shortcut_id)
        r"""Unique quick reply shortcut identifier for the greeting messages"""
        self.recipients: Union[BusinessRecipients, None] = recipients
        r"""Chosen recipients of the greeting messages"""
        self.inactivity_days: int = int(inactivity_days)
        r"""The number of days after which a chat will be considered as inactive; currently, must be on of 7, 14, 21, or 28"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessGreetingMessageSettings"]:
        return "businessGreetingMessageSettings"

    def getClass(self) -> Literal["BusinessGreetingMessageSettings"]:
        return "BusinessGreetingMessageSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "shortcut_id": self.shortcut_id,
            "recipients": self.recipients,
            "inactivity_days": self.inactivity_days,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessGreetingMessageSettings", None]:
        if data:
            data_class = cls()
            data_class.shortcut_id = int(data.get("shortcut_id", 0))
            data_class.recipients = data.get("recipients", None)
            data_class.inactivity_days = int(data.get("inactivity_days", 0))

        return data_class


class BusinessBotRights(TlObject):
    r"""Describes rights of a business bot

    Parameters:
        can_reply (:class:`bool`):
            True, if the bot can send and edit messages in the private chats that had incoming messages in the last 24 hours

        can_read_messages (:class:`bool`):
            True, if the bot can mark incoming private messages as read

        can_delete_sent_messages (:class:`bool`):
            True, if the bot can delete sent messages

        can_delete_all_messages (:class:`bool`):
            True, if the bot can delete any message

        can_edit_name (:class:`bool`):
            True, if the bot can edit name of the business account

        can_edit_bio (:class:`bool`):
            True, if the bot can edit bio of the business account

        can_edit_profile_photo (:class:`bool`):
            True, if the bot can edit profile photo of the business account

        can_edit_username (:class:`bool`):
            True, if the bot can edit username of the business account

        can_view_gifts_and_stars (:class:`bool`):
            True, if the bot can view gifts and amount of Telegram Stars owned by the business account

        can_sell_gifts (:class:`bool`):
            True, if the bot can sell regular gifts received by the business account

        can_change_gift_settings (:class:`bool`):
            True, if the bot can change gift receiving settings of the business account

        can_transfer_and_upgrade_gifts (:class:`bool`):
            True, if the bot can transfer and upgrade gifts received by the business account

        can_transfer_stars (:class:`bool`):
            True, if the bot can transfer Telegram Stars received by the business account to account of the bot, or use them to upgrade and transfer gifts

        can_manage_stories (:class:`bool`):
            True, if the bot can send, edit and delete stories

    """

    def __init__(
        self,
        can_reply: bool = False,
        can_read_messages: bool = False,
        can_delete_sent_messages: bool = False,
        can_delete_all_messages: bool = False,
        can_edit_name: bool = False,
        can_edit_bio: bool = False,
        can_edit_profile_photo: bool = False,
        can_edit_username: bool = False,
        can_view_gifts_and_stars: bool = False,
        can_sell_gifts: bool = False,
        can_change_gift_settings: bool = False,
        can_transfer_and_upgrade_gifts: bool = False,
        can_transfer_stars: bool = False,
        can_manage_stories: bool = False,
    ) -> None:
        self.can_reply: bool = bool(can_reply)
        r"""True, if the bot can send and edit messages in the private chats that had incoming messages in the last 24 hours"""
        self.can_read_messages: bool = bool(can_read_messages)
        r"""True, if the bot can mark incoming private messages as read"""
        self.can_delete_sent_messages: bool = bool(can_delete_sent_messages)
        r"""True, if the bot can delete sent messages"""
        self.can_delete_all_messages: bool = bool(can_delete_all_messages)
        r"""True, if the bot can delete any message"""
        self.can_edit_name: bool = bool(can_edit_name)
        r"""True, if the bot can edit name of the business account"""
        self.can_edit_bio: bool = bool(can_edit_bio)
        r"""True, if the bot can edit bio of the business account"""
        self.can_edit_profile_photo: bool = bool(can_edit_profile_photo)
        r"""True, if the bot can edit profile photo of the business account"""
        self.can_edit_username: bool = bool(can_edit_username)
        r"""True, if the bot can edit username of the business account"""
        self.can_view_gifts_and_stars: bool = bool(can_view_gifts_and_stars)
        r"""True, if the bot can view gifts and amount of Telegram Stars owned by the business account"""
        self.can_sell_gifts: bool = bool(can_sell_gifts)
        r"""True, if the bot can sell regular gifts received by the business account"""
        self.can_change_gift_settings: bool = bool(can_change_gift_settings)
        r"""True, if the bot can change gift receiving settings of the business account"""
        self.can_transfer_and_upgrade_gifts: bool = bool(can_transfer_and_upgrade_gifts)
        r"""True, if the bot can transfer and upgrade gifts received by the business account"""
        self.can_transfer_stars: bool = bool(can_transfer_stars)
        r"""True, if the bot can transfer Telegram Stars received by the business account to account of the bot, or use them to upgrade and transfer gifts"""
        self.can_manage_stories: bool = bool(can_manage_stories)
        r"""True, if the bot can send, edit and delete stories"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessBotRights"]:
        return "businessBotRights"

    def getClass(self) -> Literal["BusinessBotRights"]:
        return "BusinessBotRights"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "can_reply": self.can_reply,
            "can_read_messages": self.can_read_messages,
            "can_delete_sent_messages": self.can_delete_sent_messages,
            "can_delete_all_messages": self.can_delete_all_messages,
            "can_edit_name": self.can_edit_name,
            "can_edit_bio": self.can_edit_bio,
            "can_edit_profile_photo": self.can_edit_profile_photo,
            "can_edit_username": self.can_edit_username,
            "can_view_gifts_and_stars": self.can_view_gifts_and_stars,
            "can_sell_gifts": self.can_sell_gifts,
            "can_change_gift_settings": self.can_change_gift_settings,
            "can_transfer_and_upgrade_gifts": self.can_transfer_and_upgrade_gifts,
            "can_transfer_stars": self.can_transfer_stars,
            "can_manage_stories": self.can_manage_stories,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessBotRights", None]:
        if data:
            data_class = cls()
            data_class.can_reply = data.get("can_reply", False)
            data_class.can_read_messages = data.get("can_read_messages", False)
            data_class.can_delete_sent_messages = data.get(
                "can_delete_sent_messages", False
            )
            data_class.can_delete_all_messages = data.get(
                "can_delete_all_messages", False
            )
            data_class.can_edit_name = data.get("can_edit_name", False)
            data_class.can_edit_bio = data.get("can_edit_bio", False)
            data_class.can_edit_profile_photo = data.get(
                "can_edit_profile_photo", False
            )
            data_class.can_edit_username = data.get("can_edit_username", False)
            data_class.can_view_gifts_and_stars = data.get(
                "can_view_gifts_and_stars", False
            )
            data_class.can_sell_gifts = data.get("can_sell_gifts", False)
            data_class.can_change_gift_settings = data.get(
                "can_change_gift_settings", False
            )
            data_class.can_transfer_and_upgrade_gifts = data.get(
                "can_transfer_and_upgrade_gifts", False
            )
            data_class.can_transfer_stars = data.get("can_transfer_stars", False)
            data_class.can_manage_stories = data.get("can_manage_stories", False)

        return data_class


class BusinessConnectedBot(TlObject):
    r"""Describes a bot connected to a business account

    Parameters:
        bot_user_id (:class:`int`):
            User identifier of the bot

        recipients (:class:`"types.BusinessRecipients"`):
            Private chats that will be accessible to the bot

        rights (:class:`"types.BusinessBotRights"`):
            Rights of the bot

    """

    def __init__(
        self,
        bot_user_id: int = 0,
        recipients: BusinessRecipients = None,
        rights: BusinessBotRights = None,
    ) -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of the bot"""
        self.recipients: Union[BusinessRecipients, None] = recipients
        r"""Private chats that will be accessible to the bot"""
        self.rights: Union[BusinessBotRights, None] = rights
        r"""Rights of the bot"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessConnectedBot"]:
        return "businessConnectedBot"

    def getClass(self) -> Literal["BusinessConnectedBot"]:
        return "BusinessConnectedBot"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "recipients": self.recipients,
            "rights": self.rights,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessConnectedBot", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.recipients = data.get("recipients", None)
            data_class.rights = data.get("rights", None)

        return data_class


class BusinessStartPage(TlObject):
    r"""Describes settings for a business account start page

    Parameters:
        title (:class:`str`):
            Title text of the start page

        message (:class:`str`):
            Message text of the start page

        sticker (:class:`"types.Sticker"`):
            Greeting sticker of the start page; may be null if none

    """

    def __init__(
        self, title: str = "", message: str = "", sticker: Sticker = None
    ) -> None:
        self.title: Union[str, None] = title
        r"""Title text of the start page"""
        self.message: Union[str, None] = message
        r"""Message text of the start page"""
        self.sticker: Union[Sticker, None] = sticker
        r"""Greeting sticker of the start page; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessStartPage"]:
        return "businessStartPage"

    def getClass(self) -> Literal["BusinessStartPage"]:
        return "BusinessStartPage"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "message": self.message,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessStartPage", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.message = data.get("message", "")
            data_class.sticker = data.get("sticker", None)

        return data_class


class InputBusinessStartPage(TlObject):
    r"""Describes settings for a business account start page to set

    Parameters:
        title (:class:`str`):
            Title text of the start page; 0\-getOption\(\"business\_start\_page\_title\_length\_max\"\) characters

        message (:class:`str`):
            Message text of the start page; 0\-getOption\(\"business\_start\_page\_message\_length\_max\"\) characters

        sticker (:class:`"types.InputFile"`):
            Greeting sticker of the start page; pass null if none\. The sticker must belong to a sticker set and must not be a custom emoji

    """

    def __init__(
        self, title: str = "", message: str = "", sticker: InputFile = None
    ) -> None:
        self.title: Union[str, None] = title
        r"""Title text of the start page; 0\-getOption\(\"business\_start\_page\_title\_length\_max\"\) characters"""
        self.message: Union[str, None] = message
        r"""Message text of the start page; 0\-getOption\(\"business\_start\_page\_message\_length\_max\"\) characters"""
        self.sticker: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = sticker
        r"""Greeting sticker of the start page; pass null if none\. The sticker must belong to a sticker set and must not be a custom emoji"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputBusinessStartPage"]:
        return "inputBusinessStartPage"

    def getClass(self) -> Literal["InputBusinessStartPage"]:
        return "InputBusinessStartPage"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "message": self.message,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputBusinessStartPage", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.message = data.get("message", "")
            data_class.sticker = data.get("sticker", None)

        return data_class


class BusinessOpeningHoursInterval(TlObject):
    r"""Describes an interval of time when the business is open

    Parameters:
        start_minute (:class:`int`):
            The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0\-7\*24\*60

        end_minute (:class:`int`):
            The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 1\-8\*24\*60

    """

    def __init__(self, start_minute: int = 0, end_minute: int = 0) -> None:
        self.start_minute: int = int(start_minute)
        r"""The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0\-7\*24\*60"""
        self.end_minute: int = int(end_minute)
        r"""The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 1\-8\*24\*60"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessOpeningHoursInterval"]:
        return "businessOpeningHoursInterval"

    def getClass(self) -> Literal["BusinessOpeningHoursInterval"]:
        return "BusinessOpeningHoursInterval"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "start_minute": self.start_minute,
            "end_minute": self.end_minute,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessOpeningHoursInterval", None]:
        if data:
            data_class = cls()
            data_class.start_minute = int(data.get("start_minute", 0))
            data_class.end_minute = int(data.get("end_minute", 0))

        return data_class


class BusinessOpeningHours(TlObject):
    r"""Describes opening hours of a business

    Parameters:
        time_zone_id (:class:`str`):
            Unique time zone identifier

        opening_hours (:class:`List["types.BusinessOpeningHoursInterval"]`):
            Intervals of the time when the business is open

    """

    def __init__(
        self,
        time_zone_id: str = "",
        opening_hours: List[BusinessOpeningHoursInterval] = None,
    ) -> None:
        self.time_zone_id: Union[str, None] = time_zone_id
        r"""Unique time zone identifier"""
        self.opening_hours: List[BusinessOpeningHoursInterval] = opening_hours or []
        r"""Intervals of the time when the business is open"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessOpeningHours"]:
        return "businessOpeningHours"

    def getClass(self) -> Literal["BusinessOpeningHours"]:
        return "BusinessOpeningHours"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "time_zone_id": self.time_zone_id,
            "opening_hours": self.opening_hours,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessOpeningHours", None]:
        if data:
            data_class = cls()
            data_class.time_zone_id = data.get("time_zone_id", "")
            data_class.opening_hours = data.get("opening_hours", None)

        return data_class


class BusinessInfo(TlObject):
    r"""Contains information about a Telegram Business account

    Parameters:
        location (:class:`"types.BusinessLocation"`):
            Location of the business; may be null if none

        opening_hours (:class:`"types.BusinessOpeningHours"`):
            Opening hours of the business; may be null if none\. The hours are guaranteed to be valid and has already been split by week days

        local_opening_hours (:class:`"types.BusinessOpeningHours"`):
            Opening hours of the business in the local time; may be null if none\. The hours are guaranteed to be valid and has already been split by week days\. Local time zone identifier will be empty\. An updateUserFullInfo update is not triggered when value of this field changes

        next_open_in (:class:`int`):
            Time left before the business will open the next time, in seconds; 0 if unknown\. An updateUserFullInfo update is not triggered when value of this field changes

        next_close_in (:class:`int`):
            Time left before the business will close the next time, in seconds; 0 if unknown\. An updateUserFullInfo update is not triggered when value of this field changes

        greeting_message_settings (:class:`"types.BusinessGreetingMessageSettings"`):
            The greeting message; may be null if none or the Business account is not of the current user

        away_message_settings (:class:`"types.BusinessAwayMessageSettings"`):
            The away message; may be null if none or the Business account is not of the current user

        start_page (:class:`"types.BusinessStartPage"`):
            Information about start page of the account; may be null if none

    """

    def __init__(
        self,
        location: BusinessLocation = None,
        opening_hours: BusinessOpeningHours = None,
        local_opening_hours: BusinessOpeningHours = None,
        next_open_in: int = 0,
        next_close_in: int = 0,
        greeting_message_settings: BusinessGreetingMessageSettings = None,
        away_message_settings: BusinessAwayMessageSettings = None,
        start_page: BusinessStartPage = None,
    ) -> None:
        self.location: Union[BusinessLocation, None] = location
        r"""Location of the business; may be null if none"""
        self.opening_hours: Union[BusinessOpeningHours, None] = opening_hours
        r"""Opening hours of the business; may be null if none\. The hours are guaranteed to be valid and has already been split by week days"""
        self.local_opening_hours: Union[BusinessOpeningHours, None] = (
            local_opening_hours
        )
        r"""Opening hours of the business in the local time; may be null if none\. The hours are guaranteed to be valid and has already been split by week days\. Local time zone identifier will be empty\. An updateUserFullInfo update is not triggered when value of this field changes"""
        self.next_open_in: int = int(next_open_in)
        r"""Time left before the business will open the next time, in seconds; 0 if unknown\. An updateUserFullInfo update is not triggered when value of this field changes"""
        self.next_close_in: int = int(next_close_in)
        r"""Time left before the business will close the next time, in seconds; 0 if unknown\. An updateUserFullInfo update is not triggered when value of this field changes"""
        self.greeting_message_settings: Union[BusinessGreetingMessageSettings, None] = (
            greeting_message_settings
        )
        r"""The greeting message; may be null if none or the Business account is not of the current user"""
        self.away_message_settings: Union[BusinessAwayMessageSettings, None] = (
            away_message_settings
        )
        r"""The away message; may be null if none or the Business account is not of the current user"""
        self.start_page: Union[BusinessStartPage, None] = start_page
        r"""Information about start page of the account; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessInfo"]:
        return "businessInfo"

    def getClass(self) -> Literal["BusinessInfo"]:
        return "BusinessInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "opening_hours": self.opening_hours,
            "local_opening_hours": self.local_opening_hours,
            "next_open_in": self.next_open_in,
            "next_close_in": self.next_close_in,
            "greeting_message_settings": self.greeting_message_settings,
            "away_message_settings": self.away_message_settings,
            "start_page": self.start_page,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessInfo", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.opening_hours = data.get("opening_hours", None)
            data_class.local_opening_hours = data.get("local_opening_hours", None)
            data_class.next_open_in = int(data.get("next_open_in", 0))
            data_class.next_close_in = int(data.get("next_close_in", 0))
            data_class.greeting_message_settings = data.get(
                "greeting_message_settings", None
            )
            data_class.away_message_settings = data.get("away_message_settings", None)
            data_class.start_page = data.get("start_page", None)

        return data_class


class BusinessChatLink(TlObject):
    r"""Contains information about a business chat link

    Parameters:
        link (:class:`str`):
            The HTTPS link

        text (:class:`"types.FormattedText"`):
            Message draft text that will be added to the input field

        title (:class:`str`):
            Link title

        view_count (:class:`int`):
            Number of times the link was used

    """

    def __init__(
        self,
        link: str = "",
        text: FormattedText = None,
        title: str = "",
        view_count: int = 0,
    ) -> None:
        self.link: Union[str, None] = link
        r"""The HTTPS link"""
        self.text: Union[FormattedText, None] = text
        r"""Message draft text that will be added to the input field"""
        self.title: Union[str, None] = title
        r"""Link title"""
        self.view_count: int = int(view_count)
        r"""Number of times the link was used"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessChatLink"]:
        return "businessChatLink"

    def getClass(self) -> Literal["BusinessChatLink"]:
        return "BusinessChatLink"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "link": self.link,
            "text": self.text,
            "title": self.title,
            "view_count": self.view_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessChatLink", None]:
        if data:
            data_class = cls()
            data_class.link = data.get("link", "")
            data_class.text = data.get("text", None)
            data_class.title = data.get("title", "")
            data_class.view_count = int(data.get("view_count", 0))

        return data_class


class BusinessChatLinks(TlObject):
    r"""Contains a list of business chat links created by the user

    Parameters:
        links (:class:`List["types.BusinessChatLink"]`):
            List of links

    """

    def __init__(self, links: List[BusinessChatLink] = None) -> None:
        self.links: List[BusinessChatLink] = links or []
        r"""List of links"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessChatLinks"]:
        return "businessChatLinks"

    def getClass(self) -> Literal["BusinessChatLinks"]:
        return "BusinessChatLinks"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "links": self.links}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessChatLinks", None]:
        if data:
            data_class = cls()
            data_class.links = data.get("links", None)

        return data_class


class InputBusinessChatLink(TlObject):
    r"""Describes a business chat link to create or edit

    Parameters:
        text (:class:`"types.FormattedText"`):
            Message draft text that will be added to the input field

        title (:class:`str`):
            Link title

    """

    def __init__(self, text: FormattedText = None, title: str = "") -> None:
        self.text: Union[FormattedText, None] = text
        r"""Message draft text that will be added to the input field"""
        self.title: Union[str, None] = title
        r"""Link title"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputBusinessChatLink"]:
        return "inputBusinessChatLink"

    def getClass(self) -> Literal["InputBusinessChatLink"]:
        return "InputBusinessChatLink"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputBusinessChatLink", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.title = data.get("title", "")

        return data_class


class BusinessChatLinkInfo(TlObject):
    r"""Contains information about a business chat link

    Parameters:
        chat_id (:class:`int`):
            Identifier of the private chat that created the link

        text (:class:`"types.FormattedText"`):
            Message draft text that must be added to the input field

    """

    def __init__(self, chat_id: int = 0, text: FormattedText = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the private chat that created the link"""
        self.text: Union[FormattedText, None] = text
        r"""Message draft text that must be added to the input field"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessChatLinkInfo"]:
        return "businessChatLinkInfo"

    def getClass(self) -> Literal["BusinessChatLinkInfo"]:
        return "BusinessChatLinkInfo"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id, "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessChatLinkInfo", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.text = data.get("text", None)

        return data_class


class ChatPhotoStickerTypeRegularOrMask(TlObject, ChatPhotoStickerType):
    r"""Information about the sticker, which was used to create the chat photo

    Parameters:
        sticker_set_id (:class:`int`):
            Sticker set identifier

        sticker_id (:class:`int`):
            Identifier of the sticker in the set

    """

    def __init__(self, sticker_set_id: int = 0, sticker_id: int = 0) -> None:
        self.sticker_set_id: int = int(sticker_set_id)
        r"""Sticker set identifier"""
        self.sticker_id: int = int(sticker_id)
        r"""Identifier of the sticker in the set"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPhotoStickerTypeRegularOrMask"]:
        return "chatPhotoStickerTypeRegularOrMask"

    def getClass(self) -> Literal["ChatPhotoStickerType"]:
        return "ChatPhotoStickerType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker_set_id": self.sticker_set_id,
            "sticker_id": self.sticker_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPhotoStickerTypeRegularOrMask", None]:
        if data:
            data_class = cls()
            data_class.sticker_set_id = int(data.get("sticker_set_id", 0))
            data_class.sticker_id = int(data.get("sticker_id", 0))

        return data_class


class ChatPhotoStickerTypeCustomEmoji(TlObject, ChatPhotoStickerType):
    r"""Information about the custom emoji, which was used to create the chat photo

    Parameters:
        custom_emoji_id (:class:`int`):
            Identifier of the custom emoji

    """

    def __init__(self, custom_emoji_id: int = 0) -> None:
        self.custom_emoji_id: int = int(custom_emoji_id)
        r"""Identifier of the custom emoji"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPhotoStickerTypeCustomEmoji"]:
        return "chatPhotoStickerTypeCustomEmoji"

    def getClass(self) -> Literal["ChatPhotoStickerType"]:
        return "ChatPhotoStickerType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "custom_emoji_id": self.custom_emoji_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPhotoStickerTypeCustomEmoji", None]:
        if data:
            data_class = cls()
            data_class.custom_emoji_id = int(data.get("custom_emoji_id", 0))

        return data_class


class ChatPhotoSticker(TlObject):
    r"""Information about the sticker, which was used to create the chat photo\. The sticker is shown at the center of the photo and occupies at most 67% of it

    Parameters:
        type (:class:`"types.ChatPhotoStickerType"`):
            Type of the sticker

        background_fill (:class:`"types.BackgroundFill"`):
            The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported

    """

    def __init__(
        self, type: ChatPhotoStickerType = None, background_fill: BackgroundFill = None
    ) -> None:
        self.type: Union[
            ChatPhotoStickerTypeRegularOrMask, ChatPhotoStickerTypeCustomEmoji, None
        ] = type
        r"""Type of the sticker"""
        self.background_fill: Union[
            BackgroundFillSolid,
            BackgroundFillGradient,
            BackgroundFillFreeformGradient,
            None,
        ] = background_fill
        r"""The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPhotoSticker"]:
        return "chatPhotoSticker"

    def getClass(self) -> Literal["ChatPhotoSticker"]:
        return "ChatPhotoSticker"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "background_fill": self.background_fill,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPhotoSticker", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.background_fill = data.get("background_fill", None)

        return data_class


class AnimatedChatPhoto(TlObject):
    r"""Animated variant of a chat photo in MPEG4 format

    Parameters:
        length (:class:`int`):
            Animation width and height

        file (:class:`"types.File"`):
            Information about the animation file

        main_frame_timestamp (:class:`float`):
            Timestamp of the frame, used as a static chat photo

    """

    def __init__(
        self, length: int = 0, file: File = None, main_frame_timestamp: float = 0.0
    ) -> None:
        self.length: int = int(length)
        r"""Animation width and height"""
        self.file: Union[File, None] = file
        r"""Information about the animation file"""
        self.main_frame_timestamp: float = float(main_frame_timestamp)
        r"""Timestamp of the frame, used as a static chat photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["animatedChatPhoto"]:
        return "animatedChatPhoto"

    def getClass(self) -> Literal["AnimatedChatPhoto"]:
        return "AnimatedChatPhoto"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "length": self.length,
            "file": self.file,
            "main_frame_timestamp": self.main_frame_timestamp,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AnimatedChatPhoto", None]:
        if data:
            data_class = cls()
            data_class.length = int(data.get("length", 0))
            data_class.file = data.get("file", None)
            data_class.main_frame_timestamp = data.get("main_frame_timestamp", 0.0)

        return data_class


class ChatPhoto(TlObject):
    r"""Describes a chat or user profile photo

    Parameters:
        id (:class:`int`):
            Unique photo identifier

        added_date (:class:`int`):
            Point in time \(Unix timestamp\) when the photo has been added

        minithumbnail (:class:`"types.Minithumbnail"`):
            Photo minithumbnail; may be null

        sizes (:class:`List["types.PhotoSize"]`):
            Available variants of the photo in JPEG format, in different size

        animation (:class:`"types.AnimatedChatPhoto"`):
            A big \(up to 1280x1280\) animated variant of the photo in MPEG4 format; may be null

        small_animation (:class:`"types.AnimatedChatPhoto"`):
            A small \(160x160\) animated variant of the photo in MPEG4 format; may be null even the big animation is available

        sticker (:class:`"types.ChatPhotoSticker"`):
            Sticker\-based version of the chat photo; may be null

    """

    def __init__(
        self,
        id: int = 0,
        added_date: int = 0,
        minithumbnail: Minithumbnail = None,
        sizes: List[PhotoSize] = None,
        animation: AnimatedChatPhoto = None,
        small_animation: AnimatedChatPhoto = None,
        sticker: ChatPhotoSticker = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique photo identifier"""
        self.added_date: int = int(added_date)
        r"""Point in time \(Unix timestamp\) when the photo has been added"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Photo minithumbnail; may be null"""
        self.sizes: List[PhotoSize] = sizes or []
        r"""Available variants of the photo in JPEG format, in different size"""
        self.animation: Union[AnimatedChatPhoto, None] = animation
        r"""A big \(up to 1280x1280\) animated variant of the photo in MPEG4 format; may be null"""
        self.small_animation: Union[AnimatedChatPhoto, None] = small_animation
        r"""A small \(160x160\) animated variant of the photo in MPEG4 format; may be null even the big animation is available"""
        self.sticker: Union[ChatPhotoSticker, None] = sticker
        r"""Sticker\-based version of the chat photo; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPhoto"]:
        return "chatPhoto"

    def getClass(self) -> Literal["ChatPhoto"]:
        return "ChatPhoto"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "added_date": self.added_date,
            "minithumbnail": self.minithumbnail,
            "sizes": self.sizes,
            "animation": self.animation,
            "small_animation": self.small_animation,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPhoto", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.added_date = int(data.get("added_date", 0))
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.sizes = data.get("sizes", None)
            data_class.animation = data.get("animation", None)
            data_class.small_animation = data.get("small_animation", None)
            data_class.sticker = data.get("sticker", None)

        return data_class


class ChatPhotos(TlObject):
    r"""Contains a list of chat or user profile photos

    Parameters:
        total_count (:class:`int`):
            Total number of photos

        photos (:class:`List["types.ChatPhoto"]`):
            List of photos

    """

    def __init__(self, total_count: int = 0, photos: List[ChatPhoto] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of photos"""
        self.photos: List[ChatPhoto] = photos or []
        r"""List of photos"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPhotos"]:
        return "chatPhotos"

    def getClass(self) -> Literal["ChatPhotos"]:
        return "ChatPhotos"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "photos": self.photos,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPhotos", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.photos = data.get("photos", None)

        return data_class


class InputChatPhotoPrevious(TlObject, InputChatPhoto):
    r"""A previously used profile photo of the current user

    Parameters:
        chat_photo_id (:class:`int`):
            Identifier of the current user's profile photo to reuse

    """

    def __init__(self, chat_photo_id: int = 0) -> None:
        self.chat_photo_id: int = int(chat_photo_id)
        r"""Identifier of the current user's profile photo to reuse"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputChatPhotoPrevious"]:
        return "inputChatPhotoPrevious"

    def getClass(self) -> Literal["InputChatPhoto"]:
        return "InputChatPhoto"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_photo_id": self.chat_photo_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputChatPhotoPrevious", None]:
        if data:
            data_class = cls()
            data_class.chat_photo_id = int(data.get("chat_photo_id", 0))

        return data_class


class InputChatPhotoStatic(TlObject, InputChatPhoto):
    r"""A static photo in JPEG format

    Parameters:
        photo (:class:`"types.InputFile"`):
            Photo to be set as profile photo\. Only inputFileLocal and inputFileGenerated are allowed

    """

    def __init__(self, photo: InputFile = None) -> None:
        self.photo: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = photo
        r"""Photo to be set as profile photo\. Only inputFileLocal and inputFileGenerated are allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputChatPhotoStatic"]:
        return "inputChatPhotoStatic"

    def getClass(self) -> Literal["InputChatPhoto"]:
        return "InputChatPhoto"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputChatPhotoStatic", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class InputChatPhotoAnimation(TlObject, InputChatPhoto):
    r"""An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size

    Parameters:
        animation (:class:`"types.InputFile"`):
            Animation to be set as profile photo\. Only inputFileLocal and inputFileGenerated are allowed

        main_frame_timestamp (:class:`float`):
            Timestamp of the frame, which will be used as static chat photo

    """

    def __init__(
        self, animation: InputFile = None, main_frame_timestamp: float = 0.0
    ) -> None:
        self.animation: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = animation
        r"""Animation to be set as profile photo\. Only inputFileLocal and inputFileGenerated are allowed"""
        self.main_frame_timestamp: float = float(main_frame_timestamp)
        r"""Timestamp of the frame, which will be used as static chat photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputChatPhotoAnimation"]:
        return "inputChatPhotoAnimation"

    def getClass(self) -> Literal["InputChatPhoto"]:
        return "InputChatPhoto"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "animation": self.animation,
            "main_frame_timestamp": self.main_frame_timestamp,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputChatPhotoAnimation", None]:
        if data:
            data_class = cls()
            data_class.animation = data.get("animation", None)
            data_class.main_frame_timestamp = data.get("main_frame_timestamp", 0.0)

        return data_class


class InputChatPhotoSticker(TlObject, InputChatPhoto):
    r"""A sticker on a custom background

    Parameters:
        sticker (:class:`"types.ChatPhotoSticker"`):
            Information about the sticker

    """

    def __init__(self, sticker: ChatPhotoSticker = None) -> None:
        self.sticker: Union[ChatPhotoSticker, None] = sticker
        r"""Information about the sticker"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputChatPhotoSticker"]:
        return "inputChatPhotoSticker"

    def getClass(self) -> Literal["InputChatPhoto"]:
        return "InputChatPhoto"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sticker": self.sticker}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputChatPhotoSticker", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)

        return data_class


class ChatPermissions(TlObject):
    r"""Describes actions that a user is allowed to take in a chat

    Parameters:
        can_send_basic_messages (:class:`bool`):
            True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues

        can_send_audios (:class:`bool`):
            True, if the user can send music files

        can_send_documents (:class:`bool`):
            True, if the user can send documents

        can_send_photos (:class:`bool`):
            True, if the user can send photos

        can_send_videos (:class:`bool`):
            True, if the user can send videos

        can_send_video_notes (:class:`bool`):
            True, if the user can send video notes

        can_send_voice_notes (:class:`bool`):
            True, if the user can send voice notes

        can_send_polls (:class:`bool`):
            True, if the user can send polls

        can_send_other_messages (:class:`bool`):
            True, if the user can send animations, games, stickers, and dice and use inline bots

        can_add_link_previews (:class:`bool`):
            True, if the user may add a link preview to their messages

        can_change_info (:class:`bool`):
            True, if the user can change the chat title, photo, and other settings

        can_invite_users (:class:`bool`):
            True, if the user can invite new users to the chat

        can_pin_messages (:class:`bool`):
            True, if the user can pin messages

        can_create_topics (:class:`bool`):
            True, if the user can create topics

    """

    def __init__(
        self,
        can_send_basic_messages: bool = False,
        can_send_audios: bool = False,
        can_send_documents: bool = False,
        can_send_photos: bool = False,
        can_send_videos: bool = False,
        can_send_video_notes: bool = False,
        can_send_voice_notes: bool = False,
        can_send_polls: bool = False,
        can_send_other_messages: bool = False,
        can_add_link_previews: bool = False,
        can_change_info: bool = False,
        can_invite_users: bool = False,
        can_pin_messages: bool = False,
        can_create_topics: bool = False,
    ) -> None:
        self.can_send_basic_messages: bool = bool(can_send_basic_messages)
        r"""True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues"""
        self.can_send_audios: bool = bool(can_send_audios)
        r"""True, if the user can send music files"""
        self.can_send_documents: bool = bool(can_send_documents)
        r"""True, if the user can send documents"""
        self.can_send_photos: bool = bool(can_send_photos)
        r"""True, if the user can send photos"""
        self.can_send_videos: bool = bool(can_send_videos)
        r"""True, if the user can send videos"""
        self.can_send_video_notes: bool = bool(can_send_video_notes)
        r"""True, if the user can send video notes"""
        self.can_send_voice_notes: bool = bool(can_send_voice_notes)
        r"""True, if the user can send voice notes"""
        self.can_send_polls: bool = bool(can_send_polls)
        r"""True, if the user can send polls"""
        self.can_send_other_messages: bool = bool(can_send_other_messages)
        r"""True, if the user can send animations, games, stickers, and dice and use inline bots"""
        self.can_add_link_previews: bool = bool(can_add_link_previews)
        r"""True, if the user may add a link preview to their messages"""
        self.can_change_info: bool = bool(can_change_info)
        r"""True, if the user can change the chat title, photo, and other settings"""
        self.can_invite_users: bool = bool(can_invite_users)
        r"""True, if the user can invite new users to the chat"""
        self.can_pin_messages: bool = bool(can_pin_messages)
        r"""True, if the user can pin messages"""
        self.can_create_topics: bool = bool(can_create_topics)
        r"""True, if the user can create topics"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPermissions"]:
        return "chatPermissions"

    def getClass(self) -> Literal["ChatPermissions"]:
        return "ChatPermissions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "can_send_basic_messages": self.can_send_basic_messages,
            "can_send_audios": self.can_send_audios,
            "can_send_documents": self.can_send_documents,
            "can_send_photos": self.can_send_photos,
            "can_send_videos": self.can_send_videos,
            "can_send_video_notes": self.can_send_video_notes,
            "can_send_voice_notes": self.can_send_voice_notes,
            "can_send_polls": self.can_send_polls,
            "can_send_other_messages": self.can_send_other_messages,
            "can_add_link_previews": self.can_add_link_previews,
            "can_change_info": self.can_change_info,
            "can_invite_users": self.can_invite_users,
            "can_pin_messages": self.can_pin_messages,
            "can_create_topics": self.can_create_topics,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPermissions", None]:
        if data:
            data_class = cls()
            data_class.can_send_basic_messages = data.get(
                "can_send_basic_messages", False
            )
            data_class.can_send_audios = data.get("can_send_audios", False)
            data_class.can_send_documents = data.get("can_send_documents", False)
            data_class.can_send_photos = data.get("can_send_photos", False)
            data_class.can_send_videos = data.get("can_send_videos", False)
            data_class.can_send_video_notes = data.get("can_send_video_notes", False)
            data_class.can_send_voice_notes = data.get("can_send_voice_notes", False)
            data_class.can_send_polls = data.get("can_send_polls", False)
            data_class.can_send_other_messages = data.get(
                "can_send_other_messages", False
            )
            data_class.can_add_link_previews = data.get("can_add_link_previews", False)
            data_class.can_change_info = data.get("can_change_info", False)
            data_class.can_invite_users = data.get("can_invite_users", False)
            data_class.can_pin_messages = data.get("can_pin_messages", False)
            data_class.can_create_topics = data.get("can_create_topics", False)

        return data_class


class ChatAdministratorRights(TlObject):
    r"""Describes rights of the administrator

    Parameters:
        can_manage_chat (:class:`bool`):
            True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report supergroup spam messages and ignore slow mode\. Implied by any other privilege; applicable to supergroups and channels only

        can_change_info (:class:`bool`):
            True, if the administrator can change the chat title, photo, and other settings

        can_post_messages (:class:`bool`):
            True, if the administrator can create channel posts or view channel statistics; applicable to channels only

        can_edit_messages (:class:`bool`):
            True, if the administrator can edit messages of other users and pin messages; applicable to channels only

        can_delete_messages (:class:`bool`):
            True, if the administrator can delete messages of other users

        can_invite_users (:class:`bool`):
            True, if the administrator can invite new users to the chat

        can_restrict_members (:class:`bool`):
            True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels

        can_pin_messages (:class:`bool`):
            True, if the administrator can pin messages; applicable to basic groups and supergroups only

        can_manage_topics (:class:`bool`):
            True, if the administrator can create, rename, close, reopen, hide, and unhide forum topics; applicable to forum supergroups only

        can_promote_members (:class:`bool`):
            True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them

        can_manage_video_chats (:class:`bool`):
            True, if the administrator can manage video chats

        can_post_stories (:class:`bool`):
            True, if the administrator can create new chat stories, or edit and delete posted stories; applicable to supergroups and channels only

        can_edit_stories (:class:`bool`):
            True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access story archive; applicable to supergroups and channels only

        can_delete_stories (:class:`bool`):
            True, if the administrator can delete stories posted by other users; applicable to supergroups and channels only

        is_anonymous (:class:`bool`):
            True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only

    """

    def __init__(
        self,
        can_manage_chat: bool = False,
        can_change_info: bool = False,
        can_post_messages: bool = False,
        can_edit_messages: bool = False,
        can_delete_messages: bool = False,
        can_invite_users: bool = False,
        can_restrict_members: bool = False,
        can_pin_messages: bool = False,
        can_manage_topics: bool = False,
        can_promote_members: bool = False,
        can_manage_video_chats: bool = False,
        can_post_stories: bool = False,
        can_edit_stories: bool = False,
        can_delete_stories: bool = False,
        is_anonymous: bool = False,
    ) -> None:
        self.can_manage_chat: bool = bool(can_manage_chat)
        r"""True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report supergroup spam messages and ignore slow mode\. Implied by any other privilege; applicable to supergroups and channels only"""
        self.can_change_info: bool = bool(can_change_info)
        r"""True, if the administrator can change the chat title, photo, and other settings"""
        self.can_post_messages: bool = bool(can_post_messages)
        r"""True, if the administrator can create channel posts or view channel statistics; applicable to channels only"""
        self.can_edit_messages: bool = bool(can_edit_messages)
        r"""True, if the administrator can edit messages of other users and pin messages; applicable to channels only"""
        self.can_delete_messages: bool = bool(can_delete_messages)
        r"""True, if the administrator can delete messages of other users"""
        self.can_invite_users: bool = bool(can_invite_users)
        r"""True, if the administrator can invite new users to the chat"""
        self.can_restrict_members: bool = bool(can_restrict_members)
        r"""True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels"""
        self.can_pin_messages: bool = bool(can_pin_messages)
        r"""True, if the administrator can pin messages; applicable to basic groups and supergroups only"""
        self.can_manage_topics: bool = bool(can_manage_topics)
        r"""True, if the administrator can create, rename, close, reopen, hide, and unhide forum topics; applicable to forum supergroups only"""
        self.can_promote_members: bool = bool(can_promote_members)
        r"""True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them"""
        self.can_manage_video_chats: bool = bool(can_manage_video_chats)
        r"""True, if the administrator can manage video chats"""
        self.can_post_stories: bool = bool(can_post_stories)
        r"""True, if the administrator can create new chat stories, or edit and delete posted stories; applicable to supergroups and channels only"""
        self.can_edit_stories: bool = bool(can_edit_stories)
        r"""True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access story archive; applicable to supergroups and channels only"""
        self.can_delete_stories: bool = bool(can_delete_stories)
        r"""True, if the administrator can delete stories posted by other users; applicable to supergroups and channels only"""
        self.is_anonymous: bool = bool(is_anonymous)
        r"""True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatAdministratorRights"]:
        return "chatAdministratorRights"

    def getClass(self) -> Literal["ChatAdministratorRights"]:
        return "ChatAdministratorRights"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "can_manage_chat": self.can_manage_chat,
            "can_change_info": self.can_change_info,
            "can_post_messages": self.can_post_messages,
            "can_edit_messages": self.can_edit_messages,
            "can_delete_messages": self.can_delete_messages,
            "can_invite_users": self.can_invite_users,
            "can_restrict_members": self.can_restrict_members,
            "can_pin_messages": self.can_pin_messages,
            "can_manage_topics": self.can_manage_topics,
            "can_promote_members": self.can_promote_members,
            "can_manage_video_chats": self.can_manage_video_chats,
            "can_post_stories": self.can_post_stories,
            "can_edit_stories": self.can_edit_stories,
            "can_delete_stories": self.can_delete_stories,
            "is_anonymous": self.is_anonymous,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatAdministratorRights", None]:
        if data:
            data_class = cls()
            data_class.can_manage_chat = data.get("can_manage_chat", False)
            data_class.can_change_info = data.get("can_change_info", False)
            data_class.can_post_messages = data.get("can_post_messages", False)
            data_class.can_edit_messages = data.get("can_edit_messages", False)
            data_class.can_delete_messages = data.get("can_delete_messages", False)
            data_class.can_invite_users = data.get("can_invite_users", False)
            data_class.can_restrict_members = data.get("can_restrict_members", False)
            data_class.can_pin_messages = data.get("can_pin_messages", False)
            data_class.can_manage_topics = data.get("can_manage_topics", False)
            data_class.can_promote_members = data.get("can_promote_members", False)
            data_class.can_manage_video_chats = data.get(
                "can_manage_video_chats", False
            )
            data_class.can_post_stories = data.get("can_post_stories", False)
            data_class.can_edit_stories = data.get("can_edit_stories", False)
            data_class.can_delete_stories = data.get("can_delete_stories", False)
            data_class.is_anonymous = data.get("is_anonymous", False)

        return data_class


class StarAmount(TlObject):
    r"""Describes a possibly non\-integer amount of Telegram Stars

    Parameters:
        star_count (:class:`int`):
            The integer amount of Telegram Stars rounded to 0

        nanostar_count (:class:`int`):
            The number of 1/1000000000 shares of Telegram Stars; from \-999999999 to 999999999

    """

    def __init__(self, star_count: int = 0, nanostar_count: int = 0) -> None:
        self.star_count: int = int(star_count)
        r"""The integer amount of Telegram Stars rounded to 0"""
        self.nanostar_count: int = int(nanostar_count)
        r"""The number of 1/1000000000 shares of Telegram Stars; from \-999999999 to 999999999"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starAmount"]:
        return "starAmount"

    def getClass(self) -> Literal["StarAmount"]:
        return "StarAmount"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_count": self.star_count,
            "nanostar_count": self.nanostar_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarAmount", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))
            data_class.nanostar_count = int(data.get("nanostar_count", 0))

        return data_class


class StarSubscriptionTypeChannel(TlObject, StarSubscriptionType):
    r"""Describes a subscription to a channel chat

    Parameters:
        can_reuse (:class:`bool`):
            True, if the subscription is active and the user can use the method reuseStarSubscription to join the subscribed chat again

        invite_link (:class:`str`):
            The invite link that can be used to renew the subscription if it has been expired; may be empty, if the link isn't available anymore

    """

    def __init__(self, can_reuse: bool = False, invite_link: str = "") -> None:
        self.can_reuse: bool = bool(can_reuse)
        r"""True, if the subscription is active and the user can use the method reuseStarSubscription to join the subscribed chat again"""
        self.invite_link: Union[str, None] = invite_link
        r"""The invite link that can be used to renew the subscription if it has been expired; may be empty, if the link isn't available anymore"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starSubscriptionTypeChannel"]:
        return "starSubscriptionTypeChannel"

    def getClass(self) -> Literal["StarSubscriptionType"]:
        return "StarSubscriptionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "can_reuse": self.can_reuse,
            "invite_link": self.invite_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarSubscriptionTypeChannel", None]:
        if data:
            data_class = cls()
            data_class.can_reuse = data.get("can_reuse", False)
            data_class.invite_link = data.get("invite_link", "")

        return data_class


class StarSubscriptionTypeBot(TlObject, StarSubscriptionType):
    r"""Describes a subscription in a bot or a business account

    Parameters:
        is_canceled_by_bot (:class:`bool`):
            True, if the subscription was canceled by the bot and can't be extended

        title (:class:`str`):
            Subscription invoice title

        photo (:class:`"types.Photo"`):
            Subscription invoice photo

        invoice_link (:class:`str`):
            The link to the subscription invoice

    """

    def __init__(
        self,
        is_canceled_by_bot: bool = False,
        title: str = "",
        photo: Photo = None,
        invoice_link: str = "",
    ) -> None:
        self.is_canceled_by_bot: bool = bool(is_canceled_by_bot)
        r"""True, if the subscription was canceled by the bot and can't be extended"""
        self.title: Union[str, None] = title
        r"""Subscription invoice title"""
        self.photo: Union[Photo, None] = photo
        r"""Subscription invoice photo"""
        self.invoice_link: Union[str, None] = invoice_link
        r"""The link to the subscription invoice"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starSubscriptionTypeBot"]:
        return "starSubscriptionTypeBot"

    def getClass(self) -> Literal["StarSubscriptionType"]:
        return "StarSubscriptionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_canceled_by_bot": self.is_canceled_by_bot,
            "title": self.title,
            "photo": self.photo,
            "invoice_link": self.invoice_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarSubscriptionTypeBot", None]:
        if data:
            data_class = cls()
            data_class.is_canceled_by_bot = data.get("is_canceled_by_bot", False)
            data_class.title = data.get("title", "")
            data_class.photo = data.get("photo", None)
            data_class.invoice_link = data.get("invoice_link", "")

        return data_class


class StarSubscriptionPricing(TlObject):
    r"""Describes subscription plan paid in Telegram Stars

    Parameters:
        period (:class:`int`):
            The number of seconds between consecutive Telegram Star debiting

        star_count (:class:`int`):
            The amount of Telegram Stars that must be paid for each period

    """

    def __init__(self, period: int = 0, star_count: int = 0) -> None:
        self.period: int = int(period)
        r"""The number of seconds between consecutive Telegram Star debiting"""
        self.star_count: int = int(star_count)
        r"""The amount of Telegram Stars that must be paid for each period"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starSubscriptionPricing"]:
        return "starSubscriptionPricing"

    def getClass(self) -> Literal["StarSubscriptionPricing"]:
        return "StarSubscriptionPricing"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "period": self.period,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarSubscriptionPricing", None]:
        if data:
            data_class = cls()
            data_class.period = int(data.get("period", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class StarSubscription(TlObject):
    r"""Contains information about subscription to a channel chat, a bot, or a business account that was paid in Telegram Stars

    Parameters:
        id (:class:`str`):
            Unique identifier of the subscription

        chat_id (:class:`int`):
            Identifier of the chat that is subscribed

        expiration_date (:class:`int`):
            Point in time \(Unix timestamp\) when the subscription will expire or expired

        is_canceled (:class:`bool`):
            True, if the subscription was canceled

        is_expiring (:class:`bool`):
            True, if the subscription expires soon and there are no enough Telegram Stars on the user's balance to extend it

        pricing (:class:`"types.StarSubscriptionPricing"`):
            The subscription plan

        type (:class:`"types.StarSubscriptionType"`):
            Type of the subscription

    """

    def __init__(
        self,
        id: str = "",
        chat_id: int = 0,
        expiration_date: int = 0,
        is_canceled: bool = False,
        is_expiring: bool = False,
        pricing: StarSubscriptionPricing = None,
        type: StarSubscriptionType = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the subscription"""
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat that is subscribed"""
        self.expiration_date: int = int(expiration_date)
        r"""Point in time \(Unix timestamp\) when the subscription will expire or expired"""
        self.is_canceled: bool = bool(is_canceled)
        r"""True, if the subscription was canceled"""
        self.is_expiring: bool = bool(is_expiring)
        r"""True, if the subscription expires soon and there are no enough Telegram Stars on the user's balance to extend it"""
        self.pricing: Union[StarSubscriptionPricing, None] = pricing
        r"""The subscription plan"""
        self.type: Union[StarSubscriptionTypeChannel, StarSubscriptionTypeBot, None] = (
            type
        )
        r"""Type of the subscription"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starSubscription"]:
        return "starSubscription"

    def getClass(self) -> Literal["StarSubscription"]:
        return "StarSubscription"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "chat_id": self.chat_id,
            "expiration_date": self.expiration_date,
            "is_canceled": self.is_canceled,
            "is_expiring": self.is_expiring,
            "pricing": self.pricing,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarSubscription", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.expiration_date = int(data.get("expiration_date", 0))
            data_class.is_canceled = data.get("is_canceled", False)
            data_class.is_expiring = data.get("is_expiring", False)
            data_class.pricing = data.get("pricing", None)
            data_class.type = data.get("type", None)

        return data_class


class StarSubscriptions(TlObject):
    r"""Represents a list of Telegram Star subscriptions

    Parameters:
        star_amount (:class:`"types.StarAmount"`):
            The amount of owned Telegram Stars

        subscriptions (:class:`List["types.StarSubscription"]`):
            List of subscriptions for Telegram Stars

        required_star_count (:class:`int`):
            The number of Telegram Stars required to buy to extend subscriptions expiring soon

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        star_amount: StarAmount = None,
        subscriptions: List[StarSubscription] = None,
        required_star_count: int = 0,
        next_offset: str = "",
    ) -> None:
        self.star_amount: Union[StarAmount, None] = star_amount
        r"""The amount of owned Telegram Stars"""
        self.subscriptions: List[StarSubscription] = subscriptions or []
        r"""List of subscriptions for Telegram Stars"""
        self.required_star_count: int = int(required_star_count)
        r"""The number of Telegram Stars required to buy to extend subscriptions expiring soon"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starSubscriptions"]:
        return "starSubscriptions"

    def getClass(self) -> Literal["StarSubscriptions"]:
        return "StarSubscriptions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_amount": self.star_amount,
            "subscriptions": self.subscriptions,
            "required_star_count": self.required_star_count,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarSubscriptions", None]:
        if data:
            data_class = cls()
            data_class.star_amount = data.get("star_amount", None)
            data_class.subscriptions = data.get("subscriptions", None)
            data_class.required_star_count = int(data.get("required_star_count", 0))
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class AffiliateTypeCurrentUser(TlObject, AffiliateType):
    r"""The affiliate is the current user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateTypeCurrentUser"]:
        return "affiliateTypeCurrentUser"

    def getClass(self) -> Literal["AffiliateType"]:
        return "AffiliateType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AffiliateTypeCurrentUser", None]:
        if data:
            data_class = cls()

        return data_class


class AffiliateTypeBot(TlObject, AffiliateType):
    r"""The affiliate is a bot owned by the current user

    Parameters:
        user_id (:class:`int`):
            User identifier of the bot

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier of the bot"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateTypeBot"]:
        return "affiliateTypeBot"

    def getClass(self) -> Literal["AffiliateType"]:
        return "AffiliateType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AffiliateTypeBot", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class AffiliateTypeChannel(TlObject, AffiliateType):
    r"""The affiliate is a channel chat where the current user has can\_post\_messages administrator right

    Parameters:
        chat_id (:class:`int`):
            Identifier of the channel chat

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the channel chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateTypeChannel"]:
        return "affiliateTypeChannel"

    def getClass(self) -> Literal["AffiliateType"]:
        return "AffiliateType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AffiliateTypeChannel", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class AffiliateProgramSortOrderProfitability(TlObject, AffiliateProgramSortOrder):
    r"""The affiliate programs must be sorted by the profitability"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateProgramSortOrderProfitability"]:
        return "affiliateProgramSortOrderProfitability"

    def getClass(self) -> Literal["AffiliateProgramSortOrder"]:
        return "AffiliateProgramSortOrder"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["AffiliateProgramSortOrderProfitability", None]:
        if data:
            data_class = cls()

        return data_class


class AffiliateProgramSortOrderCreationDate(TlObject, AffiliateProgramSortOrder):
    r"""The affiliate programs must be sorted by creation date"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateProgramSortOrderCreationDate"]:
        return "affiliateProgramSortOrderCreationDate"

    def getClass(self) -> Literal["AffiliateProgramSortOrder"]:
        return "AffiliateProgramSortOrder"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["AffiliateProgramSortOrderCreationDate", None]:
        if data:
            data_class = cls()

        return data_class


class AffiliateProgramSortOrderRevenue(TlObject, AffiliateProgramSortOrder):
    r"""The affiliate programs must be sorted by the expected revenue"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateProgramSortOrderRevenue"]:
        return "affiliateProgramSortOrderRevenue"

    def getClass(self) -> Literal["AffiliateProgramSortOrder"]:
        return "AffiliateProgramSortOrder"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AffiliateProgramSortOrderRevenue", None]:
        if data:
            data_class = cls()

        return data_class


class AffiliateProgramParameters(TlObject):
    r"""Describes parameters of an affiliate program

    Parameters:
        commission_per_mille (:class:`int`):
            The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner; getOption\(\"affiliate\_program\_commission\_per\_mille\_min\"\)\-getOption\(\"affiliate\_program\_commission\_per\_mille\_max\"\)

        month_count (:class:`int`):
            Number of months the program will be active; 0\-36\. If 0, then the program is eternal

    """

    def __init__(self, commission_per_mille: int = 0, month_count: int = 0) -> None:
        self.commission_per_mille: int = int(commission_per_mille)
        r"""The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner; getOption\(\"affiliate\_program\_commission\_per\_mille\_min\"\)\-getOption\(\"affiliate\_program\_commission\_per\_mille\_max\"\)"""
        self.month_count: int = int(month_count)
        r"""Number of months the program will be active; 0\-36\. If 0, then the program is eternal"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateProgramParameters"]:
        return "affiliateProgramParameters"

    def getClass(self) -> Literal["AffiliateProgramParameters"]:
        return "AffiliateProgramParameters"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "commission_per_mille": self.commission_per_mille,
            "month_count": self.month_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AffiliateProgramParameters", None]:
        if data:
            data_class = cls()
            data_class.commission_per_mille = int(data.get("commission_per_mille", 0))
            data_class.month_count = int(data.get("month_count", 0))

        return data_class


class AffiliateProgramInfo(TlObject):
    r"""Contains information about an active affiliate program

    Parameters:
        parameters (:class:`"types.AffiliateProgramParameters"`):
            Parameters of the affiliate program

        end_date (:class:`int`):
            Point in time \(Unix timestamp\) when the affiliate program will be closed; 0 if the affiliate program isn't scheduled to be closed\. If positive, then the program can't be connected using connectAffiliateProgram, but active connections will work until the date

        daily_revenue_per_user_amount (:class:`"types.StarAmount"`):
            The amount of daily revenue per user in Telegram Stars of the bot that created the affiliate program

    """

    def __init__(
        self,
        parameters: AffiliateProgramParameters = None,
        end_date: int = 0,
        daily_revenue_per_user_amount: StarAmount = None,
    ) -> None:
        self.parameters: Union[AffiliateProgramParameters, None] = parameters
        r"""Parameters of the affiliate program"""
        self.end_date: int = int(end_date)
        r"""Point in time \(Unix timestamp\) when the affiliate program will be closed; 0 if the affiliate program isn't scheduled to be closed\. If positive, then the program can't be connected using connectAffiliateProgram, but active connections will work until the date"""
        self.daily_revenue_per_user_amount: Union[StarAmount, None] = (
            daily_revenue_per_user_amount
        )
        r"""The amount of daily revenue per user in Telegram Stars of the bot that created the affiliate program"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateProgramInfo"]:
        return "affiliateProgramInfo"

    def getClass(self) -> Literal["AffiliateProgramInfo"]:
        return "AffiliateProgramInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "parameters": self.parameters,
            "end_date": self.end_date,
            "daily_revenue_per_user_amount": self.daily_revenue_per_user_amount,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AffiliateProgramInfo", None]:
        if data:
            data_class = cls()
            data_class.parameters = data.get("parameters", None)
            data_class.end_date = int(data.get("end_date", 0))
            data_class.daily_revenue_per_user_amount = data.get(
                "daily_revenue_per_user_amount", None
            )

        return data_class


class AffiliateInfo(TlObject):
    r"""Contains information about an affiliate that received commission from a Telegram Star transaction

    Parameters:
        commission_per_mille (:class:`int`):
            The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner

        affiliate_chat_id (:class:`int`):
            Identifier of the chat which received the commission

        star_amount (:class:`"types.StarAmount"`):
            The amount of Telegram Stars that were received by the affiliate; can be negative for refunds

    """

    def __init__(
        self,
        commission_per_mille: int = 0,
        affiliate_chat_id: int = 0,
        star_amount: StarAmount = None,
    ) -> None:
        self.commission_per_mille: int = int(commission_per_mille)
        r"""The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner"""
        self.affiliate_chat_id: int = int(affiliate_chat_id)
        r"""Identifier of the chat which received the commission"""
        self.star_amount: Union[StarAmount, None] = star_amount
        r"""The amount of Telegram Stars that were received by the affiliate; can be negative for refunds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["affiliateInfo"]:
        return "affiliateInfo"

    def getClass(self) -> Literal["AffiliateInfo"]:
        return "AffiliateInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "commission_per_mille": self.commission_per_mille,
            "affiliate_chat_id": self.affiliate_chat_id,
            "star_amount": self.star_amount,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AffiliateInfo", None]:
        if data:
            data_class = cls()
            data_class.commission_per_mille = int(data.get("commission_per_mille", 0))
            data_class.affiliate_chat_id = int(data.get("affiliate_chat_id", 0))
            data_class.star_amount = data.get("star_amount", None)

        return data_class


class FoundAffiliateProgram(TlObject):
    r"""Describes a found affiliate program

    Parameters:
        bot_user_id (:class:`int`):
            User identifier of the bot created the program

        info (:class:`"types.AffiliateProgramInfo"`):
            Information about the affiliate program

    """

    def __init__(self, bot_user_id: int = 0, info: AffiliateProgramInfo = None) -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of the bot created the program"""
        self.info: Union[AffiliateProgramInfo, None] = info
        r"""Information about the affiliate program"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundAffiliateProgram"]:
        return "foundAffiliateProgram"

    def getClass(self) -> Literal["FoundAffiliateProgram"]:
        return "FoundAffiliateProgram"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "info": self.info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundAffiliateProgram", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.info = data.get("info", None)

        return data_class


class FoundAffiliatePrograms(TlObject):
    r"""Represents a list of found affiliate programs

    Parameters:
        total_count (:class:`int`):
            The total number of found affiliate programs

        programs (:class:`List["types.FoundAffiliateProgram"]`):
            The list of affiliate programs

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        programs: List[FoundAffiliateProgram] = None,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""The total number of found affiliate programs"""
        self.programs: List[FoundAffiliateProgram] = programs or []
        r"""The list of affiliate programs"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundAffiliatePrograms"]:
        return "foundAffiliatePrograms"

    def getClass(self) -> Literal["FoundAffiliatePrograms"]:
        return "FoundAffiliatePrograms"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "programs": self.programs,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundAffiliatePrograms", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.programs = data.get("programs", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class ConnectedAffiliateProgram(TlObject):
    r"""Describes an affiliate program that was connected to an affiliate

    Parameters:
        url (:class:`str`):
            The link that can be used to refer users if the program is still active

        bot_user_id (:class:`int`):
            User identifier of the bot created the program

        parameters (:class:`"types.AffiliateProgramParameters"`):
            The parameters of the affiliate program

        connection_date (:class:`int`):
            Point in time \(Unix timestamp\) when the affiliate program was connected

        is_disconnected (:class:`bool`):
            True, if the program was canceled by the bot, or disconnected by the chat owner and isn't available anymore

        user_count (:class:`int`):
            The number of users that used the affiliate program

        revenue_star_count (:class:`int`):
            The number of Telegram Stars that were earned by the affiliate program

    """

    def __init__(
        self,
        url: str = "",
        bot_user_id: int = 0,
        parameters: AffiliateProgramParameters = None,
        connection_date: int = 0,
        is_disconnected: bool = False,
        user_count: int = 0,
        revenue_star_count: int = 0,
    ) -> None:
        self.url: Union[str, None] = url
        r"""The link that can be used to refer users if the program is still active"""
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of the bot created the program"""
        self.parameters: Union[AffiliateProgramParameters, None] = parameters
        r"""The parameters of the affiliate program"""
        self.connection_date: int = int(connection_date)
        r"""Point in time \(Unix timestamp\) when the affiliate program was connected"""
        self.is_disconnected: bool = bool(is_disconnected)
        r"""True, if the program was canceled by the bot, or disconnected by the chat owner and isn't available anymore"""
        self.user_count: int = int(user_count)
        r"""The number of users that used the affiliate program"""
        self.revenue_star_count: int = int(revenue_star_count)
        r"""The number of Telegram Stars that were earned by the affiliate program"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectedAffiliateProgram"]:
        return "connectedAffiliateProgram"

    def getClass(self) -> Literal["ConnectedAffiliateProgram"]:
        return "ConnectedAffiliateProgram"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "bot_user_id": self.bot_user_id,
            "parameters": self.parameters,
            "connection_date": self.connection_date,
            "is_disconnected": self.is_disconnected,
            "user_count": self.user_count,
            "revenue_star_count": self.revenue_star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectedAffiliateProgram", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.parameters = data.get("parameters", None)
            data_class.connection_date = int(data.get("connection_date", 0))
            data_class.is_disconnected = data.get("is_disconnected", False)
            data_class.user_count = int(data.get("user_count", 0))
            data_class.revenue_star_count = int(data.get("revenue_star_count", 0))

        return data_class


class ConnectedAffiliatePrograms(TlObject):
    r"""Represents a list of affiliate programs that were connected to an affiliate

    Parameters:
        total_count (:class:`int`):
            The total number of affiliate programs that were connected to the affiliate

        programs (:class:`List["types.ConnectedAffiliateProgram"]`):
            The list of connected affiliate programs

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        programs: List[ConnectedAffiliateProgram] = None,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""The total number of affiliate programs that were connected to the affiliate"""
        self.programs: List[ConnectedAffiliateProgram] = programs or []
        r"""The list of connected affiliate programs"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectedAffiliatePrograms"]:
        return "connectedAffiliatePrograms"

    def getClass(self) -> Literal["ConnectedAffiliatePrograms"]:
        return "ConnectedAffiliatePrograms"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "programs": self.programs,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectedAffiliatePrograms", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.programs = data.get("programs", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class ProductInfo(TlObject):
    r"""Contains information about a product that can be paid with invoice

    Parameters:
        title (:class:`str`):
            Product title

        description (:class:`"types.FormattedText"`):
            Product description

        photo (:class:`"types.Photo"`):
            Product photo; may be null

    """

    def __init__(
        self, title: str = "", description: FormattedText = None, photo: Photo = None
    ) -> None:
        self.title: Union[str, None] = title
        r"""Product title"""
        self.description: Union[FormattedText, None] = description
        r"""Product description"""
        self.photo: Union[Photo, None] = photo
        r"""Product photo; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["productInfo"]:
        return "productInfo"

    def getClass(self) -> Literal["ProductInfo"]:
        return "ProductInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "description": self.description,
            "photo": self.photo,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ProductInfo", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", None)
            data_class.photo = data.get("photo", None)

        return data_class


class PremiumPaymentOption(TlObject):
    r"""Describes an option for buying Telegram Premium to a user

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code for Telegram Premium subscription payment

        amount (:class:`int`):
            The amount to pay, in the smallest units of the currency

        discount_percentage (:class:`int`):
            The discount associated with this option, as a percentage

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active\. Use getPremiumInfoSticker to get the sticker to be used as representation of the Telegram Premium subscription

        store_product_id (:class:`str`):
            Identifier of the store product associated with the option

        payment_link (:class:`"types.InternalLinkType"`):
            An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available

    """

    def __init__(
        self,
        currency: str = "",
        amount: int = 0,
        discount_percentage: int = 0,
        month_count: int = 0,
        store_product_id: str = "",
        payment_link: InternalLinkType = None,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code for Telegram Premium subscription payment"""
        self.amount: int = int(amount)
        r"""The amount to pay, in the smallest units of the currency"""
        self.discount_percentage: int = int(discount_percentage)
        r"""The discount associated with this option, as a percentage"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active\. Use getPremiumInfoSticker to get the sticker to be used as representation of the Telegram Premium subscription"""
        self.store_product_id: Union[str, None] = store_product_id
        r"""Identifier of the store product associated with the option"""
        self.payment_link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = payment_link
        r"""An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumPaymentOption"]:
        return "premiumPaymentOption"

    def getClass(self) -> Literal["PremiumPaymentOption"]:
        return "PremiumPaymentOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "discount_percentage": self.discount_percentage,
            "month_count": self.month_count,
            "store_product_id": self.store_product_id,
            "payment_link": self.payment_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumPaymentOption", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.discount_percentage = int(data.get("discount_percentage", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.store_product_id = data.get("store_product_id", "")
            data_class.payment_link = data.get("payment_link", None)

        return data_class


class PremiumStatePaymentOption(TlObject):
    r"""Describes an option for buying or upgrading Telegram Premium for self

    Parameters:
        payment_option (:class:`"types.PremiumPaymentOption"`):
            Information about the payment option

        is_current (:class:`bool`):
            True, if this is the currently used Telegram Premium subscription option

        is_upgrade (:class:`bool`):
            True, if the payment option can be used to upgrade the existing Telegram Premium subscription

        last_transaction_id (:class:`str`):
            Identifier of the last in\-store transaction for the currently used option

    """

    def __init__(
        self,
        payment_option: PremiumPaymentOption = None,
        is_current: bool = False,
        is_upgrade: bool = False,
        last_transaction_id: str = "",
    ) -> None:
        self.payment_option: Union[PremiumPaymentOption, None] = payment_option
        r"""Information about the payment option"""
        self.is_current: bool = bool(is_current)
        r"""True, if this is the currently used Telegram Premium subscription option"""
        self.is_upgrade: bool = bool(is_upgrade)
        r"""True, if the payment option can be used to upgrade the existing Telegram Premium subscription"""
        self.last_transaction_id: Union[str, None] = last_transaction_id
        r"""Identifier of the last in\-store transaction for the currently used option"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStatePaymentOption"]:
        return "premiumStatePaymentOption"

    def getClass(self) -> Literal["PremiumStatePaymentOption"]:
        return "PremiumStatePaymentOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "payment_option": self.payment_option,
            "is_current": self.is_current,
            "is_upgrade": self.is_upgrade,
            "last_transaction_id": self.last_transaction_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumStatePaymentOption", None]:
        if data:
            data_class = cls()
            data_class.payment_option = data.get("payment_option", None)
            data_class.is_current = data.get("is_current", False)
            data_class.is_upgrade = data.get("is_upgrade", False)
            data_class.last_transaction_id = data.get("last_transaction_id", "")

        return data_class


class PremiumGiftPaymentOption(TlObject):
    r"""Describes an option for gifting Telegram Premium to a user\. Use telegramPaymentPurposePremiumGift for out\-of\-store payments or payments in Telegram Stars

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code for the payment

        amount (:class:`int`):
            The amount to pay, in the smallest units of the currency

        star_count (:class:`int`):
            The alternative amount of Telegram Stars to pay; 0 if payment in Telegram Stars is not possible

        discount_percentage (:class:`int`):
            The discount associated with this option, as a percentage

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active

        store_product_id (:class:`str`):
            Identifier of the store product associated with the option

        sticker (:class:`"types.Sticker"`):
            A sticker to be shown along with the option; may be null if unknown

    """

    def __init__(
        self,
        currency: str = "",
        amount: int = 0,
        star_count: int = 0,
        discount_percentage: int = 0,
        month_count: int = 0,
        store_product_id: str = "",
        sticker: Sticker = None,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code for the payment"""
        self.amount: int = int(amount)
        r"""The amount to pay, in the smallest units of the currency"""
        self.star_count: int = int(star_count)
        r"""The alternative amount of Telegram Stars to pay; 0 if payment in Telegram Stars is not possible"""
        self.discount_percentage: int = int(discount_percentage)
        r"""The discount associated with this option, as a percentage"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active"""
        self.store_product_id: Union[str, None] = store_product_id
        r"""Identifier of the store product associated with the option"""
        self.sticker: Union[Sticker, None] = sticker
        r"""A sticker to be shown along with the option; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumGiftPaymentOption"]:
        return "premiumGiftPaymentOption"

    def getClass(self) -> Literal["PremiumGiftPaymentOption"]:
        return "PremiumGiftPaymentOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "star_count": self.star_count,
            "discount_percentage": self.discount_percentage,
            "month_count": self.month_count,
            "store_product_id": self.store_product_id,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumGiftPaymentOption", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.star_count = int(data.get("star_count", 0))
            data_class.discount_percentage = int(data.get("discount_percentage", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.store_product_id = data.get("store_product_id", "")
            data_class.sticker = data.get("sticker", None)

        return data_class


class PremiumGiftPaymentOptions(TlObject):
    r"""Contains a list of options for gifting Telegram Premium to a user

    Parameters:
        options (:class:`List["types.PremiumGiftPaymentOption"]`):
            The list of options sorted by Telegram Premium subscription duration

    """

    def __init__(self, options: List[PremiumGiftPaymentOption] = None) -> None:
        self.options: List[PremiumGiftPaymentOption] = options or []
        r"""The list of options sorted by Telegram Premium subscription duration"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumGiftPaymentOptions"]:
        return "premiumGiftPaymentOptions"

    def getClass(self) -> Literal["PremiumGiftPaymentOptions"]:
        return "PremiumGiftPaymentOptions"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "options": self.options}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumGiftPaymentOptions", None]:
        if data:
            data_class = cls()
            data_class.options = data.get("options", None)

        return data_class


class PremiumGiveawayPaymentOption(TlObject):
    r"""Describes an option for creating of Telegram Premium giveaway or manual distribution of Telegram Premium among chat members\. Use telegramPaymentPurposePremiumGiftCodes or telegramPaymentPurposePremiumGiveaway for out\-of\-store payments

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code for Telegram Premium gift code payment

        amount (:class:`int`):
            The amount to pay, in the smallest units of the currency

        winner_count (:class:`int`):
            Number of users which will be able to activate the gift codes

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active

        store_product_id (:class:`str`):
            Identifier of the store product associated with the option; may be empty if none

        store_product_quantity (:class:`int`):
            Number of times the store product must be paid

    """

    def __init__(
        self,
        currency: str = "",
        amount: int = 0,
        winner_count: int = 0,
        month_count: int = 0,
        store_product_id: str = "",
        store_product_quantity: int = 0,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code for Telegram Premium gift code payment"""
        self.amount: int = int(amount)
        r"""The amount to pay, in the smallest units of the currency"""
        self.winner_count: int = int(winner_count)
        r"""Number of users which will be able to activate the gift codes"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active"""
        self.store_product_id: Union[str, None] = store_product_id
        r"""Identifier of the store product associated with the option; may be empty if none"""
        self.store_product_quantity: int = int(store_product_quantity)
        r"""Number of times the store product must be paid"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumGiveawayPaymentOption"]:
        return "premiumGiveawayPaymentOption"

    def getClass(self) -> Literal["PremiumGiveawayPaymentOption"]:
        return "PremiumGiveawayPaymentOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "winner_count": self.winner_count,
            "month_count": self.month_count,
            "store_product_id": self.store_product_id,
            "store_product_quantity": self.store_product_quantity,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumGiveawayPaymentOption", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.store_product_id = data.get("store_product_id", "")
            data_class.store_product_quantity = int(
                data.get("store_product_quantity", 0)
            )

        return data_class


class PremiumGiveawayPaymentOptions(TlObject):
    r"""Contains a list of options for creating of Telegram Premium giveaway or manual distribution of Telegram Premium among chat members

    Parameters:
        options (:class:`List["types.PremiumGiveawayPaymentOption"]`):
            The list of options

    """

    def __init__(self, options: List[PremiumGiveawayPaymentOption] = None) -> None:
        self.options: List[PremiumGiveawayPaymentOption] = options or []
        r"""The list of options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumGiveawayPaymentOptions"]:
        return "premiumGiveawayPaymentOptions"

    def getClass(self) -> Literal["PremiumGiveawayPaymentOptions"]:
        return "PremiumGiveawayPaymentOptions"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "options": self.options}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumGiveawayPaymentOptions", None]:
        if data:
            data_class = cls()
            data_class.options = data.get("options", None)

        return data_class


class PremiumGiftCodeInfo(TlObject):
    r"""Contains information about a Telegram Premium gift code

    Parameters:
        creator_id (:class:`"types.MessageSender"`):
            Identifier of a chat or a user that created the gift code; may be null if unknown\. If null and the code is from messagePremiumGiftCode message, then creator\_id from the message can be used

        creation_date (:class:`int`):
            Point in time \(Unix timestamp\) when the code was created

        is_from_giveaway (:class:`bool`):
            True, if the gift code was created for a giveaway

        giveaway_message_id (:class:`int`):
            Identifier of the corresponding giveaway message in the creator\_id chat; can be 0 or an identifier of a deleted message

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active after code activation

        user_id (:class:`int`):
            Identifier of a user for which the code was created; 0 if none

        use_date (:class:`int`):
            Point in time \(Unix timestamp\) when the code was activated; 0 if none

    """

    def __init__(
        self,
        creator_id: MessageSender = None,
        creation_date: int = 0,
        is_from_giveaway: bool = False,
        giveaway_message_id: int = 0,
        month_count: int = 0,
        user_id: int = 0,
        use_date: int = 0,
    ) -> None:
        self.creator_id: Union[MessageSenderUser, MessageSenderChat, None] = creator_id
        r"""Identifier of a chat or a user that created the gift code; may be null if unknown\. If null and the code is from messagePremiumGiftCode message, then creator\_id from the message can be used"""
        self.creation_date: int = int(creation_date)
        r"""Point in time \(Unix timestamp\) when the code was created"""
        self.is_from_giveaway: bool = bool(is_from_giveaway)
        r"""True, if the gift code was created for a giveaway"""
        self.giveaway_message_id: int = int(giveaway_message_id)
        r"""Identifier of the corresponding giveaway message in the creator\_id chat; can be 0 or an identifier of a deleted message"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active after code activation"""
        self.user_id: int = int(user_id)
        r"""Identifier of a user for which the code was created; 0 if none"""
        self.use_date: int = int(use_date)
        r"""Point in time \(Unix timestamp\) when the code was activated; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumGiftCodeInfo"]:
        return "premiumGiftCodeInfo"

    def getClass(self) -> Literal["PremiumGiftCodeInfo"]:
        return "PremiumGiftCodeInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "creator_id": self.creator_id,
            "creation_date": self.creation_date,
            "is_from_giveaway": self.is_from_giveaway,
            "giveaway_message_id": self.giveaway_message_id,
            "month_count": self.month_count,
            "user_id": self.user_id,
            "use_date": self.use_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumGiftCodeInfo", None]:
        if data:
            data_class = cls()
            data_class.creator_id = data.get("creator_id", None)
            data_class.creation_date = int(data.get("creation_date", 0))
            data_class.is_from_giveaway = data.get("is_from_giveaway", False)
            data_class.giveaway_message_id = int(data.get("giveaway_message_id", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.user_id = int(data.get("user_id", 0))
            data_class.use_date = int(data.get("use_date", 0))

        return data_class


class StarPaymentOption(TlObject):
    r"""Describes an option for buying Telegram Stars\. Use telegramPaymentPurposeStars for out\-of\-store payments

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code for the payment

        amount (:class:`int`):
            The amount to pay, in the smallest units of the currency

        star_count (:class:`int`):
            Number of Telegram Stars that will be purchased

        store_product_id (:class:`str`):
            Identifier of the store product associated with the option; may be empty if none

        is_additional (:class:`bool`):
            True, if the option must be shown only in the full list of payment options

    """

    def __init__(
        self,
        currency: str = "",
        amount: int = 0,
        star_count: int = 0,
        store_product_id: str = "",
        is_additional: bool = False,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code for the payment"""
        self.amount: int = int(amount)
        r"""The amount to pay, in the smallest units of the currency"""
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that will be purchased"""
        self.store_product_id: Union[str, None] = store_product_id
        r"""Identifier of the store product associated with the option; may be empty if none"""
        self.is_additional: bool = bool(is_additional)
        r"""True, if the option must be shown only in the full list of payment options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starPaymentOption"]:
        return "starPaymentOption"

    def getClass(self) -> Literal["StarPaymentOption"]:
        return "StarPaymentOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "star_count": self.star_count,
            "store_product_id": self.store_product_id,
            "is_additional": self.is_additional,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarPaymentOption", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.star_count = int(data.get("star_count", 0))
            data_class.store_product_id = data.get("store_product_id", "")
            data_class.is_additional = data.get("is_additional", False)

        return data_class


class StarPaymentOptions(TlObject):
    r"""Contains a list of options for buying Telegram Stars

    Parameters:
        options (:class:`List["types.StarPaymentOption"]`):
            The list of options

    """

    def __init__(self, options: List[StarPaymentOption] = None) -> None:
        self.options: List[StarPaymentOption] = options or []
        r"""The list of options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starPaymentOptions"]:
        return "starPaymentOptions"

    def getClass(self) -> Literal["StarPaymentOptions"]:
        return "StarPaymentOptions"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "options": self.options}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarPaymentOptions", None]:
        if data:
            data_class = cls()
            data_class.options = data.get("options", None)

        return data_class


class StarGiveawayWinnerOption(TlObject):
    r"""Describes an option for the number of winners of a Telegram Star giveaway

    Parameters:
        winner_count (:class:`int`):
            The number of users that will be chosen as winners

        won_star_count (:class:`int`):
            The number of Telegram Stars that will be won by the winners of the giveaway

        is_default (:class:`bool`):
            True, if the option must be chosen by default

    """

    def __init__(
        self, winner_count: int = 0, won_star_count: int = 0, is_default: bool = False
    ) -> None:
        self.winner_count: int = int(winner_count)
        r"""The number of users that will be chosen as winners"""
        self.won_star_count: int = int(won_star_count)
        r"""The number of Telegram Stars that will be won by the winners of the giveaway"""
        self.is_default: bool = bool(is_default)
        r"""True, if the option must be chosen by default"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starGiveawayWinnerOption"]:
        return "starGiveawayWinnerOption"

    def getClass(self) -> Literal["StarGiveawayWinnerOption"]:
        return "StarGiveawayWinnerOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "winner_count": self.winner_count,
            "won_star_count": self.won_star_count,
            "is_default": self.is_default,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarGiveawayWinnerOption", None]:
        if data:
            data_class = cls()
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.won_star_count = int(data.get("won_star_count", 0))
            data_class.is_default = data.get("is_default", False)

        return data_class


class StarGiveawayPaymentOption(TlObject):
    r"""Describes an option for creating of Telegram Star giveaway\. Use telegramPaymentPurposeStarGiveaway for out\-of\-store payments

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code for the payment

        amount (:class:`int`):
            The amount to pay, in the smallest units of the currency

        star_count (:class:`int`):
            Number of Telegram Stars that will be distributed among winners

        store_product_id (:class:`str`):
            Identifier of the store product associated with the option; may be empty if none

        yearly_boost_count (:class:`int`):
            Number of times the chat will be boosted for one year if the option is chosen

        winner_options (:class:`List["types.StarGiveawayWinnerOption"]`):
            Allowed options for the number of giveaway winners

        is_default (:class:`bool`):
            True, if the option must be chosen by default

        is_additional (:class:`bool`):
            True, if the option must be shown only in the full list of payment options

    """

    def __init__(
        self,
        currency: str = "",
        amount: int = 0,
        star_count: int = 0,
        store_product_id: str = "",
        yearly_boost_count: int = 0,
        winner_options: List[StarGiveawayWinnerOption] = None,
        is_default: bool = False,
        is_additional: bool = False,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code for the payment"""
        self.amount: int = int(amount)
        r"""The amount to pay, in the smallest units of the currency"""
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that will be distributed among winners"""
        self.store_product_id: Union[str, None] = store_product_id
        r"""Identifier of the store product associated with the option; may be empty if none"""
        self.yearly_boost_count: int = int(yearly_boost_count)
        r"""Number of times the chat will be boosted for one year if the option is chosen"""
        self.winner_options: List[StarGiveawayWinnerOption] = winner_options or []
        r"""Allowed options for the number of giveaway winners"""
        self.is_default: bool = bool(is_default)
        r"""True, if the option must be chosen by default"""
        self.is_additional: bool = bool(is_additional)
        r"""True, if the option must be shown only in the full list of payment options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starGiveawayPaymentOption"]:
        return "starGiveawayPaymentOption"

    def getClass(self) -> Literal["StarGiveawayPaymentOption"]:
        return "StarGiveawayPaymentOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "star_count": self.star_count,
            "store_product_id": self.store_product_id,
            "yearly_boost_count": self.yearly_boost_count,
            "winner_options": self.winner_options,
            "is_default": self.is_default,
            "is_additional": self.is_additional,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarGiveawayPaymentOption", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.star_count = int(data.get("star_count", 0))
            data_class.store_product_id = data.get("store_product_id", "")
            data_class.yearly_boost_count = int(data.get("yearly_boost_count", 0))
            data_class.winner_options = data.get("winner_options", None)
            data_class.is_default = data.get("is_default", False)
            data_class.is_additional = data.get("is_additional", False)

        return data_class


class StarGiveawayPaymentOptions(TlObject):
    r"""Contains a list of options for creating of Telegram Star giveaway

    Parameters:
        options (:class:`List["types.StarGiveawayPaymentOption"]`):
            The list of options

    """

    def __init__(self, options: List[StarGiveawayPaymentOption] = None) -> None:
        self.options: List[StarGiveawayPaymentOption] = options or []
        r"""The list of options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starGiveawayPaymentOptions"]:
        return "starGiveawayPaymentOptions"

    def getClass(self) -> Literal["StarGiveawayPaymentOptions"]:
        return "StarGiveawayPaymentOptions"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "options": self.options}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarGiveawayPaymentOptions", None]:
        if data:
            data_class = cls()
            data_class.options = data.get("options", None)

        return data_class


class AcceptedGiftTypes(TlObject):
    r"""Describes gift types that are accepted by a user

    Parameters:
        unlimited_gifts (:class:`bool`):
            True, if unlimited regular gifts are accepted

        limited_gifts (:class:`bool`):
            True, if limited regular gifts are accepted

        upgraded_gifts (:class:`bool`):
            True, if upgraded gifts and regular gifts that can be upgraded for free are accepted

        premium_subscription (:class:`bool`):
            True, if Telegram Premium subscription is accepted

    """

    def __init__(
        self,
        unlimited_gifts: bool = False,
        limited_gifts: bool = False,
        upgraded_gifts: bool = False,
        premium_subscription: bool = False,
    ) -> None:
        self.unlimited_gifts: bool = bool(unlimited_gifts)
        r"""True, if unlimited regular gifts are accepted"""
        self.limited_gifts: bool = bool(limited_gifts)
        r"""True, if limited regular gifts are accepted"""
        self.upgraded_gifts: bool = bool(upgraded_gifts)
        r"""True, if upgraded gifts and regular gifts that can be upgraded for free are accepted"""
        self.premium_subscription: bool = bool(premium_subscription)
        r"""True, if Telegram Premium subscription is accepted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["acceptedGiftTypes"]:
        return "acceptedGiftTypes"

    def getClass(self) -> Literal["AcceptedGiftTypes"]:
        return "AcceptedGiftTypes"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "unlimited_gifts": self.unlimited_gifts,
            "limited_gifts": self.limited_gifts,
            "upgraded_gifts": self.upgraded_gifts,
            "premium_subscription": self.premium_subscription,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AcceptedGiftTypes", None]:
        if data:
            data_class = cls()
            data_class.unlimited_gifts = data.get("unlimited_gifts", False)
            data_class.limited_gifts = data.get("limited_gifts", False)
            data_class.upgraded_gifts = data.get("upgraded_gifts", False)
            data_class.premium_subscription = data.get("premium_subscription", False)

        return data_class


class GiftSettings(TlObject):
    r"""Contains settings for gift receiving for a user

    Parameters:
        show_gift_button (:class:`bool`):
            True, if a button for sending a gift to the user or by the user must always be shown in the input field

        accepted_gift_types (:class:`"types.AcceptedGiftTypes"`):
            Types of gifts accepted by the user; for Telegram Premium users only

    """

    def __init__(
        self,
        show_gift_button: bool = False,
        accepted_gift_types: AcceptedGiftTypes = None,
    ) -> None:
        self.show_gift_button: bool = bool(show_gift_button)
        r"""True, if a button for sending a gift to the user or by the user must always be shown in the input field"""
        self.accepted_gift_types: Union[AcceptedGiftTypes, None] = accepted_gift_types
        r"""Types of gifts accepted by the user; for Telegram Premium users only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giftSettings"]:
        return "giftSettings"

    def getClass(self) -> Literal["GiftSettings"]:
        return "GiftSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "show_gift_button": self.show_gift_button,
            "accepted_gift_types": self.accepted_gift_types,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiftSettings", None]:
        if data:
            data_class = cls()
            data_class.show_gift_button = data.get("show_gift_button", False)
            data_class.accepted_gift_types = data.get("accepted_gift_types", None)

        return data_class


class UpgradedGiftModel(TlObject):
    r"""Describes a model of an upgraded gift

    Parameters:
        name (:class:`str`):
            Name of the model

        sticker (:class:`"types.Sticker"`):
            The sticker representing the upgraded gift

        rarity_per_mille (:class:`int`):
            The number of upgraded gifts that receive this model for each 1000 gifts upgraded

    """

    def __init__(
        self, name: str = "", sticker: Sticker = None, rarity_per_mille: int = 0
    ) -> None:
        self.name: Union[str, None] = name
        r"""Name of the model"""
        self.sticker: Union[Sticker, None] = sticker
        r"""The sticker representing the upgraded gift"""
        self.rarity_per_mille: int = int(rarity_per_mille)
        r"""The number of upgraded gifts that receive this model for each 1000 gifts upgraded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["upgradedGiftModel"]:
        return "upgradedGiftModel"

    def getClass(self) -> Literal["UpgradedGiftModel"]:
        return "UpgradedGiftModel"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "sticker": self.sticker,
            "rarity_per_mille": self.rarity_per_mille,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpgradedGiftModel", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.sticker = data.get("sticker", None)
            data_class.rarity_per_mille = int(data.get("rarity_per_mille", 0))

        return data_class


class UpgradedGiftSymbol(TlObject):
    r"""Describes a symbol shown on the pattern of an upgraded gift

    Parameters:
        name (:class:`str`):
            Name of the symbol

        sticker (:class:`"types.Sticker"`):
            The sticker representing the symbol

        rarity_per_mille (:class:`int`):
            The number of upgraded gifts that receive this symbol for each 1000 gifts upgraded

    """

    def __init__(
        self, name: str = "", sticker: Sticker = None, rarity_per_mille: int = 0
    ) -> None:
        self.name: Union[str, None] = name
        r"""Name of the symbol"""
        self.sticker: Union[Sticker, None] = sticker
        r"""The sticker representing the symbol"""
        self.rarity_per_mille: int = int(rarity_per_mille)
        r"""The number of upgraded gifts that receive this symbol for each 1000 gifts upgraded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["upgradedGiftSymbol"]:
        return "upgradedGiftSymbol"

    def getClass(self) -> Literal["UpgradedGiftSymbol"]:
        return "UpgradedGiftSymbol"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "sticker": self.sticker,
            "rarity_per_mille": self.rarity_per_mille,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpgradedGiftSymbol", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.sticker = data.get("sticker", None)
            data_class.rarity_per_mille = int(data.get("rarity_per_mille", 0))

        return data_class


class UpgradedGiftBackdropColors(TlObject):
    r"""Describes colors of a backdrop of an upgraded gift

    Parameters:
        center_color (:class:`int`):
            A color in the center of the backdrop in the RGB format

        edge_color (:class:`int`):
            A color on the edges of the backdrop in the RGB format

        symbol_color (:class:`int`):
            A color to be applied for the symbol in the RGB format

        text_color (:class:`int`):
            A color for the text on the backdrop in the RGB format

    """

    def __init__(
        self,
        center_color: int = 0,
        edge_color: int = 0,
        symbol_color: int = 0,
        text_color: int = 0,
    ) -> None:
        self.center_color: int = int(center_color)
        r"""A color in the center of the backdrop in the RGB format"""
        self.edge_color: int = int(edge_color)
        r"""A color on the edges of the backdrop in the RGB format"""
        self.symbol_color: int = int(symbol_color)
        r"""A color to be applied for the symbol in the RGB format"""
        self.text_color: int = int(text_color)
        r"""A color for the text on the backdrop in the RGB format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["upgradedGiftBackdropColors"]:
        return "upgradedGiftBackdropColors"

    def getClass(self) -> Literal["UpgradedGiftBackdropColors"]:
        return "UpgradedGiftBackdropColors"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "center_color": self.center_color,
            "edge_color": self.edge_color,
            "symbol_color": self.symbol_color,
            "text_color": self.text_color,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpgradedGiftBackdropColors", None]:
        if data:
            data_class = cls()
            data_class.center_color = int(data.get("center_color", 0))
            data_class.edge_color = int(data.get("edge_color", 0))
            data_class.symbol_color = int(data.get("symbol_color", 0))
            data_class.text_color = int(data.get("text_color", 0))

        return data_class


class UpgradedGiftBackdrop(TlObject):
    r"""Describes a backdrop of an upgraded gift

    Parameters:
        name (:class:`str`):
            Name of the backdrop

        colors (:class:`"types.UpgradedGiftBackdropColors"`):
            Colors of the backdrop

        rarity_per_mille (:class:`int`):
            The number of upgraded gifts that receive this backdrop for each 1000 gifts upgraded

    """

    def __init__(
        self,
        name: str = "",
        colors: UpgradedGiftBackdropColors = None,
        rarity_per_mille: int = 0,
    ) -> None:
        self.name: Union[str, None] = name
        r"""Name of the backdrop"""
        self.colors: Union[UpgradedGiftBackdropColors, None] = colors
        r"""Colors of the backdrop"""
        self.rarity_per_mille: int = int(rarity_per_mille)
        r"""The number of upgraded gifts that receive this backdrop for each 1000 gifts upgraded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["upgradedGiftBackdrop"]:
        return "upgradedGiftBackdrop"

    def getClass(self) -> Literal["UpgradedGiftBackdrop"]:
        return "UpgradedGiftBackdrop"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "colors": self.colors,
            "rarity_per_mille": self.rarity_per_mille,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpgradedGiftBackdrop", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.colors = data.get("colors", None)
            data_class.rarity_per_mille = int(data.get("rarity_per_mille", 0))

        return data_class


class UpgradedGiftOriginalDetails(TlObject):
    r"""Describes the original details about the gift

    Parameters:
        sender_id (:class:`"types.MessageSender"`):
            Identifier of the user or the chat that sent the gift; may be null if the gift was private

        receiver_id (:class:`"types.MessageSender"`):
            Identifier of the user or the chat that received the gift

        text (:class:`"types.FormattedText"`):
            Message added to the gift

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the gift was sent

    """

    def __init__(
        self,
        sender_id: MessageSender = None,
        receiver_id: MessageSender = None,
        text: FormattedText = None,
        date: int = 0,
    ) -> None:
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the user or the chat that sent the gift; may be null if the gift was private"""
        self.receiver_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            receiver_id
        )
        r"""Identifier of the user or the chat that received the gift"""
        self.text: Union[FormattedText, None] = text
        r"""Message added to the gift"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the gift was sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["upgradedGiftOriginalDetails"]:
        return "upgradedGiftOriginalDetails"

    def getClass(self) -> Literal["UpgradedGiftOriginalDetails"]:
        return "UpgradedGiftOriginalDetails"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender_id": self.sender_id,
            "receiver_id": self.receiver_id,
            "text": self.text,
            "date": self.date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpgradedGiftOriginalDetails", None]:
        if data:
            data_class = cls()
            data_class.sender_id = data.get("sender_id", None)
            data_class.receiver_id = data.get("receiver_id", None)
            data_class.text = data.get("text", None)
            data_class.date = int(data.get("date", 0))

        return data_class


class Gift(TlObject):
    r"""Describes a gift that can be sent to another user or channel chat

    Parameters:
        id (:class:`int`):
            Unique identifier of the gift

        sticker (:class:`"types.Sticker"`):
            The sticker representing the gift

        star_count (:class:`int`):
            Number of Telegram Stars that must be paid for the gift

        default_sell_star_count (:class:`int`):
            Number of Telegram Stars that can be claimed by the receiver instead of the regular gift by default\. If the gift was paid with just bought Telegram Stars, then full value can be claimed

        upgrade_star_count (:class:`int`):
            Number of Telegram Stars that must be paid to upgrade the gift; 0 if upgrade isn't possible

        is_for_birthday (:class:`bool`):
            True, if the gift is a birthday gift

        remaining_count (:class:`int`):
            Number of remaining times the gift can be purchased; 0 if not limited or the gift was sold out

        total_count (:class:`int`):
            Number of total times the gift can be purchased; 0 if not limited

        first_send_date (:class:`int`):
            Point in time \(Unix timestamp\) when the gift was send for the first time; for sold out gifts only

        last_send_date (:class:`int`):
            Point in time \(Unix timestamp\) when the gift was send for the last time; for sold out gifts only

    """

    def __init__(
        self,
        id: int = 0,
        sticker: Sticker = None,
        star_count: int = 0,
        default_sell_star_count: int = 0,
        upgrade_star_count: int = 0,
        is_for_birthday: bool = False,
        remaining_count: int = 0,
        total_count: int = 0,
        first_send_date: int = 0,
        last_send_date: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the gift"""
        self.sticker: Union[Sticker, None] = sticker
        r"""The sticker representing the gift"""
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that must be paid for the gift"""
        self.default_sell_star_count: int = int(default_sell_star_count)
        r"""Number of Telegram Stars that can be claimed by the receiver instead of the regular gift by default\. If the gift was paid with just bought Telegram Stars, then full value can be claimed"""
        self.upgrade_star_count: int = int(upgrade_star_count)
        r"""Number of Telegram Stars that must be paid to upgrade the gift; 0 if upgrade isn't possible"""
        self.is_for_birthday: bool = bool(is_for_birthday)
        r"""True, if the gift is a birthday gift"""
        self.remaining_count: int = int(remaining_count)
        r"""Number of remaining times the gift can be purchased; 0 if not limited or the gift was sold out"""
        self.total_count: int = int(total_count)
        r"""Number of total times the gift can be purchased; 0 if not limited"""
        self.first_send_date: int = int(first_send_date)
        r"""Point in time \(Unix timestamp\) when the gift was send for the first time; for sold out gifts only"""
        self.last_send_date: int = int(last_send_date)
        r"""Point in time \(Unix timestamp\) when the gift was send for the last time; for sold out gifts only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["gift"]:
        return "gift"

    def getClass(self) -> Literal["Gift"]:
        return "Gift"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sticker": self.sticker,
            "star_count": self.star_count,
            "default_sell_star_count": self.default_sell_star_count,
            "upgrade_star_count": self.upgrade_star_count,
            "is_for_birthday": self.is_for_birthday,
            "remaining_count": self.remaining_count,
            "total_count": self.total_count,
            "first_send_date": self.first_send_date,
            "last_send_date": self.last_send_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Gift", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sticker = data.get("sticker", None)
            data_class.star_count = int(data.get("star_count", 0))
            data_class.default_sell_star_count = int(
                data.get("default_sell_star_count", 0)
            )
            data_class.upgrade_star_count = int(data.get("upgrade_star_count", 0))
            data_class.is_for_birthday = data.get("is_for_birthday", False)
            data_class.remaining_count = int(data.get("remaining_count", 0))
            data_class.total_count = int(data.get("total_count", 0))
            data_class.first_send_date = int(data.get("first_send_date", 0))
            data_class.last_send_date = int(data.get("last_send_date", 0))

        return data_class


class Gifts(TlObject):
    r"""Contains a list of gifts that can be sent to another user or channel chat

    Parameters:
        gifts (:class:`List["types.Gift"]`):
            The list of gifts

    """

    def __init__(self, gifts: List[Gift] = None) -> None:
        self.gifts: List[Gift] = gifts or []
        r"""The list of gifts"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["gifts"]:
        return "gifts"

    def getClass(self) -> Literal["Gifts"]:
        return "Gifts"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "gifts": self.gifts}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Gifts", None]:
        if data:
            data_class = cls()
            data_class.gifts = data.get("gifts", None)

        return data_class


class UpgradedGift(TlObject):
    r"""Describes an upgraded gift that can be transferred to another owner or transferred to the TON blockchain as an NFT

    Parameters:
        id (:class:`int`):
            Unique identifier of the gift

        title (:class:`str`):
            The title of the upgraded gift

        name (:class:`str`):
            Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift

        number (:class:`int`):
            Unique number of the upgraded gift among gifts upgraded from the same gift

        total_upgraded_count (:class:`int`):
            Total number of gifts that were upgraded from the same gift

        max_upgraded_count (:class:`int`):
            The maximum number of gifts that can be upgraded from the same gift

        owner_id (:class:`"types.MessageSender"`):
            Identifier of the user or the chat that owns the upgraded gift; may be null if none or unknown

        owner_address (:class:`str`):
            Address of the gift NFT owner in TON blockchain; may be empty if none\. Append the address to getOption\(\"ton\_blockchain\_explorer\_url\"\) to get a link with information about the address

        owner_name (:class:`str`):
            Name of the owner for the case when owner identifier and address aren't known

        gift_address (:class:`str`):
            Address of the gift NFT in TON blockchain; may be empty if none\. Append the address to getOption\(\"ton\_blockchain\_explorer\_url\"\) to get a link with information about the address

        model (:class:`"types.UpgradedGiftModel"`):
            Model of the upgraded gift

        symbol (:class:`"types.UpgradedGiftSymbol"`):
            Symbol of the upgraded gift

        backdrop (:class:`"types.UpgradedGiftBackdrop"`):
            Backdrop of the upgraded gift

        original_details (:class:`"types.UpgradedGiftOriginalDetails"`):
            Information about the originally sent gift; may be null if unknown

    """

    def __init__(
        self,
        id: int = 0,
        title: str = "",
        name: str = "",
        number: int = 0,
        total_upgraded_count: int = 0,
        max_upgraded_count: int = 0,
        owner_id: MessageSender = None,
        owner_address: str = "",
        owner_name: str = "",
        gift_address: str = "",
        model: UpgradedGiftModel = None,
        symbol: UpgradedGiftSymbol = None,
        backdrop: UpgradedGiftBackdrop = None,
        original_details: UpgradedGiftOriginalDetails = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the gift"""
        self.title: Union[str, None] = title
        r"""The title of the upgraded gift"""
        self.name: Union[str, None] = name
        r"""Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift"""
        self.number: int = int(number)
        r"""Unique number of the upgraded gift among gifts upgraded from the same gift"""
        self.total_upgraded_count: int = int(total_upgraded_count)
        r"""Total number of gifts that were upgraded from the same gift"""
        self.max_upgraded_count: int = int(max_upgraded_count)
        r"""The maximum number of gifts that can be upgraded from the same gift"""
        self.owner_id: Union[MessageSenderUser, MessageSenderChat, None] = owner_id
        r"""Identifier of the user or the chat that owns the upgraded gift; may be null if none or unknown"""
        self.owner_address: Union[str, None] = owner_address
        r"""Address of the gift NFT owner in TON blockchain; may be empty if none\. Append the address to getOption\(\"ton\_blockchain\_explorer\_url\"\) to get a link with information about the address"""
        self.owner_name: Union[str, None] = owner_name
        r"""Name of the owner for the case when owner identifier and address aren't known"""
        self.gift_address: Union[str, None] = gift_address
        r"""Address of the gift NFT in TON blockchain; may be empty if none\. Append the address to getOption\(\"ton\_blockchain\_explorer\_url\"\) to get a link with information about the address"""
        self.model: Union[UpgradedGiftModel, None] = model
        r"""Model of the upgraded gift"""
        self.symbol: Union[UpgradedGiftSymbol, None] = symbol
        r"""Symbol of the upgraded gift"""
        self.backdrop: Union[UpgradedGiftBackdrop, None] = backdrop
        r"""Backdrop of the upgraded gift"""
        self.original_details: Union[UpgradedGiftOriginalDetails, None] = (
            original_details
        )
        r"""Information about the originally sent gift; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["upgradedGift"]:
        return "upgradedGift"

    def getClass(self) -> Literal["UpgradedGift"]:
        return "UpgradedGift"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "name": self.name,
            "number": self.number,
            "total_upgraded_count": self.total_upgraded_count,
            "max_upgraded_count": self.max_upgraded_count,
            "owner_id": self.owner_id,
            "owner_address": self.owner_address,
            "owner_name": self.owner_name,
            "gift_address": self.gift_address,
            "model": self.model,
            "symbol": self.symbol,
            "backdrop": self.backdrop,
            "original_details": self.original_details,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.title = data.get("title", "")
            data_class.name = data.get("name", "")
            data_class.number = int(data.get("number", 0))
            data_class.total_upgraded_count = int(data.get("total_upgraded_count", 0))
            data_class.max_upgraded_count = int(data.get("max_upgraded_count", 0))
            data_class.owner_id = data.get("owner_id", None)
            data_class.owner_address = data.get("owner_address", "")
            data_class.owner_name = data.get("owner_name", "")
            data_class.gift_address = data.get("gift_address", "")
            data_class.model = data.get("model", None)
            data_class.symbol = data.get("symbol", None)
            data_class.backdrop = data.get("backdrop", None)
            data_class.original_details = data.get("original_details", None)

        return data_class


class UpgradeGiftResult(TlObject):
    r"""Contains result of gift upgrading

    Parameters:
        gift (:class:`"types.UpgradedGift"`):
            The upgraded gift

        received_gift_id (:class:`str`):
            Unique identifier of the received gift for the current user

        is_saved (:class:`bool`):
            True, if the gift is displayed on the user's or the channel's profile page

        can_be_transferred (:class:`bool`):
            True, if the gift can be transferred to another owner

        transfer_star_count (:class:`int`):
            Number of Telegram Stars that must be paid to transfer the upgraded gift

        export_date (:class:`int`):
            Point in time \(Unix timestamp\) when the gift can be transferred to the TON blockchain as an NFT

    """

    def __init__(
        self,
        gift: UpgradedGift = None,
        received_gift_id: str = "",
        is_saved: bool = False,
        can_be_transferred: bool = False,
        transfer_star_count: int = 0,
        export_date: int = 0,
    ) -> None:
        self.gift: Union[UpgradedGift, None] = gift
        r"""The upgraded gift"""
        self.received_gift_id: Union[str, None] = received_gift_id
        r"""Unique identifier of the received gift for the current user"""
        self.is_saved: bool = bool(is_saved)
        r"""True, if the gift is displayed on the user's or the channel's profile page"""
        self.can_be_transferred: bool = bool(can_be_transferred)
        r"""True, if the gift can be transferred to another owner"""
        self.transfer_star_count: int = int(transfer_star_count)
        r"""Number of Telegram Stars that must be paid to transfer the upgraded gift"""
        self.export_date: int = int(export_date)
        r"""Point in time \(Unix timestamp\) when the gift can be transferred to the TON blockchain as an NFT"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["upgradeGiftResult"]:
        return "upgradeGiftResult"

    def getClass(self) -> Literal["UpgradeGiftResult"]:
        return "UpgradeGiftResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "gift": self.gift,
            "received_gift_id": self.received_gift_id,
            "is_saved": self.is_saved,
            "can_be_transferred": self.can_be_transferred,
            "transfer_star_count": self.transfer_star_count,
            "export_date": self.export_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpgradeGiftResult", None]:
        if data:
            data_class = cls()
            data_class.gift = data.get("gift", None)
            data_class.received_gift_id = data.get("received_gift_id", "")
            data_class.is_saved = data.get("is_saved", False)
            data_class.can_be_transferred = data.get("can_be_transferred", False)
            data_class.transfer_star_count = int(data.get("transfer_star_count", 0))
            data_class.export_date = int(data.get("export_date", 0))

        return data_class


class SentGiftRegular(TlObject, SentGift):
    r"""Regular gift

    Parameters:
        gift (:class:`"types.Gift"`):
            The gift

    """

    def __init__(self, gift: Gift = None) -> None:
        self.gift: Union[Gift, None] = gift
        r"""The gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sentGiftRegular"]:
        return "sentGiftRegular"

    def getClass(self) -> Literal["SentGift"]:
        return "SentGift"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "gift": self.gift}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SentGiftRegular", None]:
        if data:
            data_class = cls()
            data_class.gift = data.get("gift", None)

        return data_class


class SentGiftUpgraded(TlObject, SentGift):
    r"""Upgraded gift

    Parameters:
        gift (:class:`"types.UpgradedGift"`):
            The gift

    """

    def __init__(self, gift: UpgradedGift = None) -> None:
        self.gift: Union[UpgradedGift, None] = gift
        r"""The gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sentGiftUpgraded"]:
        return "sentGiftUpgraded"

    def getClass(self) -> Literal["SentGift"]:
        return "SentGift"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "gift": self.gift}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SentGiftUpgraded", None]:
        if data:
            data_class = cls()
            data_class.gift = data.get("gift", None)

        return data_class


class ReceivedGift(TlObject):
    r"""Represents a gift received by a user or a chat

    Parameters:
        received_gift_id (:class:`str`):
            Unique identifier of the received gift for the current user; only for the receiver of the gift

        sender_id (:class:`"types.MessageSender"`):
            Identifier of a user or a chat that sent the gift; may be null if unknown

        text (:class:`"types.FormattedText"`):
            Message added to the gift

        is_private (:class:`bool`):
            True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone are able to see them

        is_saved (:class:`bool`):
            True, if the gift is displayed on the chat's profile page; only for the receiver of the gift

        is_pinned (:class:`bool`):
            True, if the gift is pinned to the top of the chat's profile page

        can_be_upgraded (:class:`bool`):
            True, if the gift is a regular gift that can be upgraded to a unique gift; only for the receiver of the gift

        can_be_transferred (:class:`bool`):
            True, if the gift is an upgraded gift that can be transferred to another owner; only for the receiver of the gift

        was_refunded (:class:`bool`):
            True, if the gift was refunded and isn't available anymore

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the gift was sent

        gift (:class:`"types.SentGift"`):
            The gift

        sell_star_count (:class:`int`):
            Number of Telegram Stars that can be claimed by the receiver instead of the regular gift; 0 if the gift can't be sold by the current user

        prepaid_upgrade_star_count (:class:`int`):
            Number of Telegram Stars that were paid by the sender for the ability to upgrade the gift

        transfer_star_count (:class:`int`):
            Number of Telegram Stars that must be paid to transfer the upgraded gift; only for the receiver of the gift

        export_date (:class:`int`):
            Point in time \(Unix timestamp\) when the upgraded gift can be transferred to the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift

    """

    def __init__(
        self,
        received_gift_id: str = "",
        sender_id: MessageSender = None,
        text: FormattedText = None,
        is_private: bool = False,
        is_saved: bool = False,
        is_pinned: bool = False,
        can_be_upgraded: bool = False,
        can_be_transferred: bool = False,
        was_refunded: bool = False,
        date: int = 0,
        gift: SentGift = None,
        sell_star_count: int = 0,
        prepaid_upgrade_star_count: int = 0,
        transfer_star_count: int = 0,
        export_date: int = 0,
    ) -> None:
        self.received_gift_id: Union[str, None] = received_gift_id
        r"""Unique identifier of the received gift for the current user; only for the receiver of the gift"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of a user or a chat that sent the gift; may be null if unknown"""
        self.text: Union[FormattedText, None] = text
        r"""Message added to the gift"""
        self.is_private: bool = bool(is_private)
        r"""True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone are able to see them"""
        self.is_saved: bool = bool(is_saved)
        r"""True, if the gift is displayed on the chat's profile page; only for the receiver of the gift"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the gift is pinned to the top of the chat's profile page"""
        self.can_be_upgraded: bool = bool(can_be_upgraded)
        r"""True, if the gift is a regular gift that can be upgraded to a unique gift; only for the receiver of the gift"""
        self.can_be_transferred: bool = bool(can_be_transferred)
        r"""True, if the gift is an upgraded gift that can be transferred to another owner; only for the receiver of the gift"""
        self.was_refunded: bool = bool(was_refunded)
        r"""True, if the gift was refunded and isn't available anymore"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the gift was sent"""
        self.gift: Union[SentGiftRegular, SentGiftUpgraded, None] = gift
        r"""The gift"""
        self.sell_star_count: int = int(sell_star_count)
        r"""Number of Telegram Stars that can be claimed by the receiver instead of the regular gift; 0 if the gift can't be sold by the current user"""
        self.prepaid_upgrade_star_count: int = int(prepaid_upgrade_star_count)
        r"""Number of Telegram Stars that were paid by the sender for the ability to upgrade the gift"""
        self.transfer_star_count: int = int(transfer_star_count)
        r"""Number of Telegram Stars that must be paid to transfer the upgraded gift; only for the receiver of the gift"""
        self.export_date: int = int(export_date)
        r"""Point in time \(Unix timestamp\) when the upgraded gift can be transferred to the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["receivedGift"]:
        return "receivedGift"

    def getClass(self) -> Literal["ReceivedGift"]:
        return "ReceivedGift"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "received_gift_id": self.received_gift_id,
            "sender_id": self.sender_id,
            "text": self.text,
            "is_private": self.is_private,
            "is_saved": self.is_saved,
            "is_pinned": self.is_pinned,
            "can_be_upgraded": self.can_be_upgraded,
            "can_be_transferred": self.can_be_transferred,
            "was_refunded": self.was_refunded,
            "date": self.date,
            "gift": self.gift,
            "sell_star_count": self.sell_star_count,
            "prepaid_upgrade_star_count": self.prepaid_upgrade_star_count,
            "transfer_star_count": self.transfer_star_count,
            "export_date": self.export_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReceivedGift", None]:
        if data:
            data_class = cls()
            data_class.received_gift_id = data.get("received_gift_id", "")
            data_class.sender_id = data.get("sender_id", None)
            data_class.text = data.get("text", None)
            data_class.is_private = data.get("is_private", False)
            data_class.is_saved = data.get("is_saved", False)
            data_class.is_pinned = data.get("is_pinned", False)
            data_class.can_be_upgraded = data.get("can_be_upgraded", False)
            data_class.can_be_transferred = data.get("can_be_transferred", False)
            data_class.was_refunded = data.get("was_refunded", False)
            data_class.date = int(data.get("date", 0))
            data_class.gift = data.get("gift", None)
            data_class.sell_star_count = int(data.get("sell_star_count", 0))
            data_class.prepaid_upgrade_star_count = int(
                data.get("prepaid_upgrade_star_count", 0)
            )
            data_class.transfer_star_count = int(data.get("transfer_star_count", 0))
            data_class.export_date = int(data.get("export_date", 0))

        return data_class


class ReceivedGifts(TlObject):
    r"""Represents a list of gifts received by a user or a chat

    Parameters:
        total_count (:class:`int`):
            The total number of received gifts

        gifts (:class:`List["types.ReceivedGift"]`):
            The list of gifts

        are_notifications_enabled (:class:`bool`):
            True, if notifications about new gifts of the owner are enabled

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        gifts: List[ReceivedGift] = None,
        are_notifications_enabled: bool = False,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""The total number of received gifts"""
        self.gifts: List[ReceivedGift] = gifts or []
        r"""The list of gifts"""
        self.are_notifications_enabled: bool = bool(are_notifications_enabled)
        r"""True, if notifications about new gifts of the owner are enabled"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["receivedGifts"]:
        return "receivedGifts"

    def getClass(self) -> Literal["ReceivedGifts"]:
        return "ReceivedGifts"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "gifts": self.gifts,
            "are_notifications_enabled": self.are_notifications_enabled,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReceivedGifts", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.gifts = data.get("gifts", None)
            data_class.are_notifications_enabled = data.get(
                "are_notifications_enabled", False
            )
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class GiftUpgradePreview(TlObject):
    r"""Contains examples of possible upgraded gifts for the given regular gift

    Parameters:
        models (:class:`List["types.UpgradedGiftModel"]`):
            Examples of possible models that can be chosen for the gift after upgrade

        symbols (:class:`List["types.UpgradedGiftSymbol"]`):
            Examples of possible symbols that can be chosen for the gift after upgrade

        backdrops (:class:`List["types.UpgradedGiftBackdrop"]`):
            Examples of possible backdrops that can be chosen for the gift after upgrade

    """

    def __init__(
        self,
        models: List[UpgradedGiftModel] = None,
        symbols: List[UpgradedGiftSymbol] = None,
        backdrops: List[UpgradedGiftBackdrop] = None,
    ) -> None:
        self.models: List[UpgradedGiftModel] = models or []
        r"""Examples of possible models that can be chosen for the gift after upgrade"""
        self.symbols: List[UpgradedGiftSymbol] = symbols or []
        r"""Examples of possible symbols that can be chosen for the gift after upgrade"""
        self.backdrops: List[UpgradedGiftBackdrop] = backdrops or []
        r"""Examples of possible backdrops that can be chosen for the gift after upgrade"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giftUpgradePreview"]:
        return "giftUpgradePreview"

    def getClass(self) -> Literal["GiftUpgradePreview"]:
        return "GiftUpgradePreview"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "models": self.models,
            "symbols": self.symbols,
            "backdrops": self.backdrops,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiftUpgradePreview", None]:
        if data:
            data_class = cls()
            data_class.models = data.get("models", None)
            data_class.symbols = data.get("symbols", None)
            data_class.backdrops = data.get("backdrops", None)

        return data_class


class StarTransactionDirectionIncoming(TlObject, StarTransactionDirection):
    r"""The transaction is incoming and increases the number of owned Telegram Stars"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionDirectionIncoming"]:
        return "starTransactionDirectionIncoming"

    def getClass(self) -> Literal["StarTransactionDirection"]:
        return "StarTransactionDirection"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionDirectionIncoming", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransactionDirectionOutgoing(TlObject, StarTransactionDirection):
    r"""The transaction is outgoing and decreases the number of owned Telegram Stars"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionDirectionOutgoing"]:
        return "starTransactionDirectionOutgoing"

    def getClass(self) -> Literal["StarTransactionDirection"]:
        return "StarTransactionDirection"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionDirectionOutgoing", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransactionTypePremiumBotDeposit(TlObject, StarTransactionType):
    r"""The transaction is a deposit of Telegram Stars from the Premium bot; for regular users only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypePremiumBotDeposit"]:
        return "starTransactionTypePremiumBotDeposit"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypePremiumBotDeposit", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransactionTypeAppStoreDeposit(TlObject, StarTransactionType):
    r"""The transaction is a deposit of Telegram Stars from App Store; for regular users only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeAppStoreDeposit"]:
        return "starTransactionTypeAppStoreDeposit"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeAppStoreDeposit", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransactionTypeGooglePlayDeposit(TlObject, StarTransactionType):
    r"""The transaction is a deposit of Telegram Stars from Google Play; for regular users only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeGooglePlayDeposit"]:
        return "starTransactionTypeGooglePlayDeposit"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeGooglePlayDeposit", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransactionTypeFragmentDeposit(TlObject, StarTransactionType):
    r"""The transaction is a deposit of Telegram Stars from Fragment; for regular users and bots only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeFragmentDeposit"]:
        return "starTransactionTypeFragmentDeposit"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeFragmentDeposit", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransactionTypeUserDeposit(TlObject, StarTransactionType):
    r"""The transaction is a deposit of Telegram Stars by another user; for regular users only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that gifted Telegram Stars; 0 if the user was anonymous

        sticker (:class:`"types.Sticker"`):
            The sticker to be shown in the transaction information; may be null if unknown

    """

    def __init__(self, user_id: int = 0, sticker: Sticker = None) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that gifted Telegram Stars; 0 if the user was anonymous"""
        self.sticker: Union[Sticker, None] = sticker
        r"""The sticker to be shown in the transaction information; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeUserDeposit"]:
        return "starTransactionTypeUserDeposit"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeUserDeposit", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.sticker = data.get("sticker", None)

        return data_class


class StarTransactionTypeGiveawayDeposit(TlObject, StarTransactionType):
    r"""The transaction is a deposit of Telegram Stars from a giveaway; for regular users only

    Parameters:
        chat_id (:class:`int`):
            Identifier of a supergroup or a channel chat that created the giveaway

        giveaway_message_id (:class:`int`):
            Identifier of the message with the giveaway; can be 0 or an identifier of a deleted message

    """

    def __init__(self, chat_id: int = 0, giveaway_message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of a supergroup or a channel chat that created the giveaway"""
        self.giveaway_message_id: int = int(giveaway_message_id)
        r"""Identifier of the message with the giveaway; can be 0 or an identifier of a deleted message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeGiveawayDeposit"]:
        return "starTransactionTypeGiveawayDeposit"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "giveaway_message_id": self.giveaway_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeGiveawayDeposit", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.giveaway_message_id = int(data.get("giveaway_message_id", 0))

        return data_class


class StarTransactionTypeFragmentWithdrawal(TlObject, StarTransactionType):
    r"""The transaction is a withdrawal of earned Telegram Stars to Fragment; for regular users, bots, supergroup and channel chats only

    Parameters:
        withdrawal_state (:class:`"types.RevenueWithdrawalState"`):
            State of the withdrawal; may be null for refunds from Fragment

    """

    def __init__(self, withdrawal_state: RevenueWithdrawalState = None) -> None:
        self.withdrawal_state: Union[
            RevenueWithdrawalStatePending,
            RevenueWithdrawalStateSucceeded,
            RevenueWithdrawalStateFailed,
            None,
        ] = withdrawal_state
        r"""State of the withdrawal; may be null for refunds from Fragment"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeFragmentWithdrawal"]:
        return "starTransactionTypeFragmentWithdrawal"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "withdrawal_state": self.withdrawal_state}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeFragmentWithdrawal", None]:
        if data:
            data_class = cls()
            data_class.withdrawal_state = data.get("withdrawal_state", None)

        return data_class


class StarTransactionTypeTelegramAdsWithdrawal(TlObject, StarTransactionType):
    r"""The transaction is a withdrawal of earned Telegram Stars to Telegram Ad platform; for bots and channel chats only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeTelegramAdsWithdrawal"]:
        return "starTransactionTypeTelegramAdsWithdrawal"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeTelegramAdsWithdrawal", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransactionTypeTelegramApiUsage(TlObject, StarTransactionType):
    r"""The transaction is a payment for Telegram API usage; for bots only

    Parameters:
        request_count (:class:`int`):
            The number of billed requests

    """

    def __init__(self, request_count: int = 0) -> None:
        self.request_count: int = int(request_count)
        r"""The number of billed requests"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeTelegramApiUsage"]:
        return "starTransactionTypeTelegramApiUsage"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "request_count": self.request_count}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeTelegramApiUsage", None]:
        if data:
            data_class = cls()
            data_class.request_count = int(data.get("request_count", 0))

        return data_class


class StarTransactionTypeBotPaidMediaPurchase(TlObject, StarTransactionType):
    r"""The transaction is a purchase of paid media from a bot or a business account by the current user; for regular users only

    Parameters:
        user_id (:class:`int`):
            Identifier of the bot or the business account user that sent the paid media

        media (:class:`List["types.PaidMedia"]`):
            The bought media if the transaction wasn't refunded

    """

    def __init__(self, user_id: int = 0, media: List[PaidMedia] = None) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the bot or the business account user that sent the paid media"""
        self.media: List[PaidMedia] = media or []
        r"""The bought media if the transaction wasn't refunded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBotPaidMediaPurchase"]:
        return "starTransactionTypeBotPaidMediaPurchase"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id, "media": self.media}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeBotPaidMediaPurchase", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.media = data.get("media", None)

        return data_class


class StarTransactionTypeBotPaidMediaSale(TlObject, StarTransactionType):
    r"""The transaction is a sale of paid media by the bot or a business account managed by the bot; for bots only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that bought the media

        media (:class:`List["types.PaidMedia"]`):
            The bought media

        payload (:class:`str`):
            Bot\-provided payload

        affiliate (:class:`"types.AffiliateInfo"`):
            Information about the affiliate which received commission from the transaction; may be null if none

    """

    def __init__(
        self,
        user_id: int = 0,
        media: List[PaidMedia] = None,
        payload: str = "",
        affiliate: AffiliateInfo = None,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that bought the media"""
        self.media: List[PaidMedia] = media or []
        r"""The bought media"""
        self.payload: Union[str, None] = payload
        r"""Bot\-provided payload"""
        self.affiliate: Union[AffiliateInfo, None] = affiliate
        r"""Information about the affiliate which received commission from the transaction; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBotPaidMediaSale"]:
        return "starTransactionTypeBotPaidMediaSale"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "media": self.media,
            "payload": self.payload,
            "affiliate": self.affiliate,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeBotPaidMediaSale", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.media = data.get("media", None)
            data_class.payload = data.get("payload", "")
            data_class.affiliate = data.get("affiliate", None)

        return data_class


class StarTransactionTypeChannelPaidMediaPurchase(TlObject, StarTransactionType):
    r"""The transaction is a purchase of paid media from a channel by the current user; for regular users only

    Parameters:
        chat_id (:class:`int`):
            Identifier of the channel chat that sent the paid media

        message_id (:class:`int`):
            Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message

        media (:class:`List["types.PaidMedia"]`):
            The bought media if the transaction wasn't refunded

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, media: List[PaidMedia] = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the channel chat that sent the paid media"""
        self.message_id: int = int(message_id)
        r"""Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message"""
        self.media: List[PaidMedia] = media or []
        r"""The bought media if the transaction wasn't refunded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeChannelPaidMediaPurchase"]:
        return "starTransactionTypeChannelPaidMediaPurchase"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "media": self.media,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeChannelPaidMediaPurchase", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.media = data.get("media", None)

        return data_class


class StarTransactionTypeChannelPaidMediaSale(TlObject, StarTransactionType):
    r"""The transaction is a sale of paid media by the channel chat; for channel chats only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that bought the media

        message_id (:class:`int`):
            Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message

        media (:class:`List["types.PaidMedia"]`):
            The bought media

    """

    def __init__(
        self, user_id: int = 0, message_id: int = 0, media: List[PaidMedia] = None
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that bought the media"""
        self.message_id: int = int(message_id)
        r"""Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message"""
        self.media: List[PaidMedia] = media or []
        r"""The bought media"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeChannelPaidMediaSale"]:
        return "starTransactionTypeChannelPaidMediaSale"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "message_id": self.message_id,
            "media": self.media,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeChannelPaidMediaSale", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.media = data.get("media", None)

        return data_class


class StarTransactionTypeBotInvoicePurchase(TlObject, StarTransactionType):
    r"""The transaction is a purchase of a product from a bot or a business account by the current user; for regular users only

    Parameters:
        user_id (:class:`int`):
            Identifier of the bot or the business account user that created the invoice

        product_info (:class:`"types.ProductInfo"`):
            Information about the bought product

    """

    def __init__(self, user_id: int = 0, product_info: ProductInfo = None) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the bot or the business account user that created the invoice"""
        self.product_info: Union[ProductInfo, None] = product_info
        r"""Information about the bought product"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBotInvoicePurchase"]:
        return "starTransactionTypeBotInvoicePurchase"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "product_info": self.product_info,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeBotInvoicePurchase", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.product_info = data.get("product_info", None)

        return data_class


class StarTransactionTypeBotInvoiceSale(TlObject, StarTransactionType):
    r"""The transaction is a sale of a product by the bot; for bots only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that bought the product

        product_info (:class:`"types.ProductInfo"`):
            Information about the bought product

        invoice_payload (:class:`bytes`):
            Invoice payload

        affiliate (:class:`"types.AffiliateInfo"`):
            Information about the affiliate which received commission from the transaction; may be null if none

    """

    def __init__(
        self,
        user_id: int = 0,
        product_info: ProductInfo = None,
        invoice_payload: bytes = b"",
        affiliate: AffiliateInfo = None,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that bought the product"""
        self.product_info: Union[ProductInfo, None] = product_info
        r"""Information about the bought product"""
        self.invoice_payload: Union[bytes, None] = invoice_payload
        r"""Invoice payload"""
        self.affiliate: Union[AffiliateInfo, None] = affiliate
        r"""Information about the affiliate which received commission from the transaction; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBotInvoiceSale"]:
        return "starTransactionTypeBotInvoiceSale"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "product_info": self.product_info,
            "invoice_payload": self.invoice_payload,
            "affiliate": self.affiliate,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeBotInvoiceSale", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.product_info = data.get("product_info", None)
            data_class.invoice_payload = b64decode(data.get("invoice_payload", b""))
            data_class.affiliate = data.get("affiliate", None)

        return data_class


class StarTransactionTypeBotSubscriptionPurchase(TlObject, StarTransactionType):
    r"""The transaction is a purchase of a subscription from a bot or a business account by the current user; for regular users only

    Parameters:
        user_id (:class:`int`):
            Identifier of the bot or the business account user that created the subscription link

        subscription_period (:class:`int`):
            The number of seconds between consecutive Telegram Star debitings

        product_info (:class:`"types.ProductInfo"`):
            Information about the bought subscription

    """

    def __init__(
        self,
        user_id: int = 0,
        subscription_period: int = 0,
        product_info: ProductInfo = None,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the bot or the business account user that created the subscription link"""
        self.subscription_period: int = int(subscription_period)
        r"""The number of seconds between consecutive Telegram Star debitings"""
        self.product_info: Union[ProductInfo, None] = product_info
        r"""Information about the bought subscription"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBotSubscriptionPurchase"]:
        return "starTransactionTypeBotSubscriptionPurchase"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "subscription_period": self.subscription_period,
            "product_info": self.product_info,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeBotSubscriptionPurchase", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.subscription_period = int(data.get("subscription_period", 0))
            data_class.product_info = data.get("product_info", None)

        return data_class


class StarTransactionTypeBotSubscriptionSale(TlObject, StarTransactionType):
    r"""The transaction is a sale of a subscription by the bot; for bots only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that bought the subscription

        subscription_period (:class:`int`):
            The number of seconds between consecutive Telegram Star debitings

        product_info (:class:`"types.ProductInfo"`):
            Information about the bought subscription

        invoice_payload (:class:`bytes`):
            Invoice payload

        affiliate (:class:`"types.AffiliateInfo"`):
            Information about the affiliate which received commission from the transaction; may be null if none

    """

    def __init__(
        self,
        user_id: int = 0,
        subscription_period: int = 0,
        product_info: ProductInfo = None,
        invoice_payload: bytes = b"",
        affiliate: AffiliateInfo = None,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that bought the subscription"""
        self.subscription_period: int = int(subscription_period)
        r"""The number of seconds between consecutive Telegram Star debitings"""
        self.product_info: Union[ProductInfo, None] = product_info
        r"""Information about the bought subscription"""
        self.invoice_payload: Union[bytes, None] = invoice_payload
        r"""Invoice payload"""
        self.affiliate: Union[AffiliateInfo, None] = affiliate
        r"""Information about the affiliate which received commission from the transaction; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBotSubscriptionSale"]:
        return "starTransactionTypeBotSubscriptionSale"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "subscription_period": self.subscription_period,
            "product_info": self.product_info,
            "invoice_payload": self.invoice_payload,
            "affiliate": self.affiliate,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeBotSubscriptionSale", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.subscription_period = int(data.get("subscription_period", 0))
            data_class.product_info = data.get("product_info", None)
            data_class.invoice_payload = b64decode(data.get("invoice_payload", b""))
            data_class.affiliate = data.get("affiliate", None)

        return data_class


class StarTransactionTypeChannelSubscriptionPurchase(TlObject, StarTransactionType):
    r"""The transaction is a purchase of a subscription to a channel chat by the current user; for regular users only

    Parameters:
        chat_id (:class:`int`):
            Identifier of the channel chat that created the subscription

        subscription_period (:class:`int`):
            The number of seconds between consecutive Telegram Star debitings

    """

    def __init__(self, chat_id: int = 0, subscription_period: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the channel chat that created the subscription"""
        self.subscription_period: int = int(subscription_period)
        r"""The number of seconds between consecutive Telegram Star debitings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeChannelSubscriptionPurchase"]:
        return "starTransactionTypeChannelSubscriptionPurchase"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "subscription_period": self.subscription_period,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeChannelSubscriptionPurchase", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.subscription_period = int(data.get("subscription_period", 0))

        return data_class


class StarTransactionTypeChannelSubscriptionSale(TlObject, StarTransactionType):
    r"""The transaction is a sale of a subscription by the channel chat; for channel chats only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that bought the subscription

        subscription_period (:class:`int`):
            The number of seconds between consecutive Telegram Star debitings

    """

    def __init__(self, user_id: int = 0, subscription_period: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that bought the subscription"""
        self.subscription_period: int = int(subscription_period)
        r"""The number of seconds between consecutive Telegram Star debitings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeChannelSubscriptionSale"]:
        return "starTransactionTypeChannelSubscriptionSale"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "subscription_period": self.subscription_period,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeChannelSubscriptionSale", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.subscription_period = int(data.get("subscription_period", 0))

        return data_class


class StarTransactionTypeGiftPurchase(TlObject, StarTransactionType):
    r"""The transaction is a purchase of a regular gift; for regular users and bots only

    Parameters:
        owner_id (:class:`"types.MessageSender"`):
            Identifier of the user or the channel that received the gift

        gift (:class:`"types.Gift"`):
            The gift

    """

    def __init__(self, owner_id: MessageSender = None, gift: Gift = None) -> None:
        self.owner_id: Union[MessageSenderUser, MessageSenderChat, None] = owner_id
        r"""Identifier of the user or the channel that received the gift"""
        self.gift: Union[Gift, None] = gift
        r"""The gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeGiftPurchase"]:
        return "starTransactionTypeGiftPurchase"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "owner_id": self.owner_id, "gift": self.gift}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeGiftPurchase", None]:
        if data:
            data_class = cls()
            data_class.owner_id = data.get("owner_id", None)
            data_class.gift = data.get("gift", None)

        return data_class


class StarTransactionTypeGiftTransfer(TlObject, StarTransactionType):
    r"""The transaction is a transfer of an upgraded gift; for regular users only

    Parameters:
        owner_id (:class:`"types.MessageSender"`):
            Identifier of the user or the channel that received the gift

        gift (:class:`"types.UpgradedGift"`):
            The gift

    """

    def __init__(
        self, owner_id: MessageSender = None, gift: UpgradedGift = None
    ) -> None:
        self.owner_id: Union[MessageSenderUser, MessageSenderChat, None] = owner_id
        r"""Identifier of the user or the channel that received the gift"""
        self.gift: Union[UpgradedGift, None] = gift
        r"""The gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeGiftTransfer"]:
        return "starTransactionTypeGiftTransfer"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "owner_id": self.owner_id, "gift": self.gift}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeGiftTransfer", None]:
        if data:
            data_class = cls()
            data_class.owner_id = data.get("owner_id", None)
            data_class.gift = data.get("gift", None)

        return data_class


class StarTransactionTypeGiftSale(TlObject, StarTransactionType):
    r"""The transaction is a sale of a received gift; for regular users and channel chats only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that sent the gift

        gift (:class:`"types.Gift"`):
            The gift

    """

    def __init__(self, user_id: int = 0, gift: Gift = None) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that sent the gift"""
        self.gift: Union[Gift, None] = gift
        r"""The gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeGiftSale"]:
        return "starTransactionTypeGiftSale"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id, "gift": self.gift}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeGiftSale", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.gift = data.get("gift", None)

        return data_class


class StarTransactionTypeGiftUpgrade(TlObject, StarTransactionType):
    r"""The transaction is an upgrade of a gift; for regular users only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that initially sent the gift

        gift (:class:`"types.UpgradedGift"`):
            The upgraded gift

    """

    def __init__(self, user_id: int = 0, gift: UpgradedGift = None) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that initially sent the gift"""
        self.gift: Union[UpgradedGift, None] = gift
        r"""The upgraded gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeGiftUpgrade"]:
        return "starTransactionTypeGiftUpgrade"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id, "gift": self.gift}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeGiftUpgrade", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.gift = data.get("gift", None)

        return data_class


class StarTransactionTypeChannelPaidReactionSend(TlObject, StarTransactionType):
    r"""The transaction is a sending of a paid reaction to a message in a channel chat by the current user; for regular users only

    Parameters:
        chat_id (:class:`int`):
            Identifier of the channel chat

        message_id (:class:`int`):
            Identifier of the reacted message; can be 0 or an identifier of a deleted message

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the channel chat"""
        self.message_id: int = int(message_id)
        r"""Identifier of the reacted message; can be 0 or an identifier of a deleted message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeChannelPaidReactionSend"]:
        return "starTransactionTypeChannelPaidReactionSend"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeChannelPaidReactionSend", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class StarTransactionTypeChannelPaidReactionReceive(TlObject, StarTransactionType):
    r"""The transaction is a receiving of a paid reaction to a message by the channel chat; for channel chats only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that added the paid reaction

        message_id (:class:`int`):
            Identifier of the reacted message; can be 0 or an identifier of a deleted message

    """

    def __init__(self, user_id: int = 0, message_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that added the paid reaction"""
        self.message_id: int = int(message_id)
        r"""Identifier of the reacted message; can be 0 or an identifier of a deleted message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeChannelPaidReactionReceive"]:
        return "starTransactionTypeChannelPaidReactionReceive"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeChannelPaidReactionReceive", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class StarTransactionTypeAffiliateProgramCommission(TlObject, StarTransactionType):
    r"""The transaction is a receiving of a commission from an affiliate program; for regular users, bots and channel chats only

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat that created the affiliate program

        commission_per_mille (:class:`int`):
            The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner

    """

    def __init__(self, chat_id: int = 0, commission_per_mille: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat that created the affiliate program"""
        self.commission_per_mille: int = int(commission_per_mille)
        r"""The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the program owner"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeAffiliateProgramCommission"]:
        return "starTransactionTypeAffiliateProgramCommission"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "commission_per_mille": self.commission_per_mille,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeAffiliateProgramCommission", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.commission_per_mille = int(data.get("commission_per_mille", 0))

        return data_class


class StarTransactionTypePaidMessageSend(TlObject, StarTransactionType):
    r"""The transaction is a sending of a paid message; for regular users only

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat that received the payment

        message_count (:class:`int`):
            Number of sent paid messages

    """

    def __init__(self, chat_id: int = 0, message_count: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat that received the payment"""
        self.message_count: int = int(message_count)
        r"""Number of sent paid messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypePaidMessageSend"]:
        return "starTransactionTypePaidMessageSend"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_count": self.message_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypePaidMessageSend", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_count = int(data.get("message_count", 0))

        return data_class


class StarTransactionTypePaidMessageReceive(TlObject, StarTransactionType):
    r"""The transaction is a receiving of a paid message; for regular users and supergroup chats only

    Parameters:
        sender_id (:class:`"types.MessageSender"`):
            Identifier of the sender of the message

        message_count (:class:`int`):
            Number of received paid messages

        commission_per_mille (:class:`int`):
            The number of Telegram Stars received by the Telegram for each 1000 Telegram Stars paid for message sending

        commission_star_amount (:class:`"types.StarAmount"`):
            The amount of Telegram Stars that were received by Telegram; can be negative for refunds

    """

    def __init__(
        self,
        sender_id: MessageSender = None,
        message_count: int = 0,
        commission_per_mille: int = 0,
        commission_star_amount: StarAmount = None,
    ) -> None:
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the sender of the message"""
        self.message_count: int = int(message_count)
        r"""Number of received paid messages"""
        self.commission_per_mille: int = int(commission_per_mille)
        r"""The number of Telegram Stars received by the Telegram for each 1000 Telegram Stars paid for message sending"""
        self.commission_star_amount: Union[StarAmount, None] = commission_star_amount
        r"""The amount of Telegram Stars that were received by Telegram; can be negative for refunds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypePaidMessageReceive"]:
        return "starTransactionTypePaidMessageReceive"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender_id": self.sender_id,
            "message_count": self.message_count,
            "commission_per_mille": self.commission_per_mille,
            "commission_star_amount": self.commission_star_amount,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypePaidMessageReceive", None]:
        if data:
            data_class = cls()
            data_class.sender_id = data.get("sender_id", None)
            data_class.message_count = int(data.get("message_count", 0))
            data_class.commission_per_mille = int(data.get("commission_per_mille", 0))
            data_class.commission_star_amount = data.get("commission_star_amount", None)

        return data_class


class StarTransactionTypePremiumPurchase(TlObject, StarTransactionType):
    r"""The transaction is a purchase of Telegram Premium subscription; for regular users and bots only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that received the Telegram Premium subscription

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active

        sticker (:class:`"types.Sticker"`):
            A sticker to be shown in the transaction information; may be null if unknown

    """

    def __init__(
        self, user_id: int = 0, month_count: int = 0, sticker: Sticker = None
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that received the Telegram Premium subscription"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active"""
        self.sticker: Union[Sticker, None] = sticker
        r"""A sticker to be shown in the transaction information; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypePremiumPurchase"]:
        return "starTransactionTypePremiumPurchase"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "month_count": self.month_count,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypePremiumPurchase", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.sticker = data.get("sticker", None)

        return data_class


class StarTransactionTypeBusinessBotTransferSend(TlObject, StarTransactionType):
    r"""The transaction is a transfer of Telegram Stars to a business bot; for regular users only

    Parameters:
        user_id (:class:`int`):
            Identifier of the bot that received Telegram Stars

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the bot that received Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBusinessBotTransferSend"]:
        return "starTransactionTypeBusinessBotTransferSend"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeBusinessBotTransferSend", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class StarTransactionTypeBusinessBotTransferReceive(TlObject, StarTransactionType):
    r"""The transaction is a transfer of Telegram Stars from a business account; for bots only

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that sent Telegram Stars

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that sent Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeBusinessBotTransferReceive"]:
        return "starTransactionTypeBusinessBotTransferReceive"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StarTransactionTypeBusinessBotTransferReceive", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class StarTransactionTypeUnsupported(TlObject, StarTransactionType):
    r"""The transaction is a transaction of an unsupported type"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactionTypeUnsupported"]:
        return "starTransactionTypeUnsupported"

    def getClass(self) -> Literal["StarTransactionType"]:
        return "StarTransactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactionTypeUnsupported", None]:
        if data:
            data_class = cls()

        return data_class


class StarTransaction(TlObject):
    r"""Represents a transaction changing the amount of owned Telegram Stars

    Parameters:
        id (:class:`str`):
            Unique identifier of the transaction

        star_amount (:class:`"types.StarAmount"`):
            The amount of added owned Telegram Stars; negative for outgoing transactions

        is_refund (:class:`bool`):
            True, if the transaction is a refund of a previous transaction

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the transaction was completed

        type (:class:`"types.StarTransactionType"`):
            Type of the transaction

    """

    def __init__(
        self,
        id: str = "",
        star_amount: StarAmount = None,
        is_refund: bool = False,
        date: int = 0,
        type: StarTransactionType = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the transaction"""
        self.star_amount: Union[StarAmount, None] = star_amount
        r"""The amount of added owned Telegram Stars; negative for outgoing transactions"""
        self.is_refund: bool = bool(is_refund)
        r"""True, if the transaction is a refund of a previous transaction"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the transaction was completed"""
        self.type: Union[
            StarTransactionTypePremiumBotDeposit,
            StarTransactionTypeAppStoreDeposit,
            StarTransactionTypeGooglePlayDeposit,
            StarTransactionTypeFragmentDeposit,
            StarTransactionTypeUserDeposit,
            StarTransactionTypeGiveawayDeposit,
            StarTransactionTypeFragmentWithdrawal,
            StarTransactionTypeTelegramAdsWithdrawal,
            StarTransactionTypeTelegramApiUsage,
            StarTransactionTypeBotPaidMediaPurchase,
            StarTransactionTypeBotPaidMediaSale,
            StarTransactionTypeChannelPaidMediaPurchase,
            StarTransactionTypeChannelPaidMediaSale,
            StarTransactionTypeBotInvoicePurchase,
            StarTransactionTypeBotInvoiceSale,
            StarTransactionTypeBotSubscriptionPurchase,
            StarTransactionTypeBotSubscriptionSale,
            StarTransactionTypeChannelSubscriptionPurchase,
            StarTransactionTypeChannelSubscriptionSale,
            StarTransactionTypeGiftPurchase,
            StarTransactionTypeGiftTransfer,
            StarTransactionTypeGiftSale,
            StarTransactionTypeGiftUpgrade,
            StarTransactionTypeChannelPaidReactionSend,
            StarTransactionTypeChannelPaidReactionReceive,
            StarTransactionTypeAffiliateProgramCommission,
            StarTransactionTypePaidMessageSend,
            StarTransactionTypePaidMessageReceive,
            StarTransactionTypePremiumPurchase,
            StarTransactionTypeBusinessBotTransferSend,
            StarTransactionTypeBusinessBotTransferReceive,
            StarTransactionTypeUnsupported,
            None,
        ] = type
        r"""Type of the transaction"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransaction"]:
        return "starTransaction"

    def getClass(self) -> Literal["StarTransaction"]:
        return "StarTransaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "star_amount": self.star_amount,
            "is_refund": self.is_refund,
            "date": self.date,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransaction", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.star_amount = data.get("star_amount", None)
            data_class.is_refund = data.get("is_refund", False)
            data_class.date = int(data.get("date", 0))
            data_class.type = data.get("type", None)

        return data_class


class StarTransactions(TlObject):
    r"""Represents a list of Telegram Star transactions

    Parameters:
        star_amount (:class:`"types.StarAmount"`):
            The amount of owned Telegram Stars

        transactions (:class:`List["types.StarTransaction"]`):
            List of transactions with Telegram Stars

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        star_amount: StarAmount = None,
        transactions: List[StarTransaction] = None,
        next_offset: str = "",
    ) -> None:
        self.star_amount: Union[StarAmount, None] = star_amount
        r"""The amount of owned Telegram Stars"""
        self.transactions: List[StarTransaction] = transactions or []
        r"""List of transactions with Telegram Stars"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starTransactions"]:
        return "starTransactions"

    def getClass(self) -> Literal["StarTransactions"]:
        return "StarTransactions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_amount": self.star_amount,
            "transactions": self.transactions,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarTransactions", None]:
        if data:
            data_class = cls()
            data_class.star_amount = data.get("star_amount", None)
            data_class.transactions = data.get("transactions", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class GiveawayParticipantStatusEligible(TlObject, GiveawayParticipantStatus):
    r"""The user is eligible for the giveaway"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayParticipantStatusEligible"]:
        return "giveawayParticipantStatusEligible"

    def getClass(self) -> Literal["GiveawayParticipantStatus"]:
        return "GiveawayParticipantStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiveawayParticipantStatusEligible", None]:
        if data:
            data_class = cls()

        return data_class


class GiveawayParticipantStatusParticipating(TlObject, GiveawayParticipantStatus):
    r"""The user participates in the giveaway"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayParticipantStatusParticipating"]:
        return "giveawayParticipantStatusParticipating"

    def getClass(self) -> Literal["GiveawayParticipantStatus"]:
        return "GiveawayParticipantStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["GiveawayParticipantStatusParticipating", None]:
        if data:
            data_class = cls()

        return data_class


class GiveawayParticipantStatusAlreadyWasMember(TlObject, GiveawayParticipantStatus):
    r"""The user can't participate in the giveaway, because they have already been member of the chat

    Parameters:
        joined_chat_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user joined the chat

    """

    def __init__(self, joined_chat_date: int = 0) -> None:
        self.joined_chat_date: int = int(joined_chat_date)
        r"""Point in time \(Unix timestamp\) when the user joined the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayParticipantStatusAlreadyWasMember"]:
        return "giveawayParticipantStatusAlreadyWasMember"

    def getClass(self) -> Literal["GiveawayParticipantStatus"]:
        return "GiveawayParticipantStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "joined_chat_date": self.joined_chat_date}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["GiveawayParticipantStatusAlreadyWasMember", None]:
        if data:
            data_class = cls()
            data_class.joined_chat_date = int(data.get("joined_chat_date", 0))

        return data_class


class GiveawayParticipantStatusAdministrator(TlObject, GiveawayParticipantStatus):
    r"""The user can't participate in the giveaway, because they are an administrator in one of the chats that created the giveaway

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat administered by the user

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat administered by the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayParticipantStatusAdministrator"]:
        return "giveawayParticipantStatusAdministrator"

    def getClass(self) -> Literal["GiveawayParticipantStatus"]:
        return "GiveawayParticipantStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["GiveawayParticipantStatusAdministrator", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class GiveawayParticipantStatusDisallowedCountry(TlObject, GiveawayParticipantStatus):
    r"""The user can't participate in the giveaway, because they phone number is from a disallowed country

    Parameters:
        user_country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code of the user's country

    """

    def __init__(self, user_country_code: str = "") -> None:
        self.user_country_code: Union[str, None] = user_country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code of the user's country"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayParticipantStatusDisallowedCountry"]:
        return "giveawayParticipantStatusDisallowedCountry"

    def getClass(self) -> Literal["GiveawayParticipantStatus"]:
        return "GiveawayParticipantStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_country_code": self.user_country_code}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["GiveawayParticipantStatusDisallowedCountry", None]:
        if data:
            data_class = cls()
            data_class.user_country_code = data.get("user_country_code", "")

        return data_class


class GiveawayInfoOngoing(TlObject, GiveawayInfo):
    r"""Describes an ongoing giveaway

    Parameters:
        creation_date (:class:`int`):
            Point in time \(Unix timestamp\) when the giveaway was created

        status (:class:`"types.GiveawayParticipantStatus"`):
            Status of the current user in the giveaway

        is_ended (:class:`bool`):
            True, if the giveaway has ended and results are being prepared

    """

    def __init__(
        self,
        creation_date: int = 0,
        status: GiveawayParticipantStatus = None,
        is_ended: bool = False,
    ) -> None:
        self.creation_date: int = int(creation_date)
        r"""Point in time \(Unix timestamp\) when the giveaway was created"""
        self.status: Union[
            GiveawayParticipantStatusEligible,
            GiveawayParticipantStatusParticipating,
            GiveawayParticipantStatusAlreadyWasMember,
            GiveawayParticipantStatusAdministrator,
            GiveawayParticipantStatusDisallowedCountry,
            None,
        ] = status
        r"""Status of the current user in the giveaway"""
        self.is_ended: bool = bool(is_ended)
        r"""True, if the giveaway has ended and results are being prepared"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayInfoOngoing"]:
        return "giveawayInfoOngoing"

    def getClass(self) -> Literal["GiveawayInfo"]:
        return "GiveawayInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "creation_date": self.creation_date,
            "status": self.status,
            "is_ended": self.is_ended,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiveawayInfoOngoing", None]:
        if data:
            data_class = cls()
            data_class.creation_date = int(data.get("creation_date", 0))
            data_class.status = data.get("status", None)
            data_class.is_ended = data.get("is_ended", False)

        return data_class


class GiveawayInfoCompleted(TlObject, GiveawayInfo):
    r"""Describes a completed giveaway

    Parameters:
        creation_date (:class:`int`):
            Point in time \(Unix timestamp\) when the giveaway was created

        actual_winners_selection_date (:class:`int`):
            Point in time \(Unix timestamp\) when the winners were selected\. May be bigger than winners selection date specified in parameters of the giveaway

        was_refunded (:class:`bool`):
            True, if the giveaway was canceled and was fully refunded

        is_winner (:class:`bool`):
            True, if the current user is a winner of the giveaway

        winner_count (:class:`int`):
            Number of winners in the giveaway

        activation_count (:class:`int`):
            Number of winners, which activated their gift codes; for Telegram Premium giveaways only

        gift_code (:class:`str`):
            Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium giveaway

        won_star_count (:class:`int`):
            The amount of Telegram Stars won by the current user; 0 if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Star giveaway

    """

    def __init__(
        self,
        creation_date: int = 0,
        actual_winners_selection_date: int = 0,
        was_refunded: bool = False,
        is_winner: bool = False,
        winner_count: int = 0,
        activation_count: int = 0,
        gift_code: str = "",
        won_star_count: int = 0,
    ) -> None:
        self.creation_date: int = int(creation_date)
        r"""Point in time \(Unix timestamp\) when the giveaway was created"""
        self.actual_winners_selection_date: int = int(actual_winners_selection_date)
        r"""Point in time \(Unix timestamp\) when the winners were selected\. May be bigger than winners selection date specified in parameters of the giveaway"""
        self.was_refunded: bool = bool(was_refunded)
        r"""True, if the giveaway was canceled and was fully refunded"""
        self.is_winner: bool = bool(is_winner)
        r"""True, if the current user is a winner of the giveaway"""
        self.winner_count: int = int(winner_count)
        r"""Number of winners in the giveaway"""
        self.activation_count: int = int(activation_count)
        r"""Number of winners, which activated their gift codes; for Telegram Premium giveaways only"""
        self.gift_code: Union[str, None] = gift_code
        r"""Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium giveaway"""
        self.won_star_count: int = int(won_star_count)
        r"""The amount of Telegram Stars won by the current user; 0 if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Star giveaway"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayInfoCompleted"]:
        return "giveawayInfoCompleted"

    def getClass(self) -> Literal["GiveawayInfo"]:
        return "GiveawayInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "creation_date": self.creation_date,
            "actual_winners_selection_date": self.actual_winners_selection_date,
            "was_refunded": self.was_refunded,
            "is_winner": self.is_winner,
            "winner_count": self.winner_count,
            "activation_count": self.activation_count,
            "gift_code": self.gift_code,
            "won_star_count": self.won_star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiveawayInfoCompleted", None]:
        if data:
            data_class = cls()
            data_class.creation_date = int(data.get("creation_date", 0))
            data_class.actual_winners_selection_date = int(
                data.get("actual_winners_selection_date", 0)
            )
            data_class.was_refunded = data.get("was_refunded", False)
            data_class.is_winner = data.get("is_winner", False)
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.activation_count = int(data.get("activation_count", 0))
            data_class.gift_code = data.get("gift_code", "")
            data_class.won_star_count = int(data.get("won_star_count", 0))

        return data_class


class GiveawayPrizePremium(TlObject, GiveawayPrize):
    r"""The giveaway sends Telegram Premium subscriptions to the winners

    Parameters:
        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active after code activation

    """

    def __init__(self, month_count: int = 0) -> None:
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active after code activation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayPrizePremium"]:
        return "giveawayPrizePremium"

    def getClass(self) -> Literal["GiveawayPrize"]:
        return "GiveawayPrize"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "month_count": self.month_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiveawayPrizePremium", None]:
        if data:
            data_class = cls()
            data_class.month_count = int(data.get("month_count", 0))

        return data_class


class GiveawayPrizeStars(TlObject, GiveawayPrize):
    r"""The giveaway sends Telegram Stars to the winners

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars that will be shared by all winners

    """

    def __init__(self, star_count: int = 0) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that will be shared by all winners"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayPrizeStars"]:
        return "giveawayPrizeStars"

    def getClass(self) -> Literal["GiveawayPrize"]:
        return "GiveawayPrize"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "star_count": self.star_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiveawayPrizeStars", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class AccentColor(TlObject):
    r"""Contains information about supported accent color for user/chat name, background of empty chat photo, replies to messages and link previews

    Parameters:
        id (:class:`int`):
            Accent color identifier

        built_in_accent_color_id (:class:`int`):
            Identifier of a built\-in color to use in places, where only one color is needed; 0\-6

        light_theme_colors (:class:`List[int]`):
            The list of 1\-3 colors in RGB format, describing the accent color, as expected to be shown in light themes

        dark_theme_colors (:class:`List[int]`):
            The list of 1\-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes

        min_channel_chat_boost_level (:class:`int`):
            The minimum chat boost level required to use the color in a channel chat

    """

    def __init__(
        self,
        id: int = 0,
        built_in_accent_color_id: int = 0,
        light_theme_colors: List[int] = None,
        dark_theme_colors: List[int] = None,
        min_channel_chat_boost_level: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Accent color identifier"""
        self.built_in_accent_color_id: int = int(built_in_accent_color_id)
        r"""Identifier of a built\-in color to use in places, where only one color is needed; 0\-6"""
        self.light_theme_colors: List[int] = light_theme_colors or []
        r"""The list of 1\-3 colors in RGB format, describing the accent color, as expected to be shown in light themes"""
        self.dark_theme_colors: List[int] = dark_theme_colors or []
        r"""The list of 1\-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes"""
        self.min_channel_chat_boost_level: int = int(min_channel_chat_boost_level)
        r"""The minimum chat boost level required to use the color in a channel chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["accentColor"]:
        return "accentColor"

    def getClass(self) -> Literal["AccentColor"]:
        return "AccentColor"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "built_in_accent_color_id": self.built_in_accent_color_id,
            "light_theme_colors": self.light_theme_colors,
            "dark_theme_colors": self.dark_theme_colors,
            "min_channel_chat_boost_level": self.min_channel_chat_boost_level,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AccentColor", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.built_in_accent_color_id = int(
                data.get("built_in_accent_color_id", 0)
            )
            data_class.light_theme_colors = data.get("light_theme_colors", None)
            data_class.dark_theme_colors = data.get("dark_theme_colors", None)
            data_class.min_channel_chat_boost_level = int(
                data.get("min_channel_chat_boost_level", 0)
            )

        return data_class


class ProfileAccentColors(TlObject):
    r"""Contains information about supported accent colors for user profile photo background in RGB format

    Parameters:
        palette_colors (:class:`List[int]`):
            The list of 1\-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings

        background_colors (:class:`List[int]`):
            The list of 1\-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background

        story_colors (:class:`List[int]`):
            The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo

    """

    def __init__(
        self,
        palette_colors: List[int] = None,
        background_colors: List[int] = None,
        story_colors: List[int] = None,
    ) -> None:
        self.palette_colors: List[int] = palette_colors or []
        r"""The list of 1\-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings"""
        self.background_colors: List[int] = background_colors or []
        r"""The list of 1\-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background"""
        self.story_colors: List[int] = story_colors or []
        r"""The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["profileAccentColors"]:
        return "profileAccentColors"

    def getClass(self) -> Literal["ProfileAccentColors"]:
        return "ProfileAccentColors"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "palette_colors": self.palette_colors,
            "background_colors": self.background_colors,
            "story_colors": self.story_colors,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ProfileAccentColors", None]:
        if data:
            data_class = cls()
            data_class.palette_colors = data.get("palette_colors", None)
            data_class.background_colors = data.get("background_colors", None)
            data_class.story_colors = data.get("story_colors", None)

        return data_class


class ProfileAccentColor(TlObject):
    r"""Contains information about supported accent color for user profile photo background

    Parameters:
        id (:class:`int`):
            Profile accent color identifier

        light_theme_colors (:class:`"types.ProfileAccentColors"`):
            Accent colors expected to be used in light themes

        dark_theme_colors (:class:`"types.ProfileAccentColors"`):
            Accent colors expected to be used in dark themes

        min_supergroup_chat_boost_level (:class:`int`):
            The minimum chat boost level required to use the color in a supergroup chat

        min_channel_chat_boost_level (:class:`int`):
            The minimum chat boost level required to use the color in a channel chat

    """

    def __init__(
        self,
        id: int = 0,
        light_theme_colors: ProfileAccentColors = None,
        dark_theme_colors: ProfileAccentColors = None,
        min_supergroup_chat_boost_level: int = 0,
        min_channel_chat_boost_level: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Profile accent color identifier"""
        self.light_theme_colors: Union[ProfileAccentColors, None] = light_theme_colors
        r"""Accent colors expected to be used in light themes"""
        self.dark_theme_colors: Union[ProfileAccentColors, None] = dark_theme_colors
        r"""Accent colors expected to be used in dark themes"""
        self.min_supergroup_chat_boost_level: int = int(min_supergroup_chat_boost_level)
        r"""The minimum chat boost level required to use the color in a supergroup chat"""
        self.min_channel_chat_boost_level: int = int(min_channel_chat_boost_level)
        r"""The minimum chat boost level required to use the color in a channel chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["profileAccentColor"]:
        return "profileAccentColor"

    def getClass(self) -> Literal["ProfileAccentColor"]:
        return "ProfileAccentColor"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "light_theme_colors": self.light_theme_colors,
            "dark_theme_colors": self.dark_theme_colors,
            "min_supergroup_chat_boost_level": self.min_supergroup_chat_boost_level,
            "min_channel_chat_boost_level": self.min_channel_chat_boost_level,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ProfileAccentColor", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.light_theme_colors = data.get("light_theme_colors", None)
            data_class.dark_theme_colors = data.get("dark_theme_colors", None)
            data_class.min_supergroup_chat_boost_level = int(
                data.get("min_supergroup_chat_boost_level", 0)
            )
            data_class.min_channel_chat_boost_level = int(
                data.get("min_channel_chat_boost_level", 0)
            )

        return data_class


class EmojiStatusTypeCustomEmoji(TlObject, EmojiStatusType):
    r"""A custom emoji set as emoji status

    Parameters:
        custom_emoji_id (:class:`int`):
            Identifier of the custom emoji in stickerFormatTgs format

    """

    def __init__(self, custom_emoji_id: int = 0) -> None:
        self.custom_emoji_id: int = int(custom_emoji_id)
        r"""Identifier of the custom emoji in stickerFormatTgs format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiStatusTypeCustomEmoji"]:
        return "emojiStatusTypeCustomEmoji"

    def getClass(self) -> Literal["EmojiStatusType"]:
        return "EmojiStatusType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "custom_emoji_id": self.custom_emoji_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiStatusTypeCustomEmoji", None]:
        if data:
            data_class = cls()
            data_class.custom_emoji_id = int(data.get("custom_emoji_id", 0))

        return data_class


class EmojiStatusTypeUpgradedGift(TlObject, EmojiStatusType):
    r"""An upgraded gift set as emoji status

    Parameters:
        upgraded_gift_id (:class:`int`):
            Identifier of the upgraded gift

        gift_title (:class:`str`):
            The title of the upgraded gift

        gift_name (:class:`str`):
            Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift

        model_custom_emoji_id (:class:`int`):
            Custom emoji identifier of the model of the upgraded gift

        symbol_custom_emoji_id (:class:`int`):
            Custom emoji identifier of the symbol of the upgraded gift

        backdrop_colors (:class:`"types.UpgradedGiftBackdropColors"`):
            Colors of the backdrop of the upgraded gift

    """

    def __init__(
        self,
        upgraded_gift_id: int = 0,
        gift_title: str = "",
        gift_name: str = "",
        model_custom_emoji_id: int = 0,
        symbol_custom_emoji_id: int = 0,
        backdrop_colors: UpgradedGiftBackdropColors = None,
    ) -> None:
        self.upgraded_gift_id: int = int(upgraded_gift_id)
        r"""Identifier of the upgraded gift"""
        self.gift_title: Union[str, None] = gift_title
        r"""The title of the upgraded gift"""
        self.gift_name: Union[str, None] = gift_name
        r"""Unique name of the upgraded gift that can be used with internalLinkTypeUpgradedGift"""
        self.model_custom_emoji_id: int = int(model_custom_emoji_id)
        r"""Custom emoji identifier of the model of the upgraded gift"""
        self.symbol_custom_emoji_id: int = int(symbol_custom_emoji_id)
        r"""Custom emoji identifier of the symbol of the upgraded gift"""
        self.backdrop_colors: Union[UpgradedGiftBackdropColors, None] = backdrop_colors
        r"""Colors of the backdrop of the upgraded gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiStatusTypeUpgradedGift"]:
        return "emojiStatusTypeUpgradedGift"

    def getClass(self) -> Literal["EmojiStatusType"]:
        return "EmojiStatusType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "upgraded_gift_id": self.upgraded_gift_id,
            "gift_title": self.gift_title,
            "gift_name": self.gift_name,
            "model_custom_emoji_id": self.model_custom_emoji_id,
            "symbol_custom_emoji_id": self.symbol_custom_emoji_id,
            "backdrop_colors": self.backdrop_colors,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiStatusTypeUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.upgraded_gift_id = int(data.get("upgraded_gift_id", 0))
            data_class.gift_title = data.get("gift_title", "")
            data_class.gift_name = data.get("gift_name", "")
            data_class.model_custom_emoji_id = int(data.get("model_custom_emoji_id", 0))
            data_class.symbol_custom_emoji_id = int(
                data.get("symbol_custom_emoji_id", 0)
            )
            data_class.backdrop_colors = data.get("backdrop_colors", None)

        return data_class


class EmojiStatus(TlObject):
    r"""Describes an emoji to be shown instead of the Telegram Premium badge

    Parameters:
        type (:class:`"types.EmojiStatusType"`):
            Type of the emoji status

        expiration_date (:class:`int`):
            Point in time \(Unix timestamp\) when the status will expire; 0 if never

    """

    def __init__(self, type: EmojiStatusType = None, expiration_date: int = 0) -> None:
        self.type: Union[
            EmojiStatusTypeCustomEmoji, EmojiStatusTypeUpgradedGift, None
        ] = type
        r"""Type of the emoji status"""
        self.expiration_date: int = int(expiration_date)
        r"""Point in time \(Unix timestamp\) when the status will expire; 0 if never"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiStatus"]:
        return "emojiStatus"

    def getClass(self) -> Literal["EmojiStatus"]:
        return "EmojiStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "expiration_date": self.expiration_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiStatus", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.expiration_date = int(data.get("expiration_date", 0))

        return data_class


class EmojiStatuses(TlObject):
    r"""Contains a list of emoji statuses

    Parameters:
        emoji_statuses (:class:`List["types.EmojiStatus"]`):
            The list of emoji statuses identifiers

    """

    def __init__(self, emoji_statuses: List[EmojiStatus] = None) -> None:
        self.emoji_statuses: List[EmojiStatus] = emoji_statuses or []
        r"""The list of emoji statuses identifiers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiStatuses"]:
        return "emojiStatuses"

    def getClass(self) -> Literal["EmojiStatuses"]:
        return "EmojiStatuses"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emoji_statuses": self.emoji_statuses}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiStatuses", None]:
        if data:
            data_class = cls()
            data_class.emoji_statuses = data.get("emoji_statuses", None)

        return data_class


class EmojiStatusCustomEmojis(TlObject):
    r"""Contains a list of custom emoji identifiers for emoji statuses

    Parameters:
        custom_emoji_ids (:class:`List[int]`):
            The list of custom emoji identifiers

    """

    def __init__(self, custom_emoji_ids: List[int] = None) -> None:
        self.custom_emoji_ids: List[int] = custom_emoji_ids or []
        r"""The list of custom emoji identifiers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiStatusCustomEmojis"]:
        return "emojiStatusCustomEmojis"

    def getClass(self) -> Literal["EmojiStatusCustomEmojis"]:
        return "EmojiStatusCustomEmojis"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "custom_emoji_ids": self.custom_emoji_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiStatusCustomEmojis", None]:
        if data:
            data_class = cls()
            data_class.custom_emoji_ids = data.get("custom_emoji_ids", None)

        return data_class


class Usernames(TlObject):
    r"""Describes usernames assigned to a user, a supergroup, or a channel

    Parameters:
        active_usernames (:class:`List[str]`):
            List of active usernames; the first one must be shown as the primary username\. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames

        disabled_usernames (:class:`List[str]`):
            List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive

        editable_username (:class:`str`):
            The active username, which can be changed with setUsername or setSupergroupUsername\. Information about other active usernames can be received using getCollectibleItemInfo

    """

    def __init__(
        self,
        active_usernames: List[str] = None,
        disabled_usernames: List[str] = None,
        editable_username: str = "",
    ) -> None:
        self.active_usernames: List[str] = active_usernames or []
        r"""List of active usernames; the first one must be shown as the primary username\. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames"""
        self.disabled_usernames: List[str] = disabled_usernames or []
        r"""List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive"""
        self.editable_username: Union[str, None] = editable_username
        r"""The active username, which can be changed with setUsername or setSupergroupUsername\. Information about other active usernames can be received using getCollectibleItemInfo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["usernames"]:
        return "usernames"

    def getClass(self) -> Literal["Usernames"]:
        return "Usernames"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "active_usernames": self.active_usernames,
            "disabled_usernames": self.disabled_usernames,
            "editable_username": self.editable_username,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Usernames", None]:
        if data:
            data_class = cls()
            data_class.active_usernames = data.get("active_usernames", None)
            data_class.disabled_usernames = data.get("disabled_usernames", None)
            data_class.editable_username = data.get("editable_username", "")

        return data_class


class User(TlObject):
    r"""Represents a user

    Parameters:
        id (:class:`int`):
            User identifier

        first_name (:class:`str`):
            First name of the user

        last_name (:class:`str`):
            Last name of the user

        usernames (:class:`"types.Usernames"`):
            Usernames of the user; may be null

        phone_number (:class:`str`):
            Phone number of the user

        status (:class:`"types.UserStatus"`):
            Current online status of the user

        profile_photo (:class:`"types.ProfilePhoto"`):
            Profile photo of the user; may be null

        accent_color_id (:class:`int`):
            Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview

        background_custom_emoji_id (:class:`int`):
            Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none

        profile_accent_color_id (:class:`int`):
            Identifier of the accent color for the user's profile; \-1 if none

        profile_background_custom_emoji_id (:class:`int`):
            Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none

        emoji_status (:class:`"types.EmojiStatus"`):
            Emoji status to be shown instead of the default Telegram Premium badge; may be null

        is_contact (:class:`bool`):
            The user is a contact of the current user

        is_mutual_contact (:class:`bool`):
            The user is a contact of the current user and the current user is a contact of the user

        is_close_friend (:class:`bool`):
            The user is a close friend of the current user; implies that the user is a contact

        verification_status (:class:`"types.VerificationStatus"`):
            Information about verification status of the user; may be null if none

        is_premium (:class:`bool`):
            True, if the user is a Telegram Premium user

        is_support (:class:`bool`):
            True, if the user is Telegram support account

        restriction_reason (:class:`str`):
            If non\-empty, it contains a human\-readable description of the reason why access to this user must be restricted

        has_active_stories (:class:`bool`):
            True, if the user has non\-expired stories available to the current user

        has_unread_active_stories (:class:`bool`):
            True, if the user has unread non\-expired stories available to the current user

        restricts_new_chats (:class:`bool`):
            True, if the user may restrict new chats with non\-contacts\. Use canSendMessageToUser to check whether the current user can message the user or try to create a chat with them

        paid_message_star_count (:class:`int`):
            Number of Telegram Stars that must be paid by general user for each sent message to the user\. If positive and userFullInfo is unknown, use canSendMessageToUser to check whether the current user must pay

        have_access (:class:`bool`):
            If false, the user is inaccessible, and the only information known about the user is inside this class\. Identifier of the user can't be passed to any method

        type (:class:`"types.UserType"`):
            Type of the user

        language_code (:class:`str`):
            IETF language tag of the user's language; only available to bots

        added_to_attachment_menu (:class:`bool`):
            True, if the user added the current bot to attachment menu; only available to bots

    """

    def __init__(
        self,
        id: int = 0,
        first_name: str = "",
        last_name: str = "",
        usernames: Usernames = None,
        phone_number: str = "",
        status: UserStatus = None,
        profile_photo: ProfilePhoto = None,
        accent_color_id: int = 0,
        background_custom_emoji_id: int = 0,
        profile_accent_color_id: int = 0,
        profile_background_custom_emoji_id: int = 0,
        emoji_status: EmojiStatus = None,
        is_contact: bool = False,
        is_mutual_contact: bool = False,
        is_close_friend: bool = False,
        verification_status: VerificationStatus = None,
        is_premium: bool = False,
        is_support: bool = False,
        restriction_reason: str = "",
        has_active_stories: bool = False,
        has_unread_active_stories: bool = False,
        restricts_new_chats: bool = False,
        paid_message_star_count: int = 0,
        have_access: bool = False,
        type: UserType = None,
        language_code: str = "",
        added_to_attachment_menu: bool = False,
    ) -> None:
        self.id: int = int(id)
        r"""User identifier"""
        self.first_name: Union[str, None] = first_name
        r"""First name of the user"""
        self.last_name: Union[str, None] = last_name
        r"""Last name of the user"""
        self.usernames: Union[Usernames, None] = usernames
        r"""Usernames of the user; may be null"""
        self.phone_number: Union[str, None] = phone_number
        r"""Phone number of the user"""
        self.status: Union[
            UserStatusEmpty,
            UserStatusOnline,
            UserStatusOffline,
            UserStatusRecently,
            UserStatusLastWeek,
            UserStatusLastMonth,
            None,
        ] = status
        r"""Current online status of the user"""
        self.profile_photo: Union[ProfilePhoto, None] = profile_photo
        r"""Profile photo of the user; may be null"""
        self.accent_color_id: int = int(accent_color_id)
        r"""Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview"""
        self.background_custom_emoji_id: int = int(background_custom_emoji_id)
        r"""Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none"""
        self.profile_accent_color_id: int = int(profile_accent_color_id)
        r"""Identifier of the accent color for the user's profile; \-1 if none"""
        self.profile_background_custom_emoji_id: int = int(
            profile_background_custom_emoji_id
        )
        r"""Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none"""
        self.emoji_status: Union[EmojiStatus, None] = emoji_status
        r"""Emoji status to be shown instead of the default Telegram Premium badge; may be null"""
        self.is_contact: bool = bool(is_contact)
        r"""The user is a contact of the current user"""
        self.is_mutual_contact: bool = bool(is_mutual_contact)
        r"""The user is a contact of the current user and the current user is a contact of the user"""
        self.is_close_friend: bool = bool(is_close_friend)
        r"""The user is a close friend of the current user; implies that the user is a contact"""
        self.verification_status: Union[VerificationStatus, None] = verification_status
        r"""Information about verification status of the user; may be null if none"""
        self.is_premium: bool = bool(is_premium)
        r"""True, if the user is a Telegram Premium user"""
        self.is_support: bool = bool(is_support)
        r"""True, if the user is Telegram support account"""
        self.restriction_reason: Union[str, None] = restriction_reason
        r"""If non\-empty, it contains a human\-readable description of the reason why access to this user must be restricted"""
        self.has_active_stories: bool = bool(has_active_stories)
        r"""True, if the user has non\-expired stories available to the current user"""
        self.has_unread_active_stories: bool = bool(has_unread_active_stories)
        r"""True, if the user has unread non\-expired stories available to the current user"""
        self.restricts_new_chats: bool = bool(restricts_new_chats)
        r"""True, if the user may restrict new chats with non\-contacts\. Use canSendMessageToUser to check whether the current user can message the user or try to create a chat with them"""
        self.paid_message_star_count: int = int(paid_message_star_count)
        r"""Number of Telegram Stars that must be paid by general user for each sent message to the user\. If positive and userFullInfo is unknown, use canSendMessageToUser to check whether the current user must pay"""
        self.have_access: bool = bool(have_access)
        r"""If false, the user is inaccessible, and the only information known about the user is inside this class\. Identifier of the user can't be passed to any method"""
        self.type: Union[
            UserTypeRegular, UserTypeDeleted, UserTypeBot, UserTypeUnknown, None
        ] = type
        r"""Type of the user"""
        self.language_code: Union[str, None] = language_code
        r"""IETF language tag of the user's language; only available to bots"""
        self.added_to_attachment_menu: bool = bool(added_to_attachment_menu)
        r"""True, if the user added the current bot to attachment menu; only available to bots"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["user"]:
        return "user"

    def getClass(self) -> Literal["User"]:
        return "User"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "usernames": self.usernames,
            "phone_number": self.phone_number,
            "status": self.status,
            "profile_photo": self.profile_photo,
            "accent_color_id": self.accent_color_id,
            "background_custom_emoji_id": self.background_custom_emoji_id,
            "profile_accent_color_id": self.profile_accent_color_id,
            "profile_background_custom_emoji_id": self.profile_background_custom_emoji_id,
            "emoji_status": self.emoji_status,
            "is_contact": self.is_contact,
            "is_mutual_contact": self.is_mutual_contact,
            "is_close_friend": self.is_close_friend,
            "verification_status": self.verification_status,
            "is_premium": self.is_premium,
            "is_support": self.is_support,
            "restriction_reason": self.restriction_reason,
            "has_active_stories": self.has_active_stories,
            "has_unread_active_stories": self.has_unread_active_stories,
            "restricts_new_chats": self.restricts_new_chats,
            "paid_message_star_count": self.paid_message_star_count,
            "have_access": self.have_access,
            "type": self.type,
            "language_code": self.language_code,
            "added_to_attachment_menu": self.added_to_attachment_menu,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["User", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.first_name = data.get("first_name", "")
            data_class.last_name = data.get("last_name", "")
            data_class.usernames = data.get("usernames", None)
            data_class.phone_number = data.get("phone_number", "")
            data_class.status = data.get("status", None)
            data_class.profile_photo = data.get("profile_photo", None)
            data_class.accent_color_id = int(data.get("accent_color_id", 0))
            data_class.background_custom_emoji_id = int(
                data.get("background_custom_emoji_id", 0)
            )
            data_class.profile_accent_color_id = int(
                data.get("profile_accent_color_id", 0)
            )
            data_class.profile_background_custom_emoji_id = int(
                data.get("profile_background_custom_emoji_id", 0)
            )
            data_class.emoji_status = data.get("emoji_status", None)
            data_class.is_contact = data.get("is_contact", False)
            data_class.is_mutual_contact = data.get("is_mutual_contact", False)
            data_class.is_close_friend = data.get("is_close_friend", False)
            data_class.verification_status = data.get("verification_status", None)
            data_class.is_premium = data.get("is_premium", False)
            data_class.is_support = data.get("is_support", False)
            data_class.restriction_reason = data.get("restriction_reason", "")
            data_class.has_active_stories = data.get("has_active_stories", False)
            data_class.has_unread_active_stories = data.get(
                "has_unread_active_stories", False
            )
            data_class.restricts_new_chats = data.get("restricts_new_chats", False)
            data_class.paid_message_star_count = int(
                data.get("paid_message_star_count", 0)
            )
            data_class.have_access = data.get("have_access", False)
            data_class.type = data.get("type", None)
            data_class.language_code = data.get("language_code", "")
            data_class.added_to_attachment_menu = data.get(
                "added_to_attachment_menu", False
            )

        return data_class


class BotInfo(TlObject):
    r"""Contains information about a bot

    Parameters:
        short_description (:class:`str`):
            The text that is shown on the bot's profile page and is sent together with the link when users share the bot

        description (:class:`str`):
            The text shown in the chat with the bot if the chat is empty

        photo (:class:`"types.Photo"`):
            Photo shown in the chat with the bot if the chat is empty; may be null

        animation (:class:`"types.Animation"`):
            Animation shown in the chat with the bot if the chat is empty; may be null

        menu_button (:class:`"types.BotMenuButton"`):
            Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown

        commands (:class:`List["types.BotCommand"]`):
            List of the bot commands

        privacy_policy_url (:class:`str`):
            The HTTP link to the privacy policy of the bot\. If empty, then /privacy command must be used if supported by the bot\. If the command isn't supported, then https://telegram\.org/privacy\-tpa must be opened

        default_group_administrator_rights (:class:`"types.ChatAdministratorRights"`):
            Default administrator rights for adding the bot to basic group and supergroup chats; may be null

        default_channel_administrator_rights (:class:`"types.ChatAdministratorRights"`):
            Default administrator rights for adding the bot to channels; may be null

        affiliate_program (:class:`"types.AffiliateProgramInfo"`):
            Information about the affiliate program of the bot; may be null if none

        web_app_background_light_color (:class:`int`):
            Default light background color for bot Web Apps; \-1 if not specified

        web_app_background_dark_color (:class:`int`):
            Default dark background color for bot Web Apps; \-1 if not specified

        web_app_header_light_color (:class:`int`):
            Default light header color for bot Web Apps; \-1 if not specified

        web_app_header_dark_color (:class:`int`):
            Default dark header color for bot Web Apps; \-1 if not specified

        verification_parameters (:class:`"types.BotVerificationParameters"`):
            Parameters of the verification that can be provided by the bot; may be null if none or the current user isn't the owner of the bot

        can_get_revenue_statistics (:class:`bool`):
            True, if the bot's revenue statistics are available to the current user

        can_manage_emoji_status (:class:`bool`):
            True, if the bot can manage emoji status of the current user

        has_media_previews (:class:`bool`):
            True, if the bot has media previews

        edit_commands_link (:class:`"types.InternalLinkType"`):
            The internal link, which can be used to edit bot commands; may be null

        edit_description_link (:class:`"types.InternalLinkType"`):
            The internal link, which can be used to edit bot description; may be null

        edit_description_media_link (:class:`"types.InternalLinkType"`):
            The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null

        edit_settings_link (:class:`"types.InternalLinkType"`):
            The internal link, which can be used to edit bot settings; may be null

    """

    def __init__(
        self,
        short_description: str = "",
        description: str = "",
        photo: Photo = None,
        animation: Animation = None,
        menu_button: BotMenuButton = None,
        commands: List[BotCommand] = None,
        privacy_policy_url: str = "",
        default_group_administrator_rights: ChatAdministratorRights = None,
        default_channel_administrator_rights: ChatAdministratorRights = None,
        affiliate_program: AffiliateProgramInfo = None,
        web_app_background_light_color: int = 0,
        web_app_background_dark_color: int = 0,
        web_app_header_light_color: int = 0,
        web_app_header_dark_color: int = 0,
        verification_parameters: BotVerificationParameters = None,
        can_get_revenue_statistics: bool = False,
        can_manage_emoji_status: bool = False,
        has_media_previews: bool = False,
        edit_commands_link: InternalLinkType = None,
        edit_description_link: InternalLinkType = None,
        edit_description_media_link: InternalLinkType = None,
        edit_settings_link: InternalLinkType = None,
    ) -> None:
        self.short_description: Union[str, None] = short_description
        r"""The text that is shown on the bot's profile page and is sent together with the link when users share the bot"""
        self.description: Union[str, None] = description
        r"""The text shown in the chat with the bot if the chat is empty"""
        self.photo: Union[Photo, None] = photo
        r"""Photo shown in the chat with the bot if the chat is empty; may be null"""
        self.animation: Union[Animation, None] = animation
        r"""Animation shown in the chat with the bot if the chat is empty; may be null"""
        self.menu_button: Union[BotMenuButton, None] = menu_button
        r"""Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown"""
        self.commands: List[BotCommand] = commands or []
        r"""List of the bot commands"""
        self.privacy_policy_url: Union[str, None] = privacy_policy_url
        r"""The HTTP link to the privacy policy of the bot\. If empty, then /privacy command must be used if supported by the bot\. If the command isn't supported, then https://telegram\.org/privacy\-tpa must be opened"""
        self.default_group_administrator_rights: Union[
            ChatAdministratorRights, None
        ] = default_group_administrator_rights
        r"""Default administrator rights for adding the bot to basic group and supergroup chats; may be null"""
        self.default_channel_administrator_rights: Union[
            ChatAdministratorRights, None
        ] = default_channel_administrator_rights
        r"""Default administrator rights for adding the bot to channels; may be null"""
        self.affiliate_program: Union[AffiliateProgramInfo, None] = affiliate_program
        r"""Information about the affiliate program of the bot; may be null if none"""
        self.web_app_background_light_color: int = int(web_app_background_light_color)
        r"""Default light background color for bot Web Apps; \-1 if not specified"""
        self.web_app_background_dark_color: int = int(web_app_background_dark_color)
        r"""Default dark background color for bot Web Apps; \-1 if not specified"""
        self.web_app_header_light_color: int = int(web_app_header_light_color)
        r"""Default light header color for bot Web Apps; \-1 if not specified"""
        self.web_app_header_dark_color: int = int(web_app_header_dark_color)
        r"""Default dark header color for bot Web Apps; \-1 if not specified"""
        self.verification_parameters: Union[BotVerificationParameters, None] = (
            verification_parameters
        )
        r"""Parameters of the verification that can be provided by the bot; may be null if none or the current user isn't the owner of the bot"""
        self.can_get_revenue_statistics: bool = bool(can_get_revenue_statistics)
        r"""True, if the bot's revenue statistics are available to the current user"""
        self.can_manage_emoji_status: bool = bool(can_manage_emoji_status)
        r"""True, if the bot can manage emoji status of the current user"""
        self.has_media_previews: bool = bool(has_media_previews)
        r"""True, if the bot has media previews"""
        self.edit_commands_link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = edit_commands_link
        r"""The internal link, which can be used to edit bot commands; may be null"""
        self.edit_description_link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = edit_description_link
        r"""The internal link, which can be used to edit bot description; may be null"""
        self.edit_description_media_link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = edit_description_media_link
        r"""The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null"""
        self.edit_settings_link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = edit_settings_link
        r"""The internal link, which can be used to edit bot settings; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botInfo"]:
        return "botInfo"

    def getClass(self) -> Literal["BotInfo"]:
        return "BotInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "short_description": self.short_description,
            "description": self.description,
            "photo": self.photo,
            "animation": self.animation,
            "menu_button": self.menu_button,
            "commands": self.commands,
            "privacy_policy_url": self.privacy_policy_url,
            "default_group_administrator_rights": self.default_group_administrator_rights,
            "default_channel_administrator_rights": self.default_channel_administrator_rights,
            "affiliate_program": self.affiliate_program,
            "web_app_background_light_color": self.web_app_background_light_color,
            "web_app_background_dark_color": self.web_app_background_dark_color,
            "web_app_header_light_color": self.web_app_header_light_color,
            "web_app_header_dark_color": self.web_app_header_dark_color,
            "verification_parameters": self.verification_parameters,
            "can_get_revenue_statistics": self.can_get_revenue_statistics,
            "can_manage_emoji_status": self.can_manage_emoji_status,
            "has_media_previews": self.has_media_previews,
            "edit_commands_link": self.edit_commands_link,
            "edit_description_link": self.edit_description_link,
            "edit_description_media_link": self.edit_description_media_link,
            "edit_settings_link": self.edit_settings_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotInfo", None]:
        if data:
            data_class = cls()
            data_class.short_description = data.get("short_description", "")
            data_class.description = data.get("description", "")
            data_class.photo = data.get("photo", None)
            data_class.animation = data.get("animation", None)
            data_class.menu_button = data.get("menu_button", None)
            data_class.commands = data.get("commands", None)
            data_class.privacy_policy_url = data.get("privacy_policy_url", "")
            data_class.default_group_administrator_rights = data.get(
                "default_group_administrator_rights", None
            )
            data_class.default_channel_administrator_rights = data.get(
                "default_channel_administrator_rights", None
            )
            data_class.affiliate_program = data.get("affiliate_program", None)
            data_class.web_app_background_light_color = int(
                data.get("web_app_background_light_color", 0)
            )
            data_class.web_app_background_dark_color = int(
                data.get("web_app_background_dark_color", 0)
            )
            data_class.web_app_header_light_color = int(
                data.get("web_app_header_light_color", 0)
            )
            data_class.web_app_header_dark_color = int(
                data.get("web_app_header_dark_color", 0)
            )
            data_class.verification_parameters = data.get(
                "verification_parameters", None
            )
            data_class.can_get_revenue_statistics = data.get(
                "can_get_revenue_statistics", False
            )
            data_class.can_manage_emoji_status = data.get(
                "can_manage_emoji_status", False
            )
            data_class.has_media_previews = data.get("has_media_previews", False)
            data_class.edit_commands_link = data.get("edit_commands_link", None)
            data_class.edit_description_link = data.get("edit_description_link", None)
            data_class.edit_description_media_link = data.get(
                "edit_description_media_link", None
            )
            data_class.edit_settings_link = data.get("edit_settings_link", None)

        return data_class


class UserFullInfo(TlObject):
    r"""Contains full information about a user

    Parameters:
        personal_photo (:class:`"types.ChatPhoto"`):
            User profile photo set by the current user for the contact; may be null\. If null and user\.profile\_photo is null, then the photo is empty; otherwise, it is unknown\. If non\-null, then it is the same photo as in user\.profile\_photo and chat\.photo\. This photo isn't returned in the list of user photos

        photo (:class:`"types.ChatPhoto"`):
            User profile photo; may be null\. If null and user\.profile\_photo is null, then the photo is empty; otherwise, it is unknown\. If non\-null and personal\_photo is null, then it is the same photo as in user\.profile\_photo and chat\.photo

        public_photo (:class:`"types.ChatPhoto"`):
            User profile photo visible if the main photo is hidden by privacy settings; may be null\. If null and user\.profile\_photo is null, then the photo is empty; otherwise, it is unknown\. If non\-null and both photo and personal\_photo are null, then it is the same photo as in user\.profile\_photo and chat\.photo\. This photo isn't returned in the list of user photos

        block_list (:class:`"types.BlockList"`):
            Block list to which the user is added; may be null if none

        can_be_called (:class:`bool`):
            True, if the user can be called

        supports_video_calls (:class:`bool`):
            True, if a video call can be created with the user

        has_private_calls (:class:`bool`):
            True, if the user can't be called due to their privacy settings

        has_private_forwards (:class:`bool`):
            True, if the user can't be linked in forwarded messages due to their privacy settings

        has_restricted_voice_and_video_note_messages (:class:`bool`):
            True, if voice and video notes can't be sent or forwarded to the user

        has_posted_to_profile_stories (:class:`bool`):
            True, if the user has posted to profile stories

        has_sponsored_messages_enabled (:class:`bool`):
            True, if the user always enabled sponsored messages; known only for the current user

        need_phone_number_privacy_exception (:class:`bool`):
            True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used

        set_chat_background (:class:`bool`):
            True, if the user set chat background for both chat users and it wasn't reverted yet

        bio (:class:`"types.FormattedText"`):
            A short user bio; may be null for bots

        birthdate (:class:`"types.Birthdate"`):
            Birthdate of the user; may be null if unknown

        personal_chat_id (:class:`int`):
            Identifier of the personal chat of the user; 0 if none

        gift_count (:class:`int`):
            Number of saved to profile gifts for other users or the total number of received gifts for the current user

        group_in_common_count (:class:`int`):
            Number of group chats where both the other user and the current user are a member; 0 for the current user

        incoming_paid_message_star_count (:class:`int`):
            Number of Telegram Stars that must be paid by the user for each sent message to the current user

        outgoing_paid_message_star_count (:class:`int`):
            Number of Telegram Stars that must be paid by the current user for each sent message to the user

        gift_settings (:class:`"types.GiftSettings"`):
            Settings for gift receiving for the user

        bot_verification (:class:`"types.BotVerification"`):
            Information about verification status of the user provided by a bot; may be null if none or unknown

        business_info (:class:`"types.BusinessInfo"`):
            Information about business settings for Telegram Business accounts; may be null if none

        bot_info (:class:`"types.BotInfo"`):
            For bots, information about the bot; may be null if the user isn't a bot

    """

    def __init__(
        self,
        personal_photo: ChatPhoto = None,
        photo: ChatPhoto = None,
        public_photo: ChatPhoto = None,
        block_list: BlockList = None,
        can_be_called: bool = False,
        supports_video_calls: bool = False,
        has_private_calls: bool = False,
        has_private_forwards: bool = False,
        has_restricted_voice_and_video_note_messages: bool = False,
        has_posted_to_profile_stories: bool = False,
        has_sponsored_messages_enabled: bool = False,
        need_phone_number_privacy_exception: bool = False,
        set_chat_background: bool = False,
        bio: FormattedText = None,
        birthdate: Birthdate = None,
        personal_chat_id: int = 0,
        gift_count: int = 0,
        group_in_common_count: int = 0,
        incoming_paid_message_star_count: int = 0,
        outgoing_paid_message_star_count: int = 0,
        gift_settings: GiftSettings = None,
        bot_verification: BotVerification = None,
        business_info: BusinessInfo = None,
        bot_info: BotInfo = None,
    ) -> None:
        self.personal_photo: Union[ChatPhoto, None] = personal_photo
        r"""User profile photo set by the current user for the contact; may be null\. If null and user\.profile\_photo is null, then the photo is empty; otherwise, it is unknown\. If non\-null, then it is the same photo as in user\.profile\_photo and chat\.photo\. This photo isn't returned in the list of user photos"""
        self.photo: Union[ChatPhoto, None] = photo
        r"""User profile photo; may be null\. If null and user\.profile\_photo is null, then the photo is empty; otherwise, it is unknown\. If non\-null and personal\_photo is null, then it is the same photo as in user\.profile\_photo and chat\.photo"""
        self.public_photo: Union[ChatPhoto, None] = public_photo
        r"""User profile photo visible if the main photo is hidden by privacy settings; may be null\. If null and user\.profile\_photo is null, then the photo is empty; otherwise, it is unknown\. If non\-null and both photo and personal\_photo are null, then it is the same photo as in user\.profile\_photo and chat\.photo\. This photo isn't returned in the list of user photos"""
        self.block_list: Union[BlockListMain, BlockListStories, None] = block_list
        r"""Block list to which the user is added; may be null if none"""
        self.can_be_called: bool = bool(can_be_called)
        r"""True, if the user can be called"""
        self.supports_video_calls: bool = bool(supports_video_calls)
        r"""True, if a video call can be created with the user"""
        self.has_private_calls: bool = bool(has_private_calls)
        r"""True, if the user can't be called due to their privacy settings"""
        self.has_private_forwards: bool = bool(has_private_forwards)
        r"""True, if the user can't be linked in forwarded messages due to their privacy settings"""
        self.has_restricted_voice_and_video_note_messages: bool = bool(
            has_restricted_voice_and_video_note_messages
        )
        r"""True, if voice and video notes can't be sent or forwarded to the user"""
        self.has_posted_to_profile_stories: bool = bool(has_posted_to_profile_stories)
        r"""True, if the user has posted to profile stories"""
        self.has_sponsored_messages_enabled: bool = bool(has_sponsored_messages_enabled)
        r"""True, if the user always enabled sponsored messages; known only for the current user"""
        self.need_phone_number_privacy_exception: bool = bool(
            need_phone_number_privacy_exception
        )
        r"""True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used"""
        self.set_chat_background: bool = bool(set_chat_background)
        r"""True, if the user set chat background for both chat users and it wasn't reverted yet"""
        self.bio: Union[FormattedText, None] = bio
        r"""A short user bio; may be null for bots"""
        self.birthdate: Union[Birthdate, None] = birthdate
        r"""Birthdate of the user; may be null if unknown"""
        self.personal_chat_id: int = int(personal_chat_id)
        r"""Identifier of the personal chat of the user; 0 if none"""
        self.gift_count: int = int(gift_count)
        r"""Number of saved to profile gifts for other users or the total number of received gifts for the current user"""
        self.group_in_common_count: int = int(group_in_common_count)
        r"""Number of group chats where both the other user and the current user are a member; 0 for the current user"""
        self.incoming_paid_message_star_count: int = int(
            incoming_paid_message_star_count
        )
        r"""Number of Telegram Stars that must be paid by the user for each sent message to the current user"""
        self.outgoing_paid_message_star_count: int = int(
            outgoing_paid_message_star_count
        )
        r"""Number of Telegram Stars that must be paid by the current user for each sent message to the user"""
        self.gift_settings: Union[GiftSettings, None] = gift_settings
        r"""Settings for gift receiving for the user"""
        self.bot_verification: Union[BotVerification, None] = bot_verification
        r"""Information about verification status of the user provided by a bot; may be null if none or unknown"""
        self.business_info: Union[BusinessInfo, None] = business_info
        r"""Information about business settings for Telegram Business accounts; may be null if none"""
        self.bot_info: Union[BotInfo, None] = bot_info
        r"""For bots, information about the bot; may be null if the user isn't a bot"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userFullInfo"]:
        return "userFullInfo"

    def getClass(self) -> Literal["UserFullInfo"]:
        return "UserFullInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "personal_photo": self.personal_photo,
            "photo": self.photo,
            "public_photo": self.public_photo,
            "block_list": self.block_list,
            "can_be_called": self.can_be_called,
            "supports_video_calls": self.supports_video_calls,
            "has_private_calls": self.has_private_calls,
            "has_private_forwards": self.has_private_forwards,
            "has_restricted_voice_and_video_note_messages": self.has_restricted_voice_and_video_note_messages,
            "has_posted_to_profile_stories": self.has_posted_to_profile_stories,
            "has_sponsored_messages_enabled": self.has_sponsored_messages_enabled,
            "need_phone_number_privacy_exception": self.need_phone_number_privacy_exception,
            "set_chat_background": self.set_chat_background,
            "bio": self.bio,
            "birthdate": self.birthdate,
            "personal_chat_id": self.personal_chat_id,
            "gift_count": self.gift_count,
            "group_in_common_count": self.group_in_common_count,
            "incoming_paid_message_star_count": self.incoming_paid_message_star_count,
            "outgoing_paid_message_star_count": self.outgoing_paid_message_star_count,
            "gift_settings": self.gift_settings,
            "bot_verification": self.bot_verification,
            "business_info": self.business_info,
            "bot_info": self.bot_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserFullInfo", None]:
        if data:
            data_class = cls()
            data_class.personal_photo = data.get("personal_photo", None)
            data_class.photo = data.get("photo", None)
            data_class.public_photo = data.get("public_photo", None)
            data_class.block_list = data.get("block_list", None)
            data_class.can_be_called = data.get("can_be_called", False)
            data_class.supports_video_calls = data.get("supports_video_calls", False)
            data_class.has_private_calls = data.get("has_private_calls", False)
            data_class.has_private_forwards = data.get("has_private_forwards", False)
            data_class.has_restricted_voice_and_video_note_messages = data.get(
                "has_restricted_voice_and_video_note_messages", False
            )
            data_class.has_posted_to_profile_stories = data.get(
                "has_posted_to_profile_stories", False
            )
            data_class.has_sponsored_messages_enabled = data.get(
                "has_sponsored_messages_enabled", False
            )
            data_class.need_phone_number_privacy_exception = data.get(
                "need_phone_number_privacy_exception", False
            )
            data_class.set_chat_background = data.get("set_chat_background", False)
            data_class.bio = data.get("bio", None)
            data_class.birthdate = data.get("birthdate", None)
            data_class.personal_chat_id = int(data.get("personal_chat_id", 0))
            data_class.gift_count = int(data.get("gift_count", 0))
            data_class.group_in_common_count = int(data.get("group_in_common_count", 0))
            data_class.incoming_paid_message_star_count = int(
                data.get("incoming_paid_message_star_count", 0)
            )
            data_class.outgoing_paid_message_star_count = int(
                data.get("outgoing_paid_message_star_count", 0)
            )
            data_class.gift_settings = data.get("gift_settings", None)
            data_class.bot_verification = data.get("bot_verification", None)
            data_class.business_info = data.get("business_info", None)
            data_class.bot_info = data.get("bot_info", None)

        return data_class


class Users(TlObject):
    r"""Represents a list of users

    Parameters:
        total_count (:class:`int`):
            Approximate total number of users found

        user_ids (:class:`List[int]`):
            A list of user identifiers

    """

    def __init__(self, total_count: int = 0, user_ids: List[int] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of users found"""
        self.user_ids: List[int] = user_ids or []
        r"""A list of user identifiers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["users"]:
        return "users"

    def getClass(self) -> Literal["Users"]:
        return "Users"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "user_ids": self.user_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Users", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.user_ids = data.get("user_ids", None)

        return data_class


class FoundUsers(TlObject):
    r"""Represents a list of found users

    Parameters:
        user_ids (:class:`List[int]`):
            Identifiers of the found users

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(self, user_ids: List[int] = None, next_offset: str = "") -> None:
        self.user_ids: List[int] = user_ids or []
        r"""Identifiers of the found users"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundUsers"]:
        return "foundUsers"

    def getClass(self) -> Literal["FoundUsers"]:
        return "FoundUsers"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_ids": self.user_ids,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundUsers", None]:
        if data:
            data_class = cls()
            data_class.user_ids = data.get("user_ids", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class ChatAdministrator(TlObject):
    r"""Contains information about a chat administrator

    Parameters:
        user_id (:class:`int`):
            User identifier of the administrator

        custom_title (:class:`str`):
            Custom title of the administrator

        is_owner (:class:`bool`):
            True, if the user is the owner of the chat

    """

    def __init__(
        self, user_id: int = 0, custom_title: str = "", is_owner: bool = False
    ) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier of the administrator"""
        self.custom_title: Union[str, None] = custom_title
        r"""Custom title of the administrator"""
        self.is_owner: bool = bool(is_owner)
        r"""True, if the user is the owner of the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatAdministrator"]:
        return "chatAdministrator"

    def getClass(self) -> Literal["ChatAdministrator"]:
        return "ChatAdministrator"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "custom_title": self.custom_title,
            "is_owner": self.is_owner,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatAdministrator", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.custom_title = data.get("custom_title", "")
            data_class.is_owner = data.get("is_owner", False)

        return data_class


class ChatAdministrators(TlObject):
    r"""Represents a list of chat administrators

    Parameters:
        administrators (:class:`List["types.ChatAdministrator"]`):
            A list of chat administrators

    """

    def __init__(self, administrators: List[ChatAdministrator] = None) -> None:
        self.administrators: List[ChatAdministrator] = administrators or []
        r"""A list of chat administrators"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatAdministrators"]:
        return "chatAdministrators"

    def getClass(self) -> Literal["ChatAdministrators"]:
        return "ChatAdministrators"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "administrators": self.administrators}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatAdministrators", None]:
        if data:
            data_class = cls()
            data_class.administrators = data.get("administrators", None)

        return data_class


class ChatMemberStatusCreator(TlObject, ChatMemberStatus):
    r"""The user is the owner of the chat and has all the administrator privileges

    Parameters:
        custom_title (:class:`str`):
            A custom title of the owner; 0\-16 characters without emoji; applicable to supergroups only

        is_anonymous (:class:`bool`):
            True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only

        is_member (:class:`bool`):
            True, if the user is a member of the chat

    """

    def __init__(
        self,
        custom_title: str = "",
        is_anonymous: bool = False,
        is_member: bool = False,
    ) -> None:
        self.custom_title: Union[str, None] = custom_title
        r"""A custom title of the owner; 0\-16 characters without emoji; applicable to supergroups only"""
        self.is_anonymous: bool = bool(is_anonymous)
        r"""True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only"""
        self.is_member: bool = bool(is_member)
        r"""True, if the user is a member of the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMemberStatusCreator"]:
        return "chatMemberStatusCreator"

    def getClass(self) -> Literal["ChatMemberStatus"]:
        return "ChatMemberStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "custom_title": self.custom_title,
            "is_anonymous": self.is_anonymous,
            "is_member": self.is_member,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMemberStatusCreator", None]:
        if data:
            data_class = cls()
            data_class.custom_title = data.get("custom_title", "")
            data_class.is_anonymous = data.get("is_anonymous", False)
            data_class.is_member = data.get("is_member", False)

        return data_class


class ChatMemberStatusAdministrator(TlObject, ChatMemberStatus):
    r"""The user is a member of the chat and has some additional privileges\. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats\. In supergroups and channels, there are more detailed options for administrator privileges

    Parameters:
        custom_title (:class:`str`):
            A custom title of the administrator; 0\-16 characters without emoji; applicable to supergroups only

        can_be_edited (:class:`bool`):
            True, if the current user can edit the administrator privileges for the called user

        rights (:class:`"types.ChatAdministratorRights"`):
            Rights of the administrator

    """

    def __init__(
        self,
        custom_title: str = "",
        can_be_edited: bool = False,
        rights: ChatAdministratorRights = None,
    ) -> None:
        self.custom_title: Union[str, None] = custom_title
        r"""A custom title of the administrator; 0\-16 characters without emoji; applicable to supergroups only"""
        self.can_be_edited: bool = bool(can_be_edited)
        r"""True, if the current user can edit the administrator privileges for the called user"""
        self.rights: Union[ChatAdministratorRights, None] = rights
        r"""Rights of the administrator"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMemberStatusAdministrator"]:
        return "chatMemberStatusAdministrator"

    def getClass(self) -> Literal["ChatMemberStatus"]:
        return "ChatMemberStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "custom_title": self.custom_title,
            "can_be_edited": self.can_be_edited,
            "rights": self.rights,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMemberStatusAdministrator", None]:
        if data:
            data_class = cls()
            data_class.custom_title = data.get("custom_title", "")
            data_class.can_be_edited = data.get("can_be_edited", False)
            data_class.rights = data.get("rights", None)

        return data_class


class ChatMemberStatusMember(TlObject, ChatMemberStatus):
    r"""The user is a member of the chat, without any additional privileges or restrictions

    Parameters:
        member_until_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user will be removed from the chat because of the expired subscription; 0 if never\. Ignored in setChatMemberStatus

    """

    def __init__(self, member_until_date: int = 0) -> None:
        self.member_until_date: int = int(member_until_date)
        r"""Point in time \(Unix timestamp\) when the user will be removed from the chat because of the expired subscription; 0 if never\. Ignored in setChatMemberStatus"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMemberStatusMember"]:
        return "chatMemberStatusMember"

    def getClass(self) -> Literal["ChatMemberStatus"]:
        return "ChatMemberStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "member_until_date": self.member_until_date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMemberStatusMember", None]:
        if data:
            data_class = cls()
            data_class.member_until_date = int(data.get("member_until_date", 0))

        return data_class


class ChatMemberStatusRestricted(TlObject, ChatMemberStatus):
    r"""The user is under certain restrictions in the chat\. Not supported in basic groups and channels

    Parameters:
        is_member (:class:`bool`):
            True, if the user is a member of the chat

        restricted_until_date (:class:`int`):
            Point in time \(Unix timestamp\) when restrictions will be lifted from the user; 0 if never\. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever

        permissions (:class:`"types.ChatPermissions"`):
            User permissions in the chat

    """

    def __init__(
        self,
        is_member: bool = False,
        restricted_until_date: int = 0,
        permissions: ChatPermissions = None,
    ) -> None:
        self.is_member: bool = bool(is_member)
        r"""True, if the user is a member of the chat"""
        self.restricted_until_date: int = int(restricted_until_date)
        r"""Point in time \(Unix timestamp\) when restrictions will be lifted from the user; 0 if never\. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever"""
        self.permissions: Union[ChatPermissions, None] = permissions
        r"""User permissions in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMemberStatusRestricted"]:
        return "chatMemberStatusRestricted"

    def getClass(self) -> Literal["ChatMemberStatus"]:
        return "ChatMemberStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_member": self.is_member,
            "restricted_until_date": self.restricted_until_date,
            "permissions": self.permissions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMemberStatusRestricted", None]:
        if data:
            data_class = cls()
            data_class.is_member = data.get("is_member", False)
            data_class.restricted_until_date = int(data.get("restricted_until_date", 0))
            data_class.permissions = data.get("permissions", None)

        return data_class


class ChatMemberStatusLeft(TlObject, ChatMemberStatus):
    r"""The user or the chat is not a chat member"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMemberStatusLeft"]:
        return "chatMemberStatusLeft"

    def getClass(self) -> Literal["ChatMemberStatus"]:
        return "ChatMemberStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMemberStatusLeft", None]:
        if data:
            data_class = cls()

        return data_class


class ChatMemberStatusBanned(TlObject, ChatMemberStatus):
    r"""The user or the chat was banned \(and hence is not a member of the chat\)\. Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat

    Parameters:
        banned_until_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user will be unbanned; 0 if never\. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever\. Always 0 in basic groups

    """

    def __init__(self, banned_until_date: int = 0) -> None:
        self.banned_until_date: int = int(banned_until_date)
        r"""Point in time \(Unix timestamp\) when the user will be unbanned; 0 if never\. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever\. Always 0 in basic groups"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMemberStatusBanned"]:
        return "chatMemberStatusBanned"

    def getClass(self) -> Literal["ChatMemberStatus"]:
        return "ChatMemberStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "banned_until_date": self.banned_until_date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMemberStatusBanned", None]:
        if data:
            data_class = cls()
            data_class.banned_until_date = int(data.get("banned_until_date", 0))

        return data_class


class ChatMember(TlObject):
    r"""Describes a user or a chat as a member of another chat

    Parameters:
        member_id (:class:`"types.MessageSender"`):
            Identifier of the chat member\. Currently, other chats can be only Left or Banned\. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels

        inviter_user_id (:class:`int`):
            Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown

        joined_chat_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user joined/was promoted/was banned in the chat

        status (:class:`"types.ChatMemberStatus"`):
            Status of the member in the chat

    """

    def __init__(
        self,
        member_id: MessageSender = None,
        inviter_user_id: int = 0,
        joined_chat_date: int = 0,
        status: ChatMemberStatus = None,
    ) -> None:
        self.member_id: Union[MessageSenderUser, MessageSenderChat, None] = member_id
        r"""Identifier of the chat member\. Currently, other chats can be only Left or Banned\. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels"""
        self.inviter_user_id: int = int(inviter_user_id)
        r"""Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown"""
        self.joined_chat_date: int = int(joined_chat_date)
        r"""Point in time \(Unix timestamp\) when the user joined/was promoted/was banned in the chat"""
        self.status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = status
        r"""Status of the member in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMember"]:
        return "chatMember"

    def getClass(self) -> Literal["ChatMember"]:
        return "ChatMember"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "member_id": self.member_id,
            "inviter_user_id": self.inviter_user_id,
            "joined_chat_date": self.joined_chat_date,
            "status": self.status,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMember", None]:
        if data:
            data_class = cls()
            data_class.member_id = data.get("member_id", None)
            data_class.inviter_user_id = int(data.get("inviter_user_id", 0))
            data_class.joined_chat_date = int(data.get("joined_chat_date", 0))
            data_class.status = data.get("status", None)

        return data_class


class ChatMembers(TlObject):
    r"""Contains a list of chat members

    Parameters:
        total_count (:class:`int`):
            Approximate total number of chat members found

        members (:class:`List["types.ChatMember"]`):
            A list of chat members

    """

    def __init__(self, total_count: int = 0, members: List[ChatMember] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of chat members found"""
        self.members: List[ChatMember] = members or []
        r"""A list of chat members"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembers"]:
        return "chatMembers"

    def getClass(self) -> Literal["ChatMembers"]:
        return "ChatMembers"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "members": self.members,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembers", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.members = data.get("members", None)

        return data_class


class ChatMembersFilterContacts(TlObject, ChatMembersFilter):
    r"""Returns contacts of the user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembersFilterContacts"]:
        return "chatMembersFilterContacts"

    def getClass(self) -> Literal["ChatMembersFilter"]:
        return "ChatMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembersFilterContacts", None]:
        if data:
            data_class = cls()

        return data_class


class ChatMembersFilterAdministrators(TlObject, ChatMembersFilter):
    r"""Returns the owner and administrators"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembersFilterAdministrators"]:
        return "chatMembersFilterAdministrators"

    def getClass(self) -> Literal["ChatMembersFilter"]:
        return "ChatMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembersFilterAdministrators", None]:
        if data:
            data_class = cls()

        return data_class


class ChatMembersFilterMembers(TlObject, ChatMembersFilter):
    r"""Returns all chat members, including restricted chat members"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembersFilterMembers"]:
        return "chatMembersFilterMembers"

    def getClass(self) -> Literal["ChatMembersFilter"]:
        return "ChatMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembersFilterMembers", None]:
        if data:
            data_class = cls()

        return data_class


class ChatMembersFilterMention(TlObject, ChatMembersFilter):
    r"""Returns users which can be mentioned in the chat

    Parameters:
        message_thread_id (:class:`int`):
            If non\-zero, the identifier of the current message thread

    """

    def __init__(self, message_thread_id: int = 0) -> None:
        self.message_thread_id: int = int(message_thread_id)
        r"""If non\-zero, the identifier of the current message thread"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembersFilterMention"]:
        return "chatMembersFilterMention"

    def getClass(self) -> Literal["ChatMembersFilter"]:
        return "ChatMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message_thread_id": self.message_thread_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembersFilterMention", None]:
        if data:
            data_class = cls()
            data_class.message_thread_id = int(data.get("message_thread_id", 0))

        return data_class


class ChatMembersFilterRestricted(TlObject, ChatMembersFilter):
    r"""Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembersFilterRestricted"]:
        return "chatMembersFilterRestricted"

    def getClass(self) -> Literal["ChatMembersFilter"]:
        return "ChatMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembersFilterRestricted", None]:
        if data:
            data_class = cls()

        return data_class


class ChatMembersFilterBanned(TlObject, ChatMembersFilter):
    r"""Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembersFilterBanned"]:
        return "chatMembersFilterBanned"

    def getClass(self) -> Literal["ChatMembersFilter"]:
        return "ChatMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembersFilterBanned", None]:
        if data:
            data_class = cls()

        return data_class


class ChatMembersFilterBots(TlObject, ChatMembersFilter):
    r"""Returns bot members of the chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMembersFilterBots"]:
        return "chatMembersFilterBots"

    def getClass(self) -> Literal["ChatMembersFilter"]:
        return "ChatMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMembersFilterBots", None]:
        if data:
            data_class = cls()

        return data_class


class SupergroupMembersFilterRecent(TlObject, SupergroupMembersFilter):
    r"""Returns recently active users in reverse chronological order"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterRecent"]:
        return "supergroupMembersFilterRecent"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupMembersFilterRecent", None]:
        if data:
            data_class = cls()

        return data_class


class SupergroupMembersFilterContacts(TlObject, SupergroupMembersFilter):
    r"""Returns contacts of the user, which are members of the supergroup or channel

    Parameters:
        query (:class:`str`):
            Query to search for

    """

    def __init__(self, query: str = "") -> None:
        self.query: Union[str, None] = query
        r"""Query to search for"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterContacts"]:
        return "supergroupMembersFilterContacts"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "query": self.query}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupMembersFilterContacts", None]:
        if data:
            data_class = cls()
            data_class.query = data.get("query", "")

        return data_class


class SupergroupMembersFilterAdministrators(TlObject, SupergroupMembersFilter):
    r"""Returns the owner and administrators"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterAdministrators"]:
        return "supergroupMembersFilterAdministrators"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SupergroupMembersFilterAdministrators", None]:
        if data:
            data_class = cls()

        return data_class


class SupergroupMembersFilterSearch(TlObject, SupergroupMembersFilter):
    r"""Used to search for supergroup or channel members via a \(string\) query

    Parameters:
        query (:class:`str`):
            Query to search for

    """

    def __init__(self, query: str = "") -> None:
        self.query: Union[str, None] = query
        r"""Query to search for"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterSearch"]:
        return "supergroupMembersFilterSearch"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "query": self.query}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupMembersFilterSearch", None]:
        if data:
            data_class = cls()
            data_class.query = data.get("query", "")

        return data_class


class SupergroupMembersFilterRestricted(TlObject, SupergroupMembersFilter):
    r"""Returns restricted supergroup members; can be used only by administrators

    Parameters:
        query (:class:`str`):
            Query to search for

    """

    def __init__(self, query: str = "") -> None:
        self.query: Union[str, None] = query
        r"""Query to search for"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterRestricted"]:
        return "supergroupMembersFilterRestricted"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "query": self.query}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupMembersFilterRestricted", None]:
        if data:
            data_class = cls()
            data_class.query = data.get("query", "")

        return data_class


class SupergroupMembersFilterBanned(TlObject, SupergroupMembersFilter):
    r"""Returns users banned from the supergroup or channel; can be used only by administrators

    Parameters:
        query (:class:`str`):
            Query to search for

    """

    def __init__(self, query: str = "") -> None:
        self.query: Union[str, None] = query
        r"""Query to search for"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterBanned"]:
        return "supergroupMembersFilterBanned"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "query": self.query}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupMembersFilterBanned", None]:
        if data:
            data_class = cls()
            data_class.query = data.get("query", "")

        return data_class


class SupergroupMembersFilterMention(TlObject, SupergroupMembersFilter):
    r"""Returns users which can be mentioned in the supergroup

    Parameters:
        query (:class:`str`):
            Query to search for

        message_thread_id (:class:`int`):
            If non\-zero, the identifier of the current message thread

    """

    def __init__(self, query: str = "", message_thread_id: int = 0) -> None:
        self.query: Union[str, None] = query
        r"""Query to search for"""
        self.message_thread_id: int = int(message_thread_id)
        r"""If non\-zero, the identifier of the current message thread"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterMention"]:
        return "supergroupMembersFilterMention"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "query": self.query,
            "message_thread_id": self.message_thread_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupMembersFilterMention", None]:
        if data:
            data_class = cls()
            data_class.query = data.get("query", "")
            data_class.message_thread_id = int(data.get("message_thread_id", 0))

        return data_class


class SupergroupMembersFilterBots(TlObject, SupergroupMembersFilter):
    r"""Returns bot members of the supergroup or channel"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupMembersFilterBots"]:
        return "supergroupMembersFilterBots"

    def getClass(self) -> Literal["SupergroupMembersFilter"]:
        return "SupergroupMembersFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupMembersFilterBots", None]:
        if data:
            data_class = cls()

        return data_class


class ChatInviteLink(TlObject):
    r"""Contains a chat invite link

    Parameters:
        invite_link (:class:`str`):
            Chat invite link

        name (:class:`str`):
            Name of the link

        creator_user_id (:class:`int`):
            User identifier of an administrator created the link

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the link was created

        edit_date (:class:`int`):
            Point in time \(Unix timestamp\) when the link was last edited; 0 if never or unknown

        expiration_date (:class:`int`):
            Point in time \(Unix timestamp\) when the link will expire; 0 if never

        subscription_pricing (:class:`"types.StarSubscriptionPricing"`):
            Information about subscription plan that is applied to the users joining the chat by the link; may be null if the link doesn't require subscription

        member_limit (:class:`int`):
            The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited\. Always 0 if the link requires approval

        member_count (:class:`int`):
            Number of chat members, which joined the chat using the link

        expired_member_count (:class:`int`):
            Number of chat members, which joined the chat using the link, but have already left because of expired subscription; for subscription links only

        pending_join_request_count (:class:`int`):
            Number of pending join requests created using this link

        creates_join_request (:class:`bool`):
            True, if the link only creates join request\. If true, total number of joining members will be unlimited

        is_primary (:class:`bool`):
            True, if the link is primary\. Primary invite link can't have name, expiration date, or usage limit\. There is exactly one primary invite link for each administrator with can\_invite\_users right at a given time

        is_revoked (:class:`bool`):
            True, if the link was revoked

    """

    def __init__(
        self,
        invite_link: str = "",
        name: str = "",
        creator_user_id: int = 0,
        date: int = 0,
        edit_date: int = 0,
        expiration_date: int = 0,
        subscription_pricing: StarSubscriptionPricing = None,
        member_limit: int = 0,
        member_count: int = 0,
        expired_member_count: int = 0,
        pending_join_request_count: int = 0,
        creates_join_request: bool = False,
        is_primary: bool = False,
        is_revoked: bool = False,
    ) -> None:
        self.invite_link: Union[str, None] = invite_link
        r"""Chat invite link"""
        self.name: Union[str, None] = name
        r"""Name of the link"""
        self.creator_user_id: int = int(creator_user_id)
        r"""User identifier of an administrator created the link"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the link was created"""
        self.edit_date: int = int(edit_date)
        r"""Point in time \(Unix timestamp\) when the link was last edited; 0 if never or unknown"""
        self.expiration_date: int = int(expiration_date)
        r"""Point in time \(Unix timestamp\) when the link will expire; 0 if never"""
        self.subscription_pricing: Union[StarSubscriptionPricing, None] = (
            subscription_pricing
        )
        r"""Information about subscription plan that is applied to the users joining the chat by the link; may be null if the link doesn't require subscription"""
        self.member_limit: int = int(member_limit)
        r"""The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited\. Always 0 if the link requires approval"""
        self.member_count: int = int(member_count)
        r"""Number of chat members, which joined the chat using the link"""
        self.expired_member_count: int = int(expired_member_count)
        r"""Number of chat members, which joined the chat using the link, but have already left because of expired subscription; for subscription links only"""
        self.pending_join_request_count: int = int(pending_join_request_count)
        r"""Number of pending join requests created using this link"""
        self.creates_join_request: bool = bool(creates_join_request)
        r"""True, if the link only creates join request\. If true, total number of joining members will be unlimited"""
        self.is_primary: bool = bool(is_primary)
        r"""True, if the link is primary\. Primary invite link can't have name, expiration date, or usage limit\. There is exactly one primary invite link for each administrator with can\_invite\_users right at a given time"""
        self.is_revoked: bool = bool(is_revoked)
        r"""True, if the link was revoked"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLink"]:
        return "chatInviteLink"

    def getClass(self) -> Literal["ChatInviteLink"]:
        return "ChatInviteLink"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "invite_link": self.invite_link,
            "name": self.name,
            "creator_user_id": self.creator_user_id,
            "date": self.date,
            "edit_date": self.edit_date,
            "expiration_date": self.expiration_date,
            "subscription_pricing": self.subscription_pricing,
            "member_limit": self.member_limit,
            "member_count": self.member_count,
            "expired_member_count": self.expired_member_count,
            "pending_join_request_count": self.pending_join_request_count,
            "creates_join_request": self.creates_join_request,
            "is_primary": self.is_primary,
            "is_revoked": self.is_revoked,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLink", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", "")
            data_class.name = data.get("name", "")
            data_class.creator_user_id = int(data.get("creator_user_id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.edit_date = int(data.get("edit_date", 0))
            data_class.expiration_date = int(data.get("expiration_date", 0))
            data_class.subscription_pricing = data.get("subscription_pricing", None)
            data_class.member_limit = int(data.get("member_limit", 0))
            data_class.member_count = int(data.get("member_count", 0))
            data_class.expired_member_count = int(data.get("expired_member_count", 0))
            data_class.pending_join_request_count = int(
                data.get("pending_join_request_count", 0)
            )
            data_class.creates_join_request = data.get("creates_join_request", False)
            data_class.is_primary = data.get("is_primary", False)
            data_class.is_revoked = data.get("is_revoked", False)

        return data_class


class ChatInviteLinks(TlObject):
    r"""Contains a list of chat invite links

    Parameters:
        total_count (:class:`int`):
            Approximate total number of chat invite links found

        invite_links (:class:`List["types.ChatInviteLink"]`):
            List of invite links

    """

    def __init__(
        self, total_count: int = 0, invite_links: List[ChatInviteLink] = None
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of chat invite links found"""
        self.invite_links: List[ChatInviteLink] = invite_links or []
        r"""List of invite links"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLinks"]:
        return "chatInviteLinks"

    def getClass(self) -> Literal["ChatInviteLinks"]:
        return "ChatInviteLinks"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "invite_links": self.invite_links,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLinks", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.invite_links = data.get("invite_links", None)

        return data_class


class ChatInviteLinkCount(TlObject):
    r"""Describes a chat administrator with a number of active and revoked chat invite links

    Parameters:
        user_id (:class:`int`):
            Administrator's user identifier

        invite_link_count (:class:`int`):
            Number of active invite links

        revoked_invite_link_count (:class:`int`):
            Number of revoked invite links

    """

    def __init__(
        self,
        user_id: int = 0,
        invite_link_count: int = 0,
        revoked_invite_link_count: int = 0,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Administrator's user identifier"""
        self.invite_link_count: int = int(invite_link_count)
        r"""Number of active invite links"""
        self.revoked_invite_link_count: int = int(revoked_invite_link_count)
        r"""Number of revoked invite links"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLinkCount"]:
        return "chatInviteLinkCount"

    def getClass(self) -> Literal["ChatInviteLinkCount"]:
        return "ChatInviteLinkCount"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "invite_link_count": self.invite_link_count,
            "revoked_invite_link_count": self.revoked_invite_link_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLinkCount", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.invite_link_count = int(data.get("invite_link_count", 0))
            data_class.revoked_invite_link_count = int(
                data.get("revoked_invite_link_count", 0)
            )

        return data_class


class ChatInviteLinkCounts(TlObject):
    r"""Contains a list of chat invite link counts

    Parameters:
        invite_link_counts (:class:`List["types.ChatInviteLinkCount"]`):
            List of invite link counts

    """

    def __init__(self, invite_link_counts: List[ChatInviteLinkCount] = None) -> None:
        self.invite_link_counts: List[ChatInviteLinkCount] = invite_link_counts or []
        r"""List of invite link counts"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLinkCounts"]:
        return "chatInviteLinkCounts"

    def getClass(self) -> Literal["ChatInviteLinkCounts"]:
        return "ChatInviteLinkCounts"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invite_link_counts": self.invite_link_counts}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLinkCounts", None]:
        if data:
            data_class = cls()
            data_class.invite_link_counts = data.get("invite_link_counts", None)

        return data_class


class ChatInviteLinkMember(TlObject):
    r"""Describes a chat member joined a chat via an invite link

    Parameters:
        user_id (:class:`int`):
            User identifier

        joined_chat_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user joined the chat

        via_chat_folder_invite_link (:class:`bool`):
            True, if the user has joined the chat using an invite link for a chat folder

        approver_user_id (:class:`int`):
            User identifier of the chat administrator, approved user join request

    """

    def __init__(
        self,
        user_id: int = 0,
        joined_chat_date: int = 0,
        via_chat_folder_invite_link: bool = False,
        approver_user_id: int = 0,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.joined_chat_date: int = int(joined_chat_date)
        r"""Point in time \(Unix timestamp\) when the user joined the chat"""
        self.via_chat_folder_invite_link: bool = bool(via_chat_folder_invite_link)
        r"""True, if the user has joined the chat using an invite link for a chat folder"""
        self.approver_user_id: int = int(approver_user_id)
        r"""User identifier of the chat administrator, approved user join request"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLinkMember"]:
        return "chatInviteLinkMember"

    def getClass(self) -> Literal["ChatInviteLinkMember"]:
        return "ChatInviteLinkMember"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "joined_chat_date": self.joined_chat_date,
            "via_chat_folder_invite_link": self.via_chat_folder_invite_link,
            "approver_user_id": self.approver_user_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLinkMember", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.joined_chat_date = int(data.get("joined_chat_date", 0))
            data_class.via_chat_folder_invite_link = data.get(
                "via_chat_folder_invite_link", False
            )
            data_class.approver_user_id = int(data.get("approver_user_id", 0))

        return data_class


class ChatInviteLinkMembers(TlObject):
    r"""Contains a list of chat members joined a chat via an invite link

    Parameters:
        total_count (:class:`int`):
            Approximate total number of chat members found

        members (:class:`List["types.ChatInviteLinkMember"]`):
            List of chat members, joined a chat via an invite link

    """

    def __init__(
        self, total_count: int = 0, members: List[ChatInviteLinkMember] = None
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of chat members found"""
        self.members: List[ChatInviteLinkMember] = members or []
        r"""List of chat members, joined a chat via an invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLinkMembers"]:
        return "chatInviteLinkMembers"

    def getClass(self) -> Literal["ChatInviteLinkMembers"]:
        return "ChatInviteLinkMembers"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "members": self.members,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLinkMembers", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.members = data.get("members", None)

        return data_class


class InviteLinkChatTypeBasicGroup(TlObject, InviteLinkChatType):
    r"""The link is an invite link for a basic group"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inviteLinkChatTypeBasicGroup"]:
        return "inviteLinkChatTypeBasicGroup"

    def getClass(self) -> Literal["InviteLinkChatType"]:
        return "InviteLinkChatType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InviteLinkChatTypeBasicGroup", None]:
        if data:
            data_class = cls()

        return data_class


class InviteLinkChatTypeSupergroup(TlObject, InviteLinkChatType):
    r"""The link is an invite link for a supergroup"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inviteLinkChatTypeSupergroup"]:
        return "inviteLinkChatTypeSupergroup"

    def getClass(self) -> Literal["InviteLinkChatType"]:
        return "InviteLinkChatType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InviteLinkChatTypeSupergroup", None]:
        if data:
            data_class = cls()

        return data_class


class InviteLinkChatTypeChannel(TlObject, InviteLinkChatType):
    r"""The link is an invite link for a channel"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inviteLinkChatTypeChannel"]:
        return "inviteLinkChatTypeChannel"

    def getClass(self) -> Literal["InviteLinkChatType"]:
        return "InviteLinkChatType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InviteLinkChatTypeChannel", None]:
        if data:
            data_class = cls()

        return data_class


class ChatInviteLinkSubscriptionInfo(TlObject):
    r"""Contains information about subscription plan that must be paid by the user to use a chat invite link

    Parameters:
        pricing (:class:`"types.StarSubscriptionPricing"`):
            Information about subscription plan that must be paid by the user to use the link

        can_reuse (:class:`bool`):
            True, if the user has already paid for the subscription and can use joinChatByInviteLink to join the subscribed chat again

        form_id (:class:`int`):
            Identifier of the payment form to use for subscription payment; 0 if the subscription can't be paid

    """

    def __init__(
        self,
        pricing: StarSubscriptionPricing = None,
        can_reuse: bool = False,
        form_id: int = 0,
    ) -> None:
        self.pricing: Union[StarSubscriptionPricing, None] = pricing
        r"""Information about subscription plan that must be paid by the user to use the link"""
        self.can_reuse: bool = bool(can_reuse)
        r"""True, if the user has already paid for the subscription and can use joinChatByInviteLink to join the subscribed chat again"""
        self.form_id: int = int(form_id)
        r"""Identifier of the payment form to use for subscription payment; 0 if the subscription can't be paid"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLinkSubscriptionInfo"]:
        return "chatInviteLinkSubscriptionInfo"

    def getClass(self) -> Literal["ChatInviteLinkSubscriptionInfo"]:
        return "ChatInviteLinkSubscriptionInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "pricing": self.pricing,
            "can_reuse": self.can_reuse,
            "form_id": self.form_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLinkSubscriptionInfo", None]:
        if data:
            data_class = cls()
            data_class.pricing = data.get("pricing", None)
            data_class.can_reuse = data.get("can_reuse", False)
            data_class.form_id = int(data.get("form_id", 0))

        return data_class


class ChatInviteLinkInfo(TlObject):
    r"""Contains information about a chat invite link

    Parameters:
        chat_id (:class:`int`):
            Chat identifier of the invite link; 0 if the user has no access to the chat before joining

        accessible_for (:class:`int`):
            If non\-zero, the amount of time for which read access to the chat will remain available, in seconds

        type (:class:`"types.InviteLinkChatType"`):
            Type of the chat

        title (:class:`str`):
            Title of the chat

        photo (:class:`"types.ChatPhotoInfo"`):
            Chat photo; may be null

        accent_color_id (:class:`int`):
            Identifier of the accent color for chat title and background of chat photo

        description (:class:`str`):
            Chat description

        member_count (:class:`int`):
            Number of members in the chat

        member_user_ids (:class:`List[int]`):
            User identifiers of some chat members that may be known to the current user

        subscription_info (:class:`"types.ChatInviteLinkSubscriptionInfo"`):
            Information about subscription plan that must be paid by the user to use the link; may be null if the link doesn't require subscription

        creates_join_request (:class:`bool`):
            True, if the link only creates join request

        is_public (:class:`bool`):
            True, if the chat is a public supergroup or channel, i\.e\. it has a username or it is a location\-based supergroup

        verification_status (:class:`"types.VerificationStatus"`):
            Information about verification status of the chat; may be null if none

    """

    def __init__(
        self,
        chat_id: int = 0,
        accessible_for: int = 0,
        type: InviteLinkChatType = None,
        title: str = "",
        photo: ChatPhotoInfo = None,
        accent_color_id: int = 0,
        description: str = "",
        member_count: int = 0,
        member_user_ids: List[int] = None,
        subscription_info: ChatInviteLinkSubscriptionInfo = None,
        creates_join_request: bool = False,
        is_public: bool = False,
        verification_status: VerificationStatus = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier of the invite link; 0 if the user has no access to the chat before joining"""
        self.accessible_for: int = int(accessible_for)
        r"""If non\-zero, the amount of time for which read access to the chat will remain available, in seconds"""
        self.type: Union[
            InviteLinkChatTypeBasicGroup,
            InviteLinkChatTypeSupergroup,
            InviteLinkChatTypeChannel,
            None,
        ] = type
        r"""Type of the chat"""
        self.title: Union[str, None] = title
        r"""Title of the chat"""
        self.photo: Union[ChatPhotoInfo, None] = photo
        r"""Chat photo; may be null"""
        self.accent_color_id: int = int(accent_color_id)
        r"""Identifier of the accent color for chat title and background of chat photo"""
        self.description: Union[str, None] = description
        r"""Chat description"""
        self.member_count: int = int(member_count)
        r"""Number of members in the chat"""
        self.member_user_ids: List[int] = member_user_ids or []
        r"""User identifiers of some chat members that may be known to the current user"""
        self.subscription_info: Union[ChatInviteLinkSubscriptionInfo, None] = (
            subscription_info
        )
        r"""Information about subscription plan that must be paid by the user to use the link; may be null if the link doesn't require subscription"""
        self.creates_join_request: bool = bool(creates_join_request)
        r"""True, if the link only creates join request"""
        self.is_public: bool = bool(is_public)
        r"""True, if the chat is a public supergroup or channel, i\.e\. it has a username or it is a location\-based supergroup"""
        self.verification_status: Union[VerificationStatus, None] = verification_status
        r"""Information about verification status of the chat; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatInviteLinkInfo"]:
        return "chatInviteLinkInfo"

    def getClass(self) -> Literal["ChatInviteLinkInfo"]:
        return "ChatInviteLinkInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "accessible_for": self.accessible_for,
            "type": self.type,
            "title": self.title,
            "photo": self.photo,
            "accent_color_id": self.accent_color_id,
            "description": self.description,
            "member_count": self.member_count,
            "member_user_ids": self.member_user_ids,
            "subscription_info": self.subscription_info,
            "creates_join_request": self.creates_join_request,
            "is_public": self.is_public,
            "verification_status": self.verification_status,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatInviteLinkInfo", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.accessible_for = int(data.get("accessible_for", 0))
            data_class.type = data.get("type", None)
            data_class.title = data.get("title", "")
            data_class.photo = data.get("photo", None)
            data_class.accent_color_id = int(data.get("accent_color_id", 0))
            data_class.description = data.get("description", "")
            data_class.member_count = int(data.get("member_count", 0))
            data_class.member_user_ids = data.get("member_user_ids", None)
            data_class.subscription_info = data.get("subscription_info", None)
            data_class.creates_join_request = data.get("creates_join_request", False)
            data_class.is_public = data.get("is_public", False)
            data_class.verification_status = data.get("verification_status", None)

        return data_class


class ChatJoinRequest(TlObject):
    r"""Describes a user that sent a join request and waits for administrator approval

    Parameters:
        user_id (:class:`int`):
            User identifier

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the user sent the join request

        bio (:class:`str`):
            A short bio of the user

    """

    def __init__(self, user_id: int = 0, date: int = 0, bio: str = "") -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the user sent the join request"""
        self.bio: Union[str, None] = bio
        r"""A short bio of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatJoinRequest"]:
        return "chatJoinRequest"

    def getClass(self) -> Literal["ChatJoinRequest"]:
        return "ChatJoinRequest"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "date": self.date,
            "bio": self.bio,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatJoinRequest", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.bio = data.get("bio", "")

        return data_class


class ChatJoinRequests(TlObject):
    r"""Contains a list of requests to join a chat

    Parameters:
        total_count (:class:`int`):
            Approximate total number of requests found

        requests (:class:`List["types.ChatJoinRequest"]`):
            List of the requests

    """

    def __init__(
        self, total_count: int = 0, requests: List[ChatJoinRequest] = None
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of requests found"""
        self.requests: List[ChatJoinRequest] = requests or []
        r"""List of the requests"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatJoinRequests"]:
        return "chatJoinRequests"

    def getClass(self) -> Literal["ChatJoinRequests"]:
        return "ChatJoinRequests"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "requests": self.requests,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatJoinRequests", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.requests = data.get("requests", None)

        return data_class


class ChatJoinRequestsInfo(TlObject):
    r"""Contains information about pending join requests for a chat

    Parameters:
        total_count (:class:`int`):
            Total number of pending join requests

        user_ids (:class:`List[int]`):
            Identifiers of at most 3 users sent the newest pending join requests

    """

    def __init__(self, total_count: int = 0, user_ids: List[int] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of pending join requests"""
        self.user_ids: List[int] = user_ids or []
        r"""Identifiers of at most 3 users sent the newest pending join requests"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatJoinRequestsInfo"]:
        return "chatJoinRequestsInfo"

    def getClass(self) -> Literal["ChatJoinRequestsInfo"]:
        return "ChatJoinRequestsInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "user_ids": self.user_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatJoinRequestsInfo", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.user_ids = data.get("user_ids", None)

        return data_class


class BasicGroup(TlObject):
    r"""Represents a basic group of 0\-200 users \(must be upgraded to a supergroup to accommodate more than 200 users\)

    Parameters:
        id (:class:`int`):
            Group identifier

        member_count (:class:`int`):
            Number of members in the group

        status (:class:`"types.ChatMemberStatus"`):
            Status of the current user in the group

        is_active (:class:`bool`):
            True, if the group is active

        upgraded_to_supergroup_id (:class:`int`):
            Identifier of the supergroup to which this group was upgraded; 0 if none

    """

    def __init__(
        self,
        id: int = 0,
        member_count: int = 0,
        status: ChatMemberStatus = None,
        is_active: bool = False,
        upgraded_to_supergroup_id: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Group identifier"""
        self.member_count: int = int(member_count)
        r"""Number of members in the group"""
        self.status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = status
        r"""Status of the current user in the group"""
        self.is_active: bool = bool(is_active)
        r"""True, if the group is active"""
        self.upgraded_to_supergroup_id: int = int(upgraded_to_supergroup_id)
        r"""Identifier of the supergroup to which this group was upgraded; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["basicGroup"]:
        return "basicGroup"

    def getClass(self) -> Literal["BasicGroup"]:
        return "BasicGroup"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "member_count": self.member_count,
            "status": self.status,
            "is_active": self.is_active,
            "upgraded_to_supergroup_id": self.upgraded_to_supergroup_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BasicGroup", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.member_count = int(data.get("member_count", 0))
            data_class.status = data.get("status", None)
            data_class.is_active = data.get("is_active", False)
            data_class.upgraded_to_supergroup_id = int(
                data.get("upgraded_to_supergroup_id", 0)
            )

        return data_class


class BasicGroupFullInfo(TlObject):
    r"""Contains full information about a basic group

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            Chat photo; may be null if empty or unknown\. If non\-null, then it is the same photo as in chat\.photo

        description (:class:`str`):
            Group description\. Updated only after the basic group is opened

        creator_user_id (:class:`int`):
            User identifier of the creator of the group; 0 if unknown

        members (:class:`List["types.ChatMember"]`):
            Group members

        can_hide_members (:class:`bool`):
            True, if non\-administrators and non\-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non\-administrators after upgrading the basic group to a supergroup

        can_toggle_aggressive_anti_spam (:class:`bool`):
            True, if aggressive anti\-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup

        invite_link (:class:`"types.ChatInviteLink"`):
            Primary invite link for this group; may be null\. For chat administrators with can\_invite\_users right only\. Updated only after the basic group is opened

        bot_commands (:class:`List["types.BotCommands"]`):
            List of commands of bots in the group

    """

    def __init__(
        self,
        photo: ChatPhoto = None,
        description: str = "",
        creator_user_id: int = 0,
        members: List[ChatMember] = None,
        can_hide_members: bool = False,
        can_toggle_aggressive_anti_spam: bool = False,
        invite_link: ChatInviteLink = None,
        bot_commands: List[BotCommands] = None,
    ) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""Chat photo; may be null if empty or unknown\. If non\-null, then it is the same photo as in chat\.photo"""
        self.description: Union[str, None] = description
        r"""Group description\. Updated only after the basic group is opened"""
        self.creator_user_id: int = int(creator_user_id)
        r"""User identifier of the creator of the group; 0 if unknown"""
        self.members: List[ChatMember] = members or []
        r"""Group members"""
        self.can_hide_members: bool = bool(can_hide_members)
        r"""True, if non\-administrators and non\-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non\-administrators after upgrading the basic group to a supergroup"""
        self.can_toggle_aggressive_anti_spam: bool = bool(
            can_toggle_aggressive_anti_spam
        )
        r"""True, if aggressive anti\-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup"""
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""Primary invite link for this group; may be null\. For chat administrators with can\_invite\_users right only\. Updated only after the basic group is opened"""
        self.bot_commands: List[BotCommands] = bot_commands or []
        r"""List of commands of bots in the group"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["basicGroupFullInfo"]:
        return "basicGroupFullInfo"

    def getClass(self) -> Literal["BasicGroupFullInfo"]:
        return "BasicGroupFullInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "description": self.description,
            "creator_user_id": self.creator_user_id,
            "members": self.members,
            "can_hide_members": self.can_hide_members,
            "can_toggle_aggressive_anti_spam": self.can_toggle_aggressive_anti_spam,
            "invite_link": self.invite_link,
            "bot_commands": self.bot_commands,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BasicGroupFullInfo", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.description = data.get("description", "")
            data_class.creator_user_id = int(data.get("creator_user_id", 0))
            data_class.members = data.get("members", None)
            data_class.can_hide_members = data.get("can_hide_members", False)
            data_class.can_toggle_aggressive_anti_spam = data.get(
                "can_toggle_aggressive_anti_spam", False
            )
            data_class.invite_link = data.get("invite_link", None)
            data_class.bot_commands = data.get("bot_commands", None)

        return data_class


class Supergroup(TlObject):
    r"""Represents a supergroup or channel with zero or more members \(subscribers in the case of channels\)\. From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos\. Unlike supergroups, channels can have an unlimited number of subscribers

    Parameters:
        id (:class:`int`):
            Supergroup or channel identifier

        usernames (:class:`"types.Usernames"`):
            Usernames of the supergroup or channel; may be null

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member

        status (:class:`"types.ChatMemberStatus"`):
            Status of the current user in the supergroup or channel; custom title will always be empty

        member_count (:class:`int`):
            Number of members in the supergroup or channel; 0 if unknown\. Currently, it is guaranteed to be known only if the supergroup or channel was received through getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchPublicChats, or in chatFolderInviteLinkInfo\.missing\_chat\_ids, or in userFullInfo\.personal\_chat\_id, or for chats with messages or stories from publicForwards and foundStories

        boost_level (:class:`int`):
            Approximate boost level for the chat

        has_linked_chat (:class:`bool`):
            True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel

        has_location (:class:`bool`):
            True, if the supergroup is connected to a location, i\.e\. the supergroup is a location\-based supergroup

        sign_messages (:class:`bool`):
            True, if messages sent to the channel contains name of the sender\. This field is only applicable to channels

        show_message_sender (:class:`bool`):
            True, if messages sent to the channel have information about the sender user\. This field is only applicable to channels

        join_to_send_messages (:class:`bool`):
            True, if users need to join the supergroup before they can send messages\. Always true for channels and non\-discussion supergroups

        join_by_request (:class:`bool`):
            True, if all users directly joining the supergroup need to be approved by supergroup administrators\. Always false for channels and supergroups without username, location, or a linked chat

        is_slow_mode_enabled (:class:`bool`):
            True, if the slow mode is enabled in the supergroup

        is_channel (:class:`bool`):
            True, if the supergroup is a channel

        is_broadcast_group (:class:`bool`):
            True, if the supergroup is a broadcast group, i\.e\. only administrators can send messages and there is no limit on the number of members

        is_forum (:class:`bool`):
            True, if the supergroup is a forum with topics

        verification_status (:class:`"types.VerificationStatus"`):
            Information about verification status of the supergroup or channel; may be null if none

        has_sensitive_content (:class:`bool`):
            True, if content of media messages in the supergroup or channel chat must be hidden with 18\+ spoiler

        restriction_reason (:class:`str`):
            If non\-empty, contains a human\-readable description of the reason why access to this supergroup or channel must be restricted

        paid_message_star_count (:class:`int`):
            Number of Telegram Stars that must be paid by non\-administrator users of the supergroup chat for each sent message

        has_active_stories (:class:`bool`):
            True, if the supergroup or channel has non\-expired stories available to the current user

        has_unread_active_stories (:class:`bool`):
            True, if the supergroup or channel has unread non\-expired stories available to the current user

    """

    def __init__(
        self,
        id: int = 0,
        usernames: Usernames = None,
        date: int = 0,
        status: ChatMemberStatus = None,
        member_count: int = 0,
        boost_level: int = 0,
        has_linked_chat: bool = False,
        has_location: bool = False,
        sign_messages: bool = False,
        show_message_sender: bool = False,
        join_to_send_messages: bool = False,
        join_by_request: bool = False,
        is_slow_mode_enabled: bool = False,
        is_channel: bool = False,
        is_broadcast_group: bool = False,
        is_forum: bool = False,
        verification_status: VerificationStatus = None,
        has_sensitive_content: bool = False,
        restriction_reason: str = "",
        paid_message_star_count: int = 0,
        has_active_stories: bool = False,
        has_unread_active_stories: bool = False,
    ) -> None:
        self.id: int = int(id)
        r"""Supergroup or channel identifier"""
        self.usernames: Union[Usernames, None] = usernames
        r"""Usernames of the supergroup or channel; may be null"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member"""
        self.status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = status
        r"""Status of the current user in the supergroup or channel; custom title will always be empty"""
        self.member_count: int = int(member_count)
        r"""Number of members in the supergroup or channel; 0 if unknown\. Currently, it is guaranteed to be known only if the supergroup or channel was received through getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchPublicChats, or in chatFolderInviteLinkInfo\.missing\_chat\_ids, or in userFullInfo\.personal\_chat\_id, or for chats with messages or stories from publicForwards and foundStories"""
        self.boost_level: int = int(boost_level)
        r"""Approximate boost level for the chat"""
        self.has_linked_chat: bool = bool(has_linked_chat)
        r"""True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel"""
        self.has_location: bool = bool(has_location)
        r"""True, if the supergroup is connected to a location, i\.e\. the supergroup is a location\-based supergroup"""
        self.sign_messages: bool = bool(sign_messages)
        r"""True, if messages sent to the channel contains name of the sender\. This field is only applicable to channels"""
        self.show_message_sender: bool = bool(show_message_sender)
        r"""True, if messages sent to the channel have information about the sender user\. This field is only applicable to channels"""
        self.join_to_send_messages: bool = bool(join_to_send_messages)
        r"""True, if users need to join the supergroup before they can send messages\. Always true for channels and non\-discussion supergroups"""
        self.join_by_request: bool = bool(join_by_request)
        r"""True, if all users directly joining the supergroup need to be approved by supergroup administrators\. Always false for channels and supergroups without username, location, or a linked chat"""
        self.is_slow_mode_enabled: bool = bool(is_slow_mode_enabled)
        r"""True, if the slow mode is enabled in the supergroup"""
        self.is_channel: bool = bool(is_channel)
        r"""True, if the supergroup is a channel"""
        self.is_broadcast_group: bool = bool(is_broadcast_group)
        r"""True, if the supergroup is a broadcast group, i\.e\. only administrators can send messages and there is no limit on the number of members"""
        self.is_forum: bool = bool(is_forum)
        r"""True, if the supergroup is a forum with topics"""
        self.verification_status: Union[VerificationStatus, None] = verification_status
        r"""Information about verification status of the supergroup or channel; may be null if none"""
        self.has_sensitive_content: bool = bool(has_sensitive_content)
        r"""True, if content of media messages in the supergroup or channel chat must be hidden with 18\+ spoiler"""
        self.restriction_reason: Union[str, None] = restriction_reason
        r"""If non\-empty, contains a human\-readable description of the reason why access to this supergroup or channel must be restricted"""
        self.paid_message_star_count: int = int(paid_message_star_count)
        r"""Number of Telegram Stars that must be paid by non\-administrator users of the supergroup chat for each sent message"""
        self.has_active_stories: bool = bool(has_active_stories)
        r"""True, if the supergroup or channel has non\-expired stories available to the current user"""
        self.has_unread_active_stories: bool = bool(has_unread_active_stories)
        r"""True, if the supergroup or channel has unread non\-expired stories available to the current user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroup"]:
        return "supergroup"

    def getClass(self) -> Literal["Supergroup"]:
        return "Supergroup"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "usernames": self.usernames,
            "date": self.date,
            "status": self.status,
            "member_count": self.member_count,
            "boost_level": self.boost_level,
            "has_linked_chat": self.has_linked_chat,
            "has_location": self.has_location,
            "sign_messages": self.sign_messages,
            "show_message_sender": self.show_message_sender,
            "join_to_send_messages": self.join_to_send_messages,
            "join_by_request": self.join_by_request,
            "is_slow_mode_enabled": self.is_slow_mode_enabled,
            "is_channel": self.is_channel,
            "is_broadcast_group": self.is_broadcast_group,
            "is_forum": self.is_forum,
            "verification_status": self.verification_status,
            "has_sensitive_content": self.has_sensitive_content,
            "restriction_reason": self.restriction_reason,
            "paid_message_star_count": self.paid_message_star_count,
            "has_active_stories": self.has_active_stories,
            "has_unread_active_stories": self.has_unread_active_stories,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Supergroup", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.usernames = data.get("usernames", None)
            data_class.date = int(data.get("date", 0))
            data_class.status = data.get("status", None)
            data_class.member_count = int(data.get("member_count", 0))
            data_class.boost_level = int(data.get("boost_level", 0))
            data_class.has_linked_chat = data.get("has_linked_chat", False)
            data_class.has_location = data.get("has_location", False)
            data_class.sign_messages = data.get("sign_messages", False)
            data_class.show_message_sender = data.get("show_message_sender", False)
            data_class.join_to_send_messages = data.get("join_to_send_messages", False)
            data_class.join_by_request = data.get("join_by_request", False)
            data_class.is_slow_mode_enabled = data.get("is_slow_mode_enabled", False)
            data_class.is_channel = data.get("is_channel", False)
            data_class.is_broadcast_group = data.get("is_broadcast_group", False)
            data_class.is_forum = data.get("is_forum", False)
            data_class.verification_status = data.get("verification_status", None)
            data_class.has_sensitive_content = data.get("has_sensitive_content", False)
            data_class.restriction_reason = data.get("restriction_reason", "")
            data_class.paid_message_star_count = int(
                data.get("paid_message_star_count", 0)
            )
            data_class.has_active_stories = data.get("has_active_stories", False)
            data_class.has_unread_active_stories = data.get(
                "has_unread_active_stories", False
            )

        return data_class


class SupergroupFullInfo(TlObject):
    r"""Contains full information about a supergroup or channel

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            Chat photo; may be null if empty or unknown\. If non\-null, then it is the same photo as in chat\.photo

        description (:class:`str`):
            Supergroup or channel description

        member_count (:class:`int`):
            Number of members in the supergroup or channel; 0 if unknown

        administrator_count (:class:`int`):
            Number of privileged users in the supergroup or channel; 0 if unknown

        restricted_count (:class:`int`):
            Number of restricted users in the supergroup; 0 if unknown

        banned_count (:class:`int`):
            Number of users banned from chat; 0 if unknown

        linked_chat_id (:class:`int`):
            Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown

        slow_mode_delay (:class:`int`):
            Delay between consecutive sent messages for non\-administrator supergroup members, in seconds

        slow_mode_delay_expires_in (:class:`float`):
            Time left before next message can be sent in the supergroup, in seconds\. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non\-zero

        can_enable_paid_messages (:class:`bool`):
            True, if paid messages can be enabled in the supergroup chat; for supergroup only

        can_enable_paid_reaction (:class:`bool`):
            True, if paid reaction can be enabled in the channel chat; for channels only

        can_get_members (:class:`bool`):
            True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers

        has_hidden_members (:class:`bool`):
            True, if non\-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers

        can_hide_members (:class:`bool`):
            True, if non\-administrators and non\-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non\-administrators

        can_set_sticker_set (:class:`bool`):
            True, if the supergroup sticker set can be changed

        can_set_location (:class:`bool`):
            True, if the supergroup location can be changed

        can_get_statistics (:class:`bool`):
            True, if the supergroup or channel statistics are available

        can_get_revenue_statistics (:class:`bool`):
            True, if the supergroup or channel revenue statistics are available

        can_get_star_revenue_statistics (:class:`bool`):
            True, if the supergroup or channel Telegram Star revenue statistics are available

        can_send_gift (:class:`bool`):
            True, if the user can send a gift to the supergroup or channel using sendGift or transferGift

        can_toggle_aggressive_anti_spam (:class:`bool`):
            True, if aggressive anti\-spam checks can be enabled or disabled in the supergroup

        is_all_history_available (:class:`bool`):
            True, if new chat members will have access to old messages\. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non\-forum supergroups without a linked chat\. The value of this field is only available to chat administrators

        can_have_sponsored_messages (:class:`bool`):
            True, if the chat can have sponsored messages\. The value of this field is only available to the owner of the chat

        has_aggressive_anti_spam_enabled (:class:`bool`):
            True, if aggressive anti\-spam checks are enabled in the supergroup\. The value of this field is only available to chat administrators

        has_paid_media_allowed (:class:`bool`):
            True, if paid media can be sent and forwarded to the channel chat; for channels only

        has_pinned_stories (:class:`bool`):
            True, if the supergroup or channel has pinned stories

        gift_count (:class:`int`):
            Number of saved to profile gifts for channels without can\_post\_messages administrator right, otherwise, the total number of received gifts

        my_boost_count (:class:`int`):
            Number of times the current user boosted the supergroup or channel

        unrestrict_boost_count (:class:`int`):
            Number of times the supergroup must be boosted by a user to ignore slow mode and chat permission restrictions; 0 if unspecified

        sticker_set_id (:class:`int`):
            Identifier of the supergroup sticker set that must be shown before user sticker sets; 0 if none

        custom_emoji_sticker_set_id (:class:`int`):
            Identifier of the custom emoji sticker set that can be used in the supergroup without Telegram Premium subscription; 0 if none

        location (:class:`"types.ChatLocation"`):
            Location to which the supergroup is connected; may be null if none

        invite_link (:class:`"types.ChatInviteLink"`):
            Primary invite link for the chat; may be null\. For chat administrators with can\_invite\_users right only

        bot_commands (:class:`List["types.BotCommands"]`):
            List of commands of bots in the group

        bot_verification (:class:`"types.BotVerification"`):
            Information about verification status of the supergroup or the channel provided by a bot; may be null if none or unknown

        upgraded_from_basic_group_id (:class:`int`):
            Identifier of the basic group from which supergroup was upgraded; 0 if none

        upgraded_from_max_message_id (:class:`int`):
            Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none

    """

    def __init__(
        self,
        photo: ChatPhoto = None,
        description: str = "",
        member_count: int = 0,
        administrator_count: int = 0,
        restricted_count: int = 0,
        banned_count: int = 0,
        linked_chat_id: int = 0,
        slow_mode_delay: int = 0,
        slow_mode_delay_expires_in: float = 0.0,
        can_enable_paid_messages: bool = False,
        can_enable_paid_reaction: bool = False,
        can_get_members: bool = False,
        has_hidden_members: bool = False,
        can_hide_members: bool = False,
        can_set_sticker_set: bool = False,
        can_set_location: bool = False,
        can_get_statistics: bool = False,
        can_get_revenue_statistics: bool = False,
        can_get_star_revenue_statistics: bool = False,
        can_send_gift: bool = False,
        can_toggle_aggressive_anti_spam: bool = False,
        is_all_history_available: bool = False,
        can_have_sponsored_messages: bool = False,
        has_aggressive_anti_spam_enabled: bool = False,
        has_paid_media_allowed: bool = False,
        has_pinned_stories: bool = False,
        gift_count: int = 0,
        my_boost_count: int = 0,
        unrestrict_boost_count: int = 0,
        sticker_set_id: int = 0,
        custom_emoji_sticker_set_id: int = 0,
        location: ChatLocation = None,
        invite_link: ChatInviteLink = None,
        bot_commands: List[BotCommands] = None,
        bot_verification: BotVerification = None,
        upgraded_from_basic_group_id: int = 0,
        upgraded_from_max_message_id: int = 0,
    ) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""Chat photo; may be null if empty or unknown\. If non\-null, then it is the same photo as in chat\.photo"""
        self.description: Union[str, None] = description
        r"""Supergroup or channel description"""
        self.member_count: int = int(member_count)
        r"""Number of members in the supergroup or channel; 0 if unknown"""
        self.administrator_count: int = int(administrator_count)
        r"""Number of privileged users in the supergroup or channel; 0 if unknown"""
        self.restricted_count: int = int(restricted_count)
        r"""Number of restricted users in the supergroup; 0 if unknown"""
        self.banned_count: int = int(banned_count)
        r"""Number of users banned from chat; 0 if unknown"""
        self.linked_chat_id: int = int(linked_chat_id)
        r"""Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown"""
        self.slow_mode_delay: int = int(slow_mode_delay)
        r"""Delay between consecutive sent messages for non\-administrator supergroup members, in seconds"""
        self.slow_mode_delay_expires_in: float = float(slow_mode_delay_expires_in)
        r"""Time left before next message can be sent in the supergroup, in seconds\. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non\-zero"""
        self.can_enable_paid_messages: bool = bool(can_enable_paid_messages)
        r"""True, if paid messages can be enabled in the supergroup chat; for supergroup only"""
        self.can_enable_paid_reaction: bool = bool(can_enable_paid_reaction)
        r"""True, if paid reaction can be enabled in the channel chat; for channels only"""
        self.can_get_members: bool = bool(can_get_members)
        r"""True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers"""
        self.has_hidden_members: bool = bool(has_hidden_members)
        r"""True, if non\-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers"""
        self.can_hide_members: bool = bool(can_hide_members)
        r"""True, if non\-administrators and non\-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non\-administrators"""
        self.can_set_sticker_set: bool = bool(can_set_sticker_set)
        r"""True, if the supergroup sticker set can be changed"""
        self.can_set_location: bool = bool(can_set_location)
        r"""True, if the supergroup location can be changed"""
        self.can_get_statistics: bool = bool(can_get_statistics)
        r"""True, if the supergroup or channel statistics are available"""
        self.can_get_revenue_statistics: bool = bool(can_get_revenue_statistics)
        r"""True, if the supergroup or channel revenue statistics are available"""
        self.can_get_star_revenue_statistics: bool = bool(
            can_get_star_revenue_statistics
        )
        r"""True, if the supergroup or channel Telegram Star revenue statistics are available"""
        self.can_send_gift: bool = bool(can_send_gift)
        r"""True, if the user can send a gift to the supergroup or channel using sendGift or transferGift"""
        self.can_toggle_aggressive_anti_spam: bool = bool(
            can_toggle_aggressive_anti_spam
        )
        r"""True, if aggressive anti\-spam checks can be enabled or disabled in the supergroup"""
        self.is_all_history_available: bool = bool(is_all_history_available)
        r"""True, if new chat members will have access to old messages\. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non\-forum supergroups without a linked chat\. The value of this field is only available to chat administrators"""
        self.can_have_sponsored_messages: bool = bool(can_have_sponsored_messages)
        r"""True, if the chat can have sponsored messages\. The value of this field is only available to the owner of the chat"""
        self.has_aggressive_anti_spam_enabled: bool = bool(
            has_aggressive_anti_spam_enabled
        )
        r"""True, if aggressive anti\-spam checks are enabled in the supergroup\. The value of this field is only available to chat administrators"""
        self.has_paid_media_allowed: bool = bool(has_paid_media_allowed)
        r"""True, if paid media can be sent and forwarded to the channel chat; for channels only"""
        self.has_pinned_stories: bool = bool(has_pinned_stories)
        r"""True, if the supergroup or channel has pinned stories"""
        self.gift_count: int = int(gift_count)
        r"""Number of saved to profile gifts for channels without can\_post\_messages administrator right, otherwise, the total number of received gifts"""
        self.my_boost_count: int = int(my_boost_count)
        r"""Number of times the current user boosted the supergroup or channel"""
        self.unrestrict_boost_count: int = int(unrestrict_boost_count)
        r"""Number of times the supergroup must be boosted by a user to ignore slow mode and chat permission restrictions; 0 if unspecified"""
        self.sticker_set_id: int = int(sticker_set_id)
        r"""Identifier of the supergroup sticker set that must be shown before user sticker sets; 0 if none"""
        self.custom_emoji_sticker_set_id: int = int(custom_emoji_sticker_set_id)
        r"""Identifier of the custom emoji sticker set that can be used in the supergroup without Telegram Premium subscription; 0 if none"""
        self.location: Union[ChatLocation, None] = location
        r"""Location to which the supergroup is connected; may be null if none"""
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""Primary invite link for the chat; may be null\. For chat administrators with can\_invite\_users right only"""
        self.bot_commands: List[BotCommands] = bot_commands or []
        r"""List of commands of bots in the group"""
        self.bot_verification: Union[BotVerification, None] = bot_verification
        r"""Information about verification status of the supergroup or the channel provided by a bot; may be null if none or unknown"""
        self.upgraded_from_basic_group_id: int = int(upgraded_from_basic_group_id)
        r"""Identifier of the basic group from which supergroup was upgraded; 0 if none"""
        self.upgraded_from_max_message_id: int = int(upgraded_from_max_message_id)
        r"""Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["supergroupFullInfo"]:
        return "supergroupFullInfo"

    def getClass(self) -> Literal["SupergroupFullInfo"]:
        return "SupergroupFullInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "description": self.description,
            "member_count": self.member_count,
            "administrator_count": self.administrator_count,
            "restricted_count": self.restricted_count,
            "banned_count": self.banned_count,
            "linked_chat_id": self.linked_chat_id,
            "slow_mode_delay": self.slow_mode_delay,
            "slow_mode_delay_expires_in": self.slow_mode_delay_expires_in,
            "can_enable_paid_messages": self.can_enable_paid_messages,
            "can_enable_paid_reaction": self.can_enable_paid_reaction,
            "can_get_members": self.can_get_members,
            "has_hidden_members": self.has_hidden_members,
            "can_hide_members": self.can_hide_members,
            "can_set_sticker_set": self.can_set_sticker_set,
            "can_set_location": self.can_set_location,
            "can_get_statistics": self.can_get_statistics,
            "can_get_revenue_statistics": self.can_get_revenue_statistics,
            "can_get_star_revenue_statistics": self.can_get_star_revenue_statistics,
            "can_send_gift": self.can_send_gift,
            "can_toggle_aggressive_anti_spam": self.can_toggle_aggressive_anti_spam,
            "is_all_history_available": self.is_all_history_available,
            "can_have_sponsored_messages": self.can_have_sponsored_messages,
            "has_aggressive_anti_spam_enabled": self.has_aggressive_anti_spam_enabled,
            "has_paid_media_allowed": self.has_paid_media_allowed,
            "has_pinned_stories": self.has_pinned_stories,
            "gift_count": self.gift_count,
            "my_boost_count": self.my_boost_count,
            "unrestrict_boost_count": self.unrestrict_boost_count,
            "sticker_set_id": self.sticker_set_id,
            "custom_emoji_sticker_set_id": self.custom_emoji_sticker_set_id,
            "location": self.location,
            "invite_link": self.invite_link,
            "bot_commands": self.bot_commands,
            "bot_verification": self.bot_verification,
            "upgraded_from_basic_group_id": self.upgraded_from_basic_group_id,
            "upgraded_from_max_message_id": self.upgraded_from_max_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SupergroupFullInfo", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.description = data.get("description", "")
            data_class.member_count = int(data.get("member_count", 0))
            data_class.administrator_count = int(data.get("administrator_count", 0))
            data_class.restricted_count = int(data.get("restricted_count", 0))
            data_class.banned_count = int(data.get("banned_count", 0))
            data_class.linked_chat_id = int(data.get("linked_chat_id", 0))
            data_class.slow_mode_delay = int(data.get("slow_mode_delay", 0))
            data_class.slow_mode_delay_expires_in = data.get(
                "slow_mode_delay_expires_in", 0.0
            )
            data_class.can_enable_paid_messages = data.get(
                "can_enable_paid_messages", False
            )
            data_class.can_enable_paid_reaction = data.get(
                "can_enable_paid_reaction", False
            )
            data_class.can_get_members = data.get("can_get_members", False)
            data_class.has_hidden_members = data.get("has_hidden_members", False)
            data_class.can_hide_members = data.get("can_hide_members", False)
            data_class.can_set_sticker_set = data.get("can_set_sticker_set", False)
            data_class.can_set_location = data.get("can_set_location", False)
            data_class.can_get_statistics = data.get("can_get_statistics", False)
            data_class.can_get_revenue_statistics = data.get(
                "can_get_revenue_statistics", False
            )
            data_class.can_get_star_revenue_statistics = data.get(
                "can_get_star_revenue_statistics", False
            )
            data_class.can_send_gift = data.get("can_send_gift", False)
            data_class.can_toggle_aggressive_anti_spam = data.get(
                "can_toggle_aggressive_anti_spam", False
            )
            data_class.is_all_history_available = data.get(
                "is_all_history_available", False
            )
            data_class.can_have_sponsored_messages = data.get(
                "can_have_sponsored_messages", False
            )
            data_class.has_aggressive_anti_spam_enabled = data.get(
                "has_aggressive_anti_spam_enabled", False
            )
            data_class.has_paid_media_allowed = data.get(
                "has_paid_media_allowed", False
            )
            data_class.has_pinned_stories = data.get("has_pinned_stories", False)
            data_class.gift_count = int(data.get("gift_count", 0))
            data_class.my_boost_count = int(data.get("my_boost_count", 0))
            data_class.unrestrict_boost_count = int(
                data.get("unrestrict_boost_count", 0)
            )
            data_class.sticker_set_id = int(data.get("sticker_set_id", 0))
            data_class.custom_emoji_sticker_set_id = int(
                data.get("custom_emoji_sticker_set_id", 0)
            )
            data_class.location = data.get("location", None)
            data_class.invite_link = data.get("invite_link", None)
            data_class.bot_commands = data.get("bot_commands", None)
            data_class.bot_verification = data.get("bot_verification", None)
            data_class.upgraded_from_basic_group_id = int(
                data.get("upgraded_from_basic_group_id", 0)
            )
            data_class.upgraded_from_max_message_id = int(
                data.get("upgraded_from_max_message_id", 0)
            )

        return data_class


class SecretChatStatePending(TlObject, SecretChatState):
    r"""The secret chat is not yet created; waiting for the other user to get online"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["secretChatStatePending"]:
        return "secretChatStatePending"

    def getClass(self) -> Literal["SecretChatState"]:
        return "SecretChatState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SecretChatStatePending", None]:
        if data:
            data_class = cls()

        return data_class


class SecretChatStateReady(TlObject, SecretChatState):
    r"""The secret chat is ready to use"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["secretChatStateReady"]:
        return "secretChatStateReady"

    def getClass(self) -> Literal["SecretChatState"]:
        return "SecretChatState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SecretChatStateReady", None]:
        if data:
            data_class = cls()

        return data_class


class SecretChatStateClosed(TlObject, SecretChatState):
    r"""The secret chat is closed"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["secretChatStateClosed"]:
        return "secretChatStateClosed"

    def getClass(self) -> Literal["SecretChatState"]:
        return "SecretChatState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SecretChatStateClosed", None]:
        if data:
            data_class = cls()

        return data_class


class SecretChat(TlObject):
    r"""Represents a secret chat

    Parameters:
        id (:class:`int`):
            Secret chat identifier

        user_id (:class:`int`):
            Identifier of the chat partner

        state (:class:`"types.SecretChatState"`):
            State of the secret chat

        is_outbound (:class:`bool`):
            True, if the chat was created by the current user; false otherwise

        key_hash (:class:`bytes`):
            Hash of the currently used key for comparison with the hash of the chat partner's key\. This is a string of 36 little\-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9\. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom\. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2\-digit hex numbers

        layer (:class:`int`):
            Secret chat layer; determines features supported by the chat partner's application\. Nested text entities and underline and strikethrough entities are supported if the layer \>\= 101, files bigger than 2000MB are supported if the layer \>\= 143, spoiler and custom emoji text entities are supported if the layer \>\= 144

    """

    def __init__(
        self,
        id: int = 0,
        user_id: int = 0,
        state: SecretChatState = None,
        is_outbound: bool = False,
        key_hash: bytes = b"",
        layer: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Secret chat identifier"""
        self.user_id: int = int(user_id)
        r"""Identifier of the chat partner"""
        self.state: Union[
            SecretChatStatePending, SecretChatStateReady, SecretChatStateClosed, None
        ] = state
        r"""State of the secret chat"""
        self.is_outbound: bool = bool(is_outbound)
        r"""True, if the chat was created by the current user; false otherwise"""
        self.key_hash: Union[bytes, None] = key_hash
        r"""Hash of the currently used key for comparison with the hash of the chat partner's key\. This is a string of 36 little\-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9\. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom\. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2\-digit hex numbers"""
        self.layer: int = int(layer)
        r"""Secret chat layer; determines features supported by the chat partner's application\. Nested text entities and underline and strikethrough entities are supported if the layer \>\= 101, files bigger than 2000MB are supported if the layer \>\= 143, spoiler and custom emoji text entities are supported if the layer \>\= 144"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["secretChat"]:
        return "secretChat"

    def getClass(self) -> Literal["SecretChat"]:
        return "SecretChat"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "user_id": self.user_id,
            "state": self.state,
            "is_outbound": self.is_outbound,
            "key_hash": self.key_hash,
            "layer": self.layer,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SecretChat", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.user_id = int(data.get("user_id", 0))
            data_class.state = data.get("state", None)
            data_class.is_outbound = data.get("is_outbound", False)
            data_class.key_hash = b64decode(data.get("key_hash", b""))
            data_class.layer = int(data.get("layer", 0))

        return data_class


class MessageSenderUser(TlObject, MessageSender):
    r"""The message was sent by a known user

    Parameters:
        user_id (:class:`int`):
            Identifier of the user that sent the message

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user that sent the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSenderUser"]:
        return "messageSenderUser"

    def getClass(self) -> Literal["MessageSender"]:
        return "MessageSender"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSenderUser", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class MessageSenderChat(TlObject, MessageSender):
    r"""The message was sent on behalf of a chat

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat that sent the message

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat that sent the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSenderChat"]:
        return "messageSenderChat"

    def getClass(self) -> Literal["MessageSender"]:
        return "MessageSender"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSenderChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class MessageSenders(TlObject):
    r"""Represents a list of message senders

    Parameters:
        total_count (:class:`int`):
            Approximate total number of messages senders found

        senders (:class:`List["types.MessageSender"]`):
            List of message senders

    """

    def __init__(
        self, total_count: int = 0, senders: List[MessageSender] = None
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of messages senders found"""
        self.senders: List[MessageSender] = senders or []
        r"""List of message senders"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSenders"]:
        return "messageSenders"

    def getClass(self) -> Literal["MessageSenders"]:
        return "MessageSenders"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "senders": self.senders,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSenders", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.senders = data.get("senders", None)

        return data_class


class ChatMessageSender(TlObject):
    r"""Represents a message sender, which can be used to send messages in a chat

    Parameters:
        sender (:class:`"types.MessageSender"`):
            The message sender

        needs_premium (:class:`bool`):
            True, if Telegram Premium is needed to use the message sender

    """

    def __init__(
        self, sender: MessageSender = None, needs_premium: bool = False
    ) -> None:
        self.sender: Union[MessageSenderUser, MessageSenderChat, None] = sender
        r"""The message sender"""
        self.needs_premium: bool = bool(needs_premium)
        r"""True, if Telegram Premium is needed to use the message sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMessageSender"]:
        return "chatMessageSender"

    def getClass(self) -> Literal["ChatMessageSender"]:
        return "ChatMessageSender"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender": self.sender,
            "needs_premium": self.needs_premium,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMessageSender", None]:
        if data:
            data_class = cls()
            data_class.sender = data.get("sender", None)
            data_class.needs_premium = data.get("needs_premium", False)

        return data_class


class ChatMessageSenders(TlObject):
    r"""Represents a list of message senders, which can be used to send messages in a chat

    Parameters:
        senders (:class:`List["types.ChatMessageSender"]`):
            List of available message senders

    """

    def __init__(self, senders: List[ChatMessageSender] = None) -> None:
        self.senders: List[ChatMessageSender] = senders or []
        r"""List of available message senders"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatMessageSenders"]:
        return "chatMessageSenders"

    def getClass(self) -> Literal["ChatMessageSenders"]:
        return "ChatMessageSenders"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "senders": self.senders}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatMessageSenders", None]:
        if data:
            data_class = cls()
            data_class.senders = data.get("senders", None)

        return data_class


class MessageReadDateRead(TlObject, MessageReadDate):
    r"""Contains read date of the message

    Parameters:
        read_date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was read by the other user

    """

    def __init__(self, read_date: int = 0) -> None:
        self.read_date: int = int(read_date)
        r"""Point in time \(Unix timestamp\) when the message was read by the other user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReadDateRead"]:
        return "messageReadDateRead"

    def getClass(self) -> Literal["MessageReadDate"]:
        return "MessageReadDate"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "read_date": self.read_date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReadDateRead", None]:
        if data:
            data_class = cls()
            data_class.read_date = int(data.get("read_date", 0))

        return data_class


class MessageReadDateUnread(TlObject, MessageReadDate):
    r"""The message is unread yet"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReadDateUnread"]:
        return "messageReadDateUnread"

    def getClass(self) -> Literal["MessageReadDate"]:
        return "MessageReadDate"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReadDateUnread", None]:
        if data:
            data_class = cls()

        return data_class


class MessageReadDateTooOld(TlObject, MessageReadDate):
    r"""The message is too old to get read date"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReadDateTooOld"]:
        return "messageReadDateTooOld"

    def getClass(self) -> Literal["MessageReadDate"]:
        return "MessageReadDate"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReadDateTooOld", None]:
        if data:
            data_class = cls()

        return data_class


class MessageReadDateUserPrivacyRestricted(TlObject, MessageReadDate):
    r"""The read date is unknown due to privacy settings of the other user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReadDateUserPrivacyRestricted"]:
        return "messageReadDateUserPrivacyRestricted"

    def getClass(self) -> Literal["MessageReadDate"]:
        return "MessageReadDate"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["MessageReadDateUserPrivacyRestricted", None]:
        if data:
            data_class = cls()

        return data_class


class MessageReadDateMyPrivacyRestricted(TlObject, MessageReadDate):
    r"""The read date is unknown due to privacy settings of the current user, but will be known if the user subscribes to Telegram Premium"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReadDateMyPrivacyRestricted"]:
        return "messageReadDateMyPrivacyRestricted"

    def getClass(self) -> Literal["MessageReadDate"]:
        return "MessageReadDate"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReadDateMyPrivacyRestricted", None]:
        if data:
            data_class = cls()

        return data_class


class MessageViewer(TlObject):
    r"""Represents a viewer of a message

    Parameters:
        user_id (:class:`int`):
            User identifier of the viewer

        view_date (:class:`int`):
            Approximate point in time \(Unix timestamp\) when the message was viewed

    """

    def __init__(self, user_id: int = 0, view_date: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier of the viewer"""
        self.view_date: int = int(view_date)
        r"""Approximate point in time \(Unix timestamp\) when the message was viewed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageViewer"]:
        return "messageViewer"

    def getClass(self) -> Literal["MessageViewer"]:
        return "MessageViewer"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "view_date": self.view_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageViewer", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.view_date = int(data.get("view_date", 0))

        return data_class


class MessageViewers(TlObject):
    r"""Represents a list of message viewers

    Parameters:
        viewers (:class:`List["types.MessageViewer"]`):
            List of message viewers

    """

    def __init__(self, viewers: List[MessageViewer] = None) -> None:
        self.viewers: List[MessageViewer] = viewers or []
        r"""List of message viewers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageViewers"]:
        return "messageViewers"

    def getClass(self) -> Literal["MessageViewers"]:
        return "MessageViewers"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "viewers": self.viewers}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageViewers", None]:
        if data:
            data_class = cls()
            data_class.viewers = data.get("viewers", None)

        return data_class


class MessageOriginUser(TlObject, MessageOrigin):
    r"""The message was originally sent by a known user

    Parameters:
        sender_user_id (:class:`int`):
            Identifier of the user that originally sent the message

    """

    def __init__(self, sender_user_id: int = 0) -> None:
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user that originally sent the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageOriginUser"]:
        return "messageOriginUser"

    def getClass(self) -> Literal["MessageOrigin"]:
        return "MessageOrigin"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sender_user_id": self.sender_user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageOriginUser", None]:
        if data:
            data_class = cls()
            data_class.sender_user_id = int(data.get("sender_user_id", 0))

        return data_class


class MessageOriginHiddenUser(TlObject, MessageOrigin):
    r"""The message was originally sent by a user, which is hidden by their privacy settings

    Parameters:
        sender_name (:class:`str`):
            Name of the sender

    """

    def __init__(self, sender_name: str = "") -> None:
        self.sender_name: Union[str, None] = sender_name
        r"""Name of the sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageOriginHiddenUser"]:
        return "messageOriginHiddenUser"

    def getClass(self) -> Literal["MessageOrigin"]:
        return "MessageOrigin"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sender_name": self.sender_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageOriginHiddenUser", None]:
        if data:
            data_class = cls()
            data_class.sender_name = data.get("sender_name", "")

        return data_class


class MessageOriginChat(TlObject, MessageOrigin):
    r"""The message was originally sent on behalf of a chat

    Parameters:
        sender_chat_id (:class:`int`):
            Identifier of the chat that originally sent the message

        author_signature (:class:`str`):
            For messages originally sent by an anonymous chat administrator, original message author signature

    """

    def __init__(self, sender_chat_id: int = 0, author_signature: str = "") -> None:
        self.sender_chat_id: int = int(sender_chat_id)
        r"""Identifier of the chat that originally sent the message"""
        self.author_signature: Union[str, None] = author_signature
        r"""For messages originally sent by an anonymous chat administrator, original message author signature"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageOriginChat"]:
        return "messageOriginChat"

    def getClass(self) -> Literal["MessageOrigin"]:
        return "MessageOrigin"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender_chat_id": self.sender_chat_id,
            "author_signature": self.author_signature,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageOriginChat", None]:
        if data:
            data_class = cls()
            data_class.sender_chat_id = int(data.get("sender_chat_id", 0))
            data_class.author_signature = data.get("author_signature", "")

        return data_class


class MessageOriginChannel(TlObject, MessageOrigin):
    r"""The message was originally a post in a channel

    Parameters:
        chat_id (:class:`int`):
            Identifier of the channel chat to which the message was originally sent

        message_id (:class:`int`):
            Message identifier of the original message

        author_signature (:class:`str`):
            Original post author signature

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, author_signature: str = ""
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the channel chat to which the message was originally sent"""
        self.message_id: int = int(message_id)
        r"""Message identifier of the original message"""
        self.author_signature: Union[str, None] = author_signature
        r"""Original post author signature"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageOriginChannel"]:
        return "messageOriginChannel"

    def getClass(self) -> Literal["MessageOrigin"]:
        return "MessageOrigin"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "author_signature": self.author_signature,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageOriginChannel", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.author_signature = data.get("author_signature", "")

        return data_class


class ForwardSource(TlObject):
    r"""Contains information about the last message from which a new message was forwarded last time

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat to which the message that was forwarded belonged; may be 0 if unknown

        message_id (:class:`int`):
            Identifier of the message; may be 0 if unknown

        sender_id (:class:`"types.MessageSender"`):
            Identifier of the sender of the message; may be null if unknown or the new message was forwarded not to Saved Messages

        sender_name (:class:`str`):
            Name of the sender of the message if the sender is hidden by their privacy settings

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the message is sent; 0 if unknown

        is_outgoing (:class:`bool`):
            True, if the message that was forwarded is outgoing; always false if sender is unknown

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_id: int = 0,
        sender_id: MessageSender = None,
        sender_name: str = "",
        date: int = 0,
        is_outgoing: bool = False,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat to which the message that was forwarded belonged; may be 0 if unknown"""
        self.message_id: int = int(message_id)
        r"""Identifier of the message; may be 0 if unknown"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the sender of the message; may be null if unknown or the new message was forwarded not to Saved Messages"""
        self.sender_name: Union[str, None] = sender_name
        r"""Name of the sender of the message if the sender is hidden by their privacy settings"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the message is sent; 0 if unknown"""
        self.is_outgoing: bool = bool(is_outgoing)
        r"""True, if the message that was forwarded is outgoing; always false if sender is unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["forwardSource"]:
        return "forwardSource"

    def getClass(self) -> Literal["ForwardSource"]:
        return "ForwardSource"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "sender_id": self.sender_id,
            "sender_name": self.sender_name,
            "date": self.date,
            "is_outgoing": self.is_outgoing,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ForwardSource", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.sender_id = data.get("sender_id", None)
            data_class.sender_name = data.get("sender_name", "")
            data_class.date = int(data.get("date", 0))
            data_class.is_outgoing = data.get("is_outgoing", False)

        return data_class


class ReactionTypeEmoji(TlObject, ReactionType):
    r"""A reaction with an emoji

    Parameters:
        emoji (:class:`str`):
            Text representation of the reaction

    """

    def __init__(self, emoji: str = "") -> None:
        self.emoji: Union[str, None] = emoji
        r"""Text representation of the reaction"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionTypeEmoji"]:
        return "reactionTypeEmoji"

    def getClass(self) -> Literal["ReactionType"]:
        return "ReactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emoji": self.emoji}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionTypeEmoji", None]:
        if data:
            data_class = cls()
            data_class.emoji = data.get("emoji", "")

        return data_class


class ReactionTypeCustomEmoji(TlObject, ReactionType):
    r"""A reaction with a custom emoji

    Parameters:
        custom_emoji_id (:class:`int`):
            Unique identifier of the custom emoji

    """

    def __init__(self, custom_emoji_id: int = 0) -> None:
        self.custom_emoji_id: int = int(custom_emoji_id)
        r"""Unique identifier of the custom emoji"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionTypeCustomEmoji"]:
        return "reactionTypeCustomEmoji"

    def getClass(self) -> Literal["ReactionType"]:
        return "ReactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "custom_emoji_id": self.custom_emoji_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionTypeCustomEmoji", None]:
        if data:
            data_class = cls()
            data_class.custom_emoji_id = int(data.get("custom_emoji_id", 0))

        return data_class


class ReactionTypePaid(TlObject, ReactionType):
    r"""The paid reaction in a channel chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionTypePaid"]:
        return "reactionTypePaid"

    def getClass(self) -> Literal["ReactionType"]:
        return "ReactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionTypePaid", None]:
        if data:
            data_class = cls()

        return data_class


class PaidReactionTypeRegular(TlObject, PaidReactionType):
    r"""A paid reaction on behalf of the current user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidReactionTypeRegular"]:
        return "paidReactionTypeRegular"

    def getClass(self) -> Literal["PaidReactionType"]:
        return "PaidReactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidReactionTypeRegular", None]:
        if data:
            data_class = cls()

        return data_class


class PaidReactionTypeAnonymous(TlObject, PaidReactionType):
    r"""An anonymous paid reaction"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidReactionTypeAnonymous"]:
        return "paidReactionTypeAnonymous"

    def getClass(self) -> Literal["PaidReactionType"]:
        return "PaidReactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidReactionTypeAnonymous", None]:
        if data:
            data_class = cls()

        return data_class


class PaidReactionTypeChat(TlObject, PaidReactionType):
    r"""A paid reaction on behalf of an owned chat

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidReactionTypeChat"]:
        return "paidReactionTypeChat"

    def getClass(self) -> Literal["PaidReactionType"]:
        return "PaidReactionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidReactionTypeChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class PaidReactor(TlObject):
    r"""Contains information about a user that added paid reactions

    Parameters:
        sender_id (:class:`"types.MessageSender"`):
            Identifier of the user or chat that added the reactions; may be null for anonymous reactors that aren't the current user

        star_count (:class:`int`):
            Number of Telegram Stars added

        is_top (:class:`bool`):
            True, if the reactor is one of the most active reactors; may be false if the reactor is the current user

        is_me (:class:`bool`):
            True, if the paid reaction was added by the current user

        is_anonymous (:class:`bool`):
            True, if the reactor is anonymous

    """

    def __init__(
        self,
        sender_id: MessageSender = None,
        star_count: int = 0,
        is_top: bool = False,
        is_me: bool = False,
        is_anonymous: bool = False,
    ) -> None:
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the user or chat that added the reactions; may be null for anonymous reactors that aren't the current user"""
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars added"""
        self.is_top: bool = bool(is_top)
        r"""True, if the reactor is one of the most active reactors; may be false if the reactor is the current user"""
        self.is_me: bool = bool(is_me)
        r"""True, if the paid reaction was added by the current user"""
        self.is_anonymous: bool = bool(is_anonymous)
        r"""True, if the reactor is anonymous"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidReactor"]:
        return "paidReactor"

    def getClass(self) -> Literal["PaidReactor"]:
        return "PaidReactor"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender_id": self.sender_id,
            "star_count": self.star_count,
            "is_top": self.is_top,
            "is_me": self.is_me,
            "is_anonymous": self.is_anonymous,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidReactor", None]:
        if data:
            data_class = cls()
            data_class.sender_id = data.get("sender_id", None)
            data_class.star_count = int(data.get("star_count", 0))
            data_class.is_top = data.get("is_top", False)
            data_class.is_me = data.get("is_me", False)
            data_class.is_anonymous = data.get("is_anonymous", False)

        return data_class


class MessageForwardInfo(TlObject):
    r"""Contains information about a forwarded message

    Parameters:
        origin (:class:`"types.MessageOrigin"`):
            Origin of the forwarded message

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was originally sent

        source (:class:`"types.ForwardSource"`):
            For messages forwarded to the chat with the current user \(Saved Messages\), to the Replies bot chat, or to the channel's discussion group, information about the source message from which the message was forwarded last time; may be null for other forwards or if unknown

        public_service_announcement_type (:class:`str`):
            The type of public service announcement for the forwarded message

    """

    def __init__(
        self,
        origin: MessageOrigin = None,
        date: int = 0,
        source: ForwardSource = None,
        public_service_announcement_type: str = "",
    ) -> None:
        self.origin: Union[
            MessageOriginUser,
            MessageOriginHiddenUser,
            MessageOriginChat,
            MessageOriginChannel,
            None,
        ] = origin
        r"""Origin of the forwarded message"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the message was originally sent"""
        self.source: Union[ForwardSource, None] = source
        r"""For messages forwarded to the chat with the current user \(Saved Messages\), to the Replies bot chat, or to the channel's discussion group, information about the source message from which the message was forwarded last time; may be null for other forwards or if unknown"""
        self.public_service_announcement_type: Union[str, None] = (
            public_service_announcement_type
        )
        r"""The type of public service announcement for the forwarded message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageForwardInfo"]:
        return "messageForwardInfo"

    def getClass(self) -> Literal["MessageForwardInfo"]:
        return "MessageForwardInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "origin": self.origin,
            "date": self.date,
            "source": self.source,
            "public_service_announcement_type": self.public_service_announcement_type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageForwardInfo", None]:
        if data:
            data_class = cls()
            data_class.origin = data.get("origin", None)
            data_class.date = int(data.get("date", 0))
            data_class.source = data.get("source", None)
            data_class.public_service_announcement_type = data.get(
                "public_service_announcement_type", ""
            )

        return data_class


class MessageImportInfo(TlObject):
    r"""Contains information about a message created with importMessages

    Parameters:
        sender_name (:class:`str`):
            Name of the original sender

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was originally sent

    """

    def __init__(self, sender_name: str = "", date: int = 0) -> None:
        self.sender_name: Union[str, None] = sender_name
        r"""Name of the original sender"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the message was originally sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageImportInfo"]:
        return "messageImportInfo"

    def getClass(self) -> Literal["MessageImportInfo"]:
        return "MessageImportInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender_name": self.sender_name,
            "date": self.date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageImportInfo", None]:
        if data:
            data_class = cls()
            data_class.sender_name = data.get("sender_name", "")
            data_class.date = int(data.get("date", 0))

        return data_class


class MessageReplyInfo(TlObject):
    r"""Contains information about replies to a message

    Parameters:
        reply_count (:class:`int`):
            Number of times the message was directly or indirectly replied

        recent_replier_ids (:class:`List["types.MessageSender"]`):
            Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup\. The users and chats are expected to be inaccessible: only their photo and name will be available

        last_read_inbox_message_id (:class:`int`):
            Identifier of the last read incoming reply to the message

        last_read_outbox_message_id (:class:`int`):
            Identifier of the last read outgoing reply to the message

        last_message_id (:class:`int`):
            Identifier of the last reply to the message

    """

    def __init__(
        self,
        reply_count: int = 0,
        recent_replier_ids: List[MessageSender] = None,
        last_read_inbox_message_id: int = 0,
        last_read_outbox_message_id: int = 0,
        last_message_id: int = 0,
    ) -> None:
        self.reply_count: int = int(reply_count)
        r"""Number of times the message was directly or indirectly replied"""
        self.recent_replier_ids: List[MessageSender] = recent_replier_ids or []
        r"""Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup\. The users and chats are expected to be inaccessible: only their photo and name will be available"""
        self.last_read_inbox_message_id: int = int(last_read_inbox_message_id)
        r"""Identifier of the last read incoming reply to the message"""
        self.last_read_outbox_message_id: int = int(last_read_outbox_message_id)
        r"""Identifier of the last read outgoing reply to the message"""
        self.last_message_id: int = int(last_message_id)
        r"""Identifier of the last reply to the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReplyInfo"]:
        return "messageReplyInfo"

    def getClass(self) -> Literal["MessageReplyInfo"]:
        return "MessageReplyInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reply_count": self.reply_count,
            "recent_replier_ids": self.recent_replier_ids,
            "last_read_inbox_message_id": self.last_read_inbox_message_id,
            "last_read_outbox_message_id": self.last_read_outbox_message_id,
            "last_message_id": self.last_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReplyInfo", None]:
        if data:
            data_class = cls()
            data_class.reply_count = int(data.get("reply_count", 0))
            data_class.recent_replier_ids = data.get("recent_replier_ids", None)
            data_class.last_read_inbox_message_id = int(
                data.get("last_read_inbox_message_id", 0)
            )
            data_class.last_read_outbox_message_id = int(
                data.get("last_read_outbox_message_id", 0)
            )
            data_class.last_message_id = int(data.get("last_message_id", 0))

        return data_class


class MessageReaction(TlObject):
    r"""Contains information about a reaction to a message

    Parameters:
        type (:class:`"types.ReactionType"`):
            Type of the reaction

        total_count (:class:`int`):
            Number of times the reaction was added

        is_chosen (:class:`bool`):
            True, if the reaction is chosen by the current user

        used_sender_id (:class:`"types.MessageSender"`):
            Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen

        recent_sender_ids (:class:`List["types.MessageSender"]`):
            Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats

    """

    def __init__(
        self,
        type: ReactionType = None,
        total_count: int = 0,
        is_chosen: bool = False,
        used_sender_id: MessageSender = None,
        recent_sender_ids: List[MessageSender] = None,
    ) -> None:
        self.type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = type
        r"""Type of the reaction"""
        self.total_count: int = int(total_count)
        r"""Number of times the reaction was added"""
        self.is_chosen: bool = bool(is_chosen)
        r"""True, if the reaction is chosen by the current user"""
        self.used_sender_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            used_sender_id
        )
        r"""Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen"""
        self.recent_sender_ids: List[MessageSender] = recent_sender_ids or []
        r"""Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReaction"]:
        return "messageReaction"

    def getClass(self) -> Literal["MessageReaction"]:
        return "MessageReaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "total_count": self.total_count,
            "is_chosen": self.is_chosen,
            "used_sender_id": self.used_sender_id,
            "recent_sender_ids": self.recent_sender_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReaction", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.total_count = int(data.get("total_count", 0))
            data_class.is_chosen = data.get("is_chosen", False)
            data_class.used_sender_id = data.get("used_sender_id", None)
            data_class.recent_sender_ids = data.get("recent_sender_ids", None)

        return data_class


class MessageReactions(TlObject):
    r"""Contains a list of reactions added to a message

    Parameters:
        reactions (:class:`List["types.MessageReaction"]`):
            List of added reactions

        are_tags (:class:`bool`):
            True, if the reactions are tags and Telegram Premium users can filter messages by them

        paid_reactors (:class:`List["types.PaidReactor"]`):
            Information about top users that added the paid reaction

        can_get_added_reactions (:class:`bool`):
            True, if the list of added reactions is available using getMessageAddedReactions

    """

    def __init__(
        self,
        reactions: List[MessageReaction] = None,
        are_tags: bool = False,
        paid_reactors: List[PaidReactor] = None,
        can_get_added_reactions: bool = False,
    ) -> None:
        self.reactions: List[MessageReaction] = reactions or []
        r"""List of added reactions"""
        self.are_tags: bool = bool(are_tags)
        r"""True, if the reactions are tags and Telegram Premium users can filter messages by them"""
        self.paid_reactors: List[PaidReactor] = paid_reactors or []
        r"""Information about top users that added the paid reaction"""
        self.can_get_added_reactions: bool = bool(can_get_added_reactions)
        r"""True, if the list of added reactions is available using getMessageAddedReactions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReactions"]:
        return "messageReactions"

    def getClass(self) -> Literal["MessageReactions"]:
        return "MessageReactions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reactions": self.reactions,
            "are_tags": self.are_tags,
            "paid_reactors": self.paid_reactors,
            "can_get_added_reactions": self.can_get_added_reactions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReactions", None]:
        if data:
            data_class = cls()
            data_class.reactions = data.get("reactions", None)
            data_class.are_tags = data.get("are_tags", False)
            data_class.paid_reactors = data.get("paid_reactors", None)
            data_class.can_get_added_reactions = data.get(
                "can_get_added_reactions", False
            )

        return data_class


class MessageInteractionInfo(TlObject):
    r"""Contains information about interactions with a message

    Parameters:
        view_count (:class:`int`):
            Number of times the message was viewed

        forward_count (:class:`int`):
            Number of times the message was forwarded

        reply_info (:class:`"types.MessageReplyInfo"`):
            Information about direct or indirect replies to the message; may be null\. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself

        reactions (:class:`"types.MessageReactions"`):
            The list of reactions or tags added to the message; may be null

    """

    def __init__(
        self,
        view_count: int = 0,
        forward_count: int = 0,
        reply_info: MessageReplyInfo = None,
        reactions: MessageReactions = None,
    ) -> None:
        self.view_count: int = int(view_count)
        r"""Number of times the message was viewed"""
        self.forward_count: int = int(forward_count)
        r"""Number of times the message was forwarded"""
        self.reply_info: Union[MessageReplyInfo, None] = reply_info
        r"""Information about direct or indirect replies to the message; may be null\. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself"""
        self.reactions: Union[MessageReactions, None] = reactions
        r"""The list of reactions or tags added to the message; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageInteractionInfo"]:
        return "messageInteractionInfo"

    def getClass(self) -> Literal["MessageInteractionInfo"]:
        return "MessageInteractionInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "view_count": self.view_count,
            "forward_count": self.forward_count,
            "reply_info": self.reply_info,
            "reactions": self.reactions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageInteractionInfo", None]:
        if data:
            data_class = cls()
            data_class.view_count = int(data.get("view_count", 0))
            data_class.forward_count = int(data.get("forward_count", 0))
            data_class.reply_info = data.get("reply_info", None)
            data_class.reactions = data.get("reactions", None)

        return data_class


class UnreadReaction(TlObject):
    r"""Contains information about an unread reaction to a message

    Parameters:
        type (:class:`"types.ReactionType"`):
            Type of the reaction

        sender_id (:class:`"types.MessageSender"`):
            Identifier of the sender, added the reaction

        is_big (:class:`bool`):
            True, if the reaction was added with a big animation

    """

    def __init__(
        self,
        type: ReactionType = None,
        sender_id: MessageSender = None,
        is_big: bool = False,
    ) -> None:
        self.type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = type
        r"""Type of the reaction"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the sender, added the reaction"""
        self.is_big: bool = bool(is_big)
        r"""True, if the reaction was added with a big animation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["unreadReaction"]:
        return "unreadReaction"

    def getClass(self) -> Literal["UnreadReaction"]:
        return "UnreadReaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "sender_id": self.sender_id,
            "is_big": self.is_big,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UnreadReaction", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.sender_id = data.get("sender_id", None)
            data_class.is_big = data.get("is_big", False)

        return data_class


class MessageEffectTypeEmojiReaction(TlObject, MessageEffectType):
    r"""An effect from an emoji reaction

    Parameters:
        select_animation (:class:`"types.Sticker"`):
            Select animation for the effect in TGS format

        effect_animation (:class:`"types.Sticker"`):
            Effect animation for the effect in TGS format

    """

    def __init__(
        self, select_animation: Sticker = None, effect_animation: Sticker = None
    ) -> None:
        self.select_animation: Union[Sticker, None] = select_animation
        r"""Select animation for the effect in TGS format"""
        self.effect_animation: Union[Sticker, None] = effect_animation
        r"""Effect animation for the effect in TGS format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageEffectTypeEmojiReaction"]:
        return "messageEffectTypeEmojiReaction"

    def getClass(self) -> Literal["MessageEffectType"]:
        return "MessageEffectType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "select_animation": self.select_animation,
            "effect_animation": self.effect_animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageEffectTypeEmojiReaction", None]:
        if data:
            data_class = cls()
            data_class.select_animation = data.get("select_animation", None)
            data_class.effect_animation = data.get("effect_animation", None)

        return data_class


class MessageEffectTypePremiumSticker(TlObject, MessageEffectType):
    r"""An effect from a premium sticker

    Parameters:
        sticker (:class:`"types.Sticker"`):
            The premium sticker\. The effect can be found at sticker\.full\_type\.premium\_animation

    """

    def __init__(self, sticker: Sticker = None) -> None:
        self.sticker: Union[Sticker, None] = sticker
        r"""The premium sticker\. The effect can be found at sticker\.full\_type\.premium\_animation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageEffectTypePremiumSticker"]:
        return "messageEffectTypePremiumSticker"

    def getClass(self) -> Literal["MessageEffectType"]:
        return "MessageEffectType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sticker": self.sticker}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageEffectTypePremiumSticker", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)

        return data_class


class MessageEffect(TlObject):
    r"""Contains information about an effect added to a message

    Parameters:
        id (:class:`int`):
            Unique identifier of the effect

        static_icon (:class:`"types.Sticker"`):
            Static icon for the effect in WEBP format; may be null if none

        emoji (:class:`str`):
            Emoji corresponding to the effect that can be used if static icon isn't available

        is_premium (:class:`bool`):
            True, if Telegram Premium subscription is required to use the effect

        type (:class:`"types.MessageEffectType"`):
            Type of the effect

    """

    def __init__(
        self,
        id: int = 0,
        static_icon: Sticker = None,
        emoji: str = "",
        is_premium: bool = False,
        type: MessageEffectType = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the effect"""
        self.static_icon: Union[Sticker, None] = static_icon
        r"""Static icon for the effect in WEBP format; may be null if none"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji corresponding to the effect that can be used if static icon isn't available"""
        self.is_premium: bool = bool(is_premium)
        r"""True, if Telegram Premium subscription is required to use the effect"""
        self.type: Union[
            MessageEffectTypeEmojiReaction, MessageEffectTypePremiumSticker, None
        ] = type
        r"""Type of the effect"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageEffect"]:
        return "messageEffect"

    def getClass(self) -> Literal["MessageEffect"]:
        return "MessageEffect"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "static_icon": self.static_icon,
            "emoji": self.emoji,
            "is_premium": self.is_premium,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageEffect", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.static_icon = data.get("static_icon", None)
            data_class.emoji = data.get("emoji", "")
            data_class.is_premium = data.get("is_premium", False)
            data_class.type = data.get("type", None)

        return data_class


class MessageSendingStatePending(TlObject, MessageSendingState):
    r"""The message is being sent now, but has not yet been delivered to the server

    Parameters:
        sending_id (:class:`int`):
            Non\-persistent message sending identifier, specified by the application

    """

    def __init__(self, sending_id: int = 0) -> None:
        self.sending_id: int = int(sending_id)
        r"""Non\-persistent message sending identifier, specified by the application"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSendingStatePending"]:
        return "messageSendingStatePending"

    def getClass(self) -> Literal["MessageSendingState"]:
        return "MessageSendingState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sending_id": self.sending_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSendingStatePending", None]:
        if data:
            data_class = cls()
            data_class.sending_id = int(data.get("sending_id", 0))

        return data_class


class MessageSendingStateFailed(TlObject, MessageSendingState):
    r"""The message failed to be sent

    Parameters:
        error (:class:`"types.Error"`):
            The cause of the message sending failure

        can_retry (:class:`bool`):
            True, if the message can be re\-sent using resendMessages or readdQuickReplyShortcutMessages

        need_another_sender (:class:`bool`):
            True, if the message can be re\-sent only on behalf of a different sender

        need_another_reply_quote (:class:`bool`):
            True, if the message can be re\-sent only if another quote is chosen in the message that is replied by the given message

        need_drop_reply (:class:`bool`):
            True, if the message can be re\-sent only if the message to be replied is removed\. This will be done automatically by resendMessages

        required_paid_message_star_count (:class:`int`):
            The number of Telegram Stars that must be paid to send the message; 0 if the current amount is correct

        retry_after (:class:`float`):
            Time left before the message can be re\-sent, in seconds\. No update is sent when this field changes

    """

    def __init__(
        self,
        error: Error = None,
        can_retry: bool = False,
        need_another_sender: bool = False,
        need_another_reply_quote: bool = False,
        need_drop_reply: bool = False,
        required_paid_message_star_count: int = 0,
        retry_after: float = 0.0,
    ) -> None:
        self.error: Union[Error, None] = error
        r"""The cause of the message sending failure"""
        self.can_retry: bool = bool(can_retry)
        r"""True, if the message can be re\-sent using resendMessages or readdQuickReplyShortcutMessages"""
        self.need_another_sender: bool = bool(need_another_sender)
        r"""True, if the message can be re\-sent only on behalf of a different sender"""
        self.need_another_reply_quote: bool = bool(need_another_reply_quote)
        r"""True, if the message can be re\-sent only if another quote is chosen in the message that is replied by the given message"""
        self.need_drop_reply: bool = bool(need_drop_reply)
        r"""True, if the message can be re\-sent only if the message to be replied is removed\. This will be done automatically by resendMessages"""
        self.required_paid_message_star_count: int = int(
            required_paid_message_star_count
        )
        r"""The number of Telegram Stars that must be paid to send the message; 0 if the current amount is correct"""
        self.retry_after: float = float(retry_after)
        r"""Time left before the message can be re\-sent, in seconds\. No update is sent when this field changes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSendingStateFailed"]:
        return "messageSendingStateFailed"

    def getClass(self) -> Literal["MessageSendingState"]:
        return "MessageSendingState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "error": self.error,
            "can_retry": self.can_retry,
            "need_another_sender": self.need_another_sender,
            "need_another_reply_quote": self.need_another_reply_quote,
            "need_drop_reply": self.need_drop_reply,
            "required_paid_message_star_count": self.required_paid_message_star_count,
            "retry_after": self.retry_after,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSendingStateFailed", None]:
        if data:
            data_class = cls()
            data_class.error = data.get("error", None)
            data_class.can_retry = data.get("can_retry", False)
            data_class.need_another_sender = data.get("need_another_sender", False)
            data_class.need_another_reply_quote = data.get(
                "need_another_reply_quote", False
            )
            data_class.need_drop_reply = data.get("need_drop_reply", False)
            data_class.required_paid_message_star_count = int(
                data.get("required_paid_message_star_count", 0)
            )
            data_class.retry_after = data.get("retry_after", 0.0)

        return data_class


class TextQuote(TlObject):
    r"""Describes manually or automatically chosen quote from another message

    Parameters:
        text (:class:`"types.FormattedText"`):
            Text of the quote\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text

        position (:class:`int`):
            Approximate quote position in the original message in UTF\-16 code units as specified by the message sender

        is_manual (:class:`bool`):
            True, if the quote was manually chosen by the message sender

    """

    def __init__(
        self, text: FormattedText = None, position: int = 0, is_manual: bool = False
    ) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Text of the quote\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text"""
        self.position: int = int(position)
        r"""Approximate quote position in the original message in UTF\-16 code units as specified by the message sender"""
        self.is_manual: bool = bool(is_manual)
        r"""True, if the quote was manually chosen by the message sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textQuote"]:
        return "textQuote"

    def getClass(self) -> Literal["TextQuote"]:
        return "TextQuote"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "position": self.position,
            "is_manual": self.is_manual,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextQuote", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.position = int(data.get("position", 0))
            data_class.is_manual = data.get("is_manual", False)

        return data_class


class InputTextQuote(TlObject):
    r"""Describes manually chosen quote from another message

    Parameters:
        text (:class:`"types.FormattedText"`):
            Text of the quote; 0\-getOption\(\"message\_reply\_quote\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote

        position (:class:`int`):
            Quote position in the original message in UTF\-16 code units

    """

    def __init__(self, text: FormattedText = None, position: int = 0) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Text of the quote; 0\-getOption\(\"message\_reply\_quote\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote"""
        self.position: int = int(position)
        r"""Quote position in the original message in UTF\-16 code units"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputTextQuote"]:
        return "inputTextQuote"

    def getClass(self) -> Literal["InputTextQuote"]:
        return "InputTextQuote"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "position": self.position}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputTextQuote", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.position = int(data.get("position", 0))

        return data_class


class MessageReplyToMessage(TlObject, MessageReplyTo):
    r"""Describes a message replied by a given message

    Parameters:
        chat_id (:class:`int`):
            The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat

        message_id (:class:`int`):
            The identifier of the message; may be 0 if the replied message is in unknown chat

        quote (:class:`"types.TextQuote"`):
            Chosen quote from the replied message; may be null if none

        origin (:class:`"types.MessageOrigin"`):
            Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat

        origin_send_date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat

        content (:class:`"types.MessageContent"`):
            Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media\. Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageGiveaway, messageGiveawayWinners, messageInvoice, messageLocation, messagePaidMedia, messagePhoto, messagePoll, messageSticker, messageStory, messageText \(for link preview\), messageVenue, messageVideo, messageVideoNote, or messageVoiceNote

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_id: int = 0,
        quote: TextQuote = None,
        origin: MessageOrigin = None,
        origin_send_date: int = 0,
        content: MessageContent = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat"""
        self.message_id: int = int(message_id)
        r"""The identifier of the message; may be 0 if the replied message is in unknown chat"""
        self.quote: Union[TextQuote, None] = quote
        r"""Chosen quote from the replied message; may be null if none"""
        self.origin: Union[
            MessageOriginUser,
            MessageOriginHiddenUser,
            MessageOriginChat,
            MessageOriginChannel,
            None,
        ] = origin
        r"""Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat"""
        self.origin_send_date: int = int(origin_send_date)
        r"""Point in time \(Unix timestamp\) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat"""
        self.content: Union[
            MessageText,
            MessageAnimation,
            MessageAudio,
            MessageDocument,
            MessagePaidMedia,
            MessagePhoto,
            MessageSticker,
            MessageVideo,
            MessageVideoNote,
            MessageVoiceNote,
            MessageExpiredPhoto,
            MessageExpiredVideo,
            MessageExpiredVideoNote,
            MessageExpiredVoiceNote,
            MessageLocation,
            MessageVenue,
            MessageContact,
            MessageAnimatedEmoji,
            MessageDice,
            MessageGame,
            MessagePoll,
            MessageStory,
            MessageInvoice,
            MessageCall,
            MessageVideoChatScheduled,
            MessageVideoChatStarted,
            MessageVideoChatEnded,
            MessageInviteVideoChatParticipants,
            MessageBasicGroupChatCreate,
            MessageSupergroupChatCreate,
            MessageChatChangeTitle,
            MessageChatChangePhoto,
            MessageChatDeletePhoto,
            MessageChatAddMembers,
            MessageChatJoinByLink,
            MessageChatJoinByRequest,
            MessageChatDeleteMember,
            MessageChatUpgradeTo,
            MessageChatUpgradeFrom,
            MessagePinMessage,
            MessageScreenshotTaken,
            MessageChatSetBackground,
            MessageChatSetTheme,
            MessageChatSetMessageAutoDeleteTime,
            MessageChatBoost,
            MessageForumTopicCreated,
            MessageForumTopicEdited,
            MessageForumTopicIsClosedToggled,
            MessageForumTopicIsHiddenToggled,
            MessageSuggestProfilePhoto,
            MessageCustomServiceAction,
            MessageGameScore,
            MessagePaymentSuccessful,
            MessagePaymentSuccessfulBot,
            MessagePaymentRefunded,
            MessageGiftedPremium,
            MessagePremiumGiftCode,
            MessageGiveawayCreated,
            MessageGiveaway,
            MessageGiveawayCompleted,
            MessageGiveawayWinners,
            MessageGiftedStars,
            MessageGiveawayPrizeStars,
            MessageGift,
            MessageUpgradedGift,
            MessageRefundedUpgradedGift,
            MessagePaidMessagesRefunded,
            MessagePaidMessagePriceChanged,
            MessageContactRegistered,
            MessageUsersShared,
            MessageChatShared,
            MessageBotWriteAccessAllowed,
            MessageWebAppDataSent,
            MessageWebAppDataReceived,
            MessagePassportDataSent,
            MessagePassportDataReceived,
            MessageProximityAlertTriggered,
            MessageUnsupported,
            None,
        ] = content
        r"""Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media\. Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageGiveaway, messageGiveawayWinners, messageInvoice, messageLocation, messagePaidMedia, messagePhoto, messagePoll, messageSticker, messageStory, messageText \(for link preview\), messageVenue, messageVideo, messageVideoNote, or messageVoiceNote"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReplyToMessage"]:
        return "messageReplyToMessage"

    def getClass(self) -> Literal["MessageReplyTo"]:
        return "MessageReplyTo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "quote": self.quote,
            "origin": self.origin,
            "origin_send_date": self.origin_send_date,
            "content": self.content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReplyToMessage", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.quote = data.get("quote", None)
            data_class.origin = data.get("origin", None)
            data_class.origin_send_date = int(data.get("origin_send_date", 0))
            data_class.content = data.get("content", None)

        return data_class


class MessageReplyToStory(TlObject, MessageReplyTo):
    r"""Describes a story replied by a given message

    Parameters:
        story_sender_chat_id (:class:`int`):
            The identifier of the sender of the story

        story_id (:class:`int`):
            The identifier of the story

    """

    def __init__(self, story_sender_chat_id: int = 0, story_id: int = 0) -> None:
        self.story_sender_chat_id: int = int(story_sender_chat_id)
        r"""The identifier of the sender of the story"""
        self.story_id: int = int(story_id)
        r"""The identifier of the story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageReplyToStory"]:
        return "messageReplyToStory"

    def getClass(self) -> Literal["MessageReplyTo"]:
        return "MessageReplyTo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_sender_chat_id": self.story_sender_chat_id,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageReplyToStory", None]:
        if data:
            data_class = cls()
            data_class.story_sender_chat_id = int(data.get("story_sender_chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class InputMessageReplyToMessage(TlObject, InputMessageReplyTo):
    r"""Describes a message to be replied in the same chat and forum topic

    Parameters:
        message_id (:class:`int`):
            The identifier of the message to be replied in the same chat and forum topic\. A message can be replied in the same chat and forum topic only if messageProperties\.can\_be\_replied

        quote (:class:`"types.InputTextQuote"`):
            Quote from the message to be replied; pass null if none\. Must always be null for replies in secret chats

    """

    def __init__(self, message_id: int = 0, quote: InputTextQuote = None) -> None:
        self.message_id: int = int(message_id)
        r"""The identifier of the message to be replied in the same chat and forum topic\. A message can be replied in the same chat and forum topic only if messageProperties\.can\_be\_replied"""
        self.quote: Union[InputTextQuote, None] = quote
        r"""Quote from the message to be replied; pass null if none\. Must always be null for replies in secret chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageReplyToMessage"]:
        return "inputMessageReplyToMessage"

    def getClass(self) -> Literal["InputMessageReplyTo"]:
        return "InputMessageReplyTo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_id": self.message_id,
            "quote": self.quote,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageReplyToMessage", None]:
        if data:
            data_class = cls()
            data_class.message_id = int(data.get("message_id", 0))
            data_class.quote = data.get("quote", None)

        return data_class


class InputMessageReplyToExternalMessage(TlObject, InputMessageReplyTo):
    r"""Describes a message to be replied that is from a different chat or a forum topic; not supported in secret chats

    Parameters:
        chat_id (:class:`int`):
            The identifier of the chat to which the message to be replied belongs

        message_id (:class:`int`):
            The identifier of the message to be replied in the specified chat\. A message can be replied in another chat or forum topic only if messageProperties\.can\_be\_replied\_in\_another\_chat

        quote (:class:`"types.InputTextQuote"`):
            Quote from the message to be replied; pass null if none

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, quote: InputTextQuote = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""The identifier of the chat to which the message to be replied belongs"""
        self.message_id: int = int(message_id)
        r"""The identifier of the message to be replied in the specified chat\. A message can be replied in another chat or forum topic only if messageProperties\.can\_be\_replied\_in\_another\_chat"""
        self.quote: Union[InputTextQuote, None] = quote
        r"""Quote from the message to be replied; pass null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageReplyToExternalMessage"]:
        return "inputMessageReplyToExternalMessage"

    def getClass(self) -> Literal["InputMessageReplyTo"]:
        return "InputMessageReplyTo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "quote": self.quote,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageReplyToExternalMessage", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.quote = data.get("quote", None)

        return data_class


class InputMessageReplyToStory(TlObject, InputMessageReplyTo):
    r"""Describes a story to be replied

    Parameters:
        story_sender_chat_id (:class:`int`):
            The identifier of the sender of the story\. Currently, stories can be replied only in the sender's chat and channel stories can't be replied

        story_id (:class:`int`):
            The identifier of the story

    """

    def __init__(self, story_sender_chat_id: int = 0, story_id: int = 0) -> None:
        self.story_sender_chat_id: int = int(story_sender_chat_id)
        r"""The identifier of the sender of the story\. Currently, stories can be replied only in the sender's chat and channel stories can't be replied"""
        self.story_id: int = int(story_id)
        r"""The identifier of the story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageReplyToStory"]:
        return "inputMessageReplyToStory"

    def getClass(self) -> Literal["InputMessageReplyTo"]:
        return "InputMessageReplyTo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_sender_chat_id": self.story_sender_chat_id,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageReplyToStory", None]:
        if data:
            data_class = cls()
            data_class.story_sender_chat_id = int(data.get("story_sender_chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class FactCheck(TlObject):
    r"""Describes a fact\-check added to the message by an independent checker

    Parameters:
        text (:class:`"types.FormattedText"`):
            Text of the fact\-check

        country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code of the country for which the fact\-check is shown

    """

    def __init__(self, text: FormattedText = None, country_code: str = "") -> None:
        self.text: Union[FormattedText, None] = text
        r"""Text of the fact\-check"""
        self.country_code: Union[str, None] = country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code of the country for which the fact\-check is shown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["factCheck"]:
        return "factCheck"

    def getClass(self) -> Literal["FactCheck"]:
        return "FactCheck"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "country_code": self.country_code,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FactCheck", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.country_code = data.get("country_code", "")

        return data_class


class Message(TlObject, MessageBoundMethods):
    r"""Describes a message

    Parameters:
        id (:class:`int`):
            Message identifier; unique for the chat to which the message belongs

        sender_id (:class:`"types.MessageSender"`):
            Identifier of the sender of the message

        chat_id (:class:`int`):
            Chat identifier

        sending_state (:class:`"types.MessageSendingState"`):
            The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent

        scheduling_state (:class:`"types.MessageSchedulingState"`):
            The scheduling state of the message; may be null if the message isn't scheduled

        is_outgoing (:class:`bool`):
            True, if the message is outgoing

        is_pinned (:class:`bool`):
            True, if the message is pinned

        is_from_offline (:class:`bool`):
            True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message

        can_be_saved (:class:`bool`):
            True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options

        has_timestamped_media (:class:`bool`):
            True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message

        is_channel_post (:class:`bool`):
            True, if the message is a channel post\. All messages to channels are channel posts, all other messages are not channel posts

        is_topic_message (:class:`bool`):
            True, if the message is a forum topic message

        contains_unread_mention (:class:`bool`):
            True, if the message contains an unread mention for the current user

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was sent; 0 for scheduled messages

        edit_date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was last edited; 0 for scheduled messages

        forward_info (:class:`"types.MessageForwardInfo"`):
            Information about the initial message sender; may be null if none or unknown

        import_info (:class:`"types.MessageImportInfo"`):
            Information about the initial message for messages created with importMessages; may be null if the message isn't imported

        interaction_info (:class:`"types.MessageInteractionInfo"`):
            Information about interactions with the message; may be null if none

        unread_reactions (:class:`List["types.UnreadReaction"]`):
            Information about unread reactions added to the message

        fact_check (:class:`"types.FactCheck"`):
            Information about fact\-check added to the message; may be null if none

        reply_to (:class:`"types.MessageReplyTo"`):
            Information about the message or the story this message is replying to; may be null if none

        message_thread_id (:class:`int`):
            If non\-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs

        saved_messages_topic_id (:class:`int`):
            Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages

        self_destruct_type (:class:`"types.MessageSelfDestructType"`):
            The message's self\-destruct type; may be null if none

        self_destruct_in (:class:`float`):
            Time left before the message self\-destruct timer expires, in seconds; 0 if self\-destruction isn't scheduled yet

        auto_delete_in (:class:`float`):
            Time left before the message will be automatically deleted by message\_auto\_delete\_time setting of the chat, in seconds; 0 if never

        via_bot_user_id (:class:`int`):
            If non\-zero, the user identifier of the inline bot through which this message was sent

        sender_business_bot_user_id (:class:`int`):
            If non\-zero, the user identifier of the business bot that sent this message

        sender_boost_count (:class:`int`):
            Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown\. For messages sent by the current user, supergroupFullInfo\.my\_boost\_count must be used instead

        paid_message_star_count (:class:`int`):
            The number of Telegram Stars the sender paid to send the message

        author_signature (:class:`str`):
            For channel posts and anonymous group messages, optional author signature

        media_album_id (:class:`int`):
            Unique identifier of an album this message belongs to; 0 if none\. Only audios, documents, photos and videos can be grouped together in albums

        effect_id (:class:`int`):
            Unique identifier of the effect added to the message; 0 if none

        has_sensitive_content (:class:`bool`):
            True, if media content of the message must be hidden with 18\+ spoiler

        restriction_reason (:class:`str`):
            If non\-empty, contains a human\-readable description of the reason why access to this message must be restricted

        content (:class:`"types.MessageContent"`):
            Content of the message

        reply_markup (:class:`"types.ReplyMarkup"`):
            Reply markup for the message; may be null if none

    """

    def __init__(
        self,
        id: int = 0,
        sender_id: MessageSender = None,
        chat_id: int = 0,
        sending_state: MessageSendingState = None,
        scheduling_state: MessageSchedulingState = None,
        is_outgoing: bool = False,
        is_pinned: bool = False,
        is_from_offline: bool = False,
        can_be_saved: bool = False,
        has_timestamped_media: bool = False,
        is_channel_post: bool = False,
        is_topic_message: bool = False,
        contains_unread_mention: bool = False,
        date: int = 0,
        edit_date: int = 0,
        forward_info: MessageForwardInfo = None,
        import_info: MessageImportInfo = None,
        interaction_info: MessageInteractionInfo = None,
        unread_reactions: List[UnreadReaction] = None,
        fact_check: FactCheck = None,
        reply_to: MessageReplyTo = None,
        message_thread_id: int = 0,
        saved_messages_topic_id: int = 0,
        self_destruct_type: MessageSelfDestructType = None,
        self_destruct_in: float = 0.0,
        auto_delete_in: float = 0.0,
        via_bot_user_id: int = 0,
        sender_business_bot_user_id: int = 0,
        sender_boost_count: int = 0,
        paid_message_star_count: int = 0,
        author_signature: str = "",
        media_album_id: int = 0,
        effect_id: int = 0,
        has_sensitive_content: bool = False,
        restriction_reason: str = "",
        content: MessageContent = None,
        reply_markup: ReplyMarkup = None,
    ) -> None:
        self.id: int = int(id)
        r"""Message identifier; unique for the chat to which the message belongs"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the sender of the message"""
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.sending_state: Union[
            MessageSendingStatePending, MessageSendingStateFailed, None
        ] = sending_state
        r"""The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent"""
        self.scheduling_state: Union[
            MessageSchedulingStateSendAtDate,
            MessageSchedulingStateSendWhenOnline,
            MessageSchedulingStateSendWhenVideoProcessed,
            None,
        ] = scheduling_state
        r"""The scheduling state of the message; may be null if the message isn't scheduled"""
        self.is_outgoing: bool = bool(is_outgoing)
        r"""True, if the message is outgoing"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is pinned"""
        self.is_from_offline: bool = bool(is_from_offline)
        r"""True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message"""
        self.can_be_saved: bool = bool(can_be_saved)
        r"""True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options"""
        self.has_timestamped_media: bool = bool(has_timestamped_media)
        r"""True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message"""
        self.is_channel_post: bool = bool(is_channel_post)
        r"""True, if the message is a channel post\. All messages to channels are channel posts, all other messages are not channel posts"""
        self.is_topic_message: bool = bool(is_topic_message)
        r"""True, if the message is a forum topic message"""
        self.contains_unread_mention: bool = bool(contains_unread_mention)
        r"""True, if the message contains an unread mention for the current user"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the message was sent; 0 for scheduled messages"""
        self.edit_date: int = int(edit_date)
        r"""Point in time \(Unix timestamp\) when the message was last edited; 0 for scheduled messages"""
        self.forward_info: Union[MessageForwardInfo, None] = forward_info
        r"""Information about the initial message sender; may be null if none or unknown"""
        self.import_info: Union[MessageImportInfo, None] = import_info
        r"""Information about the initial message for messages created with importMessages; may be null if the message isn't imported"""
        self.interaction_info: Union[MessageInteractionInfo, None] = interaction_info
        r"""Information about interactions with the message; may be null if none"""
        self.unread_reactions: List[UnreadReaction] = unread_reactions or []
        r"""Information about unread reactions added to the message"""
        self.fact_check: Union[FactCheck, None] = fact_check
        r"""Information about fact\-check added to the message; may be null if none"""
        self.reply_to: Union[MessageReplyToMessage, MessageReplyToStory, None] = (
            reply_to
        )
        r"""Information about the message or the story this message is replying to; may be null if none"""
        self.message_thread_id: int = int(message_thread_id)
        r"""If non\-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs"""
        self.saved_messages_topic_id: int = int(saved_messages_topic_id)
        r"""Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages"""
        self.self_destruct_type: Union[
            MessageSelfDestructTypeTimer, MessageSelfDestructTypeImmediately, None
        ] = self_destruct_type
        r"""The message's self\-destruct type; may be null if none"""
        self.self_destruct_in: float = float(self_destruct_in)
        r"""Time left before the message self\-destruct timer expires, in seconds; 0 if self\-destruction isn't scheduled yet"""
        self.auto_delete_in: float = float(auto_delete_in)
        r"""Time left before the message will be automatically deleted by message\_auto\_delete\_time setting of the chat, in seconds; 0 if never"""
        self.via_bot_user_id: int = int(via_bot_user_id)
        r"""If non\-zero, the user identifier of the inline bot through which this message was sent"""
        self.sender_business_bot_user_id: int = int(sender_business_bot_user_id)
        r"""If non\-zero, the user identifier of the business bot that sent this message"""
        self.sender_boost_count: int = int(sender_boost_count)
        r"""Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown\. For messages sent by the current user, supergroupFullInfo\.my\_boost\_count must be used instead"""
        self.paid_message_star_count: int = int(paid_message_star_count)
        r"""The number of Telegram Stars the sender paid to send the message"""
        self.author_signature: Union[str, None] = author_signature
        r"""For channel posts and anonymous group messages, optional author signature"""
        self.media_album_id: int = int(media_album_id)
        r"""Unique identifier of an album this message belongs to; 0 if none\. Only audios, documents, photos and videos can be grouped together in albums"""
        self.effect_id: int = int(effect_id)
        r"""Unique identifier of the effect added to the message; 0 if none"""
        self.has_sensitive_content: bool = bool(has_sensitive_content)
        r"""True, if media content of the message must be hidden with 18\+ spoiler"""
        self.restriction_reason: Union[str, None] = restriction_reason
        r"""If non\-empty, contains a human\-readable description of the reason why access to this message must be restricted"""
        self.content: Union[
            MessageText,
            MessageAnimation,
            MessageAudio,
            MessageDocument,
            MessagePaidMedia,
            MessagePhoto,
            MessageSticker,
            MessageVideo,
            MessageVideoNote,
            MessageVoiceNote,
            MessageExpiredPhoto,
            MessageExpiredVideo,
            MessageExpiredVideoNote,
            MessageExpiredVoiceNote,
            MessageLocation,
            MessageVenue,
            MessageContact,
            MessageAnimatedEmoji,
            MessageDice,
            MessageGame,
            MessagePoll,
            MessageStory,
            MessageInvoice,
            MessageCall,
            MessageVideoChatScheduled,
            MessageVideoChatStarted,
            MessageVideoChatEnded,
            MessageInviteVideoChatParticipants,
            MessageBasicGroupChatCreate,
            MessageSupergroupChatCreate,
            MessageChatChangeTitle,
            MessageChatChangePhoto,
            MessageChatDeletePhoto,
            MessageChatAddMembers,
            MessageChatJoinByLink,
            MessageChatJoinByRequest,
            MessageChatDeleteMember,
            MessageChatUpgradeTo,
            MessageChatUpgradeFrom,
            MessagePinMessage,
            MessageScreenshotTaken,
            MessageChatSetBackground,
            MessageChatSetTheme,
            MessageChatSetMessageAutoDeleteTime,
            MessageChatBoost,
            MessageForumTopicCreated,
            MessageForumTopicEdited,
            MessageForumTopicIsClosedToggled,
            MessageForumTopicIsHiddenToggled,
            MessageSuggestProfilePhoto,
            MessageCustomServiceAction,
            MessageGameScore,
            MessagePaymentSuccessful,
            MessagePaymentSuccessfulBot,
            MessagePaymentRefunded,
            MessageGiftedPremium,
            MessagePremiumGiftCode,
            MessageGiveawayCreated,
            MessageGiveaway,
            MessageGiveawayCompleted,
            MessageGiveawayWinners,
            MessageGiftedStars,
            MessageGiveawayPrizeStars,
            MessageGift,
            MessageUpgradedGift,
            MessageRefundedUpgradedGift,
            MessagePaidMessagesRefunded,
            MessagePaidMessagePriceChanged,
            MessageContactRegistered,
            MessageUsersShared,
            MessageChatShared,
            MessageBotWriteAccessAllowed,
            MessageWebAppDataSent,
            MessageWebAppDataReceived,
            MessagePassportDataSent,
            MessagePassportDataReceived,
            MessageProximityAlertTriggered,
            MessageUnsupported,
            None,
        ] = content
        r"""Content of the message"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""Reply markup for the message; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["message"]:
        return "message"

    def getClass(self) -> Literal["Message"]:
        return "Message"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_id": self.sender_id,
            "chat_id": self.chat_id,
            "sending_state": self.sending_state,
            "scheduling_state": self.scheduling_state,
            "is_outgoing": self.is_outgoing,
            "is_pinned": self.is_pinned,
            "is_from_offline": self.is_from_offline,
            "can_be_saved": self.can_be_saved,
            "has_timestamped_media": self.has_timestamped_media,
            "is_channel_post": self.is_channel_post,
            "is_topic_message": self.is_topic_message,
            "contains_unread_mention": self.contains_unread_mention,
            "date": self.date,
            "edit_date": self.edit_date,
            "forward_info": self.forward_info,
            "import_info": self.import_info,
            "interaction_info": self.interaction_info,
            "unread_reactions": self.unread_reactions,
            "fact_check": self.fact_check,
            "reply_to": self.reply_to,
            "message_thread_id": self.message_thread_id,
            "saved_messages_topic_id": self.saved_messages_topic_id,
            "self_destruct_type": self.self_destruct_type,
            "self_destruct_in": self.self_destruct_in,
            "auto_delete_in": self.auto_delete_in,
            "via_bot_user_id": self.via_bot_user_id,
            "sender_business_bot_user_id": self.sender_business_bot_user_id,
            "sender_boost_count": self.sender_boost_count,
            "paid_message_star_count": self.paid_message_star_count,
            "author_signature": self.author_signature,
            "media_album_id": self.media_album_id,
            "effect_id": self.effect_id,
            "has_sensitive_content": self.has_sensitive_content,
            "restriction_reason": self.restriction_reason,
            "content": self.content,
            "reply_markup": self.reply_markup,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Message", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_id = data.get("sender_id", None)
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.sending_state = data.get("sending_state", None)
            data_class.scheduling_state = data.get("scheduling_state", None)
            data_class.is_outgoing = data.get("is_outgoing", False)
            data_class.is_pinned = data.get("is_pinned", False)
            data_class.is_from_offline = data.get("is_from_offline", False)
            data_class.can_be_saved = data.get("can_be_saved", False)
            data_class.has_timestamped_media = data.get("has_timestamped_media", False)
            data_class.is_channel_post = data.get("is_channel_post", False)
            data_class.is_topic_message = data.get("is_topic_message", False)
            data_class.contains_unread_mention = data.get(
                "contains_unread_mention", False
            )
            data_class.date = int(data.get("date", 0))
            data_class.edit_date = int(data.get("edit_date", 0))
            data_class.forward_info = data.get("forward_info", None)
            data_class.import_info = data.get("import_info", None)
            data_class.interaction_info = data.get("interaction_info", None)
            data_class.unread_reactions = data.get("unread_reactions", None)
            data_class.fact_check = data.get("fact_check", None)
            data_class.reply_to = data.get("reply_to", None)
            data_class.message_thread_id = int(data.get("message_thread_id", 0))
            data_class.saved_messages_topic_id = int(
                data.get("saved_messages_topic_id", 0)
            )
            data_class.self_destruct_type = data.get("self_destruct_type", None)
            data_class.self_destruct_in = data.get("self_destruct_in", 0.0)
            data_class.auto_delete_in = data.get("auto_delete_in", 0.0)
            data_class.via_bot_user_id = int(data.get("via_bot_user_id", 0))
            data_class.sender_business_bot_user_id = int(
                data.get("sender_business_bot_user_id", 0)
            )
            data_class.sender_boost_count = int(data.get("sender_boost_count", 0))
            data_class.paid_message_star_count = int(
                data.get("paid_message_star_count", 0)
            )
            data_class.author_signature = data.get("author_signature", "")
            data_class.media_album_id = int(data.get("media_album_id", 0))
            data_class.effect_id = int(data.get("effect_id", 0))
            data_class.has_sensitive_content = data.get("has_sensitive_content", False)
            data_class.restriction_reason = data.get("restriction_reason", "")
            data_class.content = data.get("content", None)
            data_class.reply_markup = data.get("reply_markup", None)

        return data_class


class Messages(TlObject):
    r"""Contains a list of messages

    Parameters:
        total_count (:class:`int`):
            Approximate total number of messages found

        messages (:class:`List["types.Message"]`):
            List of messages; messages may be null

    """

    def __init__(self, total_count: int = 0, messages: List[Message] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of messages found"""
        self.messages: List[Message] = messages or []
        r"""List of messages; messages may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messages"]:
        return "messages"

    def getClass(self) -> Literal["Messages"]:
        return "Messages"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "messages": self.messages,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Messages", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.messages = data.get("messages", None)

        return data_class


class FoundMessages(TlObject):
    r"""Contains a list of messages found by a search

    Parameters:
        total_count (:class:`int`):
            Approximate total number of messages found; \-1 if unknown

        messages (:class:`List["types.Message"]`):
            List of messages

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        messages: List[Message] = None,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of messages found; \-1 if unknown"""
        self.messages: List[Message] = messages or []
        r"""List of messages"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundMessages"]:
        return "foundMessages"

    def getClass(self) -> Literal["FoundMessages"]:
        return "FoundMessages"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "messages": self.messages,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundMessages", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.messages = data.get("messages", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class FoundChatMessages(TlObject):
    r"""Contains a list of messages found by a search in a given chat

    Parameters:
        total_count (:class:`int`):
            Approximate total number of messages found; \-1 if unknown

        messages (:class:`List["types.Message"]`):
            List of messages

        next_from_message_id (:class:`int`):
            The offset for the next request\. If 0, there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        messages: List[Message] = None,
        next_from_message_id: int = 0,
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of messages found; \-1 if unknown"""
        self.messages: List[Message] = messages or []
        r"""List of messages"""
        self.next_from_message_id: int = int(next_from_message_id)
        r"""The offset for the next request\. If 0, there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundChatMessages"]:
        return "foundChatMessages"

    def getClass(self) -> Literal["FoundChatMessages"]:
        return "FoundChatMessages"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "messages": self.messages,
            "next_from_message_id": self.next_from_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundChatMessages", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.messages = data.get("messages", None)
            data_class.next_from_message_id = int(data.get("next_from_message_id", 0))

        return data_class


class MessagePosition(TlObject):
    r"""Contains information about a message in a specific position

    Parameters:
        position (:class:`int`):
            0\-based message position in the full list of suitable messages

        message_id (:class:`int`):
            Message identifier

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was sent

    """

    def __init__(self, position: int = 0, message_id: int = 0, date: int = 0) -> None:
        self.position: int = int(position)
        r"""0\-based message position in the full list of suitable messages"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the message was sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePosition"]:
        return "messagePosition"

    def getClass(self) -> Literal["MessagePosition"]:
        return "MessagePosition"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "position": self.position,
            "message_id": self.message_id,
            "date": self.date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePosition", None]:
        if data:
            data_class = cls()
            data_class.position = int(data.get("position", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.date = int(data.get("date", 0))

        return data_class


class MessagePositions(TlObject):
    r"""Contains a list of message positions

    Parameters:
        total_count (:class:`int`):
            Total number of messages found

        positions (:class:`List["types.MessagePosition"]`):
            List of message positions

    """

    def __init__(
        self, total_count: int = 0, positions: List[MessagePosition] = None
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of messages found"""
        self.positions: List[MessagePosition] = positions or []
        r"""List of message positions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePositions"]:
        return "messagePositions"

    def getClass(self) -> Literal["MessagePositions"]:
        return "MessagePositions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "positions": self.positions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePositions", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.positions = data.get("positions", None)

        return data_class


class MessageCalendarDay(TlObject):
    r"""Contains information about found messages sent on a specific day

    Parameters:
        total_count (:class:`int`):
            Total number of found messages sent on the day

        message (:class:`"types.Message"`):
            First message sent on the day

    """

    def __init__(self, total_count: int = 0, message: Message = None) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of found messages sent on the day"""
        self.message: Union[Message, None] = message
        r"""First message sent on the day"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageCalendarDay"]:
        return "messageCalendarDay"

    def getClass(self) -> Literal["MessageCalendarDay"]:
        return "MessageCalendarDay"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "message": self.message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageCalendarDay", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.message = data.get("message", None)

        return data_class


class MessageCalendar(TlObject):
    r"""Contains information about found messages, split by days according to the option \"utc\_time\_offset\"

    Parameters:
        total_count (:class:`int`):
            Total number of found messages

        days (:class:`List["types.MessageCalendarDay"]`):
            Information about messages sent

    """

    def __init__(
        self, total_count: int = 0, days: List[MessageCalendarDay] = None
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of found messages"""
        self.days: List[MessageCalendarDay] = days or []
        r"""Information about messages sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageCalendar"]:
        return "messageCalendar"

    def getClass(self) -> Literal["MessageCalendar"]:
        return "MessageCalendar"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "days": self.days,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageCalendar", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.days = data.get("days", None)

        return data_class


class BusinessMessage(TlObject):
    r"""Describes a message from a business account as received by a bot

    Parameters:
        message (:class:`"types.Message"`):
            The message

        reply_to_message (:class:`"types.Message"`):
            Message that is replied by the message in the same chat; may be null if none

    """

    def __init__(
        self, message: Message = None, reply_to_message: Message = None
    ) -> None:
        self.message: Union[Message, None] = message
        r"""The message"""
        self.reply_to_message: Union[Message, None] = reply_to_message
        r"""Message that is replied by the message in the same chat; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessMessage"]:
        return "businessMessage"

    def getClass(self) -> Literal["BusinessMessage"]:
        return "BusinessMessage"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message": self.message,
            "reply_to_message": self.reply_to_message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessMessage", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)
            data_class.reply_to_message = data.get("reply_to_message", None)

        return data_class


class BusinessMessages(TlObject):
    r"""Contains a list of messages from a business account as received by a bot

    Parameters:
        messages (:class:`List["types.BusinessMessage"]`):
            List of business messages

    """

    def __init__(self, messages: List[BusinessMessage] = None) -> None:
        self.messages: List[BusinessMessage] = messages or []
        r"""List of business messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessMessages"]:
        return "businessMessages"

    def getClass(self) -> Literal["BusinessMessages"]:
        return "BusinessMessages"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "messages": self.messages}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessMessages", None]:
        if data:
            data_class = cls()
            data_class.messages = data.get("messages", None)

        return data_class


class MessageSourceChatHistory(TlObject, MessageSource):
    r"""The message is from a chat history"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceChatHistory"]:
        return "messageSourceChatHistory"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceChatHistory", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceMessageThreadHistory(TlObject, MessageSource):
    r"""The message is from a message thread history"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceMessageThreadHistory"]:
        return "messageSourceMessageThreadHistory"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceMessageThreadHistory", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceForumTopicHistory(TlObject, MessageSource):
    r"""The message is from a forum topic history"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceForumTopicHistory"]:
        return "messageSourceForumTopicHistory"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceForumTopicHistory", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceHistoryPreview(TlObject, MessageSource):
    r"""The message is from chat, message thread or forum topic history preview"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceHistoryPreview"]:
        return "messageSourceHistoryPreview"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceHistoryPreview", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceChatList(TlObject, MessageSource):
    r"""The message is from a chat list or a forum topic list"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceChatList"]:
        return "messageSourceChatList"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceChatList", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceSearch(TlObject, MessageSource):
    r"""The message is from search results, including file downloads, local file list, outgoing document messages, calendar"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceSearch"]:
        return "messageSourceSearch"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceSearch", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceChatEventLog(TlObject, MessageSource):
    r"""The message is from a chat event log"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceChatEventLog"]:
        return "messageSourceChatEventLog"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceChatEventLog", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceNotification(TlObject, MessageSource):
    r"""The message is from a notification"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceNotification"]:
        return "messageSourceNotification"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceNotification", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceScreenshot(TlObject, MessageSource):
    r"""The message was screenshotted; the source must be used only if the message content was visible during the screenshot"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceScreenshot"]:
        return "messageSourceScreenshot"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceScreenshot", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSourceOther(TlObject, MessageSource):
    r"""The message is from some other source"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSourceOther"]:
        return "messageSourceOther"

    def getClass(self) -> Literal["MessageSource"]:
        return "MessageSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSourceOther", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSponsor(TlObject):
    r"""Information about the sponsor of a message

    Parameters:
        url (:class:`str`):
            URL of the sponsor to be opened when the message is clicked

        photo (:class:`"types.Photo"`):
            Photo of the sponsor; may be null if must not be shown

        info (:class:`str`):
            Additional optional information about the sponsor to be shown along with the message

    """

    def __init__(self, url: str = "", photo: Photo = None, info: str = "") -> None:
        self.url: Union[str, None] = url
        r"""URL of the sponsor to be opened when the message is clicked"""
        self.photo: Union[Photo, None] = photo
        r"""Photo of the sponsor; may be null if must not be shown"""
        self.info: Union[str, None] = info
        r"""Additional optional information about the sponsor to be shown along with the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSponsor"]:
        return "messageSponsor"

    def getClass(self) -> Literal["MessageSponsor"]:
        return "MessageSponsor"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "photo": self.photo,
            "info": self.info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSponsor", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.photo = data.get("photo", None)
            data_class.info = data.get("info", "")

        return data_class


class SponsoredMessage(TlObject):
    r"""Describes a sponsored message

    Parameters:
        message_id (:class:`int`):
            Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages

        is_recommended (:class:`bool`):
            True, if the message needs to be labeled as \"recommended\" instead of \"sponsored\"

        can_be_reported (:class:`bool`):
            True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage

        content (:class:`"types.MessageContent"`):
            Content of the message\. Currently, can be only of the types messageText, messageAnimation, messagePhoto, or messageVideo\. Video messages can be viewed fullscreen

        sponsor (:class:`"types.MessageSponsor"`):
            Information about the sponsor of the message

        title (:class:`str`):
            Title of the sponsored message

        button_text (:class:`str`):
            Text for the message action button

        accent_color_id (:class:`int`):
            Identifier of the accent color for title, button text and message background

        background_custom_emoji_id (:class:`int`):
            Identifier of a custom emoji to be shown on the message background; 0 if none

        additional_info (:class:`str`):
            If non\-empty, additional information about the sponsored message to be shown along with the message

    """

    def __init__(
        self,
        message_id: int = 0,
        is_recommended: bool = False,
        can_be_reported: bool = False,
        content: MessageContent = None,
        sponsor: MessageSponsor = None,
        title: str = "",
        button_text: str = "",
        accent_color_id: int = 0,
        background_custom_emoji_id: int = 0,
        additional_info: str = "",
    ) -> None:
        self.message_id: int = int(message_id)
        r"""Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages"""
        self.is_recommended: bool = bool(is_recommended)
        r"""True, if the message needs to be labeled as \"recommended\" instead of \"sponsored\""""
        self.can_be_reported: bool = bool(can_be_reported)
        r"""True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage"""
        self.content: Union[
            MessageText,
            MessageAnimation,
            MessageAudio,
            MessageDocument,
            MessagePaidMedia,
            MessagePhoto,
            MessageSticker,
            MessageVideo,
            MessageVideoNote,
            MessageVoiceNote,
            MessageExpiredPhoto,
            MessageExpiredVideo,
            MessageExpiredVideoNote,
            MessageExpiredVoiceNote,
            MessageLocation,
            MessageVenue,
            MessageContact,
            MessageAnimatedEmoji,
            MessageDice,
            MessageGame,
            MessagePoll,
            MessageStory,
            MessageInvoice,
            MessageCall,
            MessageVideoChatScheduled,
            MessageVideoChatStarted,
            MessageVideoChatEnded,
            MessageInviteVideoChatParticipants,
            MessageBasicGroupChatCreate,
            MessageSupergroupChatCreate,
            MessageChatChangeTitle,
            MessageChatChangePhoto,
            MessageChatDeletePhoto,
            MessageChatAddMembers,
            MessageChatJoinByLink,
            MessageChatJoinByRequest,
            MessageChatDeleteMember,
            MessageChatUpgradeTo,
            MessageChatUpgradeFrom,
            MessagePinMessage,
            MessageScreenshotTaken,
            MessageChatSetBackground,
            MessageChatSetTheme,
            MessageChatSetMessageAutoDeleteTime,
            MessageChatBoost,
            MessageForumTopicCreated,
            MessageForumTopicEdited,
            MessageForumTopicIsClosedToggled,
            MessageForumTopicIsHiddenToggled,
            MessageSuggestProfilePhoto,
            MessageCustomServiceAction,
            MessageGameScore,
            MessagePaymentSuccessful,
            MessagePaymentSuccessfulBot,
            MessagePaymentRefunded,
            MessageGiftedPremium,
            MessagePremiumGiftCode,
            MessageGiveawayCreated,
            MessageGiveaway,
            MessageGiveawayCompleted,
            MessageGiveawayWinners,
            MessageGiftedStars,
            MessageGiveawayPrizeStars,
            MessageGift,
            MessageUpgradedGift,
            MessageRefundedUpgradedGift,
            MessagePaidMessagesRefunded,
            MessagePaidMessagePriceChanged,
            MessageContactRegistered,
            MessageUsersShared,
            MessageChatShared,
            MessageBotWriteAccessAllowed,
            MessageWebAppDataSent,
            MessageWebAppDataReceived,
            MessagePassportDataSent,
            MessagePassportDataReceived,
            MessageProximityAlertTriggered,
            MessageUnsupported,
            None,
        ] = content
        r"""Content of the message\. Currently, can be only of the types messageText, messageAnimation, messagePhoto, or messageVideo\. Video messages can be viewed fullscreen"""
        self.sponsor: Union[MessageSponsor, None] = sponsor
        r"""Information about the sponsor of the message"""
        self.title: Union[str, None] = title
        r"""Title of the sponsored message"""
        self.button_text: Union[str, None] = button_text
        r"""Text for the message action button"""
        self.accent_color_id: int = int(accent_color_id)
        r"""Identifier of the accent color for title, button text and message background"""
        self.background_custom_emoji_id: int = int(background_custom_emoji_id)
        r"""Identifier of a custom emoji to be shown on the message background; 0 if none"""
        self.additional_info: Union[str, None] = additional_info
        r"""If non\-empty, additional information about the sponsored message to be shown along with the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sponsoredMessage"]:
        return "sponsoredMessage"

    def getClass(self) -> Literal["SponsoredMessage"]:
        return "SponsoredMessage"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_id": self.message_id,
            "is_recommended": self.is_recommended,
            "can_be_reported": self.can_be_reported,
            "content": self.content,
            "sponsor": self.sponsor,
            "title": self.title,
            "button_text": self.button_text,
            "accent_color_id": self.accent_color_id,
            "background_custom_emoji_id": self.background_custom_emoji_id,
            "additional_info": self.additional_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SponsoredMessage", None]:
        if data:
            data_class = cls()
            data_class.message_id = int(data.get("message_id", 0))
            data_class.is_recommended = data.get("is_recommended", False)
            data_class.can_be_reported = data.get("can_be_reported", False)
            data_class.content = data.get("content", None)
            data_class.sponsor = data.get("sponsor", None)
            data_class.title = data.get("title", "")
            data_class.button_text = data.get("button_text", "")
            data_class.accent_color_id = int(data.get("accent_color_id", 0))
            data_class.background_custom_emoji_id = int(
                data.get("background_custom_emoji_id", 0)
            )
            data_class.additional_info = data.get("additional_info", "")

        return data_class


class SponsoredMessages(TlObject):
    r"""Contains a list of sponsored messages

    Parameters:
        messages (:class:`List["types.SponsoredMessage"]`):
            List of sponsored messages

        messages_between (:class:`int`):
            The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages

    """

    def __init__(
        self, messages: List[SponsoredMessage] = None, messages_between: int = 0
    ) -> None:
        self.messages: List[SponsoredMessage] = messages or []
        r"""List of sponsored messages"""
        self.messages_between: int = int(messages_between)
        r"""The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sponsoredMessages"]:
        return "sponsoredMessages"

    def getClass(self) -> Literal["SponsoredMessages"]:
        return "SponsoredMessages"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "messages": self.messages,
            "messages_between": self.messages_between,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SponsoredMessages", None]:
        if data:
            data_class = cls()
            data_class.messages = data.get("messages", None)
            data_class.messages_between = int(data.get("messages_between", 0))

        return data_class


class SponsoredChat(TlObject):
    r"""Describes a sponsored chat

    Parameters:
        unique_id (:class:`int`):
            Unique identifier of this result

        chat_id (:class:`int`):
            Chat identifier

        sponsor_info (:class:`str`):
            Additional optional information about the sponsor to be shown along with the chat

        additional_info (:class:`str`):
            If non\-empty, additional information about the sponsored chat to be shown along with the chat

    """

    def __init__(
        self,
        unique_id: int = 0,
        chat_id: int = 0,
        sponsor_info: str = "",
        additional_info: str = "",
    ) -> None:
        self.unique_id: int = int(unique_id)
        r"""Unique identifier of this result"""
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.sponsor_info: Union[str, None] = sponsor_info
        r"""Additional optional information about the sponsor to be shown along with the chat"""
        self.additional_info: Union[str, None] = additional_info
        r"""If non\-empty, additional information about the sponsored chat to be shown along with the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sponsoredChat"]:
        return "sponsoredChat"

    def getClass(self) -> Literal["SponsoredChat"]:
        return "SponsoredChat"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "unique_id": self.unique_id,
            "chat_id": self.chat_id,
            "sponsor_info": self.sponsor_info,
            "additional_info": self.additional_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SponsoredChat", None]:
        if data:
            data_class = cls()
            data_class.unique_id = int(data.get("unique_id", 0))
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.sponsor_info = data.get("sponsor_info", "")
            data_class.additional_info = data.get("additional_info", "")

        return data_class


class SponsoredChats(TlObject):
    r"""Contains a list of sponsored chats

    Parameters:
        chats (:class:`List["types.SponsoredChat"]`):
            List of sponsored chats

    """

    def __init__(self, chats: List[SponsoredChat] = None) -> None:
        self.chats: List[SponsoredChat] = chats or []
        r"""List of sponsored chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sponsoredChats"]:
        return "sponsoredChats"

    def getClass(self) -> Literal["SponsoredChats"]:
        return "SponsoredChats"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chats": self.chats}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SponsoredChats", None]:
        if data:
            data_class = cls()
            data_class.chats = data.get("chats", None)

        return data_class


class ReportOption(TlObject):
    r"""Describes an option to report an entity to Telegram

    Parameters:
        id (:class:`bytes`):
            Unique identifier of the option

        text (:class:`str`):
            Text of the option

    """

    def __init__(self, id: bytes = b"", text: str = "") -> None:
        self.id: Union[bytes, None] = id
        r"""Unique identifier of the option"""
        self.text: Union[str, None] = text
        r"""Text of the option"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportOption"]:
        return "reportOption"

    def getClass(self) -> Literal["ReportOption"]:
        return "ReportOption"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id, "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportOption", None]:
        if data:
            data_class = cls()
            data_class.id = b64decode(data.get("id", b""))
            data_class.text = data.get("text", "")

        return data_class


class ReportSponsoredResultOk(TlObject, ReportSponsoredResult):
    r"""The message was reported successfully"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportSponsoredResultOk"]:
        return "reportSponsoredResultOk"

    def getClass(self) -> Literal["ReportSponsoredResult"]:
        return "ReportSponsoredResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportSponsoredResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class ReportSponsoredResultFailed(TlObject, ReportSponsoredResult):
    r"""The sponsored message is too old or not found"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportSponsoredResultFailed"]:
        return "reportSponsoredResultFailed"

    def getClass(self) -> Literal["ReportSponsoredResult"]:
        return "ReportSponsoredResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportSponsoredResultFailed", None]:
        if data:
            data_class = cls()

        return data_class


class ReportSponsoredResultOptionRequired(TlObject, ReportSponsoredResult):
    r"""The user must choose an option to report the message and repeat request with the chosen option

    Parameters:
        title (:class:`str`):
            Title for the option choice

        options (:class:`List["types.ReportOption"]`):
            List of available options

    """

    def __init__(self, title: str = "", options: List[ReportOption] = None) -> None:
        self.title: Union[str, None] = title
        r"""Title for the option choice"""
        self.options: List[ReportOption] = options or []
        r"""List of available options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportSponsoredResultOptionRequired"]:
        return "reportSponsoredResultOptionRequired"

    def getClass(self) -> Literal["ReportSponsoredResult"]:
        return "ReportSponsoredResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title, "options": self.options}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ReportSponsoredResultOptionRequired", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.options = data.get("options", None)

        return data_class


class ReportSponsoredResultAdsHidden(TlObject, ReportSponsoredResult):
    r"""Sponsored messages were hidden for the user in all chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportSponsoredResultAdsHidden"]:
        return "reportSponsoredResultAdsHidden"

    def getClass(self) -> Literal["ReportSponsoredResult"]:
        return "ReportSponsoredResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportSponsoredResultAdsHidden", None]:
        if data:
            data_class = cls()

        return data_class


class ReportSponsoredResultPremiumRequired(TlObject, ReportSponsoredResult):
    r"""The user asked to hide sponsored messages, but Telegram Premium is required for this"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportSponsoredResultPremiumRequired"]:
        return "reportSponsoredResultPremiumRequired"

    def getClass(self) -> Literal["ReportSponsoredResult"]:
        return "ReportSponsoredResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ReportSponsoredResultPremiumRequired", None]:
        if data:
            data_class = cls()

        return data_class


class FileDownload(TlObject):
    r"""Describes a file added to file download list

    Parameters:
        file_id (:class:`int`):
            File identifier

        message (:class:`"types.Message"`):
            The message with the file

        add_date (:class:`int`):
            Point in time \(Unix timestamp\) when the file was added to the download list

        complete_date (:class:`int`):
            Point in time \(Unix timestamp\) when the file downloading was completed; 0 if the file downloading isn't completed

        is_paused (:class:`bool`):
            True, if downloading of the file is paused

    """

    def __init__(
        self,
        file_id: int = 0,
        message: Message = None,
        add_date: int = 0,
        complete_date: int = 0,
        is_paused: bool = False,
    ) -> None:
        self.file_id: int = int(file_id)
        r"""File identifier"""
        self.message: Union[Message, None] = message
        r"""The message with the file"""
        self.add_date: int = int(add_date)
        r"""Point in time \(Unix timestamp\) when the file was added to the download list"""
        self.complete_date: int = int(complete_date)
        r"""Point in time \(Unix timestamp\) when the file downloading was completed; 0 if the file downloading isn't completed"""
        self.is_paused: bool = bool(is_paused)
        r"""True, if downloading of the file is paused"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileDownload"]:
        return "fileDownload"

    def getClass(self) -> Literal["FileDownload"]:
        return "FileDownload"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "file_id": self.file_id,
            "message": self.message,
            "add_date": self.add_date,
            "complete_date": self.complete_date,
            "is_paused": self.is_paused,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileDownload", None]:
        if data:
            data_class = cls()
            data_class.file_id = int(data.get("file_id", 0))
            data_class.message = data.get("message", None)
            data_class.add_date = int(data.get("add_date", 0))
            data_class.complete_date = int(data.get("complete_date", 0))
            data_class.is_paused = data.get("is_paused", False)

        return data_class


class DownloadedFileCounts(TlObject):
    r"""Contains number of being downloaded and recently downloaded files found

    Parameters:
        active_count (:class:`int`):
            Number of active file downloads found, including paused

        paused_count (:class:`int`):
            Number of paused file downloads found

        completed_count (:class:`int`):
            Number of completed file downloads found

    """

    def __init__(
        self, active_count: int = 0, paused_count: int = 0, completed_count: int = 0
    ) -> None:
        self.active_count: int = int(active_count)
        r"""Number of active file downloads found, including paused"""
        self.paused_count: int = int(paused_count)
        r"""Number of paused file downloads found"""
        self.completed_count: int = int(completed_count)
        r"""Number of completed file downloads found"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["downloadedFileCounts"]:
        return "downloadedFileCounts"

    def getClass(self) -> Literal["DownloadedFileCounts"]:
        return "DownloadedFileCounts"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "active_count": self.active_count,
            "paused_count": self.paused_count,
            "completed_count": self.completed_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DownloadedFileCounts", None]:
        if data:
            data_class = cls()
            data_class.active_count = int(data.get("active_count", 0))
            data_class.paused_count = int(data.get("paused_count", 0))
            data_class.completed_count = int(data.get("completed_count", 0))

        return data_class


class FoundFileDownloads(TlObject):
    r"""Contains a list of downloaded files, found by a search

    Parameters:
        total_counts (:class:`"types.DownloadedFileCounts"`):
            Total number of suitable files, ignoring offset

        files (:class:`List["types.FileDownload"]`):
            The list of files

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_counts: DownloadedFileCounts = None,
        files: List[FileDownload] = None,
        next_offset: str = "",
    ) -> None:
        self.total_counts: Union[DownloadedFileCounts, None] = total_counts
        r"""Total number of suitable files, ignoring offset"""
        self.files: List[FileDownload] = files or []
        r"""The list of files"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundFileDownloads"]:
        return "foundFileDownloads"

    def getClass(self) -> Literal["FoundFileDownloads"]:
        return "FoundFileDownloads"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_counts": self.total_counts,
            "files": self.files,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundFileDownloads", None]:
        if data:
            data_class = cls()
            data_class.total_counts = data.get("total_counts", None)
            data_class.files = data.get("files", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class NotificationSettingsScopePrivateChats(TlObject, NotificationSettingsScope):
    r"""Notification settings applied to all private and secret chats when the corresponding chat setting has a default value"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationSettingsScopePrivateChats"]:
        return "notificationSettingsScopePrivateChats"

    def getClass(self) -> Literal["NotificationSettingsScope"]:
        return "NotificationSettingsScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["NotificationSettingsScopePrivateChats", None]:
        if data:
            data_class = cls()

        return data_class


class NotificationSettingsScopeGroupChats(TlObject, NotificationSettingsScope):
    r"""Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationSettingsScopeGroupChats"]:
        return "notificationSettingsScopeGroupChats"

    def getClass(self) -> Literal["NotificationSettingsScope"]:
        return "NotificationSettingsScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["NotificationSettingsScopeGroupChats", None]:
        if data:
            data_class = cls()

        return data_class


class NotificationSettingsScopeChannelChats(TlObject, NotificationSettingsScope):
    r"""Notification settings applied to all channel chats when the corresponding chat setting has a default value"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationSettingsScopeChannelChats"]:
        return "notificationSettingsScopeChannelChats"

    def getClass(self) -> Literal["NotificationSettingsScope"]:
        return "NotificationSettingsScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["NotificationSettingsScopeChannelChats", None]:
        if data:
            data_class = cls()

        return data_class


class ChatNotificationSettings(TlObject):
    r"""Contains information about notification settings for a chat or a forum topic

    Parameters:
        use_default_mute_for (:class:`bool`):
            If true, the value for the relevant type of chat or the forum chat is used instead of mute\_for

        mute_for (:class:`int`):
            Time left before notifications will be unmuted, in seconds

        use_default_sound (:class:`bool`):
            If true, the value for the relevant type of chat or the forum chat is used instead of sound\_id

        sound_id (:class:`int`):
            Identifier of the notification sound to be played for messages; 0 if sound is disabled

        use_default_show_preview (:class:`bool`):
            If true, the value for the relevant type of chat or the forum chat is used instead of show\_preview

        show_preview (:class:`bool`):
            True, if message content must be displayed in notifications

        use_default_mute_stories (:class:`bool`):
            If true, the value for the relevant type of chat is used instead of mute\_stories

        mute_stories (:class:`bool`):
            True, if story notifications are disabled for the chat

        use_default_story_sound (:class:`bool`):
            If true, the value for the relevant type of chat is used instead of story\_sound\_id

        story_sound_id (:class:`int`):
            Identifier of the notification sound to be played for stories; 0 if sound is disabled

        use_default_show_story_sender (:class:`bool`):
            If true, the value for the relevant type of chat is used instead of show\_story\_sender

        show_story_sender (:class:`bool`):
            True, if the sender of stories must be displayed in notifications

        use_default_disable_pinned_message_notifications (:class:`bool`):
            If true, the value for the relevant type of chat or the forum chat is used instead of disable\_pinned\_message\_notifications

        disable_pinned_message_notifications (:class:`bool`):
            If true, notifications for incoming pinned messages will be created as for an ordinary unread message

        use_default_disable_mention_notifications (:class:`bool`):
            If true, the value for the relevant type of chat or the forum chat is used instead of disable\_mention\_notifications

        disable_mention_notifications (:class:`bool`):
            If true, notifications for messages with mentions will be created as for an ordinary unread message

    """

    def __init__(
        self,
        use_default_mute_for: bool = False,
        mute_for: int = 0,
        use_default_sound: bool = False,
        sound_id: int = 0,
        use_default_show_preview: bool = False,
        show_preview: bool = False,
        use_default_mute_stories: bool = False,
        mute_stories: bool = False,
        use_default_story_sound: bool = False,
        story_sound_id: int = 0,
        use_default_show_story_sender: bool = False,
        show_story_sender: bool = False,
        use_default_disable_pinned_message_notifications: bool = False,
        disable_pinned_message_notifications: bool = False,
        use_default_disable_mention_notifications: bool = False,
        disable_mention_notifications: bool = False,
    ) -> None:
        self.use_default_mute_for: bool = bool(use_default_mute_for)
        r"""If true, the value for the relevant type of chat or the forum chat is used instead of mute\_for"""
        self.mute_for: int = int(mute_for)
        r"""Time left before notifications will be unmuted, in seconds"""
        self.use_default_sound: bool = bool(use_default_sound)
        r"""If true, the value for the relevant type of chat or the forum chat is used instead of sound\_id"""
        self.sound_id: int = int(sound_id)
        r"""Identifier of the notification sound to be played for messages; 0 if sound is disabled"""
        self.use_default_show_preview: bool = bool(use_default_show_preview)
        r"""If true, the value for the relevant type of chat or the forum chat is used instead of show\_preview"""
        self.show_preview: bool = bool(show_preview)
        r"""True, if message content must be displayed in notifications"""
        self.use_default_mute_stories: bool = bool(use_default_mute_stories)
        r"""If true, the value for the relevant type of chat is used instead of mute\_stories"""
        self.mute_stories: bool = bool(mute_stories)
        r"""True, if story notifications are disabled for the chat"""
        self.use_default_story_sound: bool = bool(use_default_story_sound)
        r"""If true, the value for the relevant type of chat is used instead of story\_sound\_id"""
        self.story_sound_id: int = int(story_sound_id)
        r"""Identifier of the notification sound to be played for stories; 0 if sound is disabled"""
        self.use_default_show_story_sender: bool = bool(use_default_show_story_sender)
        r"""If true, the value for the relevant type of chat is used instead of show\_story\_sender"""
        self.show_story_sender: bool = bool(show_story_sender)
        r"""True, if the sender of stories must be displayed in notifications"""
        self.use_default_disable_pinned_message_notifications: bool = bool(
            use_default_disable_pinned_message_notifications
        )
        r"""If true, the value for the relevant type of chat or the forum chat is used instead of disable\_pinned\_message\_notifications"""
        self.disable_pinned_message_notifications: bool = bool(
            disable_pinned_message_notifications
        )
        r"""If true, notifications for incoming pinned messages will be created as for an ordinary unread message"""
        self.use_default_disable_mention_notifications: bool = bool(
            use_default_disable_mention_notifications
        )
        r"""If true, the value for the relevant type of chat or the forum chat is used instead of disable\_mention\_notifications"""
        self.disable_mention_notifications: bool = bool(disable_mention_notifications)
        r"""If true, notifications for messages with mentions will be created as for an ordinary unread message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatNotificationSettings"]:
        return "chatNotificationSettings"

    def getClass(self) -> Literal["ChatNotificationSettings"]:
        return "ChatNotificationSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "use_default_mute_for": self.use_default_mute_for,
            "mute_for": self.mute_for,
            "use_default_sound": self.use_default_sound,
            "sound_id": self.sound_id,
            "use_default_show_preview": self.use_default_show_preview,
            "show_preview": self.show_preview,
            "use_default_mute_stories": self.use_default_mute_stories,
            "mute_stories": self.mute_stories,
            "use_default_story_sound": self.use_default_story_sound,
            "story_sound_id": self.story_sound_id,
            "use_default_show_story_sender": self.use_default_show_story_sender,
            "show_story_sender": self.show_story_sender,
            "use_default_disable_pinned_message_notifications": self.use_default_disable_pinned_message_notifications,
            "disable_pinned_message_notifications": self.disable_pinned_message_notifications,
            "use_default_disable_mention_notifications": self.use_default_disable_mention_notifications,
            "disable_mention_notifications": self.disable_mention_notifications,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatNotificationSettings", None]:
        if data:
            data_class = cls()
            data_class.use_default_mute_for = data.get("use_default_mute_for", False)
            data_class.mute_for = int(data.get("mute_for", 0))
            data_class.use_default_sound = data.get("use_default_sound", False)
            data_class.sound_id = int(data.get("sound_id", 0))
            data_class.use_default_show_preview = data.get(
                "use_default_show_preview", False
            )
            data_class.show_preview = data.get("show_preview", False)
            data_class.use_default_mute_stories = data.get(
                "use_default_mute_stories", False
            )
            data_class.mute_stories = data.get("mute_stories", False)
            data_class.use_default_story_sound = data.get(
                "use_default_story_sound", False
            )
            data_class.story_sound_id = int(data.get("story_sound_id", 0))
            data_class.use_default_show_story_sender = data.get(
                "use_default_show_story_sender", False
            )
            data_class.show_story_sender = data.get("show_story_sender", False)
            data_class.use_default_disable_pinned_message_notifications = data.get(
                "use_default_disable_pinned_message_notifications", False
            )
            data_class.disable_pinned_message_notifications = data.get(
                "disable_pinned_message_notifications", False
            )
            data_class.use_default_disable_mention_notifications = data.get(
                "use_default_disable_mention_notifications", False
            )
            data_class.disable_mention_notifications = data.get(
                "disable_mention_notifications", False
            )

        return data_class


class ScopeNotificationSettings(TlObject):
    r"""Contains information about notification settings for several chats

    Parameters:
        mute_for (:class:`int`):
            Time left before notifications will be unmuted, in seconds

        sound_id (:class:`int`):
            Identifier of the notification sound to be played; 0 if sound is disabled

        show_preview (:class:`bool`):
            True, if message content must be displayed in notifications

        use_default_mute_stories (:class:`bool`):
            If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute\_stories

        mute_stories (:class:`bool`):
            True, if story notifications are disabled

        story_sound_id (:class:`int`):
            Identifier of the notification sound to be played for stories; 0 if sound is disabled

        show_story_sender (:class:`bool`):
            True, if the sender of stories must be displayed in notifications

        disable_pinned_message_notifications (:class:`bool`):
            True, if notifications for incoming pinned messages will be created as for an ordinary unread message

        disable_mention_notifications (:class:`bool`):
            True, if notifications for messages with mentions will be created as for an ordinary unread message

    """

    def __init__(
        self,
        mute_for: int = 0,
        sound_id: int = 0,
        show_preview: bool = False,
        use_default_mute_stories: bool = False,
        mute_stories: bool = False,
        story_sound_id: int = 0,
        show_story_sender: bool = False,
        disable_pinned_message_notifications: bool = False,
        disable_mention_notifications: bool = False,
    ) -> None:
        self.mute_for: int = int(mute_for)
        r"""Time left before notifications will be unmuted, in seconds"""
        self.sound_id: int = int(sound_id)
        r"""Identifier of the notification sound to be played; 0 if sound is disabled"""
        self.show_preview: bool = bool(show_preview)
        r"""True, if message content must be displayed in notifications"""
        self.use_default_mute_stories: bool = bool(use_default_mute_stories)
        r"""If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute\_stories"""
        self.mute_stories: bool = bool(mute_stories)
        r"""True, if story notifications are disabled"""
        self.story_sound_id: int = int(story_sound_id)
        r"""Identifier of the notification sound to be played for stories; 0 if sound is disabled"""
        self.show_story_sender: bool = bool(show_story_sender)
        r"""True, if the sender of stories must be displayed in notifications"""
        self.disable_pinned_message_notifications: bool = bool(
            disable_pinned_message_notifications
        )
        r"""True, if notifications for incoming pinned messages will be created as for an ordinary unread message"""
        self.disable_mention_notifications: bool = bool(disable_mention_notifications)
        r"""True, if notifications for messages with mentions will be created as for an ordinary unread message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["scopeNotificationSettings"]:
        return "scopeNotificationSettings"

    def getClass(self) -> Literal["ScopeNotificationSettings"]:
        return "ScopeNotificationSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "mute_for": self.mute_for,
            "sound_id": self.sound_id,
            "show_preview": self.show_preview,
            "use_default_mute_stories": self.use_default_mute_stories,
            "mute_stories": self.mute_stories,
            "story_sound_id": self.story_sound_id,
            "show_story_sender": self.show_story_sender,
            "disable_pinned_message_notifications": self.disable_pinned_message_notifications,
            "disable_mention_notifications": self.disable_mention_notifications,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ScopeNotificationSettings", None]:
        if data:
            data_class = cls()
            data_class.mute_for = int(data.get("mute_for", 0))
            data_class.sound_id = int(data.get("sound_id", 0))
            data_class.show_preview = data.get("show_preview", False)
            data_class.use_default_mute_stories = data.get(
                "use_default_mute_stories", False
            )
            data_class.mute_stories = data.get("mute_stories", False)
            data_class.story_sound_id = int(data.get("story_sound_id", 0))
            data_class.show_story_sender = data.get("show_story_sender", False)
            data_class.disable_pinned_message_notifications = data.get(
                "disable_pinned_message_notifications", False
            )
            data_class.disable_mention_notifications = data.get(
                "disable_mention_notifications", False
            )

        return data_class


class ReactionNotificationSourceNone(TlObject, ReactionNotificationSource):
    r"""Notifications for reactions are disabled"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionNotificationSourceNone"]:
        return "reactionNotificationSourceNone"

    def getClass(self) -> Literal["ReactionNotificationSource"]:
        return "ReactionNotificationSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionNotificationSourceNone", None]:
        if data:
            data_class = cls()

        return data_class


class ReactionNotificationSourceContacts(TlObject, ReactionNotificationSource):
    r"""Notifications for reactions are shown only for reactions from contacts"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionNotificationSourceContacts"]:
        return "reactionNotificationSourceContacts"

    def getClass(self) -> Literal["ReactionNotificationSource"]:
        return "ReactionNotificationSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionNotificationSourceContacts", None]:
        if data:
            data_class = cls()

        return data_class


class ReactionNotificationSourceAll(TlObject, ReactionNotificationSource):
    r"""Notifications for reactions are shown for all reactions"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionNotificationSourceAll"]:
        return "reactionNotificationSourceAll"

    def getClass(self) -> Literal["ReactionNotificationSource"]:
        return "ReactionNotificationSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionNotificationSourceAll", None]:
        if data:
            data_class = cls()

        return data_class


class ReactionNotificationSettings(TlObject):
    r"""Contains information about notification settings for reactions

    Parameters:
        message_reaction_source (:class:`"types.ReactionNotificationSource"`):
            Source of message reactions for which notifications are shown

        story_reaction_source (:class:`"types.ReactionNotificationSource"`):
            Source of story reactions for which notifications are shown

        sound_id (:class:`int`):
            Identifier of the notification sound to be played; 0 if sound is disabled

        show_preview (:class:`bool`):
            True, if reaction sender and emoji must be displayed in notifications

    """

    def __init__(
        self,
        message_reaction_source: ReactionNotificationSource = None,
        story_reaction_source: ReactionNotificationSource = None,
        sound_id: int = 0,
        show_preview: bool = False,
    ) -> None:
        self.message_reaction_source: Union[
            ReactionNotificationSourceNone,
            ReactionNotificationSourceContacts,
            ReactionNotificationSourceAll,
            None,
        ] = message_reaction_source
        r"""Source of message reactions for which notifications are shown"""
        self.story_reaction_source: Union[
            ReactionNotificationSourceNone,
            ReactionNotificationSourceContacts,
            ReactionNotificationSourceAll,
            None,
        ] = story_reaction_source
        r"""Source of story reactions for which notifications are shown"""
        self.sound_id: int = int(sound_id)
        r"""Identifier of the notification sound to be played; 0 if sound is disabled"""
        self.show_preview: bool = bool(show_preview)
        r"""True, if reaction sender and emoji must be displayed in notifications"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionNotificationSettings"]:
        return "reactionNotificationSettings"

    def getClass(self) -> Literal["ReactionNotificationSettings"]:
        return "ReactionNotificationSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_reaction_source": self.message_reaction_source,
            "story_reaction_source": self.story_reaction_source,
            "sound_id": self.sound_id,
            "show_preview": self.show_preview,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionNotificationSettings", None]:
        if data:
            data_class = cls()
            data_class.message_reaction_source = data.get(
                "message_reaction_source", None
            )
            data_class.story_reaction_source = data.get("story_reaction_source", None)
            data_class.sound_id = int(data.get("sound_id", 0))
            data_class.show_preview = data.get("show_preview", False)

        return data_class


class DraftMessage(TlObject):
    r"""Contains information about a message draft

    Parameters:
        reply_to (:class:`"types.InputMessageReplyTo"`):
            Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the draft was created

        input_message_text (:class:`"types.InputMessageContent"`):
            Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote, or inputMessageVoiceNote

        effect_id (:class:`int`):
            Identifier of the effect to apply to the message when it is sent; 0 if none

    """

    def __init__(
        self,
        reply_to: InputMessageReplyTo = None,
        date: int = 0,
        input_message_text: InputMessageContent = None,
        effect_id: int = 0,
    ) -> None:
        self.reply_to: Union[
            InputMessageReplyToMessage,
            InputMessageReplyToExternalMessage,
            InputMessageReplyToStory,
            None,
        ] = reply_to
        r"""Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the draft was created"""
        self.input_message_text: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_text
        r"""Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote, or inputMessageVoiceNote"""
        self.effect_id: int = int(effect_id)
        r"""Identifier of the effect to apply to the message when it is sent; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["draftMessage"]:
        return "draftMessage"

    def getClass(self) -> Literal["DraftMessage"]:
        return "DraftMessage"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reply_to": self.reply_to,
            "date": self.date,
            "input_message_text": self.input_message_text,
            "effect_id": self.effect_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DraftMessage", None]:
        if data:
            data_class = cls()
            data_class.reply_to = data.get("reply_to", None)
            data_class.date = int(data.get("date", 0))
            data_class.input_message_text = data.get("input_message_text", None)
            data_class.effect_id = int(data.get("effect_id", 0))

        return data_class


class ChatTypePrivate(TlObject, ChatType):
    r"""An ordinary chat with a user

    Parameters:
        user_id (:class:`int`):
            User identifier

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatTypePrivate"]:
        return "chatTypePrivate"

    def getClass(self) -> Literal["ChatType"]:
        return "ChatType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatTypePrivate", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class ChatTypeBasicGroup(TlObject, ChatType):
    r"""A basic group \(a chat with 0\-200 other users\)

    Parameters:
        basic_group_id (:class:`int`):
            Basic group identifier

    """

    def __init__(self, basic_group_id: int = 0) -> None:
        self.basic_group_id: int = int(basic_group_id)
        r"""Basic group identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatTypeBasicGroup"]:
        return "chatTypeBasicGroup"

    def getClass(self) -> Literal["ChatType"]:
        return "ChatType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "basic_group_id": self.basic_group_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatTypeBasicGroup", None]:
        if data:
            data_class = cls()
            data_class.basic_group_id = int(data.get("basic_group_id", 0))

        return data_class


class ChatTypeSupergroup(TlObject, ChatType):
    r"""A supergroup or channel \(with unlimited members\)

    Parameters:
        supergroup_id (:class:`int`):
            Supergroup or channel identifier

        is_channel (:class:`bool`):
            True, if the supergroup is a channel

    """

    def __init__(self, supergroup_id: int = 0, is_channel: bool = False) -> None:
        self.supergroup_id: int = int(supergroup_id)
        r"""Supergroup or channel identifier"""
        self.is_channel: bool = bool(is_channel)
        r"""True, if the supergroup is a channel"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatTypeSupergroup"]:
        return "chatTypeSupergroup"

    def getClass(self) -> Literal["ChatType"]:
        return "ChatType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "supergroup_id": self.supergroup_id,
            "is_channel": self.is_channel,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatTypeSupergroup", None]:
        if data:
            data_class = cls()
            data_class.supergroup_id = int(data.get("supergroup_id", 0))
            data_class.is_channel = data.get("is_channel", False)

        return data_class


class ChatTypeSecret(TlObject, ChatType):
    r"""A secret chat with a user

    Parameters:
        secret_chat_id (:class:`int`):
            Secret chat identifier

        user_id (:class:`int`):
            User identifier of the other user in the secret chat

    """

    def __init__(self, secret_chat_id: int = 0, user_id: int = 0) -> None:
        self.secret_chat_id: int = int(secret_chat_id)
        r"""Secret chat identifier"""
        self.user_id: int = int(user_id)
        r"""User identifier of the other user in the secret chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatTypeSecret"]:
        return "chatTypeSecret"

    def getClass(self) -> Literal["ChatType"]:
        return "ChatType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "secret_chat_id": self.secret_chat_id,
            "user_id": self.user_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatTypeSecret", None]:
        if data:
            data_class = cls()
            data_class.secret_chat_id = int(data.get("secret_chat_id", 0))
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class ChatFolderIcon(TlObject):
    r"""Represents an icon for a chat folder

    Parameters:
        name (:class:`str`):
            The chosen icon name for short folder representation; one of \"All\", \"Unread\", \"Unmuted\", \"Bots\", \"Channels\", \"Groups\", \"Private\", \"Custom\", \"Setup\", \"Cat\", \"Crown\", \"Favorite\", \"Flower\", \"Game\", \"Home\", \"Love\", \"Mask\", \"Party\", \"Sport\", \"Study\", \"Trade\", \"Travel\", \"Work\", \"Airplane\", \"Book\", \"Light\", \"Like\", \"Money\", \"Note\", \"Palette\"

    """

    def __init__(self, name: str = "") -> None:
        self.name: Union[str, None] = name
        r"""The chosen icon name for short folder representation; one of \"All\", \"Unread\", \"Unmuted\", \"Bots\", \"Channels\", \"Groups\", \"Private\", \"Custom\", \"Setup\", \"Cat\", \"Crown\", \"Favorite\", \"Flower\", \"Game\", \"Home\", \"Love\", \"Mask\", \"Party\", \"Sport\", \"Study\", \"Trade\", \"Travel\", \"Work\", \"Airplane\", \"Book\", \"Light\", \"Like\", \"Money\", \"Note\", \"Palette\""""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatFolderIcon"]:
        return "chatFolderIcon"

    def getClass(self) -> Literal["ChatFolderIcon"]:
        return "ChatFolderIcon"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatFolderIcon", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")

        return data_class


class ChatFolderName(TlObject):
    r"""Describes name of a chat folder

    Parameters:
        text (:class:`"types.FormattedText"`):
            The text of the chat folder name; 1\-12 characters without line feeds\. May contain only CustomEmoji entities

        animate_custom_emoji (:class:`bool`):
            True, if custom emoji in the name must be animated

    """

    def __init__(
        self, text: FormattedText = None, animate_custom_emoji: bool = False
    ) -> None:
        self.text: Union[FormattedText, None] = text
        r"""The text of the chat folder name; 1\-12 characters without line feeds\. May contain only CustomEmoji entities"""
        self.animate_custom_emoji: bool = bool(animate_custom_emoji)
        r"""True, if custom emoji in the name must be animated"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatFolderName"]:
        return "chatFolderName"

    def getClass(self) -> Literal["ChatFolderName"]:
        return "ChatFolderName"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "animate_custom_emoji": self.animate_custom_emoji,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatFolderName", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.animate_custom_emoji = data.get("animate_custom_emoji", False)

        return data_class


class ChatFolder(TlObject):
    r"""Represents a folder for user chats

    Parameters:
        name (:class:`"types.ChatFolderName"`):
            The name of the folder

        icon (:class:`"types.ChatFolderIcon"`):
            The chosen icon for the chat folder; may be null\. If null, use getChatFolderDefaultIconName to get default icon name for the folder

        color_id (:class:`int`):
            The identifier of the chosen color for the chat folder icon; from \-1 to 6\. If \-1, then color is disabled\. Can't be changed if folder tags are disabled or the current user doesn't have Telegram Premium subscription

        is_shareable (:class:`bool`):
            True, if at least one link has been created for the folder

        pinned_chat_ids (:class:`List[int]`):
            The chat identifiers of pinned chats in the folder\. There can be up to getOption\(\"chat\_folder\_chosen\_chat\_count\_max\"\) pinned and always included non\-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium

        included_chat_ids (:class:`List[int]`):
            The chat identifiers of always included chats in the folder\. There can be up to getOption\(\"chat\_folder\_chosen\_chat\_count\_max\"\) pinned and always included non\-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium

        excluded_chat_ids (:class:`List[int]`):
            The chat identifiers of always excluded chats in the folder\. There can be up to getOption\(\"chat\_folder\_chosen\_chat\_count\_max\"\) always excluded non\-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium

        exclude_muted (:class:`bool`):
            True, if muted chats need to be excluded

        exclude_read (:class:`bool`):
            True, if read chats need to be excluded

        exclude_archived (:class:`bool`):
            True, if archived chats need to be excluded

        include_contacts (:class:`bool`):
            True, if contacts need to be included

        include_non_contacts (:class:`bool`):
            True, if non\-contact users need to be included

        include_bots (:class:`bool`):
            True, if bots need to be included

        include_groups (:class:`bool`):
            True, if basic groups and supergroups need to be included

        include_channels (:class:`bool`):
            True, if channels need to be included

    """

    def __init__(
        self,
        name: ChatFolderName = None,
        icon: ChatFolderIcon = None,
        color_id: int = 0,
        is_shareable: bool = False,
        pinned_chat_ids: List[int] = None,
        included_chat_ids: List[int] = None,
        excluded_chat_ids: List[int] = None,
        exclude_muted: bool = False,
        exclude_read: bool = False,
        exclude_archived: bool = False,
        include_contacts: bool = False,
        include_non_contacts: bool = False,
        include_bots: bool = False,
        include_groups: bool = False,
        include_channels: bool = False,
    ) -> None:
        self.name: Union[ChatFolderName, None] = name
        r"""The name of the folder"""
        self.icon: Union[ChatFolderIcon, None] = icon
        r"""The chosen icon for the chat folder; may be null\. If null, use getChatFolderDefaultIconName to get default icon name for the folder"""
        self.color_id: int = int(color_id)
        r"""The identifier of the chosen color for the chat folder icon; from \-1 to 6\. If \-1, then color is disabled\. Can't be changed if folder tags are disabled or the current user doesn't have Telegram Premium subscription"""
        self.is_shareable: bool = bool(is_shareable)
        r"""True, if at least one link has been created for the folder"""
        self.pinned_chat_ids: List[int] = pinned_chat_ids or []
        r"""The chat identifiers of pinned chats in the folder\. There can be up to getOption\(\"chat\_folder\_chosen\_chat\_count\_max\"\) pinned and always included non\-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium"""
        self.included_chat_ids: List[int] = included_chat_ids or []
        r"""The chat identifiers of always included chats in the folder\. There can be up to getOption\(\"chat\_folder\_chosen\_chat\_count\_max\"\) pinned and always included non\-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium"""
        self.excluded_chat_ids: List[int] = excluded_chat_ids or []
        r"""The chat identifiers of always excluded chats in the folder\. There can be up to getOption\(\"chat\_folder\_chosen\_chat\_count\_max\"\) always excluded non\-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium"""
        self.exclude_muted: bool = bool(exclude_muted)
        r"""True, if muted chats need to be excluded"""
        self.exclude_read: bool = bool(exclude_read)
        r"""True, if read chats need to be excluded"""
        self.exclude_archived: bool = bool(exclude_archived)
        r"""True, if archived chats need to be excluded"""
        self.include_contacts: bool = bool(include_contacts)
        r"""True, if contacts need to be included"""
        self.include_non_contacts: bool = bool(include_non_contacts)
        r"""True, if non\-contact users need to be included"""
        self.include_bots: bool = bool(include_bots)
        r"""True, if bots need to be included"""
        self.include_groups: bool = bool(include_groups)
        r"""True, if basic groups and supergroups need to be included"""
        self.include_channels: bool = bool(include_channels)
        r"""True, if channels need to be included"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatFolder"]:
        return "chatFolder"

    def getClass(self) -> Literal["ChatFolder"]:
        return "ChatFolder"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "icon": self.icon,
            "color_id": self.color_id,
            "is_shareable": self.is_shareable,
            "pinned_chat_ids": self.pinned_chat_ids,
            "included_chat_ids": self.included_chat_ids,
            "excluded_chat_ids": self.excluded_chat_ids,
            "exclude_muted": self.exclude_muted,
            "exclude_read": self.exclude_read,
            "exclude_archived": self.exclude_archived,
            "include_contacts": self.include_contacts,
            "include_non_contacts": self.include_non_contacts,
            "include_bots": self.include_bots,
            "include_groups": self.include_groups,
            "include_channels": self.include_channels,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatFolder", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", None)
            data_class.icon = data.get("icon", None)
            data_class.color_id = int(data.get("color_id", 0))
            data_class.is_shareable = data.get("is_shareable", False)
            data_class.pinned_chat_ids = data.get("pinned_chat_ids", None)
            data_class.included_chat_ids = data.get("included_chat_ids", None)
            data_class.excluded_chat_ids = data.get("excluded_chat_ids", None)
            data_class.exclude_muted = data.get("exclude_muted", False)
            data_class.exclude_read = data.get("exclude_read", False)
            data_class.exclude_archived = data.get("exclude_archived", False)
            data_class.include_contacts = data.get("include_contacts", False)
            data_class.include_non_contacts = data.get("include_non_contacts", False)
            data_class.include_bots = data.get("include_bots", False)
            data_class.include_groups = data.get("include_groups", False)
            data_class.include_channels = data.get("include_channels", False)

        return data_class


class ChatFolderInfo(TlObject):
    r"""Contains basic information about a chat folder

    Parameters:
        id (:class:`int`):
            Unique chat folder identifier

        name (:class:`"types.ChatFolderName"`):
            The name of the folder

        icon (:class:`"types.ChatFolderIcon"`):
            The chosen or default icon for the chat folder

        color_id (:class:`int`):
            The identifier of the chosen color for the chat folder icon; from \-1 to 6\. If \-1, then color is disabled

        is_shareable (:class:`bool`):
            True, if at least one link has been created for the folder

        has_my_invite_links (:class:`bool`):
            True, if the chat folder has invite links created by the current user

    """

    def __init__(
        self,
        id: int = 0,
        name: ChatFolderName = None,
        icon: ChatFolderIcon = None,
        color_id: int = 0,
        is_shareable: bool = False,
        has_my_invite_links: bool = False,
    ) -> None:
        self.id: int = int(id)
        r"""Unique chat folder identifier"""
        self.name: Union[ChatFolderName, None] = name
        r"""The name of the folder"""
        self.icon: Union[ChatFolderIcon, None] = icon
        r"""The chosen or default icon for the chat folder"""
        self.color_id: int = int(color_id)
        r"""The identifier of the chosen color for the chat folder icon; from \-1 to 6\. If \-1, then color is disabled"""
        self.is_shareable: bool = bool(is_shareable)
        r"""True, if at least one link has been created for the folder"""
        self.has_my_invite_links: bool = bool(has_my_invite_links)
        r"""True, if the chat folder has invite links created by the current user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatFolderInfo"]:
        return "chatFolderInfo"

    def getClass(self) -> Literal["ChatFolderInfo"]:
        return "ChatFolderInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "name": self.name,
            "icon": self.icon,
            "color_id": self.color_id,
            "is_shareable": self.is_shareable,
            "has_my_invite_links": self.has_my_invite_links,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatFolderInfo", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.name = data.get("name", None)
            data_class.icon = data.get("icon", None)
            data_class.color_id = int(data.get("color_id", 0))
            data_class.is_shareable = data.get("is_shareable", False)
            data_class.has_my_invite_links = data.get("has_my_invite_links", False)

        return data_class


class ChatFolderInviteLink(TlObject):
    r"""Contains a chat folder invite link

    Parameters:
        invite_link (:class:`str`):
            The chat folder invite link

        name (:class:`str`):
            Name of the link

        chat_ids (:class:`List[int]`):
            Identifiers of chats, included in the link

    """

    def __init__(
        self, invite_link: str = "", name: str = "", chat_ids: List[int] = None
    ) -> None:
        self.invite_link: Union[str, None] = invite_link
        r"""The chat folder invite link"""
        self.name: Union[str, None] = name
        r"""Name of the link"""
        self.chat_ids: List[int] = chat_ids or []
        r"""Identifiers of chats, included in the link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatFolderInviteLink"]:
        return "chatFolderInviteLink"

    def getClass(self) -> Literal["ChatFolderInviteLink"]:
        return "ChatFolderInviteLink"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "invite_link": self.invite_link,
            "name": self.name,
            "chat_ids": self.chat_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatFolderInviteLink", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", "")
            data_class.name = data.get("name", "")
            data_class.chat_ids = data.get("chat_ids", None)

        return data_class


class ChatFolderInviteLinks(TlObject):
    r"""Represents a list of chat folder invite links

    Parameters:
        invite_links (:class:`List["types.ChatFolderInviteLink"]`):
            List of the invite links

    """

    def __init__(self, invite_links: List[ChatFolderInviteLink] = None) -> None:
        self.invite_links: List[ChatFolderInviteLink] = invite_links or []
        r"""List of the invite links"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatFolderInviteLinks"]:
        return "chatFolderInviteLinks"

    def getClass(self) -> Literal["ChatFolderInviteLinks"]:
        return "ChatFolderInviteLinks"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invite_links": self.invite_links}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatFolderInviteLinks", None]:
        if data:
            data_class = cls()
            data_class.invite_links = data.get("invite_links", None)

        return data_class


class ChatFolderInviteLinkInfo(TlObject):
    r"""Contains information about an invite link to a chat folder

    Parameters:
        chat_folder_info (:class:`"types.ChatFolderInfo"`):
            Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet

        missing_chat_ids (:class:`List[int]`):
            Identifiers of the chats from the link, which aren't added to the folder yet

        added_chat_ids (:class:`List[int]`):
            Identifiers of the chats from the link, which are added to the folder already

    """

    def __init__(
        self,
        chat_folder_info: ChatFolderInfo = None,
        missing_chat_ids: List[int] = None,
        added_chat_ids: List[int] = None,
    ) -> None:
        self.chat_folder_info: Union[ChatFolderInfo, None] = chat_folder_info
        r"""Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet"""
        self.missing_chat_ids: List[int] = missing_chat_ids or []
        r"""Identifiers of the chats from the link, which aren't added to the folder yet"""
        self.added_chat_ids: List[int] = added_chat_ids or []
        r"""Identifiers of the chats from the link, which are added to the folder already"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatFolderInviteLinkInfo"]:
        return "chatFolderInviteLinkInfo"

    def getClass(self) -> Literal["ChatFolderInviteLinkInfo"]:
        return "ChatFolderInviteLinkInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_folder_info": self.chat_folder_info,
            "missing_chat_ids": self.missing_chat_ids,
            "added_chat_ids": self.added_chat_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatFolderInviteLinkInfo", None]:
        if data:
            data_class = cls()
            data_class.chat_folder_info = data.get("chat_folder_info", None)
            data_class.missing_chat_ids = data.get("missing_chat_ids", None)
            data_class.added_chat_ids = data.get("added_chat_ids", None)

        return data_class


class RecommendedChatFolder(TlObject):
    r"""Describes a recommended chat folder

    Parameters:
        folder (:class:`"types.ChatFolder"`):
            The chat folder

        description (:class:`str`):
            Chat folder description

    """

    def __init__(self, folder: ChatFolder = None, description: str = "") -> None:
        self.folder: Union[ChatFolder, None] = folder
        r"""The chat folder"""
        self.description: Union[str, None] = description
        r"""Chat folder description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["recommendedChatFolder"]:
        return "recommendedChatFolder"

    def getClass(self) -> Literal["RecommendedChatFolder"]:
        return "RecommendedChatFolder"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "folder": self.folder,
            "description": self.description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RecommendedChatFolder", None]:
        if data:
            data_class = cls()
            data_class.folder = data.get("folder", None)
            data_class.description = data.get("description", "")

        return data_class


class RecommendedChatFolders(TlObject):
    r"""Contains a list of recommended chat folders

    Parameters:
        chat_folders (:class:`List["types.RecommendedChatFolder"]`):
            List of recommended chat folders

    """

    def __init__(self, chat_folders: List[RecommendedChatFolder] = None) -> None:
        self.chat_folders: List[RecommendedChatFolder] = chat_folders or []
        r"""List of recommended chat folders"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["recommendedChatFolders"]:
        return "recommendedChatFolders"

    def getClass(self) -> Literal["RecommendedChatFolders"]:
        return "RecommendedChatFolders"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_folders": self.chat_folders}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RecommendedChatFolders", None]:
        if data:
            data_class = cls()
            data_class.chat_folders = data.get("chat_folders", None)

        return data_class


class ArchiveChatListSettings(TlObject):
    r"""Contains settings for automatic moving of chats to and from the Archive chat lists

    Parameters:
        archive_and_mute_new_chats_from_unknown_users (:class:`bool`):
            True, if new chats from non\-contacts will be automatically archived and muted\. Can be set to true only if the option \"can\_archive\_and\_mute\_new\_chats\_from\_unknown\_users\" is true

        keep_unmuted_chats_archived (:class:`bool`):
            True, if unmuted chats will be kept in the Archive chat list when they get a new message

        keep_chats_from_folders_archived (:class:`bool`):
            True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message\. Ignored if keep\_unmuted\_chats\_archived \=\= true

    """

    def __init__(
        self,
        archive_and_mute_new_chats_from_unknown_users: bool = False,
        keep_unmuted_chats_archived: bool = False,
        keep_chats_from_folders_archived: bool = False,
    ) -> None:
        self.archive_and_mute_new_chats_from_unknown_users: bool = bool(
            archive_and_mute_new_chats_from_unknown_users
        )
        r"""True, if new chats from non\-contacts will be automatically archived and muted\. Can be set to true only if the option \"can\_archive\_and\_mute\_new\_chats\_from\_unknown\_users\" is true"""
        self.keep_unmuted_chats_archived: bool = bool(keep_unmuted_chats_archived)
        r"""True, if unmuted chats will be kept in the Archive chat list when they get a new message"""
        self.keep_chats_from_folders_archived: bool = bool(
            keep_chats_from_folders_archived
        )
        r"""True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message\. Ignored if keep\_unmuted\_chats\_archived \=\= true"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["archiveChatListSettings"]:
        return "archiveChatListSettings"

    def getClass(self) -> Literal["ArchiveChatListSettings"]:
        return "ArchiveChatListSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "archive_and_mute_new_chats_from_unknown_users": self.archive_and_mute_new_chats_from_unknown_users,
            "keep_unmuted_chats_archived": self.keep_unmuted_chats_archived,
            "keep_chats_from_folders_archived": self.keep_chats_from_folders_archived,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ArchiveChatListSettings", None]:
        if data:
            data_class = cls()
            data_class.archive_and_mute_new_chats_from_unknown_users = data.get(
                "archive_and_mute_new_chats_from_unknown_users", False
            )
            data_class.keep_unmuted_chats_archived = data.get(
                "keep_unmuted_chats_archived", False
            )
            data_class.keep_chats_from_folders_archived = data.get(
                "keep_chats_from_folders_archived", False
            )

        return data_class


class ChatListMain(TlObject, ChatList):
    r"""A main list of chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatListMain"]:
        return "chatListMain"

    def getClass(self) -> Literal["ChatList"]:
        return "ChatList"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatListMain", None]:
        if data:
            data_class = cls()

        return data_class


class ChatListArchive(TlObject, ChatList):
    r"""A list of chats usually located at the top of the main chat list\. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatListArchive"]:
        return "chatListArchive"

    def getClass(self) -> Literal["ChatList"]:
        return "ChatList"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatListArchive", None]:
        if data:
            data_class = cls()

        return data_class


class ChatListFolder(TlObject, ChatList):
    r"""A list of chats added to a chat folder

    Parameters:
        chat_folder_id (:class:`int`):
            Chat folder identifier

    """

    def __init__(self, chat_folder_id: int = 0) -> None:
        self.chat_folder_id: int = int(chat_folder_id)
        r"""Chat folder identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatListFolder"]:
        return "chatListFolder"

    def getClass(self) -> Literal["ChatList"]:
        return "ChatList"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_folder_id": self.chat_folder_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatListFolder", None]:
        if data:
            data_class = cls()
            data_class.chat_folder_id = int(data.get("chat_folder_id", 0))

        return data_class


class ChatLists(TlObject):
    r"""Contains a list of chat lists

    Parameters:
        chat_lists (:class:`List["types.ChatList"]`):
            List of chat lists

    """

    def __init__(self, chat_lists: List[ChatList] = None) -> None:
        self.chat_lists: List[ChatList] = chat_lists or []
        r"""List of chat lists"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatLists"]:
        return "chatLists"

    def getClass(self) -> Literal["ChatLists"]:
        return "ChatLists"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_lists": self.chat_lists}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatLists", None]:
        if data:
            data_class = cls()
            data_class.chat_lists = data.get("chat_lists", None)

        return data_class


class ChatSourceMtprotoProxy(TlObject, ChatSource):
    r"""The chat is sponsored by the user's MTProxy server"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatSourceMtprotoProxy"]:
        return "chatSourceMtprotoProxy"

    def getClass(self) -> Literal["ChatSource"]:
        return "ChatSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatSourceMtprotoProxy", None]:
        if data:
            data_class = cls()

        return data_class


class ChatSourcePublicServiceAnnouncement(TlObject, ChatSource):
    r"""The chat contains a public service announcement

    Parameters:
        type (:class:`str`):
            The type of the announcement

        text (:class:`str`):
            The text of the announcement

    """

    def __init__(self, type: str = "", text: str = "") -> None:
        self.type: Union[str, None] = type
        r"""The type of the announcement"""
        self.text: Union[str, None] = text
        r"""The text of the announcement"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatSourcePublicServiceAnnouncement"]:
        return "chatSourcePublicServiceAnnouncement"

    def getClass(self) -> Literal["ChatSource"]:
        return "ChatSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "type": self.type, "text": self.text}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatSourcePublicServiceAnnouncement", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", "")
            data_class.text = data.get("text", "")

        return data_class


class ChatPosition(TlObject):
    r"""Describes a position of a chat in a chat list

    Parameters:
        list (:class:`"types.ChatList"`):
            The chat list

        order (:class:`int`):
            A parameter used to determine order of the chat in the chat list\. Chats must be sorted by the pair \(order, chat\.id\) in descending order

        is_pinned (:class:`bool`):
            True, if the chat is pinned in the chat list

        source (:class:`"types.ChatSource"`):
            Source of the chat in the chat list; may be null

    """

    def __init__(
        self,
        list: ChatList = None,
        order: int = 0,
        is_pinned: bool = False,
        source: ChatSource = None,
    ) -> None:
        self.list: Union[ChatListMain, ChatListArchive, ChatListFolder, None] = list
        r"""The chat list"""
        self.order: int = int(order)
        r"""A parameter used to determine order of the chat in the chat list\. Chats must be sorted by the pair \(order, chat\.id\) in descending order"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the chat is pinned in the chat list"""
        self.source: Union[
            ChatSourceMtprotoProxy, ChatSourcePublicServiceAnnouncement, None
        ] = source
        r"""Source of the chat in the chat list; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatPosition"]:
        return "chatPosition"

    def getClass(self) -> Literal["ChatPosition"]:
        return "ChatPosition"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "list": self.list,
            "order": self.order,
            "is_pinned": self.is_pinned,
            "source": self.source,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatPosition", None]:
        if data:
            data_class = cls()
            data_class.list = data.get("list", None)
            data_class.order = int(data.get("order", 0))
            data_class.is_pinned = data.get("is_pinned", False)
            data_class.source = data.get("source", None)

        return data_class


class ChatAvailableReactionsAll(TlObject, ChatAvailableReactions):
    r"""All reactions are available in the chat, excluding the paid reaction and custom reactions in channel chats

    Parameters:
        max_reaction_count (:class:`int`):
            The maximum allowed number of reactions per message; 1\-11

    """

    def __init__(self, max_reaction_count: int = 0) -> None:
        self.max_reaction_count: int = int(max_reaction_count)
        r"""The maximum allowed number of reactions per message; 1\-11"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatAvailableReactionsAll"]:
        return "chatAvailableReactionsAll"

    def getClass(self) -> Literal["ChatAvailableReactions"]:
        return "ChatAvailableReactions"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "max_reaction_count": self.max_reaction_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatAvailableReactionsAll", None]:
        if data:
            data_class = cls()
            data_class.max_reaction_count = int(data.get("max_reaction_count", 0))

        return data_class


class ChatAvailableReactionsSome(TlObject, ChatAvailableReactions):
    r"""Only specific reactions are available in the chat

    Parameters:
        reactions (:class:`List["types.ReactionType"]`):
            The list of reactions

        max_reaction_count (:class:`int`):
            The maximum allowed number of reactions per message; 1\-11

    """

    def __init__(
        self, reactions: List[ReactionType] = None, max_reaction_count: int = 0
    ) -> None:
        self.reactions: List[ReactionType] = reactions or []
        r"""The list of reactions"""
        self.max_reaction_count: int = int(max_reaction_count)
        r"""The maximum allowed number of reactions per message; 1\-11"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatAvailableReactionsSome"]:
        return "chatAvailableReactionsSome"

    def getClass(self) -> Literal["ChatAvailableReactions"]:
        return "ChatAvailableReactions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reactions": self.reactions,
            "max_reaction_count": self.max_reaction_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatAvailableReactionsSome", None]:
        if data:
            data_class = cls()
            data_class.reactions = data.get("reactions", None)
            data_class.max_reaction_count = int(data.get("max_reaction_count", 0))

        return data_class


class SavedMessagesTag(TlObject):
    r"""Represents a tag used in Saved Messages or a Saved Messages topic

    Parameters:
        tag (:class:`"types.ReactionType"`):
            The tag

        label (:class:`str`):
            Label of the tag; 0\-12 characters\. Always empty if the tag is returned for a Saved Messages topic

        count (:class:`int`):
            Number of times the tag was used; may be 0 if the tag has non\-empty label

    """

    def __init__(
        self, tag: ReactionType = None, label: str = "", count: int = 0
    ) -> None:
        self.tag: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = tag
        r"""The tag"""
        self.label: Union[str, None] = label
        r"""Label of the tag; 0\-12 characters\. Always empty if the tag is returned for a Saved Messages topic"""
        self.count: int = int(count)
        r"""Number of times the tag was used; may be 0 if the tag has non\-empty label"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["savedMessagesTag"]:
        return "savedMessagesTag"

    def getClass(self) -> Literal["SavedMessagesTag"]:
        return "SavedMessagesTag"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "tag": self.tag,
            "label": self.label,
            "count": self.count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SavedMessagesTag", None]:
        if data:
            data_class = cls()
            data_class.tag = data.get("tag", None)
            data_class.label = data.get("label", "")
            data_class.count = int(data.get("count", 0))

        return data_class


class SavedMessagesTags(TlObject):
    r"""Contains a list of tags used in Saved Messages

    Parameters:
        tags (:class:`List["types.SavedMessagesTag"]`):
            List of tags

    """

    def __init__(self, tags: List[SavedMessagesTag] = None) -> None:
        self.tags: List[SavedMessagesTag] = tags or []
        r"""List of tags"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["savedMessagesTags"]:
        return "savedMessagesTags"

    def getClass(self) -> Literal["SavedMessagesTags"]:
        return "SavedMessagesTags"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "tags": self.tags}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SavedMessagesTags", None]:
        if data:
            data_class = cls()
            data_class.tags = data.get("tags", None)

        return data_class


class BusinessBotManageBar(TlObject):
    r"""Contains information about a business bot that manages the chat

    Parameters:
        bot_user_id (:class:`int`):
            User identifier of the bot

        manage_url (:class:`str`):
            URL to be opened to manage the bot

        is_bot_paused (:class:`bool`):
            True, if the bot is paused\. Use toggleBusinessConnectedBotChatIsPaused to change the value of the field

        can_bot_reply (:class:`bool`):
            True, if the bot can reply

    """

    def __init__(
        self,
        bot_user_id: int = 0,
        manage_url: str = "",
        is_bot_paused: bool = False,
        can_bot_reply: bool = False,
    ) -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of the bot"""
        self.manage_url: Union[str, None] = manage_url
        r"""URL to be opened to manage the bot"""
        self.is_bot_paused: bool = bool(is_bot_paused)
        r"""True, if the bot is paused\. Use toggleBusinessConnectedBotChatIsPaused to change the value of the field"""
        self.can_bot_reply: bool = bool(can_bot_reply)
        r"""True, if the bot can reply"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessBotManageBar"]:
        return "businessBotManageBar"

    def getClass(self) -> Literal["BusinessBotManageBar"]:
        return "BusinessBotManageBar"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "manage_url": self.manage_url,
            "is_bot_paused": self.is_bot_paused,
            "can_bot_reply": self.can_bot_reply,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessBotManageBar", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.manage_url = data.get("manage_url", "")
            data_class.is_bot_paused = data.get("is_bot_paused", False)
            data_class.can_bot_reply = data.get("can_bot_reply", False)

        return data_class


class VideoChat(TlObject):
    r"""Describes a video chat

    Parameters:
        group_call_id (:class:`int`):
            Group call identifier of an active video chat; 0 if none\. Full information about the video chat can be received through the method getGroupCall

        has_participants (:class:`bool`):
            True, if the video chat has participants

        default_participant_id (:class:`"types.MessageSender"`):
            Default group call participant identifier to join the video chat; may be null

    """

    def __init__(
        self,
        group_call_id: int = 0,
        has_participants: bool = False,
        default_participant_id: MessageSender = None,
    ) -> None:
        self.group_call_id: int = int(group_call_id)
        r"""Group call identifier of an active video chat; 0 if none\. Full information about the video chat can be received through the method getGroupCall"""
        self.has_participants: bool = bool(has_participants)
        r"""True, if the video chat has participants"""
        self.default_participant_id: Union[
            MessageSenderUser, MessageSenderChat, None
        ] = default_participant_id
        r"""Default group call participant identifier to join the video chat; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["videoChat"]:
        return "videoChat"

    def getClass(self) -> Literal["VideoChat"]:
        return "VideoChat"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "group_call_id": self.group_call_id,
            "has_participants": self.has_participants,
            "default_participant_id": self.default_participant_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["VideoChat", None]:
        if data:
            data_class = cls()
            data_class.group_call_id = int(data.get("group_call_id", 0))
            data_class.has_participants = data.get("has_participants", False)
            data_class.default_participant_id = data.get("default_participant_id", None)

        return data_class


class Chat(TlObject):
    r"""A chat\. \(Can be a private chat, basic group, supergroup, or secret chat\)

    Parameters:
        id (:class:`int`):
            Chat unique identifier

        type (:class:`"types.ChatType"`):
            Type of the chat

        title (:class:`str`):
            Chat title

        photo (:class:`"types.ChatPhotoInfo"`):
            Chat photo; may be null

        accent_color_id (:class:`int`):
            Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview

        background_custom_emoji_id (:class:`int`):
            Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none

        profile_accent_color_id (:class:`int`):
            Identifier of the profile accent color for the chat's profile; \-1 if none

        profile_background_custom_emoji_id (:class:`int`):
            Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none

        permissions (:class:`"types.ChatPermissions"`):
            Actions that non\-administrator chat members are allowed to take in the chat

        last_message (:class:`"types.Message"`):
            Last message in the chat; may be null if none or unknown

        positions (:class:`List["types.ChatPosition"]`):
            Positions of the chat in chat lists

        chat_lists (:class:`List["types.ChatList"]`):
            Chat lists to which the chat belongs\. A chat can have a non\-zero position in a chat list even it doesn't belong to the chat list and have no position in a chat list even it belongs to the chat list

        message_sender_id (:class:`"types.MessageSender"`):
            Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender

        block_list (:class:`"types.BlockList"`):
            Block list to which the chat is added; may be null if none

        has_protected_content (:class:`bool`):
            True, if chat content can't be saved locally, forwarded, or copied

        is_translatable (:class:`bool`):
            True, if translation of all messages in the chat must be suggested to the user

        is_marked_as_unread (:class:`bool`):
            True, if the chat is marked as unread

        view_as_topics (:class:`bool`):
            True, if the chat is a forum supergroup that must be shown in the \"View as topics\" mode, or Saved Messages chat that must be shown in the \"View as chats\"

        has_scheduled_messages (:class:`bool`):
            True, if the chat has scheduled messages

        can_be_deleted_only_for_self (:class:`bool`):
            True, if the chat messages can be deleted only for the current user while other users will continue to see the messages

        can_be_deleted_for_all_users (:class:`bool`):
            True, if the chat messages can be deleted for all users

        can_be_reported (:class:`bool`):
            True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto

        default_disable_notification (:class:`bool`):
            Default value of the disable\_notification parameter, used when a message is sent to the chat

        unread_count (:class:`int`):
            Number of unread messages in the chat

        last_read_inbox_message_id (:class:`int`):
            Identifier of the last read incoming message

        last_read_outbox_message_id (:class:`int`):
            Identifier of the last read outgoing message

        unread_mention_count (:class:`int`):
            Number of unread messages with a mention/reply in the chat

        unread_reaction_count (:class:`int`):
            Number of messages with unread reactions in the chat

        notification_settings (:class:`"types.ChatNotificationSettings"`):
            Notification settings for the chat

        available_reactions (:class:`"types.ChatAvailableReactions"`):
            Types of reaction, available in the chat

        message_auto_delete_time (:class:`int`):
            Current message auto\-delete or self\-destruct timer setting for the chat, in seconds; 0 if disabled\. Self\-destruct timer in secret chats starts after the message or its content is viewed\. Auto\-delete timer in other chats starts from the send date

        emoji_status (:class:`"types.EmojiStatus"`):
            Emoji status to be shown along with chat title; may be null

        background (:class:`"types.ChatBackground"`):
            Background set for the chat; may be null if none

        theme_name (:class:`str`):
            If non\-empty, name of a theme, set for the chat

        action_bar (:class:`"types.ChatActionBar"`):
            Information about actions which must be possible to do through the chat action bar; may be null if none

        business_bot_manage_bar (:class:`"types.BusinessBotManageBar"`):
            Information about bar for managing a business bot in the chat; may be null if none

        video_chat (:class:`"types.VideoChat"`):
            Information about video chat of the chat

        pending_join_requests (:class:`"types.ChatJoinRequestsInfo"`):
            Information about pending join requests; may be null if none

        reply_markup_message_id (:class:`int`):
            Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat

        draft_message (:class:`"types.DraftMessage"`):
            A draft of a message in the chat; may be null if none

        client_data (:class:`str`):
            Application\-specific data associated with the chat\. \(For example, the chat scroll position or local chat notification settings can be stored here\.\) Persistent if the message database is used

    """

    def __init__(
        self,
        id: int = 0,
        type: ChatType = None,
        title: str = "",
        photo: ChatPhotoInfo = None,
        accent_color_id: int = 0,
        background_custom_emoji_id: int = 0,
        profile_accent_color_id: int = 0,
        profile_background_custom_emoji_id: int = 0,
        permissions: ChatPermissions = None,
        last_message: Message = None,
        positions: List[ChatPosition] = None,
        chat_lists: List[ChatList] = None,
        message_sender_id: MessageSender = None,
        block_list: BlockList = None,
        has_protected_content: bool = False,
        is_translatable: bool = False,
        is_marked_as_unread: bool = False,
        view_as_topics: bool = False,
        has_scheduled_messages: bool = False,
        can_be_deleted_only_for_self: bool = False,
        can_be_deleted_for_all_users: bool = False,
        can_be_reported: bool = False,
        default_disable_notification: bool = False,
        unread_count: int = 0,
        last_read_inbox_message_id: int = 0,
        last_read_outbox_message_id: int = 0,
        unread_mention_count: int = 0,
        unread_reaction_count: int = 0,
        notification_settings: ChatNotificationSettings = None,
        available_reactions: ChatAvailableReactions = None,
        message_auto_delete_time: int = 0,
        emoji_status: EmojiStatus = None,
        background: ChatBackground = None,
        theme_name: str = "",
        action_bar: ChatActionBar = None,
        business_bot_manage_bar: BusinessBotManageBar = None,
        video_chat: VideoChat = None,
        pending_join_requests: ChatJoinRequestsInfo = None,
        reply_markup_message_id: int = 0,
        draft_message: DraftMessage = None,
        client_data: str = "",
    ) -> None:
        self.id: int = int(id)
        r"""Chat unique identifier"""
        self.type: Union[
            ChatTypePrivate,
            ChatTypeBasicGroup,
            ChatTypeSupergroup,
            ChatTypeSecret,
            None,
        ] = type
        r"""Type of the chat"""
        self.title: Union[str, None] = title
        r"""Chat title"""
        self.photo: Union[ChatPhotoInfo, None] = photo
        r"""Chat photo; may be null"""
        self.accent_color_id: int = int(accent_color_id)
        r"""Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview"""
        self.background_custom_emoji_id: int = int(background_custom_emoji_id)
        r"""Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none"""
        self.profile_accent_color_id: int = int(profile_accent_color_id)
        r"""Identifier of the profile accent color for the chat's profile; \-1 if none"""
        self.profile_background_custom_emoji_id: int = int(
            profile_background_custom_emoji_id
        )
        r"""Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none"""
        self.permissions: Union[ChatPermissions, None] = permissions
        r"""Actions that non\-administrator chat members are allowed to take in the chat"""
        self.last_message: Union[Message, None] = last_message
        r"""Last message in the chat; may be null if none or unknown"""
        self.positions: List[ChatPosition] = positions or []
        r"""Positions of the chat in chat lists"""
        self.chat_lists: List[ChatList] = chat_lists or []
        r"""Chat lists to which the chat belongs\. A chat can have a non\-zero position in a chat list even it doesn't belong to the chat list and have no position in a chat list even it belongs to the chat list"""
        self.message_sender_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            message_sender_id
        )
        r"""Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender"""
        self.block_list: Union[BlockListMain, BlockListStories, None] = block_list
        r"""Block list to which the chat is added; may be null if none"""
        self.has_protected_content: bool = bool(has_protected_content)
        r"""True, if chat content can't be saved locally, forwarded, or copied"""
        self.is_translatable: bool = bool(is_translatable)
        r"""True, if translation of all messages in the chat must be suggested to the user"""
        self.is_marked_as_unread: bool = bool(is_marked_as_unread)
        r"""True, if the chat is marked as unread"""
        self.view_as_topics: bool = bool(view_as_topics)
        r"""True, if the chat is a forum supergroup that must be shown in the \"View as topics\" mode, or Saved Messages chat that must be shown in the \"View as chats\""""
        self.has_scheduled_messages: bool = bool(has_scheduled_messages)
        r"""True, if the chat has scheduled messages"""
        self.can_be_deleted_only_for_self: bool = bool(can_be_deleted_only_for_self)
        r"""True, if the chat messages can be deleted only for the current user while other users will continue to see the messages"""
        self.can_be_deleted_for_all_users: bool = bool(can_be_deleted_for_all_users)
        r"""True, if the chat messages can be deleted for all users"""
        self.can_be_reported: bool = bool(can_be_reported)
        r"""True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto"""
        self.default_disable_notification: bool = bool(default_disable_notification)
        r"""Default value of the disable\_notification parameter, used when a message is sent to the chat"""
        self.unread_count: int = int(unread_count)
        r"""Number of unread messages in the chat"""
        self.last_read_inbox_message_id: int = int(last_read_inbox_message_id)
        r"""Identifier of the last read incoming message"""
        self.last_read_outbox_message_id: int = int(last_read_outbox_message_id)
        r"""Identifier of the last read outgoing message"""
        self.unread_mention_count: int = int(unread_mention_count)
        r"""Number of unread messages with a mention/reply in the chat"""
        self.unread_reaction_count: int = int(unread_reaction_count)
        r"""Number of messages with unread reactions in the chat"""
        self.notification_settings: Union[ChatNotificationSettings, None] = (
            notification_settings
        )
        r"""Notification settings for the chat"""
        self.available_reactions: Union[
            ChatAvailableReactionsAll, ChatAvailableReactionsSome, None
        ] = available_reactions
        r"""Types of reaction, available in the chat"""
        self.message_auto_delete_time: int = int(message_auto_delete_time)
        r"""Current message auto\-delete or self\-destruct timer setting for the chat, in seconds; 0 if disabled\. Self\-destruct timer in secret chats starts after the message or its content is viewed\. Auto\-delete timer in other chats starts from the send date"""
        self.emoji_status: Union[EmojiStatus, None] = emoji_status
        r"""Emoji status to be shown along with chat title; may be null"""
        self.background: Union[ChatBackground, None] = background
        r"""Background set for the chat; may be null if none"""
        self.theme_name: Union[str, None] = theme_name
        r"""If non\-empty, name of a theme, set for the chat"""
        self.action_bar: Union[
            ChatActionBarReportSpam,
            ChatActionBarInviteMembers,
            ChatActionBarReportAddBlock,
            ChatActionBarAddContact,
            ChatActionBarSharePhoneNumber,
            ChatActionBarJoinRequest,
            None,
        ] = action_bar
        r"""Information about actions which must be possible to do through the chat action bar; may be null if none"""
        self.business_bot_manage_bar: Union[BusinessBotManageBar, None] = (
            business_bot_manage_bar
        )
        r"""Information about bar for managing a business bot in the chat; may be null if none"""
        self.video_chat: Union[VideoChat, None] = video_chat
        r"""Information about video chat of the chat"""
        self.pending_join_requests: Union[ChatJoinRequestsInfo, None] = (
            pending_join_requests
        )
        r"""Information about pending join requests; may be null if none"""
        self.reply_markup_message_id: int = int(reply_markup_message_id)
        r"""Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat"""
        self.draft_message: Union[DraftMessage, None] = draft_message
        r"""A draft of a message in the chat; may be null if none"""
        self.client_data: Union[str, None] = client_data
        r"""Application\-specific data associated with the chat\. \(For example, the chat scroll position or local chat notification settings can be stored here\.\) Persistent if the message database is used"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chat"]:
        return "chat"

    def getClass(self) -> Literal["Chat"]:
        return "Chat"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "type": self.type,
            "title": self.title,
            "photo": self.photo,
            "accent_color_id": self.accent_color_id,
            "background_custom_emoji_id": self.background_custom_emoji_id,
            "profile_accent_color_id": self.profile_accent_color_id,
            "profile_background_custom_emoji_id": self.profile_background_custom_emoji_id,
            "permissions": self.permissions,
            "last_message": self.last_message,
            "positions": self.positions,
            "chat_lists": self.chat_lists,
            "message_sender_id": self.message_sender_id,
            "block_list": self.block_list,
            "has_protected_content": self.has_protected_content,
            "is_translatable": self.is_translatable,
            "is_marked_as_unread": self.is_marked_as_unread,
            "view_as_topics": self.view_as_topics,
            "has_scheduled_messages": self.has_scheduled_messages,
            "can_be_deleted_only_for_self": self.can_be_deleted_only_for_self,
            "can_be_deleted_for_all_users": self.can_be_deleted_for_all_users,
            "can_be_reported": self.can_be_reported,
            "default_disable_notification": self.default_disable_notification,
            "unread_count": self.unread_count,
            "last_read_inbox_message_id": self.last_read_inbox_message_id,
            "last_read_outbox_message_id": self.last_read_outbox_message_id,
            "unread_mention_count": self.unread_mention_count,
            "unread_reaction_count": self.unread_reaction_count,
            "notification_settings": self.notification_settings,
            "available_reactions": self.available_reactions,
            "message_auto_delete_time": self.message_auto_delete_time,
            "emoji_status": self.emoji_status,
            "background": self.background,
            "theme_name": self.theme_name,
            "action_bar": self.action_bar,
            "business_bot_manage_bar": self.business_bot_manage_bar,
            "video_chat": self.video_chat,
            "pending_join_requests": self.pending_join_requests,
            "reply_markup_message_id": self.reply_markup_message_id,
            "draft_message": self.draft_message,
            "client_data": self.client_data,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Chat", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.type = data.get("type", None)
            data_class.title = data.get("title", "")
            data_class.photo = data.get("photo", None)
            data_class.accent_color_id = int(data.get("accent_color_id", 0))
            data_class.background_custom_emoji_id = int(
                data.get("background_custom_emoji_id", 0)
            )
            data_class.profile_accent_color_id = int(
                data.get("profile_accent_color_id", 0)
            )
            data_class.profile_background_custom_emoji_id = int(
                data.get("profile_background_custom_emoji_id", 0)
            )
            data_class.permissions = data.get("permissions", None)
            data_class.last_message = data.get("last_message", None)
            data_class.positions = data.get("positions", None)
            data_class.chat_lists = data.get("chat_lists", None)
            data_class.message_sender_id = data.get("message_sender_id", None)
            data_class.block_list = data.get("block_list", None)
            data_class.has_protected_content = data.get("has_protected_content", False)
            data_class.is_translatable = data.get("is_translatable", False)
            data_class.is_marked_as_unread = data.get("is_marked_as_unread", False)
            data_class.view_as_topics = data.get("view_as_topics", False)
            data_class.has_scheduled_messages = data.get(
                "has_scheduled_messages", False
            )
            data_class.can_be_deleted_only_for_self = data.get(
                "can_be_deleted_only_for_self", False
            )
            data_class.can_be_deleted_for_all_users = data.get(
                "can_be_deleted_for_all_users", False
            )
            data_class.can_be_reported = data.get("can_be_reported", False)
            data_class.default_disable_notification = data.get(
                "default_disable_notification", False
            )
            data_class.unread_count = int(data.get("unread_count", 0))
            data_class.last_read_inbox_message_id = int(
                data.get("last_read_inbox_message_id", 0)
            )
            data_class.last_read_outbox_message_id = int(
                data.get("last_read_outbox_message_id", 0)
            )
            data_class.unread_mention_count = int(data.get("unread_mention_count", 0))
            data_class.unread_reaction_count = int(data.get("unread_reaction_count", 0))
            data_class.notification_settings = data.get("notification_settings", None)
            data_class.available_reactions = data.get("available_reactions", None)
            data_class.message_auto_delete_time = int(
                data.get("message_auto_delete_time", 0)
            )
            data_class.emoji_status = data.get("emoji_status", None)
            data_class.background = data.get("background", None)
            data_class.theme_name = data.get("theme_name", "")
            data_class.action_bar = data.get("action_bar", None)
            data_class.business_bot_manage_bar = data.get(
                "business_bot_manage_bar", None
            )
            data_class.video_chat = data.get("video_chat", None)
            data_class.pending_join_requests = data.get("pending_join_requests", None)
            data_class.reply_markup_message_id = int(
                data.get("reply_markup_message_id", 0)
            )
            data_class.draft_message = data.get("draft_message", None)
            data_class.client_data = data.get("client_data", "")

        return data_class


class Chats(TlObject):
    r"""Represents a list of chats

    Parameters:
        total_count (:class:`int`):
            Approximate total number of chats found

        chat_ids (:class:`List[int]`):
            List of chat identifiers

    """

    def __init__(self, total_count: int = 0, chat_ids: List[int] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of chats found"""
        self.chat_ids: List[int] = chat_ids or []
        r"""List of chat identifiers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chats"]:
        return "chats"

    def getClass(self) -> Literal["Chats"]:
        return "Chats"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "chat_ids": self.chat_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Chats", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.chat_ids = data.get("chat_ids", None)

        return data_class


class FailedToAddMember(TlObject):
    r"""Contains information about a user that has failed to be added to a chat

    Parameters:
        user_id (:class:`int`):
            User identifier

        premium_would_allow_invite (:class:`bool`):
            True, if subscription to Telegram Premium would have allowed to add the user to the chat

        premium_required_to_send_messages (:class:`bool`):
            True, if subscription to Telegram Premium is required to send the user chat invite link

    """

    def __init__(
        self,
        user_id: int = 0,
        premium_would_allow_invite: bool = False,
        premium_required_to_send_messages: bool = False,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.premium_would_allow_invite: bool = bool(premium_would_allow_invite)
        r"""True, if subscription to Telegram Premium would have allowed to add the user to the chat"""
        self.premium_required_to_send_messages: bool = bool(
            premium_required_to_send_messages
        )
        r"""True, if subscription to Telegram Premium is required to send the user chat invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["failedToAddMember"]:
        return "failedToAddMember"

    def getClass(self) -> Literal["FailedToAddMember"]:
        return "FailedToAddMember"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "premium_would_allow_invite": self.premium_would_allow_invite,
            "premium_required_to_send_messages": self.premium_required_to_send_messages,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FailedToAddMember", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.premium_would_allow_invite = data.get(
                "premium_would_allow_invite", False
            )
            data_class.premium_required_to_send_messages = data.get(
                "premium_required_to_send_messages", False
            )

        return data_class


class FailedToAddMembers(TlObject):
    r"""Represents a list of users that has failed to be added to a chat

    Parameters:
        failed_to_add_members (:class:`List["types.FailedToAddMember"]`):
            Information about users that weren't added to the chat

    """

    def __init__(self, failed_to_add_members: List[FailedToAddMember] = None) -> None:
        self.failed_to_add_members: List[FailedToAddMember] = (
            failed_to_add_members or []
        )
        r"""Information about users that weren't added to the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["failedToAddMembers"]:
        return "failedToAddMembers"

    def getClass(self) -> Literal["FailedToAddMembers"]:
        return "FailedToAddMembers"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "failed_to_add_members": self.failed_to_add_members,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FailedToAddMembers", None]:
        if data:
            data_class = cls()
            data_class.failed_to_add_members = data.get("failed_to_add_members", None)

        return data_class


class CreatedBasicGroupChat(TlObject):
    r"""Contains information about a newly created basic group chat

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        failed_to_add_members (:class:`"types.FailedToAddMembers"`):
            Information about failed to add members

    """

    def __init__(
        self, chat_id: int = 0, failed_to_add_members: FailedToAddMembers = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.failed_to_add_members: Union[FailedToAddMembers, None] = (
            failed_to_add_members
        )
        r"""Information about failed to add members"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["createdBasicGroupChat"]:
        return "createdBasicGroupChat"

    def getClass(self) -> Literal["CreatedBasicGroupChat"]:
        return "CreatedBasicGroupChat"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "failed_to_add_members": self.failed_to_add_members,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CreatedBasicGroupChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.failed_to_add_members = data.get("failed_to_add_members", None)

        return data_class


class PublicChatTypeHasUsername(TlObject, PublicChatType):
    r"""The chat is public, because it has an active username"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["publicChatTypeHasUsername"]:
        return "publicChatTypeHasUsername"

    def getClass(self) -> Literal["PublicChatType"]:
        return "PublicChatType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PublicChatTypeHasUsername", None]:
        if data:
            data_class = cls()

        return data_class


class PublicChatTypeIsLocationBased(TlObject, PublicChatType):
    r"""The chat is public, because it is a location\-based supergroup"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["publicChatTypeIsLocationBased"]:
        return "publicChatTypeIsLocationBased"

    def getClass(self) -> Literal["PublicChatType"]:
        return "PublicChatType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PublicChatTypeIsLocationBased", None]:
        if data:
            data_class = cls()

        return data_class


class AccountInfo(TlObject):
    r"""Contains basic information about another user that started a chat with the current user

    Parameters:
        registration_month (:class:`int`):
            Month when the user was registered in Telegram; 0\-12; may be 0 if unknown

        registration_year (:class:`int`):
            Year when the user was registered in Telegram; 0\-9999; may be 0 if unknown

        phone_number_country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code based on the phone number of the user; may be empty if unknown

        last_name_change_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user changed name last time; 0 if unknown

        last_photo_change_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user changed photo last time; 0 if unknown

    """

    def __init__(
        self,
        registration_month: int = 0,
        registration_year: int = 0,
        phone_number_country_code: str = "",
        last_name_change_date: int = 0,
        last_photo_change_date: int = 0,
    ) -> None:
        self.registration_month: int = int(registration_month)
        r"""Month when the user was registered in Telegram; 0\-12; may be 0 if unknown"""
        self.registration_year: int = int(registration_year)
        r"""Year when the user was registered in Telegram; 0\-9999; may be 0 if unknown"""
        self.phone_number_country_code: Union[str, None] = phone_number_country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code based on the phone number of the user; may be empty if unknown"""
        self.last_name_change_date: int = int(last_name_change_date)
        r"""Point in time \(Unix timestamp\) when the user changed name last time; 0 if unknown"""
        self.last_photo_change_date: int = int(last_photo_change_date)
        r"""Point in time \(Unix timestamp\) when the user changed photo last time; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["accountInfo"]:
        return "accountInfo"

    def getClass(self) -> Literal["AccountInfo"]:
        return "AccountInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "registration_month": self.registration_month,
            "registration_year": self.registration_year,
            "phone_number_country_code": self.phone_number_country_code,
            "last_name_change_date": self.last_name_change_date,
            "last_photo_change_date": self.last_photo_change_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AccountInfo", None]:
        if data:
            data_class = cls()
            data_class.registration_month = int(data.get("registration_month", 0))
            data_class.registration_year = int(data.get("registration_year", 0))
            data_class.phone_number_country_code = data.get(
                "phone_number_country_code", ""
            )
            data_class.last_name_change_date = int(data.get("last_name_change_date", 0))
            data_class.last_photo_change_date = int(
                data.get("last_photo_change_date", 0)
            )

        return data_class


class ChatActionBarReportSpam(TlObject, ChatActionBar):
    r"""The chat can be reported as spam using the method reportChat with an empty option\_id and message\_ids\. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown

    Parameters:
        can_unarchive (:class:`bool`):
            If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings

    """

    def __init__(self, can_unarchive: bool = False) -> None:
        self.can_unarchive: bool = bool(can_unarchive)
        r"""If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionBarReportSpam"]:
        return "chatActionBarReportSpam"

    def getClass(self) -> Literal["ChatActionBar"]:
        return "ChatActionBar"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "can_unarchive": self.can_unarchive}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionBarReportSpam", None]:
        if data:
            data_class = cls()
            data_class.can_unarchive = data.get("can_unarchive", False)

        return data_class


class ChatActionBarInviteMembers(TlObject, ChatActionBar):
    r"""The chat is a recently created group chat to which new members can be invited"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionBarInviteMembers"]:
        return "chatActionBarInviteMembers"

    def getClass(self) -> Literal["ChatActionBar"]:
        return "ChatActionBar"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionBarInviteMembers", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionBarReportAddBlock(TlObject, ChatActionBar):
    r"""The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList, or the other user can be added to the contact list using the method addContact\. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown

    Parameters:
        can_unarchive (:class:`bool`):
            If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings

        account_info (:class:`"types.AccountInfo"`):
            Basic information about the other user in the chat; may be null if unknown

    """

    def __init__(
        self, can_unarchive: bool = False, account_info: AccountInfo = None
    ) -> None:
        self.can_unarchive: bool = bool(can_unarchive)
        r"""If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings"""
        self.account_info: Union[AccountInfo, None] = account_info
        r"""Basic information about the other user in the chat; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionBarReportAddBlock"]:
        return "chatActionBarReportAddBlock"

    def getClass(self) -> Literal["ChatActionBar"]:
        return "ChatActionBar"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "can_unarchive": self.can_unarchive,
            "account_info": self.account_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionBarReportAddBlock", None]:
        if data:
            data_class = cls()
            data_class.can_unarchive = data.get("can_unarchive", False)
            data_class.account_info = data.get("account_info", None)

        return data_class


class ChatActionBarAddContact(TlObject, ChatActionBar):
    r"""The chat is a private or secret chat and the other user can be added to the contact list using the method addContact"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionBarAddContact"]:
        return "chatActionBarAddContact"

    def getClass(self) -> Literal["ChatActionBar"]:
        return "ChatActionBar"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionBarAddContact", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionBarSharePhoneNumber(TlObject, ChatActionBar):
    r"""The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionBarSharePhoneNumber"]:
        return "chatActionBarSharePhoneNumber"

    def getClass(self) -> Literal["ChatActionBar"]:
        return "ChatActionBar"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionBarSharePhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionBarJoinRequest(TlObject, ChatActionBar):
    r"""The chat is a private chat with an administrator of a chat to which the user sent join request

    Parameters:
        title (:class:`str`):
            Title of the chat to which the join request was sent

        is_channel (:class:`bool`):
            True, if the join request was sent to a channel chat

        request_date (:class:`int`):
            Point in time \(Unix timestamp\) when the join request was sent

    """

    def __init__(
        self, title: str = "", is_channel: bool = False, request_date: int = 0
    ) -> None:
        self.title: Union[str, None] = title
        r"""Title of the chat to which the join request was sent"""
        self.is_channel: bool = bool(is_channel)
        r"""True, if the join request was sent to a channel chat"""
        self.request_date: int = int(request_date)
        r"""Point in time \(Unix timestamp\) when the join request was sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionBarJoinRequest"]:
        return "chatActionBarJoinRequest"

    def getClass(self) -> Literal["ChatActionBar"]:
        return "ChatActionBar"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "is_channel": self.is_channel,
            "request_date": self.request_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionBarJoinRequest", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.is_channel = data.get("is_channel", False)
            data_class.request_date = int(data.get("request_date", 0))

        return data_class


class KeyboardButtonTypeText(TlObject, KeyboardButtonType):
    r"""A simple button, with text that must be sent when the button is pressed"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButtonTypeText"]:
        return "keyboardButtonTypeText"

    def getClass(self) -> Literal["KeyboardButtonType"]:
        return "KeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["KeyboardButtonTypeText", None]:
        if data:
            data_class = cls()

        return data_class


class KeyboardButtonTypeRequestPhoneNumber(TlObject, KeyboardButtonType):
    r"""A button that sends the user's phone number when pressed; available only in private chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButtonTypeRequestPhoneNumber"]:
        return "keyboardButtonTypeRequestPhoneNumber"

    def getClass(self) -> Literal["KeyboardButtonType"]:
        return "KeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["KeyboardButtonTypeRequestPhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class KeyboardButtonTypeRequestLocation(TlObject, KeyboardButtonType):
    r"""A button that sends the user's location when pressed; available only in private chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButtonTypeRequestLocation"]:
        return "keyboardButtonTypeRequestLocation"

    def getClass(self) -> Literal["KeyboardButtonType"]:
        return "KeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["KeyboardButtonTypeRequestLocation", None]:
        if data:
            data_class = cls()

        return data_class


class KeyboardButtonTypeRequestPoll(TlObject, KeyboardButtonType):
    r"""A button that allows the user to create and send a poll when pressed; available only in private chats

    Parameters:
        force_regular (:class:`bool`):
            If true, only regular polls must be allowed to create

        force_quiz (:class:`bool`):
            If true, only polls in quiz mode must be allowed to create

    """

    def __init__(self, force_regular: bool = False, force_quiz: bool = False) -> None:
        self.force_regular: bool = bool(force_regular)
        r"""If true, only regular polls must be allowed to create"""
        self.force_quiz: bool = bool(force_quiz)
        r"""If true, only polls in quiz mode must be allowed to create"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButtonTypeRequestPoll"]:
        return "keyboardButtonTypeRequestPoll"

    def getClass(self) -> Literal["KeyboardButtonType"]:
        return "KeyboardButtonType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "force_regular": self.force_regular,
            "force_quiz": self.force_quiz,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["KeyboardButtonTypeRequestPoll", None]:
        if data:
            data_class = cls()
            data_class.force_regular = data.get("force_regular", False)
            data_class.force_quiz = data.get("force_quiz", False)

        return data_class


class KeyboardButtonTypeRequestUsers(TlObject, KeyboardButtonType):
    r"""A button that requests users to be shared by the current user; available only in private chats\. Use the method shareUsersWithBot to complete the request

    Parameters:
        id (:class:`int`):
            Unique button identifier

        restrict_user_is_bot (:class:`bool`):
            True, if the shared users must or must not be bots

        user_is_bot (:class:`bool`):
            True, if the shared users must be bots; otherwise, the shared users must not be bots\. Ignored if restrict\_user\_is\_bot is false

        restrict_user_is_premium (:class:`bool`):
            True, if the shared users must or must not be Telegram Premium users

        user_is_premium (:class:`bool`):
            True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users\. Ignored if restrict\_user\_is\_premium is false

        max_quantity (:class:`int`):
            The maximum number of users to share

        request_name (:class:`bool`):
            Pass true to request name of the users; bots only

        request_username (:class:`bool`):
            Pass true to request username of the users; bots only

        request_photo (:class:`bool`):
            Pass true to request photo of the users; bots only

    """

    def __init__(
        self,
        id: int = 0,
        restrict_user_is_bot: bool = False,
        user_is_bot: bool = False,
        restrict_user_is_premium: bool = False,
        user_is_premium: bool = False,
        max_quantity: int = 0,
        request_name: bool = False,
        request_username: bool = False,
        request_photo: bool = False,
    ) -> None:
        self.id: int = int(id)
        r"""Unique button identifier"""
        self.restrict_user_is_bot: bool = bool(restrict_user_is_bot)
        r"""True, if the shared users must or must not be bots"""
        self.user_is_bot: bool = bool(user_is_bot)
        r"""True, if the shared users must be bots; otherwise, the shared users must not be bots\. Ignored if restrict\_user\_is\_bot is false"""
        self.restrict_user_is_premium: bool = bool(restrict_user_is_premium)
        r"""True, if the shared users must or must not be Telegram Premium users"""
        self.user_is_premium: bool = bool(user_is_premium)
        r"""True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users\. Ignored if restrict\_user\_is\_premium is false"""
        self.max_quantity: int = int(max_quantity)
        r"""The maximum number of users to share"""
        self.request_name: bool = bool(request_name)
        r"""Pass true to request name of the users; bots only"""
        self.request_username: bool = bool(request_username)
        r"""Pass true to request username of the users; bots only"""
        self.request_photo: bool = bool(request_photo)
        r"""Pass true to request photo of the users; bots only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButtonTypeRequestUsers"]:
        return "keyboardButtonTypeRequestUsers"

    def getClass(self) -> Literal["KeyboardButtonType"]:
        return "KeyboardButtonType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "restrict_user_is_bot": self.restrict_user_is_bot,
            "user_is_bot": self.user_is_bot,
            "restrict_user_is_premium": self.restrict_user_is_premium,
            "user_is_premium": self.user_is_premium,
            "max_quantity": self.max_quantity,
            "request_name": self.request_name,
            "request_username": self.request_username,
            "request_photo": self.request_photo,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["KeyboardButtonTypeRequestUsers", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.restrict_user_is_bot = data.get("restrict_user_is_bot", False)
            data_class.user_is_bot = data.get("user_is_bot", False)
            data_class.restrict_user_is_premium = data.get(
                "restrict_user_is_premium", False
            )
            data_class.user_is_premium = data.get("user_is_premium", False)
            data_class.max_quantity = int(data.get("max_quantity", 0))
            data_class.request_name = data.get("request_name", False)
            data_class.request_username = data.get("request_username", False)
            data_class.request_photo = data.get("request_photo", False)

        return data_class


class KeyboardButtonTypeRequestChat(TlObject, KeyboardButtonType):
    r"""A button that requests a chat to be shared by the current user; available only in private chats\. Use the method shareChatWithBot to complete the request

    Parameters:
        id (:class:`int`):
            Unique button identifier

        chat_is_channel (:class:`bool`):
            True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared

        restrict_chat_is_forum (:class:`bool`):
            True, if the chat must or must not be a forum supergroup

        chat_is_forum (:class:`bool`):
            True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup\. Ignored if restrict\_chat\_is\_forum is false

        restrict_chat_has_username (:class:`bool`):
            True, if the chat must or must not have a username

        chat_has_username (:class:`bool`):
            True, if the chat must have a username; otherwise, the chat must not have a username\. Ignored if restrict\_chat\_has\_username is false

        chat_is_created (:class:`bool`):
            True, if the chat must be created by the current user

        user_administrator_rights (:class:`"types.ChatAdministratorRights"`):
            Expected user administrator rights in the chat; may be null if they aren't restricted

        bot_administrator_rights (:class:`"types.ChatAdministratorRights"`):
            Expected bot administrator rights in the chat; may be null if they aren't restricted

        bot_is_member (:class:`bool`):
            True, if the bot must be a member of the chat; for basic group and supergroup chats only

        request_title (:class:`bool`):
            Pass true to request title of the chat; bots only

        request_username (:class:`bool`):
            Pass true to request username of the chat; bots only

        request_photo (:class:`bool`):
            Pass true to request photo of the chat; bots only

    """

    def __init__(
        self,
        id: int = 0,
        chat_is_channel: bool = False,
        restrict_chat_is_forum: bool = False,
        chat_is_forum: bool = False,
        restrict_chat_has_username: bool = False,
        chat_has_username: bool = False,
        chat_is_created: bool = False,
        user_administrator_rights: ChatAdministratorRights = None,
        bot_administrator_rights: ChatAdministratorRights = None,
        bot_is_member: bool = False,
        request_title: bool = False,
        request_username: bool = False,
        request_photo: bool = False,
    ) -> None:
        self.id: int = int(id)
        r"""Unique button identifier"""
        self.chat_is_channel: bool = bool(chat_is_channel)
        r"""True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared"""
        self.restrict_chat_is_forum: bool = bool(restrict_chat_is_forum)
        r"""True, if the chat must or must not be a forum supergroup"""
        self.chat_is_forum: bool = bool(chat_is_forum)
        r"""True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup\. Ignored if restrict\_chat\_is\_forum is false"""
        self.restrict_chat_has_username: bool = bool(restrict_chat_has_username)
        r"""True, if the chat must or must not have a username"""
        self.chat_has_username: bool = bool(chat_has_username)
        r"""True, if the chat must have a username; otherwise, the chat must not have a username\. Ignored if restrict\_chat\_has\_username is false"""
        self.chat_is_created: bool = bool(chat_is_created)
        r"""True, if the chat must be created by the current user"""
        self.user_administrator_rights: Union[ChatAdministratorRights, None] = (
            user_administrator_rights
        )
        r"""Expected user administrator rights in the chat; may be null if they aren't restricted"""
        self.bot_administrator_rights: Union[ChatAdministratorRights, None] = (
            bot_administrator_rights
        )
        r"""Expected bot administrator rights in the chat; may be null if they aren't restricted"""
        self.bot_is_member: bool = bool(bot_is_member)
        r"""True, if the bot must be a member of the chat; for basic group and supergroup chats only"""
        self.request_title: bool = bool(request_title)
        r"""Pass true to request title of the chat; bots only"""
        self.request_username: bool = bool(request_username)
        r"""Pass true to request username of the chat; bots only"""
        self.request_photo: bool = bool(request_photo)
        r"""Pass true to request photo of the chat; bots only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButtonTypeRequestChat"]:
        return "keyboardButtonTypeRequestChat"

    def getClass(self) -> Literal["KeyboardButtonType"]:
        return "KeyboardButtonType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "chat_is_channel": self.chat_is_channel,
            "restrict_chat_is_forum": self.restrict_chat_is_forum,
            "chat_is_forum": self.chat_is_forum,
            "restrict_chat_has_username": self.restrict_chat_has_username,
            "chat_has_username": self.chat_has_username,
            "chat_is_created": self.chat_is_created,
            "user_administrator_rights": self.user_administrator_rights,
            "bot_administrator_rights": self.bot_administrator_rights,
            "bot_is_member": self.bot_is_member,
            "request_title": self.request_title,
            "request_username": self.request_username,
            "request_photo": self.request_photo,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["KeyboardButtonTypeRequestChat", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.chat_is_channel = data.get("chat_is_channel", False)
            data_class.restrict_chat_is_forum = data.get(
                "restrict_chat_is_forum", False
            )
            data_class.chat_is_forum = data.get("chat_is_forum", False)
            data_class.restrict_chat_has_username = data.get(
                "restrict_chat_has_username", False
            )
            data_class.chat_has_username = data.get("chat_has_username", False)
            data_class.chat_is_created = data.get("chat_is_created", False)
            data_class.user_administrator_rights = data.get(
                "user_administrator_rights", None
            )
            data_class.bot_administrator_rights = data.get(
                "bot_administrator_rights", None
            )
            data_class.bot_is_member = data.get("bot_is_member", False)
            data_class.request_title = data.get("request_title", False)
            data_class.request_username = data.get("request_username", False)
            data_class.request_photo = data.get("request_photo", False)

        return data_class


class KeyboardButtonTypeWebApp(TlObject, KeyboardButtonType):
    r"""A button that opens a Web App by calling getWebAppUrl

    Parameters:
        url (:class:`str`):
            An HTTP URL to pass to getWebAppUrl

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""An HTTP URL to pass to getWebAppUrl"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButtonTypeWebApp"]:
        return "keyboardButtonTypeWebApp"

    def getClass(self) -> Literal["KeyboardButtonType"]:
        return "KeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["KeyboardButtonTypeWebApp", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class KeyboardButton(TlObject):
    r"""Represents a single button in a bot keyboard

    Parameters:
        text (:class:`str`):
            Text of the button

        type (:class:`"types.KeyboardButtonType"`):
            Type of the button

    """

    def __init__(self, text: str = "", type: KeyboardButtonType = None) -> None:
        self.text: Union[str, None] = text
        r"""Text of the button"""
        self.type: Union[
            KeyboardButtonTypeText,
            KeyboardButtonTypeRequestPhoneNumber,
            KeyboardButtonTypeRequestLocation,
            KeyboardButtonTypeRequestPoll,
            KeyboardButtonTypeRequestUsers,
            KeyboardButtonTypeRequestChat,
            KeyboardButtonTypeWebApp,
            None,
        ] = type
        r"""Type of the button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["keyboardButton"]:
        return "keyboardButton"

    def getClass(self) -> Literal["KeyboardButton"]:
        return "KeyboardButton"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "type": self.type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["KeyboardButton", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.type = data.get("type", None)

        return data_class


class InlineKeyboardButtonTypeUrl(TlObject, InlineKeyboardButtonType):
    r"""A button that opens a specified URL

    Parameters:
        url (:class:`str`):
            HTTP or tg:// URL to open\. If the link is of the type internalLinkTypeWebApp, then the button must be marked as a Web App button

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""HTTP or tg:// URL to open\. If the link is of the type internalLinkTypeWebApp, then the button must be marked as a Web App button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeUrl"]:
        return "inlineKeyboardButtonTypeUrl"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButtonTypeUrl", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class InlineKeyboardButtonTypeLoginUrl(TlObject, InlineKeyboardButtonType):
    r"""A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo

    Parameters:
        url (:class:`str`):
            An HTTP URL to pass to getLoginUrlInfo

        id (:class:`int`):
            Unique button identifier

        forward_text (:class:`str`):
            If non\-empty, new text of the button in forwarded messages

    """

    def __init__(self, url: str = "", id: int = 0, forward_text: str = "") -> None:
        self.url: Union[str, None] = url
        r"""An HTTP URL to pass to getLoginUrlInfo"""
        self.id: int = int(id)
        r"""Unique button identifier"""
        self.forward_text: Union[str, None] = forward_text
        r"""If non\-empty, new text of the button in forwarded messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeLoginUrl"]:
        return "inlineKeyboardButtonTypeLoginUrl"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "id": self.id,
            "forward_text": self.forward_text,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButtonTypeLoginUrl", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.id = int(data.get("id", 0))
            data_class.forward_text = data.get("forward_text", "")

        return data_class


class InlineKeyboardButtonTypeWebApp(TlObject, InlineKeyboardButtonType):
    r"""A button that opens a Web App by calling openWebApp

    Parameters:
        url (:class:`str`):
            An HTTP URL to pass to openWebApp

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""An HTTP URL to pass to openWebApp"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeWebApp"]:
        return "inlineKeyboardButtonTypeWebApp"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButtonTypeWebApp", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class InlineKeyboardButtonTypeCallback(TlObject, InlineKeyboardButtonType):
    r"""A button that sends a callback query to a bot

    Parameters:
        data (:class:`bytes`):
            Data to be sent to the bot via a callback query

    """

    def __init__(self, data: bytes = b"") -> None:
        self.data: Union[bytes, None] = data
        r"""Data to be sent to the bot via a callback query"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeCallback"]:
        return "inlineKeyboardButtonTypeCallback"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "data": self.data}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButtonTypeCallback", None]:
        if data:
            data_class = cls()
            data_class.data = b64decode(data.get("data", b""))

        return data_class


class InlineKeyboardButtonTypeCallbackWithPassword(TlObject, InlineKeyboardButtonType):
    r"""A button that asks for the 2\-step verification password of the current user and then sends a callback query to a bot

    Parameters:
        data (:class:`bytes`):
            Data to be sent to the bot via a callback query

    """

    def __init__(self, data: bytes = b"") -> None:
        self.data: Union[bytes, None] = data
        r"""Data to be sent to the bot via a callback query"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeCallbackWithPassword"]:
        return "inlineKeyboardButtonTypeCallbackWithPassword"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "data": self.data}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InlineKeyboardButtonTypeCallbackWithPassword", None]:
        if data:
            data_class = cls()
            data_class.data = b64decode(data.get("data", b""))

        return data_class


class InlineKeyboardButtonTypeCallbackGame(TlObject, InlineKeyboardButtonType):
    r"""A button with a game that sends a callback query to a bot\. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeCallbackGame"]:
        return "inlineKeyboardButtonTypeCallbackGame"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InlineKeyboardButtonTypeCallbackGame", None]:
        if data:
            data_class = cls()

        return data_class


class InlineKeyboardButtonTypeSwitchInline(TlObject, InlineKeyboardButtonType):
    r"""A button that forces an inline query to the bot to be inserted in the input field

    Parameters:
        query (:class:`str`):
            Inline query to be sent to the bot

        target_chat (:class:`"types.TargetChat"`):
            Target chat from which to send the inline query

    """

    def __init__(self, query: str = "", target_chat: TargetChat = None) -> None:
        self.query: Union[str, None] = query
        r"""Inline query to be sent to the bot"""
        self.target_chat: Union[
            TargetChatCurrent, TargetChatChosen, TargetChatInternalLink, None
        ] = target_chat
        r"""Target chat from which to send the inline query"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeSwitchInline"]:
        return "inlineKeyboardButtonTypeSwitchInline"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "query": self.query,
            "target_chat": self.target_chat,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InlineKeyboardButtonTypeSwitchInline", None]:
        if data:
            data_class = cls()
            data_class.query = data.get("query", "")
            data_class.target_chat = data.get("target_chat", None)

        return data_class


class InlineKeyboardButtonTypeBuy(TlObject, InlineKeyboardButtonType):
    r"""A button to buy something\. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeBuy"]:
        return "inlineKeyboardButtonTypeBuy"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButtonTypeBuy", None]:
        if data:
            data_class = cls()

        return data_class


class InlineKeyboardButtonTypeUser(TlObject, InlineKeyboardButtonType):
    r"""A button with a user reference to be handled in the same way as textEntityTypeMentionName entities

    Parameters:
        user_id (:class:`int`):
            User identifier

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeUser"]:
        return "inlineKeyboardButtonTypeUser"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButtonTypeUser", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class InlineKeyboardButtonTypeCopyText(TlObject, InlineKeyboardButtonType):
    r"""A button that copies specified text to clipboard

    Parameters:
        text (:class:`str`):
            The text to copy to clipboard

    """

    def __init__(self, text: str = "") -> None:
        self.text: Union[str, None] = text
        r"""The text to copy to clipboard"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButtonTypeCopyText"]:
        return "inlineKeyboardButtonTypeCopyText"

    def getClass(self) -> Literal["InlineKeyboardButtonType"]:
        return "InlineKeyboardButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButtonTypeCopyText", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")

        return data_class


class InlineKeyboardButton(TlObject):
    r"""Represents a single button in an inline keyboard

    Parameters:
        text (:class:`str`):
            Text of the button

        type (:class:`"types.InlineKeyboardButtonType"`):
            Type of the button

    """

    def __init__(self, text: str = "", type: InlineKeyboardButtonType = None) -> None:
        self.text: Union[str, None] = text
        r"""Text of the button"""
        self.type: Union[
            InlineKeyboardButtonTypeUrl,
            InlineKeyboardButtonTypeLoginUrl,
            InlineKeyboardButtonTypeWebApp,
            InlineKeyboardButtonTypeCallback,
            InlineKeyboardButtonTypeCallbackWithPassword,
            InlineKeyboardButtonTypeCallbackGame,
            InlineKeyboardButtonTypeSwitchInline,
            InlineKeyboardButtonTypeBuy,
            InlineKeyboardButtonTypeUser,
            InlineKeyboardButtonTypeCopyText,
            None,
        ] = type
        r"""Type of the button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineKeyboardButton"]:
        return "inlineKeyboardButton"

    def getClass(self) -> Literal["InlineKeyboardButton"]:
        return "InlineKeyboardButton"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "type": self.type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineKeyboardButton", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.type = data.get("type", None)

        return data_class


class ReplyMarkupRemoveKeyboard(TlObject, ReplyMarkup):
    r"""Instructs application to remove the keyboard once this message has been received\. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message\_id \=\= 0 will be sent

    Parameters:
        is_personal (:class:`bool`):
            True, if the keyboard is removed only for the mentioned users or the target user of a reply

    """

    def __init__(self, is_personal: bool = False) -> None:
        self.is_personal: bool = bool(is_personal)
        r"""True, if the keyboard is removed only for the mentioned users or the target user of a reply"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["replyMarkupRemoveKeyboard"]:
        return "replyMarkupRemoveKeyboard"

    def getClass(self) -> Literal["ReplyMarkup"]:
        return "ReplyMarkup"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_personal": self.is_personal}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReplyMarkupRemoveKeyboard", None]:
        if data:
            data_class = cls()
            data_class.is_personal = data.get("is_personal", False)

        return data_class


class ReplyMarkupForceReply(TlObject, ReplyMarkup):
    r"""Instructs application to force a reply to this message

    Parameters:
        is_personal (:class:`bool`):
            True, if a forced reply must automatically be shown to the current user\. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply

        input_field_placeholder (:class:`str`):
            If non\-empty, the placeholder to be shown in the input field when the reply is active; 0\-64 characters

    """

    def __init__(
        self, is_personal: bool = False, input_field_placeholder: str = ""
    ) -> None:
        self.is_personal: bool = bool(is_personal)
        r"""True, if a forced reply must automatically be shown to the current user\. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply"""
        self.input_field_placeholder: Union[str, None] = input_field_placeholder
        r"""If non\-empty, the placeholder to be shown in the input field when the reply is active; 0\-64 characters"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["replyMarkupForceReply"]:
        return "replyMarkupForceReply"

    def getClass(self) -> Literal["ReplyMarkup"]:
        return "ReplyMarkup"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_personal": self.is_personal,
            "input_field_placeholder": self.input_field_placeholder,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReplyMarkupForceReply", None]:
        if data:
            data_class = cls()
            data_class.is_personal = data.get("is_personal", False)
            data_class.input_field_placeholder = data.get("input_field_placeholder", "")

        return data_class


class ReplyMarkupShowKeyboard(TlObject, ReplyMarkup):
    r"""Contains a custom keyboard layout to quickly reply to bots

    Parameters:
        rows (:class:`List[List["types.KeyboardButton"]]`):
            A list of rows of bot keyboard buttons

        is_persistent (:class:`bool`):
            True, if the keyboard is expected to always be shown when the ordinary keyboard is hidden

        resize_keyboard (:class:`bool`):
            True, if the application needs to resize the keyboard vertically

        one_time (:class:`bool`):
            True, if the application needs to hide the keyboard after use

        is_personal (:class:`bool`):
            True, if the keyboard must automatically be shown to the current user\. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply

        input_field_placeholder (:class:`str`):
            If non\-empty, the placeholder to be shown in the input field when the keyboard is active; 0\-64 characters

    """

    def __init__(
        self,
        rows: List[List[KeyboardButton]] = None,
        is_persistent: bool = False,
        resize_keyboard: bool = False,
        one_time: bool = False,
        is_personal: bool = False,
        input_field_placeholder: str = "",
    ) -> None:
        self.rows: List[List[KeyboardButton]] = rows or []
        r"""A list of rows of bot keyboard buttons"""
        self.is_persistent: bool = bool(is_persistent)
        r"""True, if the keyboard is expected to always be shown when the ordinary keyboard is hidden"""
        self.resize_keyboard: bool = bool(resize_keyboard)
        r"""True, if the application needs to resize the keyboard vertically"""
        self.one_time: bool = bool(one_time)
        r"""True, if the application needs to hide the keyboard after use"""
        self.is_personal: bool = bool(is_personal)
        r"""True, if the keyboard must automatically be shown to the current user\. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply"""
        self.input_field_placeholder: Union[str, None] = input_field_placeholder
        r"""If non\-empty, the placeholder to be shown in the input field when the keyboard is active; 0\-64 characters"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["replyMarkupShowKeyboard"]:
        return "replyMarkupShowKeyboard"

    def getClass(self) -> Literal["ReplyMarkup"]:
        return "ReplyMarkup"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "rows": self.rows,
            "is_persistent": self.is_persistent,
            "resize_keyboard": self.resize_keyboard,
            "one_time": self.one_time,
            "is_personal": self.is_personal,
            "input_field_placeholder": self.input_field_placeholder,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReplyMarkupShowKeyboard", None]:
        if data:
            data_class = cls()
            data_class.rows = data.get("rows", None)
            data_class.is_persistent = data.get("is_persistent", False)
            data_class.resize_keyboard = data.get("resize_keyboard", False)
            data_class.one_time = data.get("one_time", False)
            data_class.is_personal = data.get("is_personal", False)
            data_class.input_field_placeholder = data.get("input_field_placeholder", "")

        return data_class


class ReplyMarkupInlineKeyboard(TlObject, ReplyMarkup):
    r"""Contains an inline keyboard layout

    Parameters:
        rows (:class:`List[List["types.InlineKeyboardButton"]]`):
            A list of rows of inline keyboard buttons

    """

    def __init__(self, rows: List[List[InlineKeyboardButton]] = None) -> None:
        self.rows: List[List[InlineKeyboardButton]] = rows or []
        r"""A list of rows of inline keyboard buttons"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["replyMarkupInlineKeyboard"]:
        return "replyMarkupInlineKeyboard"

    def getClass(self) -> Literal["ReplyMarkup"]:
        return "ReplyMarkup"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "rows": self.rows}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReplyMarkupInlineKeyboard", None]:
        if data:
            data_class = cls()
            data_class.rows = data.get("rows", None)

        return data_class


class LoginUrlInfoOpen(TlObject, LoginUrlInfo):
    r"""An HTTP URL needs to be open

    Parameters:
        url (:class:`str`):
            The URL to open

        skip_confirmation (:class:`bool`):
            True, if there is no need to show an ordinary open URL confirmation

    """

    def __init__(self, url: str = "", skip_confirmation: bool = False) -> None:
        self.url: Union[str, None] = url
        r"""The URL to open"""
        self.skip_confirmation: bool = bool(skip_confirmation)
        r"""True, if there is no need to show an ordinary open URL confirmation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["loginUrlInfoOpen"]:
        return "loginUrlInfoOpen"

    def getClass(self) -> Literal["LoginUrlInfo"]:
        return "LoginUrlInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "skip_confirmation": self.skip_confirmation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LoginUrlInfoOpen", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.skip_confirmation = data.get("skip_confirmation", False)

        return data_class


class LoginUrlInfoRequestConfirmation(TlObject, LoginUrlInfo):
    r"""An authorization confirmation dialog needs to be shown to the user

    Parameters:
        url (:class:`str`):
            An HTTP URL to be opened

        domain (:class:`str`):
            A domain of the URL

        bot_user_id (:class:`int`):
            User identifier of a bot linked with the website

        request_write_access (:class:`bool`):
            True, if the user must be asked for the permission to the bot to send them messages

    """

    def __init__(
        self,
        url: str = "",
        domain: str = "",
        bot_user_id: int = 0,
        request_write_access: bool = False,
    ) -> None:
        self.url: Union[str, None] = url
        r"""An HTTP URL to be opened"""
        self.domain: Union[str, None] = domain
        r"""A domain of the URL"""
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of a bot linked with the website"""
        self.request_write_access: bool = bool(request_write_access)
        r"""True, if the user must be asked for the permission to the bot to send them messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["loginUrlInfoRequestConfirmation"]:
        return "loginUrlInfoRequestConfirmation"

    def getClass(self) -> Literal["LoginUrlInfo"]:
        return "LoginUrlInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "domain": self.domain,
            "bot_user_id": self.bot_user_id,
            "request_write_access": self.request_write_access,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LoginUrlInfoRequestConfirmation", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.domain = data.get("domain", "")
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.request_write_access = data.get("request_write_access", False)

        return data_class


class ThemeParameters(TlObject):
    r"""Contains parameters of the application theme

    Parameters:
        background_color (:class:`int`):
            A color of the background in the RGB format

        secondary_background_color (:class:`int`):
            A secondary color for the background in the RGB format

        header_background_color (:class:`int`):
            A color of the header background in the RGB format

        bottom_bar_background_color (:class:`int`):
            A color of the bottom bar background in the RGB format

        section_background_color (:class:`int`):
            A color of the section background in the RGB format

        section_separator_color (:class:`int`):
            A color of the section separator in the RGB format

        text_color (:class:`int`):
            A color of text in the RGB format

        accent_text_color (:class:`int`):
            An accent color of the text in the RGB format

        section_header_text_color (:class:`int`):
            A color of text on the section headers in the RGB format

        subtitle_text_color (:class:`int`):
            A color of the subtitle text in the RGB format

        destructive_text_color (:class:`int`):
            A color of the text for destructive actions in the RGB format

        hint_color (:class:`int`):
            A color of hints in the RGB format

        link_color (:class:`int`):
            A color of links in the RGB format

        button_color (:class:`int`):
            A color of the buttons in the RGB format

        button_text_color (:class:`int`):
            A color of text on the buttons in the RGB format

    """

    def __init__(
        self,
        background_color: int = 0,
        secondary_background_color: int = 0,
        header_background_color: int = 0,
        bottom_bar_background_color: int = 0,
        section_background_color: int = 0,
        section_separator_color: int = 0,
        text_color: int = 0,
        accent_text_color: int = 0,
        section_header_text_color: int = 0,
        subtitle_text_color: int = 0,
        destructive_text_color: int = 0,
        hint_color: int = 0,
        link_color: int = 0,
        button_color: int = 0,
        button_text_color: int = 0,
    ) -> None:
        self.background_color: int = int(background_color)
        r"""A color of the background in the RGB format"""
        self.secondary_background_color: int = int(secondary_background_color)
        r"""A secondary color for the background in the RGB format"""
        self.header_background_color: int = int(header_background_color)
        r"""A color of the header background in the RGB format"""
        self.bottom_bar_background_color: int = int(bottom_bar_background_color)
        r"""A color of the bottom bar background in the RGB format"""
        self.section_background_color: int = int(section_background_color)
        r"""A color of the section background in the RGB format"""
        self.section_separator_color: int = int(section_separator_color)
        r"""A color of the section separator in the RGB format"""
        self.text_color: int = int(text_color)
        r"""A color of text in the RGB format"""
        self.accent_text_color: int = int(accent_text_color)
        r"""An accent color of the text in the RGB format"""
        self.section_header_text_color: int = int(section_header_text_color)
        r"""A color of text on the section headers in the RGB format"""
        self.subtitle_text_color: int = int(subtitle_text_color)
        r"""A color of the subtitle text in the RGB format"""
        self.destructive_text_color: int = int(destructive_text_color)
        r"""A color of the text for destructive actions in the RGB format"""
        self.hint_color: int = int(hint_color)
        r"""A color of hints in the RGB format"""
        self.link_color: int = int(link_color)
        r"""A color of links in the RGB format"""
        self.button_color: int = int(button_color)
        r"""A color of the buttons in the RGB format"""
        self.button_text_color: int = int(button_text_color)
        r"""A color of text on the buttons in the RGB format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["themeParameters"]:
        return "themeParameters"

    def getClass(self) -> Literal["ThemeParameters"]:
        return "ThemeParameters"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "background_color": self.background_color,
            "secondary_background_color": self.secondary_background_color,
            "header_background_color": self.header_background_color,
            "bottom_bar_background_color": self.bottom_bar_background_color,
            "section_background_color": self.section_background_color,
            "section_separator_color": self.section_separator_color,
            "text_color": self.text_color,
            "accent_text_color": self.accent_text_color,
            "section_header_text_color": self.section_header_text_color,
            "subtitle_text_color": self.subtitle_text_color,
            "destructive_text_color": self.destructive_text_color,
            "hint_color": self.hint_color,
            "link_color": self.link_color,
            "button_color": self.button_color,
            "button_text_color": self.button_text_color,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThemeParameters", None]:
        if data:
            data_class = cls()
            data_class.background_color = int(data.get("background_color", 0))
            data_class.secondary_background_color = int(
                data.get("secondary_background_color", 0)
            )
            data_class.header_background_color = int(
                data.get("header_background_color", 0)
            )
            data_class.bottom_bar_background_color = int(
                data.get("bottom_bar_background_color", 0)
            )
            data_class.section_background_color = int(
                data.get("section_background_color", 0)
            )
            data_class.section_separator_color = int(
                data.get("section_separator_color", 0)
            )
            data_class.text_color = int(data.get("text_color", 0))
            data_class.accent_text_color = int(data.get("accent_text_color", 0))
            data_class.section_header_text_color = int(
                data.get("section_header_text_color", 0)
            )
            data_class.subtitle_text_color = int(data.get("subtitle_text_color", 0))
            data_class.destructive_text_color = int(
                data.get("destructive_text_color", 0)
            )
            data_class.hint_color = int(data.get("hint_color", 0))
            data_class.link_color = int(data.get("link_color", 0))
            data_class.button_color = int(data.get("button_color", 0))
            data_class.button_text_color = int(data.get("button_text_color", 0))

        return data_class


class WebAppOpenModeCompact(TlObject, WebAppOpenMode):
    r"""The Web App is opened in the compact mode"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["webAppOpenModeCompact"]:
        return "webAppOpenModeCompact"

    def getClass(self) -> Literal["WebAppOpenMode"]:
        return "WebAppOpenMode"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["WebAppOpenModeCompact", None]:
        if data:
            data_class = cls()

        return data_class


class WebAppOpenModeFullSize(TlObject, WebAppOpenMode):
    r"""The Web App is opened in the full\-size mode"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["webAppOpenModeFullSize"]:
        return "webAppOpenModeFullSize"

    def getClass(self) -> Literal["WebAppOpenMode"]:
        return "WebAppOpenMode"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["WebAppOpenModeFullSize", None]:
        if data:
            data_class = cls()

        return data_class


class WebAppOpenModeFullScreen(TlObject, WebAppOpenMode):
    r"""The Web App is opened in the full\-screen mode"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["webAppOpenModeFullScreen"]:
        return "webAppOpenModeFullScreen"

    def getClass(self) -> Literal["WebAppOpenMode"]:
        return "WebAppOpenMode"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["WebAppOpenModeFullScreen", None]:
        if data:
            data_class = cls()

        return data_class


class FoundWebApp(TlObject):
    r"""Contains information about a Web App found by its short name

    Parameters:
        web_app (:class:`"types.WebApp"`):
            The Web App

        request_write_access (:class:`bool`):
            True, if the user must be asked for the permission to the bot to send them messages

        skip_confirmation (:class:`bool`):
            True, if there is no need to show an ordinary open URL confirmation before opening the Web App\. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden

    """

    def __init__(
        self,
        web_app: WebApp = None,
        request_write_access: bool = False,
        skip_confirmation: bool = False,
    ) -> None:
        self.web_app: Union[WebApp, None] = web_app
        r"""The Web App"""
        self.request_write_access: bool = bool(request_write_access)
        r"""True, if the user must be asked for the permission to the bot to send them messages"""
        self.skip_confirmation: bool = bool(skip_confirmation)
        r"""True, if there is no need to show an ordinary open URL confirmation before opening the Web App\. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundWebApp"]:
        return "foundWebApp"

    def getClass(self) -> Literal["FoundWebApp"]:
        return "FoundWebApp"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "web_app": self.web_app,
            "request_write_access": self.request_write_access,
            "skip_confirmation": self.skip_confirmation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundWebApp", None]:
        if data:
            data_class = cls()
            data_class.web_app = data.get("web_app", None)
            data_class.request_write_access = data.get("request_write_access", False)
            data_class.skip_confirmation = data.get("skip_confirmation", False)

        return data_class


class WebAppInfo(TlObject):
    r"""Contains information about a Web App

    Parameters:
        launch_id (:class:`int`):
            Unique identifier for the Web App launch

        url (:class:`str`):
            A Web App URL to open in a web view

    """

    def __init__(self, launch_id: int = 0, url: str = "") -> None:
        self.launch_id: int = int(launch_id)
        r"""Unique identifier for the Web App launch"""
        self.url: Union[str, None] = url
        r"""A Web App URL to open in a web view"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["webAppInfo"]:
        return "webAppInfo"

    def getClass(self) -> Literal["WebAppInfo"]:
        return "WebAppInfo"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "launch_id": self.launch_id, "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["WebAppInfo", None]:
        if data:
            data_class = cls()
            data_class.launch_id = int(data.get("launch_id", 0))
            data_class.url = data.get("url", "")

        return data_class


class MainWebApp(TlObject):
    r"""Contains information about the main Web App of a bot

    Parameters:
        url (:class:`str`):
            URL of the Web App to open

        mode (:class:`"types.WebAppOpenMode"`):
            The mode in which the Web App must be opened

    """

    def __init__(self, url: str = "", mode: WebAppOpenMode = None) -> None:
        self.url: Union[str, None] = url
        r"""URL of the Web App to open"""
        self.mode: Union[
            WebAppOpenModeCompact,
            WebAppOpenModeFullSize,
            WebAppOpenModeFullScreen,
            None,
        ] = mode
        r"""The mode in which the Web App must be opened"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["mainWebApp"]:
        return "mainWebApp"

    def getClass(self) -> Literal["MainWebApp"]:
        return "MainWebApp"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url, "mode": self.mode}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MainWebApp", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.mode = data.get("mode", None)

        return data_class


class WebAppOpenParameters(TlObject):
    r"""Options to be used when a Web App is opened

    Parameters:
        theme (:class:`"types.ThemeParameters"`):
            Preferred Web App theme; pass null to use the default theme

        application_name (:class:`str`):
            Short name of the current application; 0\-64 English letters, digits, and underscores

        mode (:class:`"types.WebAppOpenMode"`):
            The mode in which the Web App is opened; pass null to open in webAppOpenModeFullSize

    """

    def __init__(
        self,
        theme: ThemeParameters = None,
        application_name: str = "",
        mode: WebAppOpenMode = None,
    ) -> None:
        self.theme: Union[ThemeParameters, None] = theme
        r"""Preferred Web App theme; pass null to use the default theme"""
        self.application_name: Union[str, None] = application_name
        r"""Short name of the current application; 0\-64 English letters, digits, and underscores"""
        self.mode: Union[
            WebAppOpenModeCompact,
            WebAppOpenModeFullSize,
            WebAppOpenModeFullScreen,
            None,
        ] = mode
        r"""The mode in which the Web App is opened; pass null to open in webAppOpenModeFullSize"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["webAppOpenParameters"]:
        return "webAppOpenParameters"

    def getClass(self) -> Literal["WebAppOpenParameters"]:
        return "WebAppOpenParameters"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "theme": self.theme,
            "application_name": self.application_name,
            "mode": self.mode,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["WebAppOpenParameters", None]:
        if data:
            data_class = cls()
            data_class.theme = data.get("theme", None)
            data_class.application_name = data.get("application_name", "")
            data_class.mode = data.get("mode", None)

        return data_class


class MessageThreadInfo(TlObject):
    r"""Contains information about a message thread

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat to which the message thread belongs

        message_thread_id (:class:`int`):
            Message thread identifier, unique within the chat

        reply_info (:class:`"types.MessageReplyInfo"`):
            Information about the message thread; may be null for forum topic threads

        unread_message_count (:class:`int`):
            Approximate number of unread messages in the message thread

        messages (:class:`List["types.Message"]`):
            The messages from which the thread starts\. The messages are returned in reverse chronological order \(i\.e\., in order of decreasing message\_id\)

        draft_message (:class:`"types.DraftMessage"`):
            A draft of a message in the message thread; may be null if none

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_thread_id: int = 0,
        reply_info: MessageReplyInfo = None,
        unread_message_count: int = 0,
        messages: List[Message] = None,
        draft_message: DraftMessage = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat to which the message thread belongs"""
        self.message_thread_id: int = int(message_thread_id)
        r"""Message thread identifier, unique within the chat"""
        self.reply_info: Union[MessageReplyInfo, None] = reply_info
        r"""Information about the message thread; may be null for forum topic threads"""
        self.unread_message_count: int = int(unread_message_count)
        r"""Approximate number of unread messages in the message thread"""
        self.messages: List[Message] = messages or []
        r"""The messages from which the thread starts\. The messages are returned in reverse chronological order \(i\.e\., in order of decreasing message\_id\)"""
        self.draft_message: Union[DraftMessage, None] = draft_message
        r"""A draft of a message in the message thread; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageThreadInfo"]:
        return "messageThreadInfo"

    def getClass(self) -> Literal["MessageThreadInfo"]:
        return "MessageThreadInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_thread_id": self.message_thread_id,
            "reply_info": self.reply_info,
            "unread_message_count": self.unread_message_count,
            "messages": self.messages,
            "draft_message": self.draft_message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageThreadInfo", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_thread_id = int(data.get("message_thread_id", 0))
            data_class.reply_info = data.get("reply_info", None)
            data_class.unread_message_count = int(data.get("unread_message_count", 0))
            data_class.messages = data.get("messages", None)
            data_class.draft_message = data.get("draft_message", None)

        return data_class


class SavedMessagesTopicTypeMyNotes(TlObject, SavedMessagesTopicType):
    r"""Topic containing messages sent by the current user of forwarded from an unknown chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["savedMessagesTopicTypeMyNotes"]:
        return "savedMessagesTopicTypeMyNotes"

    def getClass(self) -> Literal["SavedMessagesTopicType"]:
        return "SavedMessagesTopicType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SavedMessagesTopicTypeMyNotes", None]:
        if data:
            data_class = cls()

        return data_class


class SavedMessagesTopicTypeAuthorHidden(TlObject, SavedMessagesTopicType):
    r"""Topic containing messages forwarded from a user with hidden privacy"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["savedMessagesTopicTypeAuthorHidden"]:
        return "savedMessagesTopicTypeAuthorHidden"

    def getClass(self) -> Literal["SavedMessagesTopicType"]:
        return "SavedMessagesTopicType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SavedMessagesTopicTypeAuthorHidden", None]:
        if data:
            data_class = cls()

        return data_class


class SavedMessagesTopicTypeSavedFromChat(TlObject, SavedMessagesTopicType):
    r"""Topic containing messages forwarded from a specific chat

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["savedMessagesTopicTypeSavedFromChat"]:
        return "savedMessagesTopicTypeSavedFromChat"

    def getClass(self) -> Literal["SavedMessagesTopicType"]:
        return "SavedMessagesTopicType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SavedMessagesTopicTypeSavedFromChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class SavedMessagesTopic(TlObject):
    r"""Contains information about a Saved Messages topic

    Parameters:
        id (:class:`int`):
            Unique topic identifier

        type (:class:`"types.SavedMessagesTopicType"`):
            Type of the topic

        is_pinned (:class:`bool`):
            True, if the topic is pinned

        order (:class:`int`):
            A parameter used to determine order of the topic in the topic list\. Topics must be sorted by the order in descending order

        last_message (:class:`"types.Message"`):
            Last message in the topic; may be null if none or unknown

        draft_message (:class:`"types.DraftMessage"`):
            A draft of a message in the topic; may be null if none

    """

    def __init__(
        self,
        id: int = 0,
        type: SavedMessagesTopicType = None,
        is_pinned: bool = False,
        order: int = 0,
        last_message: Message = None,
        draft_message: DraftMessage = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique topic identifier"""
        self.type: Union[
            SavedMessagesTopicTypeMyNotes,
            SavedMessagesTopicTypeAuthorHidden,
            SavedMessagesTopicTypeSavedFromChat,
            None,
        ] = type
        r"""Type of the topic"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the topic is pinned"""
        self.order: int = int(order)
        r"""A parameter used to determine order of the topic in the topic list\. Topics must be sorted by the order in descending order"""
        self.last_message: Union[Message, None] = last_message
        r"""Last message in the topic; may be null if none or unknown"""
        self.draft_message: Union[DraftMessage, None] = draft_message
        r"""A draft of a message in the topic; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["savedMessagesTopic"]:
        return "savedMessagesTopic"

    def getClass(self) -> Literal["SavedMessagesTopic"]:
        return "SavedMessagesTopic"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "type": self.type,
            "is_pinned": self.is_pinned,
            "order": self.order,
            "last_message": self.last_message,
            "draft_message": self.draft_message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SavedMessagesTopic", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.type = data.get("type", None)
            data_class.is_pinned = data.get("is_pinned", False)
            data_class.order = int(data.get("order", 0))
            data_class.last_message = data.get("last_message", None)
            data_class.draft_message = data.get("draft_message", None)

        return data_class


class ForumTopicIcon(TlObject):
    r"""Describes a forum topic icon

    Parameters:
        color (:class:`int`):
            Color of the topic icon in RGB format

        custom_emoji_id (:class:`int`):
            Unique identifier of the custom emoji shown on the topic icon; 0 if none

    """

    def __init__(self, color: int = 0, custom_emoji_id: int = 0) -> None:
        self.color: int = int(color)
        r"""Color of the topic icon in RGB format"""
        self.custom_emoji_id: int = int(custom_emoji_id)
        r"""Unique identifier of the custom emoji shown on the topic icon; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["forumTopicIcon"]:
        return "forumTopicIcon"

    def getClass(self) -> Literal["ForumTopicIcon"]:
        return "ForumTopicIcon"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "color": self.color,
            "custom_emoji_id": self.custom_emoji_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ForumTopicIcon", None]:
        if data:
            data_class = cls()
            data_class.color = int(data.get("color", 0))
            data_class.custom_emoji_id = int(data.get("custom_emoji_id", 0))

        return data_class


class ForumTopicInfo(TlObject):
    r"""Contains basic information about a forum topic

    Parameters:
        chat_id (:class:`int`):
            Identifier of the forum chat to which the topic belongs

        message_thread_id (:class:`int`):
            Message thread identifier of the topic

        name (:class:`str`):
            Name of the topic

        icon (:class:`"types.ForumTopicIcon"`):
            Icon of the topic

        creation_date (:class:`int`):
            Point in time \(Unix timestamp\) when the topic was created

        creator_id (:class:`"types.MessageSender"`):
            Identifier of the creator of the topic

        is_general (:class:`bool`):
            True, if the topic is the General topic list

        is_outgoing (:class:`bool`):
            True, if the topic was created by the current user

        is_closed (:class:`bool`):
            True, if the topic is closed

        is_hidden (:class:`bool`):
            True, if the topic is hidden above the topic list and closed; for General topic only

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_thread_id: int = 0,
        name: str = "",
        icon: ForumTopicIcon = None,
        creation_date: int = 0,
        creator_id: MessageSender = None,
        is_general: bool = False,
        is_outgoing: bool = False,
        is_closed: bool = False,
        is_hidden: bool = False,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the forum chat to which the topic belongs"""
        self.message_thread_id: int = int(message_thread_id)
        r"""Message thread identifier of the topic"""
        self.name: Union[str, None] = name
        r"""Name of the topic"""
        self.icon: Union[ForumTopicIcon, None] = icon
        r"""Icon of the topic"""
        self.creation_date: int = int(creation_date)
        r"""Point in time \(Unix timestamp\) when the topic was created"""
        self.creator_id: Union[MessageSenderUser, MessageSenderChat, None] = creator_id
        r"""Identifier of the creator of the topic"""
        self.is_general: bool = bool(is_general)
        r"""True, if the topic is the General topic list"""
        self.is_outgoing: bool = bool(is_outgoing)
        r"""True, if the topic was created by the current user"""
        self.is_closed: bool = bool(is_closed)
        r"""True, if the topic is closed"""
        self.is_hidden: bool = bool(is_hidden)
        r"""True, if the topic is hidden above the topic list and closed; for General topic only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["forumTopicInfo"]:
        return "forumTopicInfo"

    def getClass(self) -> Literal["ForumTopicInfo"]:
        return "ForumTopicInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_thread_id": self.message_thread_id,
            "name": self.name,
            "icon": self.icon,
            "creation_date": self.creation_date,
            "creator_id": self.creator_id,
            "is_general": self.is_general,
            "is_outgoing": self.is_outgoing,
            "is_closed": self.is_closed,
            "is_hidden": self.is_hidden,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ForumTopicInfo", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_thread_id = int(data.get("message_thread_id", 0))
            data_class.name = data.get("name", "")
            data_class.icon = data.get("icon", None)
            data_class.creation_date = int(data.get("creation_date", 0))
            data_class.creator_id = data.get("creator_id", None)
            data_class.is_general = data.get("is_general", False)
            data_class.is_outgoing = data.get("is_outgoing", False)
            data_class.is_closed = data.get("is_closed", False)
            data_class.is_hidden = data.get("is_hidden", False)

        return data_class


class ForumTopic(TlObject):
    r"""Describes a forum topic

    Parameters:
        info (:class:`"types.ForumTopicInfo"`):
            Basic information about the topic

        last_message (:class:`"types.Message"`):
            Last message in the topic; may be null if unknown

        order (:class:`int`):
            A parameter used to determine order of the topic in the topic list\. Topics must be sorted by the order in descending order

        is_pinned (:class:`bool`):
            True, if the topic is pinned in the topic list

        unread_count (:class:`int`):
            Number of unread messages in the topic

        last_read_inbox_message_id (:class:`int`):
            Identifier of the last read incoming message

        last_read_outbox_message_id (:class:`int`):
            Identifier of the last read outgoing message

        unread_mention_count (:class:`int`):
            Number of unread messages with a mention/reply in the topic

        unread_reaction_count (:class:`int`):
            Number of messages with unread reactions in the topic

        notification_settings (:class:`"types.ChatNotificationSettings"`):
            Notification settings for the topic

        draft_message (:class:`"types.DraftMessage"`):
            A draft of a message in the topic; may be null if none

    """

    def __init__(
        self,
        info: ForumTopicInfo = None,
        last_message: Message = None,
        order: int = 0,
        is_pinned: bool = False,
        unread_count: int = 0,
        last_read_inbox_message_id: int = 0,
        last_read_outbox_message_id: int = 0,
        unread_mention_count: int = 0,
        unread_reaction_count: int = 0,
        notification_settings: ChatNotificationSettings = None,
        draft_message: DraftMessage = None,
    ) -> None:
        self.info: Union[ForumTopicInfo, None] = info
        r"""Basic information about the topic"""
        self.last_message: Union[Message, None] = last_message
        r"""Last message in the topic; may be null if unknown"""
        self.order: int = int(order)
        r"""A parameter used to determine order of the topic in the topic list\. Topics must be sorted by the order in descending order"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the topic is pinned in the topic list"""
        self.unread_count: int = int(unread_count)
        r"""Number of unread messages in the topic"""
        self.last_read_inbox_message_id: int = int(last_read_inbox_message_id)
        r"""Identifier of the last read incoming message"""
        self.last_read_outbox_message_id: int = int(last_read_outbox_message_id)
        r"""Identifier of the last read outgoing message"""
        self.unread_mention_count: int = int(unread_mention_count)
        r"""Number of unread messages with a mention/reply in the topic"""
        self.unread_reaction_count: int = int(unread_reaction_count)
        r"""Number of messages with unread reactions in the topic"""
        self.notification_settings: Union[ChatNotificationSettings, None] = (
            notification_settings
        )
        r"""Notification settings for the topic"""
        self.draft_message: Union[DraftMessage, None] = draft_message
        r"""A draft of a message in the topic; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["forumTopic"]:
        return "forumTopic"

    def getClass(self) -> Literal["ForumTopic"]:
        return "ForumTopic"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "info": self.info,
            "last_message": self.last_message,
            "order": self.order,
            "is_pinned": self.is_pinned,
            "unread_count": self.unread_count,
            "last_read_inbox_message_id": self.last_read_inbox_message_id,
            "last_read_outbox_message_id": self.last_read_outbox_message_id,
            "unread_mention_count": self.unread_mention_count,
            "unread_reaction_count": self.unread_reaction_count,
            "notification_settings": self.notification_settings,
            "draft_message": self.draft_message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ForumTopic", None]:
        if data:
            data_class = cls()
            data_class.info = data.get("info", None)
            data_class.last_message = data.get("last_message", None)
            data_class.order = int(data.get("order", 0))
            data_class.is_pinned = data.get("is_pinned", False)
            data_class.unread_count = int(data.get("unread_count", 0))
            data_class.last_read_inbox_message_id = int(
                data.get("last_read_inbox_message_id", 0)
            )
            data_class.last_read_outbox_message_id = int(
                data.get("last_read_outbox_message_id", 0)
            )
            data_class.unread_mention_count = int(data.get("unread_mention_count", 0))
            data_class.unread_reaction_count = int(data.get("unread_reaction_count", 0))
            data_class.notification_settings = data.get("notification_settings", None)
            data_class.draft_message = data.get("draft_message", None)

        return data_class


class ForumTopics(TlObject):
    r"""Describes a list of forum topics

    Parameters:
        total_count (:class:`int`):
            Approximate total number of forum topics found

        topics (:class:`List["types.ForumTopic"]`):
            List of forum topics

        next_offset_date (:class:`int`):
            Offset date for the next getForumTopics request

        next_offset_message_id (:class:`int`):
            Offset message identifier for the next getForumTopics request

        next_offset_message_thread_id (:class:`int`):
            Offset message thread identifier for the next getForumTopics request

    """

    def __init__(
        self,
        total_count: int = 0,
        topics: List[ForumTopic] = None,
        next_offset_date: int = 0,
        next_offset_message_id: int = 0,
        next_offset_message_thread_id: int = 0,
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of forum topics found"""
        self.topics: List[ForumTopic] = topics or []
        r"""List of forum topics"""
        self.next_offset_date: int = int(next_offset_date)
        r"""Offset date for the next getForumTopics request"""
        self.next_offset_message_id: int = int(next_offset_message_id)
        r"""Offset message identifier for the next getForumTopics request"""
        self.next_offset_message_thread_id: int = int(next_offset_message_thread_id)
        r"""Offset message thread identifier for the next getForumTopics request"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["forumTopics"]:
        return "forumTopics"

    def getClass(self) -> Literal["ForumTopics"]:
        return "ForumTopics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "topics": self.topics,
            "next_offset_date": self.next_offset_date,
            "next_offset_message_id": self.next_offset_message_id,
            "next_offset_message_thread_id": self.next_offset_message_thread_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ForumTopics", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.topics = data.get("topics", None)
            data_class.next_offset_date = int(data.get("next_offset_date", 0))
            data_class.next_offset_message_id = int(
                data.get("next_offset_message_id", 0)
            )
            data_class.next_offset_message_thread_id = int(
                data.get("next_offset_message_thread_id", 0)
            )

        return data_class


class LinkPreviewOptions(TlObject):
    r"""Options to be used for generation of a link preview

    Parameters:
        is_disabled (:class:`bool`):
            True, if link preview must be disabled

        url (:class:`str`):
            URL to use for link preview\. If empty, then the first URL found in the message text will be used

        force_small_media (:class:`bool`):
            True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified

        force_large_media (:class:`bool`):
            True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified

        show_above_text (:class:`bool`):
            True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats

    """

    def __init__(
        self,
        is_disabled: bool = False,
        url: str = "",
        force_small_media: bool = False,
        force_large_media: bool = False,
        show_above_text: bool = False,
    ) -> None:
        self.is_disabled: bool = bool(is_disabled)
        r"""True, if link preview must be disabled"""
        self.url: Union[str, None] = url
        r"""URL to use for link preview\. If empty, then the first URL found in the message text will be used"""
        self.force_small_media: bool = bool(force_small_media)
        r"""True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified"""
        self.force_large_media: bool = bool(force_large_media)
        r"""True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified"""
        self.show_above_text: bool = bool(show_above_text)
        r"""True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewOptions"]:
        return "linkPreviewOptions"

    def getClass(self) -> Literal["LinkPreviewOptions"]:
        return "LinkPreviewOptions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_disabled": self.is_disabled,
            "url": self.url,
            "force_small_media": self.force_small_media,
            "force_large_media": self.force_large_media,
            "show_above_text": self.show_above_text,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewOptions", None]:
        if data:
            data_class = cls()
            data_class.is_disabled = data.get("is_disabled", False)
            data_class.url = data.get("url", "")
            data_class.force_small_media = data.get("force_small_media", False)
            data_class.force_large_media = data.get("force_large_media", False)
            data_class.show_above_text = data.get("show_above_text", False)

        return data_class


class SharedUser(TlObject):
    r"""Contains information about a user shared with a bot

    Parameters:
        user_id (:class:`int`):
            User identifier

        first_name (:class:`str`):
            First name of the user; for bots only

        last_name (:class:`str`):
            Last name of the user; for bots only

        username (:class:`str`):
            Username of the user; for bots only

        photo (:class:`"types.Photo"`):
            Profile photo of the user; for bots only; may be null

    """

    def __init__(
        self,
        user_id: int = 0,
        first_name: str = "",
        last_name: str = "",
        username: str = "",
        photo: Photo = None,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.first_name: Union[str, None] = first_name
        r"""First name of the user; for bots only"""
        self.last_name: Union[str, None] = last_name
        r"""Last name of the user; for bots only"""
        self.username: Union[str, None] = username
        r"""Username of the user; for bots only"""
        self.photo: Union[Photo, None] = photo
        r"""Profile photo of the user; for bots only; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sharedUser"]:
        return "sharedUser"

    def getClass(self) -> Literal["SharedUser"]:
        return "SharedUser"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "first_name": self.first_name,
            "last_name": self.last_name,
            "username": self.username,
            "photo": self.photo,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SharedUser", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.first_name = data.get("first_name", "")
            data_class.last_name = data.get("last_name", "")
            data_class.username = data.get("username", "")
            data_class.photo = data.get("photo", None)

        return data_class


class SharedChat(TlObject):
    r"""Contains information about a chat shared with a bot

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        title (:class:`str`):
            Title of the chat; for bots only

        username (:class:`str`):
            Username of the chat; for bots only

        photo (:class:`"types.Photo"`):
            Photo of the chat; for bots only; may be null

    """

    def __init__(
        self, chat_id: int = 0, title: str = "", username: str = "", photo: Photo = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.title: Union[str, None] = title
        r"""Title of the chat; for bots only"""
        self.username: Union[str, None] = username
        r"""Username of the chat; for bots only"""
        self.photo: Union[Photo, None] = photo
        r"""Photo of the chat; for bots only; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sharedChat"]:
        return "sharedChat"

    def getClass(self) -> Literal["SharedChat"]:
        return "SharedChat"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "title": self.title,
            "username": self.username,
            "photo": self.photo,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SharedChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.title = data.get("title", "")
            data_class.username = data.get("username", "")
            data_class.photo = data.get("photo", None)

        return data_class


class ThemeSettings(TlObject):
    r"""Describes theme settings

    Parameters:
        accent_color (:class:`int`):
            Theme accent color in ARGB format

        background (:class:`"types.Background"`):
            The background to be used in chats; may be null

        outgoing_message_fill (:class:`"types.BackgroundFill"`):
            The fill to be used as a background for outgoing messages

        animate_outgoing_message_fill (:class:`bool`):
            If true, the freeform gradient fill needs to be animated on every sent message

        outgoing_message_accent_color (:class:`int`):
            Accent color of outgoing messages in ARGB format

    """

    def __init__(
        self,
        accent_color: int = 0,
        background: Background = None,
        outgoing_message_fill: BackgroundFill = None,
        animate_outgoing_message_fill: bool = False,
        outgoing_message_accent_color: int = 0,
    ) -> None:
        self.accent_color: int = int(accent_color)
        r"""Theme accent color in ARGB format"""
        self.background: Union[Background, None] = background
        r"""The background to be used in chats; may be null"""
        self.outgoing_message_fill: Union[
            BackgroundFillSolid,
            BackgroundFillGradient,
            BackgroundFillFreeformGradient,
            None,
        ] = outgoing_message_fill
        r"""The fill to be used as a background for outgoing messages"""
        self.animate_outgoing_message_fill: bool = bool(animate_outgoing_message_fill)
        r"""If true, the freeform gradient fill needs to be animated on every sent message"""
        self.outgoing_message_accent_color: int = int(outgoing_message_accent_color)
        r"""Accent color of outgoing messages in ARGB format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["themeSettings"]:
        return "themeSettings"

    def getClass(self) -> Literal["ThemeSettings"]:
        return "ThemeSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "accent_color": self.accent_color,
            "background": self.background,
            "outgoing_message_fill": self.outgoing_message_fill,
            "animate_outgoing_message_fill": self.animate_outgoing_message_fill,
            "outgoing_message_accent_color": self.outgoing_message_accent_color,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ThemeSettings", None]:
        if data:
            data_class = cls()
            data_class.accent_color = int(data.get("accent_color", 0))
            data_class.background = data.get("background", None)
            data_class.outgoing_message_fill = data.get("outgoing_message_fill", None)
            data_class.animate_outgoing_message_fill = data.get(
                "animate_outgoing_message_fill", False
            )
            data_class.outgoing_message_accent_color = int(
                data.get("outgoing_message_accent_color", 0)
            )

        return data_class


class RichTextPlain(TlObject, RichText):
    r"""A plain text

    Parameters:
        text (:class:`str`):
            Text

    """

    def __init__(self, text: str = "") -> None:
        self.text: Union[str, None] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextPlain"]:
        return "richTextPlain"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextPlain", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")

        return data_class


class RichTextBold(TlObject, RichText):
    r"""A bold rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextBold"]:
        return "richTextBold"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextBold", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextItalic(TlObject, RichText):
    r"""An italicized rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextItalic"]:
        return "richTextItalic"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextItalic", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextUnderline(TlObject, RichText):
    r"""An underlined rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextUnderline"]:
        return "richTextUnderline"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextUnderline", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextStrikethrough(TlObject, RichText):
    r"""A strikethrough rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextStrikethrough"]:
        return "richTextStrikethrough"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextStrikethrough", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextFixed(TlObject, RichText):
    r"""A fixed\-width rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextFixed"]:
        return "richTextFixed"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextFixed", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextUrl(TlObject, RichText):
    r"""A rich text URL link

    Parameters:
        text (:class:`"types.RichText"`):
            Text

        url (:class:`str`):
            URL

        is_cached (:class:`bool`):
            True, if the URL has cached instant view server\-side

    """

    def __init__(
        self, text: RichText = None, url: str = "", is_cached: bool = False
    ) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""
        self.url: Union[str, None] = url
        r"""URL"""
        self.is_cached: bool = bool(is_cached)
        r"""True, if the URL has cached instant view server\-side"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextUrl"]:
        return "richTextUrl"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "url": self.url,
            "is_cached": self.is_cached,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextUrl", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.url = data.get("url", "")
            data_class.is_cached = data.get("is_cached", False)

        return data_class


class RichTextEmailAddress(TlObject, RichText):
    r"""A rich text email link

    Parameters:
        text (:class:`"types.RichText"`):
            Text

        email_address (:class:`str`):
            Email address

    """

    def __init__(self, text: RichText = None, email_address: str = "") -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""
        self.email_address: Union[str, None] = email_address
        r"""Email address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextEmailAddress"]:
        return "richTextEmailAddress"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "email_address": self.email_address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextEmailAddress", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.email_address = data.get("email_address", "")

        return data_class


class RichTextSubscript(TlObject, RichText):
    r"""A subscript rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextSubscript"]:
        return "richTextSubscript"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextSubscript", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextSuperscript(TlObject, RichText):
    r"""A superscript rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextSuperscript"]:
        return "richTextSuperscript"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextSuperscript", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextMarked(TlObject, RichText):
    r"""A marked rich text

    Parameters:
        text (:class:`"types.RichText"`):
            Text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextMarked"]:
        return "richTextMarked"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextMarked", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class RichTextPhoneNumber(TlObject, RichText):
    r"""A rich text phone number

    Parameters:
        text (:class:`"types.RichText"`):
            Text

        phone_number (:class:`str`):
            Phone number

    """

    def __init__(self, text: RichText = None, phone_number: str = "") -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Text"""
        self.phone_number: Union[str, None] = phone_number
        r"""Phone number"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextPhoneNumber"]:
        return "richTextPhoneNumber"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "phone_number": self.phone_number,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextPhoneNumber", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.phone_number = data.get("phone_number", "")

        return data_class


class RichTextIcon(TlObject, RichText):
    r"""A small image inside the text

    Parameters:
        document (:class:`"types.Document"`):
            The image represented as a document\. The image can be in GIF, JPEG or PNG format

        width (:class:`int`):
            Width of a bounding box in which the image must be shown; 0 if unknown

        height (:class:`int`):
            Height of a bounding box in which the image must be shown; 0 if unknown

    """

    def __init__(
        self, document: Document = None, width: int = 0, height: int = 0
    ) -> None:
        self.document: Union[Document, None] = document
        r"""The image represented as a document\. The image can be in GIF, JPEG or PNG format"""
        self.width: int = int(width)
        r"""Width of a bounding box in which the image must be shown; 0 if unknown"""
        self.height: int = int(height)
        r"""Height of a bounding box in which the image must be shown; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextIcon"]:
        return "richTextIcon"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "document": self.document,
            "width": self.width,
            "height": self.height,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextIcon", None]:
        if data:
            data_class = cls()
            data_class.document = data.get("document", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))

        return data_class


class RichTextReference(TlObject, RichText):
    r"""A reference to a richTexts object on the same page

    Parameters:
        text (:class:`"types.RichText"`):
            The text

        anchor_name (:class:`str`):
            The name of a richTextAnchor object, which is the first element of the target richTexts object

        url (:class:`str`):
            An HTTP URL, opening the reference

    """

    def __init__(
        self, text: RichText = None, anchor_name: str = "", url: str = ""
    ) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""The text"""
        self.anchor_name: Union[str, None] = anchor_name
        r"""The name of a richTextAnchor object, which is the first element of the target richTexts object"""
        self.url: Union[str, None] = url
        r"""An HTTP URL, opening the reference"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextReference"]:
        return "richTextReference"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "anchor_name": self.anchor_name,
            "url": self.url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextReference", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.anchor_name = data.get("anchor_name", "")
            data_class.url = data.get("url", "")

        return data_class


class RichTextAnchor(TlObject, RichText):
    r"""An anchor

    Parameters:
        name (:class:`str`):
            Anchor name

    """

    def __init__(self, name: str = "") -> None:
        self.name: Union[str, None] = name
        r"""Anchor name"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextAnchor"]:
        return "richTextAnchor"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextAnchor", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")

        return data_class


class RichTextAnchorLink(TlObject, RichText):
    r"""A link to an anchor on the same page

    Parameters:
        text (:class:`"types.RichText"`):
            The link text

        anchor_name (:class:`str`):
            The anchor name\. If the name is empty, the link must bring back to top

        url (:class:`str`):
            An HTTP URL, opening the anchor

    """

    def __init__(
        self, text: RichText = None, anchor_name: str = "", url: str = ""
    ) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""The link text"""
        self.anchor_name: Union[str, None] = anchor_name
        r"""The anchor name\. If the name is empty, the link must bring back to top"""
        self.url: Union[str, None] = url
        r"""An HTTP URL, opening the anchor"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTextAnchorLink"]:
        return "richTextAnchorLink"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "anchor_name": self.anchor_name,
            "url": self.url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTextAnchorLink", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.anchor_name = data.get("anchor_name", "")
            data_class.url = data.get("url", "")

        return data_class


class RichTexts(TlObject, RichText):
    r"""A concatenation of rich texts

    Parameters:
        texts (:class:`List["types.RichText"]`):
            Texts

    """

    def __init__(self, texts: List[RichText] = None) -> None:
        self.texts: List[RichText] = texts or []
        r"""Texts"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["richTexts"]:
        return "richTexts"

    def getClass(self) -> Literal["RichText"]:
        return "RichText"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "texts": self.texts}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RichTexts", None]:
        if data:
            data_class = cls()
            data_class.texts = data.get("texts", None)

        return data_class


class PageBlockCaption(TlObject):
    r"""Contains a caption of another block

    Parameters:
        text (:class:`"types.RichText"`):
            Content of the caption

        credit (:class:`"types.RichText"`):
            Block credit \(like HTML tag <cite\>\)

    """

    def __init__(self, text: RichText = None, credit: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Content of the caption"""
        self.credit: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = credit
        r"""Block credit \(like HTML tag <cite\>\)"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockCaption"]:
        return "pageBlockCaption"

    def getClass(self) -> Literal["PageBlockCaption"]:
        return "PageBlockCaption"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "credit": self.credit}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockCaption", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.credit = data.get("credit", None)

        return data_class


class PageBlockListItem(TlObject):
    r"""Describes an item of a list page block

    Parameters:
        label (:class:`str`):
            Item label

        page_blocks (:class:`List["types.PageBlock"]`):
            Item blocks

    """

    def __init__(self, label: str = "", page_blocks: List[PageBlock] = None) -> None:
        self.label: Union[str, None] = label
        r"""Item label"""
        self.page_blocks: List[PageBlock] = page_blocks or []
        r"""Item blocks"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockListItem"]:
        return "pageBlockListItem"

    def getClass(self) -> Literal["PageBlockListItem"]:
        return "PageBlockListItem"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "label": self.label,
            "page_blocks": self.page_blocks,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockListItem", None]:
        if data:
            data_class = cls()
            data_class.label = data.get("label", "")
            data_class.page_blocks = data.get("page_blocks", None)

        return data_class


class PageBlockHorizontalAlignmentLeft(TlObject, PageBlockHorizontalAlignment):
    r"""The content must be left\-aligned"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockHorizontalAlignmentLeft"]:
        return "pageBlockHorizontalAlignmentLeft"

    def getClass(self) -> Literal["PageBlockHorizontalAlignment"]:
        return "PageBlockHorizontalAlignment"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockHorizontalAlignmentLeft", None]:
        if data:
            data_class = cls()

        return data_class


class PageBlockHorizontalAlignmentCenter(TlObject, PageBlockHorizontalAlignment):
    r"""The content must be center\-aligned"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockHorizontalAlignmentCenter"]:
        return "pageBlockHorizontalAlignmentCenter"

    def getClass(self) -> Literal["PageBlockHorizontalAlignment"]:
        return "PageBlockHorizontalAlignment"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockHorizontalAlignmentCenter", None]:
        if data:
            data_class = cls()

        return data_class


class PageBlockHorizontalAlignmentRight(TlObject, PageBlockHorizontalAlignment):
    r"""The content must be right\-aligned"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockHorizontalAlignmentRight"]:
        return "pageBlockHorizontalAlignmentRight"

    def getClass(self) -> Literal["PageBlockHorizontalAlignment"]:
        return "PageBlockHorizontalAlignment"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockHorizontalAlignmentRight", None]:
        if data:
            data_class = cls()

        return data_class


class PageBlockVerticalAlignmentTop(TlObject, PageBlockVerticalAlignment):
    r"""The content must be top\-aligned"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockVerticalAlignmentTop"]:
        return "pageBlockVerticalAlignmentTop"

    def getClass(self) -> Literal["PageBlockVerticalAlignment"]:
        return "PageBlockVerticalAlignment"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockVerticalAlignmentTop", None]:
        if data:
            data_class = cls()

        return data_class


class PageBlockVerticalAlignmentMiddle(TlObject, PageBlockVerticalAlignment):
    r"""The content must be middle\-aligned"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockVerticalAlignmentMiddle"]:
        return "pageBlockVerticalAlignmentMiddle"

    def getClass(self) -> Literal["PageBlockVerticalAlignment"]:
        return "PageBlockVerticalAlignment"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockVerticalAlignmentMiddle", None]:
        if data:
            data_class = cls()

        return data_class


class PageBlockVerticalAlignmentBottom(TlObject, PageBlockVerticalAlignment):
    r"""The content must be bottom\-aligned"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockVerticalAlignmentBottom"]:
        return "pageBlockVerticalAlignmentBottom"

    def getClass(self) -> Literal["PageBlockVerticalAlignment"]:
        return "PageBlockVerticalAlignment"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockVerticalAlignmentBottom", None]:
        if data:
            data_class = cls()

        return data_class


class PageBlockTableCell(TlObject):
    r"""Represents a cell of a table

    Parameters:
        text (:class:`"types.RichText"`):
            Cell text; may be null\. If the text is null, then the cell must be invisible

        is_header (:class:`bool`):
            True, if it is a header cell

        colspan (:class:`int`):
            The number of columns the cell spans

        rowspan (:class:`int`):
            The number of rows the cell spans

        align (:class:`"types.PageBlockHorizontalAlignment"`):
            Horizontal cell content alignment

        valign (:class:`"types.PageBlockVerticalAlignment"`):
            Vertical cell content alignment

    """

    def __init__(
        self,
        text: RichText = None,
        is_header: bool = False,
        colspan: int = 0,
        rowspan: int = 0,
        align: PageBlockHorizontalAlignment = None,
        valign: PageBlockVerticalAlignment = None,
    ) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Cell text; may be null\. If the text is null, then the cell must be invisible"""
        self.is_header: bool = bool(is_header)
        r"""True, if it is a header cell"""
        self.colspan: int = int(colspan)
        r"""The number of columns the cell spans"""
        self.rowspan: int = int(rowspan)
        r"""The number of rows the cell spans"""
        self.align: Union[
            PageBlockHorizontalAlignmentLeft,
            PageBlockHorizontalAlignmentCenter,
            PageBlockHorizontalAlignmentRight,
            None,
        ] = align
        r"""Horizontal cell content alignment"""
        self.valign: Union[
            PageBlockVerticalAlignmentTop,
            PageBlockVerticalAlignmentMiddle,
            PageBlockVerticalAlignmentBottom,
            None,
        ] = valign
        r"""Vertical cell content alignment"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockTableCell"]:
        return "pageBlockTableCell"

    def getClass(self) -> Literal["PageBlockTableCell"]:
        return "PageBlockTableCell"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "is_header": self.is_header,
            "colspan": self.colspan,
            "rowspan": self.rowspan,
            "align": self.align,
            "valign": self.valign,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockTableCell", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.is_header = data.get("is_header", False)
            data_class.colspan = int(data.get("colspan", 0))
            data_class.rowspan = int(data.get("rowspan", 0))
            data_class.align = data.get("align", None)
            data_class.valign = data.get("valign", None)

        return data_class


class PageBlockRelatedArticle(TlObject):
    r"""Contains information about a related article

    Parameters:
        url (:class:`str`):
            Related article URL

        title (:class:`str`):
            Article title; may be empty

        description (:class:`str`):
            Article description; may be empty

        photo (:class:`"types.Photo"`):
            Article photo; may be null

        author (:class:`str`):
            Article author; may be empty

        publish_date (:class:`int`):
            Point in time \(Unix timestamp\) when the article was published; 0 if unknown

    """

    def __init__(
        self,
        url: str = "",
        title: str = "",
        description: str = "",
        photo: Photo = None,
        author: str = "",
        publish_date: int = 0,
    ) -> None:
        self.url: Union[str, None] = url
        r"""Related article URL"""
        self.title: Union[str, None] = title
        r"""Article title; may be empty"""
        self.description: Union[str, None] = description
        r"""Article description; may be empty"""
        self.photo: Union[Photo, None] = photo
        r"""Article photo; may be null"""
        self.author: Union[str, None] = author
        r"""Article author; may be empty"""
        self.publish_date: int = int(publish_date)
        r"""Point in time \(Unix timestamp\) when the article was published; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockRelatedArticle"]:
        return "pageBlockRelatedArticle"

    def getClass(self) -> Literal["PageBlockRelatedArticle"]:
        return "PageBlockRelatedArticle"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "title": self.title,
            "description": self.description,
            "photo": self.photo,
            "author": self.author,
            "publish_date": self.publish_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockRelatedArticle", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.photo = data.get("photo", None)
            data_class.author = data.get("author", "")
            data_class.publish_date = int(data.get("publish_date", 0))

        return data_class


class PageBlockTitle(TlObject, PageBlock):
    r"""The title of a page

    Parameters:
        title (:class:`"types.RichText"`):
            Title

    """

    def __init__(self, title: RichText = None) -> None:
        self.title: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = title
        r"""Title"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockTitle"]:
        return "pageBlockTitle"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockTitle", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", None)

        return data_class


class PageBlockSubtitle(TlObject, PageBlock):
    r"""The subtitle of a page

    Parameters:
        subtitle (:class:`"types.RichText"`):
            Subtitle

    """

    def __init__(self, subtitle: RichText = None) -> None:
        self.subtitle: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = subtitle
        r"""Subtitle"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockSubtitle"]:
        return "pageBlockSubtitle"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "subtitle": self.subtitle}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockSubtitle", None]:
        if data:
            data_class = cls()
            data_class.subtitle = data.get("subtitle", None)

        return data_class


class PageBlockAuthorDate(TlObject, PageBlock):
    r"""The author and publishing date of a page

    Parameters:
        author (:class:`"types.RichText"`):
            Author

        publish_date (:class:`int`):
            Point in time \(Unix timestamp\) when the article was published; 0 if unknown

    """

    def __init__(self, author: RichText = None, publish_date: int = 0) -> None:
        self.author: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = author
        r"""Author"""
        self.publish_date: int = int(publish_date)
        r"""Point in time \(Unix timestamp\) when the article was published; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockAuthorDate"]:
        return "pageBlockAuthorDate"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "author": self.author,
            "publish_date": self.publish_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockAuthorDate", None]:
        if data:
            data_class = cls()
            data_class.author = data.get("author", None)
            data_class.publish_date = int(data.get("publish_date", 0))

        return data_class


class PageBlockHeader(TlObject, PageBlock):
    r"""A header

    Parameters:
        header (:class:`"types.RichText"`):
            Header

    """

    def __init__(self, header: RichText = None) -> None:
        self.header: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = header
        r"""Header"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockHeader"]:
        return "pageBlockHeader"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "header": self.header}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockHeader", None]:
        if data:
            data_class = cls()
            data_class.header = data.get("header", None)

        return data_class


class PageBlockSubheader(TlObject, PageBlock):
    r"""A subheader

    Parameters:
        subheader (:class:`"types.RichText"`):
            Subheader

    """

    def __init__(self, subheader: RichText = None) -> None:
        self.subheader: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = subheader
        r"""Subheader"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockSubheader"]:
        return "pageBlockSubheader"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "subheader": self.subheader}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockSubheader", None]:
        if data:
            data_class = cls()
            data_class.subheader = data.get("subheader", None)

        return data_class


class PageBlockKicker(TlObject, PageBlock):
    r"""A kicker

    Parameters:
        kicker (:class:`"types.RichText"`):
            Kicker

    """

    def __init__(self, kicker: RichText = None) -> None:
        self.kicker: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = kicker
        r"""Kicker"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockKicker"]:
        return "pageBlockKicker"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "kicker": self.kicker}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockKicker", None]:
        if data:
            data_class = cls()
            data_class.kicker = data.get("kicker", None)

        return data_class


class PageBlockParagraph(TlObject, PageBlock):
    r"""A text paragraph

    Parameters:
        text (:class:`"types.RichText"`):
            Paragraph text

    """

    def __init__(self, text: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Paragraph text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockParagraph"]:
        return "pageBlockParagraph"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockParagraph", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)

        return data_class


class PageBlockPreformatted(TlObject, PageBlock):
    r"""A preformatted text paragraph

    Parameters:
        text (:class:`"types.RichText"`):
            Paragraph text

        language (:class:`str`):
            Programming language for which the text needs to be formatted

    """

    def __init__(self, text: RichText = None, language: str = "") -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Paragraph text"""
        self.language: Union[str, None] = language
        r"""Programming language for which the text needs to be formatted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockPreformatted"]:
        return "pageBlockPreformatted"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "language": self.language}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockPreformatted", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.language = data.get("language", "")

        return data_class


class PageBlockFooter(TlObject, PageBlock):
    r"""The footer of a page

    Parameters:
        footer (:class:`"types.RichText"`):
            Footer

    """

    def __init__(self, footer: RichText = None) -> None:
        self.footer: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = footer
        r"""Footer"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockFooter"]:
        return "pageBlockFooter"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "footer": self.footer}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockFooter", None]:
        if data:
            data_class = cls()
            data_class.footer = data.get("footer", None)

        return data_class


class PageBlockDivider(TlObject, PageBlock):
    r"""An empty block separating a page"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockDivider"]:
        return "pageBlockDivider"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockDivider", None]:
        if data:
            data_class = cls()

        return data_class


class PageBlockAnchor(TlObject, PageBlock):
    r"""An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor

    Parameters:
        name (:class:`str`):
            Name of the anchor

    """

    def __init__(self, name: str = "") -> None:
        self.name: Union[str, None] = name
        r"""Name of the anchor"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockAnchor"]:
        return "pageBlockAnchor"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockAnchor", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")

        return data_class


class PageBlockList(TlObject, PageBlock):
    r"""A list of data blocks

    Parameters:
        items (:class:`List["types.PageBlockListItem"]`):
            The items of the list

    """

    def __init__(self, items: List[PageBlockListItem] = None) -> None:
        self.items: List[PageBlockListItem] = items or []
        r"""The items of the list"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockList"]:
        return "pageBlockList"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "items": self.items}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockList", None]:
        if data:
            data_class = cls()
            data_class.items = data.get("items", None)

        return data_class


class PageBlockBlockQuote(TlObject, PageBlock):
    r"""A block quote

    Parameters:
        text (:class:`"types.RichText"`):
            Quote text

        credit (:class:`"types.RichText"`):
            Quote credit

    """

    def __init__(self, text: RichText = None, credit: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Quote text"""
        self.credit: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = credit
        r"""Quote credit"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockBlockQuote"]:
        return "pageBlockBlockQuote"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "credit": self.credit}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockBlockQuote", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.credit = data.get("credit", None)

        return data_class


class PageBlockPullQuote(TlObject, PageBlock):
    r"""A pull quote

    Parameters:
        text (:class:`"types.RichText"`):
            Quote text

        credit (:class:`"types.RichText"`):
            Quote credit

    """

    def __init__(self, text: RichText = None, credit: RichText = None) -> None:
        self.text: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = text
        r"""Quote text"""
        self.credit: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = credit
        r"""Quote credit"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockPullQuote"]:
        return "pageBlockPullQuote"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "credit": self.credit}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockPullQuote", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.credit = data.get("credit", None)

        return data_class


class PageBlockAnimation(TlObject, PageBlock):
    r"""An animation

    Parameters:
        animation (:class:`"types.Animation"`):
            Animation file; may be null

        caption (:class:`"types.PageBlockCaption"`):
            Animation caption

        need_autoplay (:class:`bool`):
            True, if the animation must be played automatically

    """

    def __init__(
        self,
        animation: Animation = None,
        caption: PageBlockCaption = None,
        need_autoplay: bool = False,
    ) -> None:
        self.animation: Union[Animation, None] = animation
        r"""Animation file; may be null"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Animation caption"""
        self.need_autoplay: bool = bool(need_autoplay)
        r"""True, if the animation must be played automatically"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockAnimation"]:
        return "pageBlockAnimation"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "animation": self.animation,
            "caption": self.caption,
            "need_autoplay": self.need_autoplay,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockAnimation", None]:
        if data:
            data_class = cls()
            data_class.animation = data.get("animation", None)
            data_class.caption = data.get("caption", None)
            data_class.need_autoplay = data.get("need_autoplay", False)

        return data_class


class PageBlockAudio(TlObject, PageBlock):
    r"""An audio file

    Parameters:
        audio (:class:`"types.Audio"`):
            Audio file; may be null

        caption (:class:`"types.PageBlockCaption"`):
            Audio file caption

    """

    def __init__(self, audio: Audio = None, caption: PageBlockCaption = None) -> None:
        self.audio: Union[Audio, None] = audio
        r"""Audio file; may be null"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Audio file caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockAudio"]:
        return "pageBlockAudio"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "audio": self.audio, "caption": self.caption}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockAudio", None]:
        if data:
            data_class = cls()
            data_class.audio = data.get("audio", None)
            data_class.caption = data.get("caption", None)

        return data_class


class PageBlockPhoto(TlObject, PageBlock):
    r"""A photo

    Parameters:
        photo (:class:`"types.Photo"`):
            Photo file; may be null

        caption (:class:`"types.PageBlockCaption"`):
            Photo caption

        url (:class:`str`):
            URL that needs to be opened when the photo is clicked

    """

    def __init__(
        self, photo: Photo = None, caption: PageBlockCaption = None, url: str = ""
    ) -> None:
        self.photo: Union[Photo, None] = photo
        r"""Photo file; may be null"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Photo caption"""
        self.url: Union[str, None] = url
        r"""URL that needs to be opened when the photo is clicked"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockPhoto"]:
        return "pageBlockPhoto"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "caption": self.caption,
            "url": self.url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockPhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.caption = data.get("caption", None)
            data_class.url = data.get("url", "")

        return data_class


class PageBlockVideo(TlObject, PageBlock):
    r"""A video

    Parameters:
        video (:class:`"types.Video"`):
            Video file; may be null

        caption (:class:`"types.PageBlockCaption"`):
            Video caption

        need_autoplay (:class:`bool`):
            True, if the video must be played automatically

        is_looped (:class:`bool`):
            True, if the video must be looped

    """

    def __init__(
        self,
        video: Video = None,
        caption: PageBlockCaption = None,
        need_autoplay: bool = False,
        is_looped: bool = False,
    ) -> None:
        self.video: Union[Video, None] = video
        r"""Video file; may be null"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Video caption"""
        self.need_autoplay: bool = bool(need_autoplay)
        r"""True, if the video must be played automatically"""
        self.is_looped: bool = bool(is_looped)
        r"""True, if the video must be looped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockVideo"]:
        return "pageBlockVideo"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "caption": self.caption,
            "need_autoplay": self.need_autoplay,
            "is_looped": self.is_looped,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.caption = data.get("caption", None)
            data_class.need_autoplay = data.get("need_autoplay", False)
            data_class.is_looped = data.get("is_looped", False)

        return data_class


class PageBlockVoiceNote(TlObject, PageBlock):
    r"""A voice note

    Parameters:
        voice_note (:class:`"types.VoiceNote"`):
            Voice note; may be null

        caption (:class:`"types.PageBlockCaption"`):
            Voice note caption

    """

    def __init__(
        self, voice_note: VoiceNote = None, caption: PageBlockCaption = None
    ) -> None:
        self.voice_note: Union[VoiceNote, None] = voice_note
        r"""Voice note; may be null"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Voice note caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockVoiceNote"]:
        return "pageBlockVoiceNote"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "voice_note": self.voice_note,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.voice_note = data.get("voice_note", None)
            data_class.caption = data.get("caption", None)

        return data_class


class PageBlockCover(TlObject, PageBlock):
    r"""A page cover

    Parameters:
        cover (:class:`"types.PageBlock"`):
            Cover

    """

    def __init__(self, cover: PageBlock = None) -> None:
        self.cover: Union[
            PageBlockTitle,
            PageBlockSubtitle,
            PageBlockAuthorDate,
            PageBlockHeader,
            PageBlockSubheader,
            PageBlockKicker,
            PageBlockParagraph,
            PageBlockPreformatted,
            PageBlockFooter,
            PageBlockDivider,
            PageBlockAnchor,
            PageBlockList,
            PageBlockBlockQuote,
            PageBlockPullQuote,
            PageBlockAnimation,
            PageBlockAudio,
            PageBlockPhoto,
            PageBlockVideo,
            PageBlockVoiceNote,
            PageBlockCover,
            PageBlockEmbedded,
            PageBlockEmbeddedPost,
            PageBlockCollage,
            PageBlockSlideshow,
            PageBlockChatLink,
            PageBlockTable,
            PageBlockDetails,
            PageBlockRelatedArticles,
            PageBlockMap,
            None,
        ] = cover
        r"""Cover"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockCover"]:
        return "pageBlockCover"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "cover": self.cover}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockCover", None]:
        if data:
            data_class = cls()
            data_class.cover = data.get("cover", None)

        return data_class


class PageBlockEmbedded(TlObject, PageBlock):
    r"""An embedded web page

    Parameters:
        url (:class:`str`):
            URL of the embedded page, if available

        html (:class:`str`):
            HTML\-markup of the embedded page

        poster_photo (:class:`"types.Photo"`):
            Poster photo, if available; may be null

        width (:class:`int`):
            Block width; 0 if unknown

        height (:class:`int`):
            Block height; 0 if unknown

        caption (:class:`"types.PageBlockCaption"`):
            Block caption

        is_full_width (:class:`bool`):
            True, if the block must be full width

        allow_scrolling (:class:`bool`):
            True, if scrolling needs to be allowed

    """

    def __init__(
        self,
        url: str = "",
        html: str = "",
        poster_photo: Photo = None,
        width: int = 0,
        height: int = 0,
        caption: PageBlockCaption = None,
        is_full_width: bool = False,
        allow_scrolling: bool = False,
    ) -> None:
        self.url: Union[str, None] = url
        r"""URL of the embedded page, if available"""
        self.html: Union[str, None] = html
        r"""HTML\-markup of the embedded page"""
        self.poster_photo: Union[Photo, None] = poster_photo
        r"""Poster photo, if available; may be null"""
        self.width: int = int(width)
        r"""Block width; 0 if unknown"""
        self.height: int = int(height)
        r"""Block height; 0 if unknown"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Block caption"""
        self.is_full_width: bool = bool(is_full_width)
        r"""True, if the block must be full width"""
        self.allow_scrolling: bool = bool(allow_scrolling)
        r"""True, if scrolling needs to be allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockEmbedded"]:
        return "pageBlockEmbedded"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "html": self.html,
            "poster_photo": self.poster_photo,
            "width": self.width,
            "height": self.height,
            "caption": self.caption,
            "is_full_width": self.is_full_width,
            "allow_scrolling": self.allow_scrolling,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockEmbedded", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.html = data.get("html", "")
            data_class.poster_photo = data.get("poster_photo", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.caption = data.get("caption", None)
            data_class.is_full_width = data.get("is_full_width", False)
            data_class.allow_scrolling = data.get("allow_scrolling", False)

        return data_class


class PageBlockEmbeddedPost(TlObject, PageBlock):
    r"""An embedded post

    Parameters:
        url (:class:`str`):
            URL of the embedded post

        author (:class:`str`):
            Post author

        author_photo (:class:`"types.Photo"`):
            Post author photo; may be null

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the post was created; 0 if unknown

        page_blocks (:class:`List["types.PageBlock"]`):
            Post content

        caption (:class:`"types.PageBlockCaption"`):
            Post caption

    """

    def __init__(
        self,
        url: str = "",
        author: str = "",
        author_photo: Photo = None,
        date: int = 0,
        page_blocks: List[PageBlock] = None,
        caption: PageBlockCaption = None,
    ) -> None:
        self.url: Union[str, None] = url
        r"""URL of the embedded post"""
        self.author: Union[str, None] = author
        r"""Post author"""
        self.author_photo: Union[Photo, None] = author_photo
        r"""Post author photo; may be null"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the post was created; 0 if unknown"""
        self.page_blocks: List[PageBlock] = page_blocks or []
        r"""Post content"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Post caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockEmbeddedPost"]:
        return "pageBlockEmbeddedPost"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "author": self.author,
            "author_photo": self.author_photo,
            "date": self.date,
            "page_blocks": self.page_blocks,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockEmbeddedPost", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.author = data.get("author", "")
            data_class.author_photo = data.get("author_photo", None)
            data_class.date = int(data.get("date", 0))
            data_class.page_blocks = data.get("page_blocks", None)
            data_class.caption = data.get("caption", None)

        return data_class


class PageBlockCollage(TlObject, PageBlock):
    r"""A collage

    Parameters:
        page_blocks (:class:`List["types.PageBlock"]`):
            Collage item contents

        caption (:class:`"types.PageBlockCaption"`):
            Block caption

    """

    def __init__(
        self, page_blocks: List[PageBlock] = None, caption: PageBlockCaption = None
    ) -> None:
        self.page_blocks: List[PageBlock] = page_blocks or []
        r"""Collage item contents"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Block caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockCollage"]:
        return "pageBlockCollage"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "page_blocks": self.page_blocks,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockCollage", None]:
        if data:
            data_class = cls()
            data_class.page_blocks = data.get("page_blocks", None)
            data_class.caption = data.get("caption", None)

        return data_class


class PageBlockSlideshow(TlObject, PageBlock):
    r"""A slideshow

    Parameters:
        page_blocks (:class:`List["types.PageBlock"]`):
            Slideshow item contents

        caption (:class:`"types.PageBlockCaption"`):
            Block caption

    """

    def __init__(
        self, page_blocks: List[PageBlock] = None, caption: PageBlockCaption = None
    ) -> None:
        self.page_blocks: List[PageBlock] = page_blocks or []
        r"""Slideshow item contents"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Block caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockSlideshow"]:
        return "pageBlockSlideshow"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "page_blocks": self.page_blocks,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockSlideshow", None]:
        if data:
            data_class = cls()
            data_class.page_blocks = data.get("page_blocks", None)
            data_class.caption = data.get("caption", None)

        return data_class


class PageBlockChatLink(TlObject, PageBlock):
    r"""A link to a chat

    Parameters:
        title (:class:`str`):
            Chat title

        photo (:class:`"types.ChatPhotoInfo"`):
            Chat photo; may be null

        accent_color_id (:class:`int`):
            Identifier of the accent color for chat title and background of chat photo

        username (:class:`str`):
            Chat username by which all other information about the chat can be resolved

    """

    def __init__(
        self,
        title: str = "",
        photo: ChatPhotoInfo = None,
        accent_color_id: int = 0,
        username: str = "",
    ) -> None:
        self.title: Union[str, None] = title
        r"""Chat title"""
        self.photo: Union[ChatPhotoInfo, None] = photo
        r"""Chat photo; may be null"""
        self.accent_color_id: int = int(accent_color_id)
        r"""Identifier of the accent color for chat title and background of chat photo"""
        self.username: Union[str, None] = username
        r"""Chat username by which all other information about the chat can be resolved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockChatLink"]:
        return "pageBlockChatLink"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "photo": self.photo,
            "accent_color_id": self.accent_color_id,
            "username": self.username,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockChatLink", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.photo = data.get("photo", None)
            data_class.accent_color_id = int(data.get("accent_color_id", 0))
            data_class.username = data.get("username", "")

        return data_class


class PageBlockTable(TlObject, PageBlock):
    r"""A table

    Parameters:
        caption (:class:`"types.RichText"`):
            Table caption

        cells (:class:`List[List["types.PageBlockTableCell"]]`):
            Table cells

        is_bordered (:class:`bool`):
            True, if the table is bordered

        is_striped (:class:`bool`):
            True, if the table is striped

    """

    def __init__(
        self,
        caption: RichText = None,
        cells: List[List[PageBlockTableCell]] = None,
        is_bordered: bool = False,
        is_striped: bool = False,
    ) -> None:
        self.caption: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = caption
        r"""Table caption"""
        self.cells: List[List[PageBlockTableCell]] = cells or []
        r"""Table cells"""
        self.is_bordered: bool = bool(is_bordered)
        r"""True, if the table is bordered"""
        self.is_striped: bool = bool(is_striped)
        r"""True, if the table is striped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockTable"]:
        return "pageBlockTable"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "caption": self.caption,
            "cells": self.cells,
            "is_bordered": self.is_bordered,
            "is_striped": self.is_striped,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockTable", None]:
        if data:
            data_class = cls()
            data_class.caption = data.get("caption", None)
            data_class.cells = data.get("cells", None)
            data_class.is_bordered = data.get("is_bordered", False)
            data_class.is_striped = data.get("is_striped", False)

        return data_class


class PageBlockDetails(TlObject, PageBlock):
    r"""A collapsible block

    Parameters:
        header (:class:`"types.RichText"`):
            Always visible heading for the block

        page_blocks (:class:`List["types.PageBlock"]`):
            Block contents

        is_open (:class:`bool`):
            True, if the block is open by default

    """

    def __init__(
        self,
        header: RichText = None,
        page_blocks: List[PageBlock] = None,
        is_open: bool = False,
    ) -> None:
        self.header: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = header
        r"""Always visible heading for the block"""
        self.page_blocks: List[PageBlock] = page_blocks or []
        r"""Block contents"""
        self.is_open: bool = bool(is_open)
        r"""True, if the block is open by default"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockDetails"]:
        return "pageBlockDetails"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "header": self.header,
            "page_blocks": self.page_blocks,
            "is_open": self.is_open,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockDetails", None]:
        if data:
            data_class = cls()
            data_class.header = data.get("header", None)
            data_class.page_blocks = data.get("page_blocks", None)
            data_class.is_open = data.get("is_open", False)

        return data_class


class PageBlockRelatedArticles(TlObject, PageBlock):
    r"""Related articles

    Parameters:
        header (:class:`"types.RichText"`):
            Block header

        articles (:class:`List["types.PageBlockRelatedArticle"]`):
            List of related articles

    """

    def __init__(
        self, header: RichText = None, articles: List[PageBlockRelatedArticle] = None
    ) -> None:
        self.header: Union[
            RichTextPlain,
            RichTextBold,
            RichTextItalic,
            RichTextUnderline,
            RichTextStrikethrough,
            RichTextFixed,
            RichTextUrl,
            RichTextEmailAddress,
            RichTextSubscript,
            RichTextSuperscript,
            RichTextMarked,
            RichTextPhoneNumber,
            RichTextIcon,
            RichTextReference,
            RichTextAnchor,
            RichTextAnchorLink,
            RichTexts,
            None,
        ] = header
        r"""Block header"""
        self.articles: List[PageBlockRelatedArticle] = articles or []
        r"""List of related articles"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockRelatedArticles"]:
        return "pageBlockRelatedArticles"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "header": self.header,
            "articles": self.articles,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockRelatedArticles", None]:
        if data:
            data_class = cls()
            data_class.header = data.get("header", None)
            data_class.articles = data.get("articles", None)

        return data_class


class PageBlockMap(TlObject, PageBlock):
    r"""A map

    Parameters:
        location (:class:`"types.Location"`):
            Location of the map center

        zoom (:class:`int`):
            Map zoom level

        width (:class:`int`):
            Map width

        height (:class:`int`):
            Map height

        caption (:class:`"types.PageBlockCaption"`):
            Block caption

    """

    def __init__(
        self,
        location: Location = None,
        zoom: int = 0,
        width: int = 0,
        height: int = 0,
        caption: PageBlockCaption = None,
    ) -> None:
        self.location: Union[Location, None] = location
        r"""Location of the map center"""
        self.zoom: int = int(zoom)
        r"""Map zoom level"""
        self.width: int = int(width)
        r"""Map width"""
        self.height: int = int(height)
        r"""Map height"""
        self.caption: Union[PageBlockCaption, None] = caption
        r"""Block caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pageBlockMap"]:
        return "pageBlockMap"

    def getClass(self) -> Literal["PageBlock"]:
        return "PageBlock"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "zoom": self.zoom,
            "width": self.width,
            "height": self.height,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PageBlockMap", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.zoom = int(data.get("zoom", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.caption = data.get("caption", None)

        return data_class


class WebPageInstantView(TlObject):
    r"""Describes an instant view page for a web page

    Parameters:
        page_blocks (:class:`List["types.PageBlock"]`):
            Content of the instant view page

        view_count (:class:`int`):
            Number of the instant view views; 0 if unknown

        version (:class:`int`):
            Version of the instant view; currently, can be 1 or 2

        is_rtl (:class:`bool`):
            True, if the instant view must be shown from right to left

        is_full (:class:`bool`):
            True, if the instant view contains the full page\. A network request might be needed to get the full instant view

        feedback_link (:class:`"types.InternalLinkType"`):
            An internal link to be opened to leave feedback about the instant view

    """

    def __init__(
        self,
        page_blocks: List[PageBlock] = None,
        view_count: int = 0,
        version: int = 0,
        is_rtl: bool = False,
        is_full: bool = False,
        feedback_link: InternalLinkType = None,
    ) -> None:
        self.page_blocks: List[PageBlock] = page_blocks or []
        r"""Content of the instant view page"""
        self.view_count: int = int(view_count)
        r"""Number of the instant view views; 0 if unknown"""
        self.version: int = int(version)
        r"""Version of the instant view; currently, can be 1 or 2"""
        self.is_rtl: bool = bool(is_rtl)
        r"""True, if the instant view must be shown from right to left"""
        self.is_full: bool = bool(is_full)
        r"""True, if the instant view contains the full page\. A network request might be needed to get the full instant view"""
        self.feedback_link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = feedback_link
        r"""An internal link to be opened to leave feedback about the instant view"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["webPageInstantView"]:
        return "webPageInstantView"

    def getClass(self) -> Literal["WebPageInstantView"]:
        return "WebPageInstantView"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "page_blocks": self.page_blocks,
            "view_count": self.view_count,
            "version": self.version,
            "is_rtl": self.is_rtl,
            "is_full": self.is_full,
            "feedback_link": self.feedback_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["WebPageInstantView", None]:
        if data:
            data_class = cls()
            data_class.page_blocks = data.get("page_blocks", None)
            data_class.view_count = int(data.get("view_count", 0))
            data_class.version = int(data.get("version", 0))
            data_class.is_rtl = data.get("is_rtl", False)
            data_class.is_full = data.get("is_full", False)
            data_class.feedback_link = data.get("feedback_link", None)

        return data_class


class LinkPreviewAlbumMediaPhoto(TlObject, LinkPreviewAlbumMedia):
    r"""The media is a photo

    Parameters:
        photo (:class:`"types.Photo"`):
            Photo description

    """

    def __init__(self, photo: Photo = None) -> None:
        self.photo: Union[Photo, None] = photo
        r"""Photo description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewAlbumMediaPhoto"]:
        return "linkPreviewAlbumMediaPhoto"

    def getClass(self) -> Literal["LinkPreviewAlbumMedia"]:
        return "LinkPreviewAlbumMedia"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewAlbumMediaPhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class LinkPreviewAlbumMediaVideo(TlObject, LinkPreviewAlbumMedia):
    r"""The media is a video

    Parameters:
        video (:class:`"types.Video"`):
            Video description

    """

    def __init__(self, video: Video = None) -> None:
        self.video: Union[Video, None] = video
        r"""Video description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewAlbumMediaVideo"]:
        return "linkPreviewAlbumMediaVideo"

    def getClass(self) -> Literal["LinkPreviewAlbumMedia"]:
        return "LinkPreviewAlbumMedia"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "video": self.video}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewAlbumMediaVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)

        return data_class


class LinkPreviewTypeAlbum(TlObject, LinkPreviewType):
    r"""The link is a link to a media album consisting of photos and videos

    Parameters:
        media (:class:`List["types.LinkPreviewAlbumMedia"]`):
            The list of album media

        caption (:class:`str`):
            Album caption

    """

    def __init__(
        self, media: List[LinkPreviewAlbumMedia] = None, caption: str = ""
    ) -> None:
        self.media: List[LinkPreviewAlbumMedia] = media or []
        r"""The list of album media"""
        self.caption: Union[str, None] = caption
        r"""Album caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeAlbum"]:
        return "linkPreviewTypeAlbum"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "media": self.media, "caption": self.caption}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeAlbum", None]:
        if data:
            data_class = cls()
            data_class.media = data.get("media", None)
            data_class.caption = data.get("caption", "")

        return data_class


class LinkPreviewTypeAnimation(TlObject, LinkPreviewType):
    r"""The link is a link to an animation

    Parameters:
        animation (:class:`"types.Animation"`):
            The animation

    """

    def __init__(self, animation: Animation = None) -> None:
        self.animation: Union[Animation, None] = animation
        r"""The animation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeAnimation"]:
        return "linkPreviewTypeAnimation"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "animation": self.animation}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeAnimation", None]:
        if data:
            data_class = cls()
            data_class.animation = data.get("animation", None)

        return data_class


class LinkPreviewTypeApp(TlObject, LinkPreviewType):
    r"""The link is a link to an app at App Store or Google Play

    Parameters:
        photo (:class:`"types.Photo"`):
            Photo for the app

    """

    def __init__(self, photo: Photo = None) -> None:
        self.photo: Union[Photo, None] = photo
        r"""Photo for the app"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeApp"]:
        return "linkPreviewTypeApp"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeApp", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class LinkPreviewTypeArticle(TlObject, LinkPreviewType):
    r"""The link is a link to a web site

    Parameters:
        photo (:class:`"types.Photo"`):
            Article's main photo; may be null

    """

    def __init__(self, photo: Photo = None) -> None:
        self.photo: Union[Photo, None] = photo
        r"""Article's main photo; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeArticle"]:
        return "linkPreviewTypeArticle"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeArticle", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class LinkPreviewTypeAudio(TlObject, LinkPreviewType):
    r"""The link is a link to an audio

    Parameters:
        audio (:class:`"types.Audio"`):
            The audio description

    """

    def __init__(self, audio: Audio = None) -> None:
        self.audio: Union[Audio, None] = audio
        r"""The audio description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeAudio"]:
        return "linkPreviewTypeAudio"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "audio": self.audio}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeAudio", None]:
        if data:
            data_class = cls()
            data_class.audio = data.get("audio", None)

        return data_class


class LinkPreviewTypeBackground(TlObject, LinkPreviewType):
    r"""The link is a link to a background\. Link preview title and description are available only for filled backgrounds

    Parameters:
        document (:class:`"types.Document"`):
            Document with the background; may be null for filled backgrounds

        background_type (:class:`"types.BackgroundType"`):
            Type of the background; may be null if unknown

    """

    def __init__(
        self, document: Document = None, background_type: BackgroundType = None
    ) -> None:
        self.document: Union[Document, None] = document
        r"""Document with the background; may be null for filled backgrounds"""
        self.background_type: Union[
            BackgroundTypeWallpaper,
            BackgroundTypePattern,
            BackgroundTypeFill,
            BackgroundTypeChatTheme,
            None,
        ] = background_type
        r"""Type of the background; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeBackground"]:
        return "linkPreviewTypeBackground"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "document": self.document,
            "background_type": self.background_type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeBackground", None]:
        if data:
            data_class = cls()
            data_class.document = data.get("document", None)
            data_class.background_type = data.get("background_type", None)

        return data_class


class LinkPreviewTypeChannelBoost(TlObject, LinkPreviewType):
    r"""The link is a link to boost a channel chat

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            Photo of the chat; may be null

    """

    def __init__(self, photo: ChatPhoto = None) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""Photo of the chat; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeChannelBoost"]:
        return "linkPreviewTypeChannelBoost"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeChannelBoost", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class LinkPreviewTypeChat(TlObject, LinkPreviewType):
    r"""The link is a link to a chat

    Parameters:
        type (:class:`"types.InviteLinkChatType"`):
            Type of the chat

        photo (:class:`"types.ChatPhoto"`):
            Photo of the chat; may be null

        creates_join_request (:class:`bool`):
            True, if the link only creates join request

    """

    def __init__(
        self,
        type: InviteLinkChatType = None,
        photo: ChatPhoto = None,
        creates_join_request: bool = False,
    ) -> None:
        self.type: Union[
            InviteLinkChatTypeBasicGroup,
            InviteLinkChatTypeSupergroup,
            InviteLinkChatTypeChannel,
            None,
        ] = type
        r"""Type of the chat"""
        self.photo: Union[ChatPhoto, None] = photo
        r"""Photo of the chat; may be null"""
        self.creates_join_request: bool = bool(creates_join_request)
        r"""True, if the link only creates join request"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeChat"]:
        return "linkPreviewTypeChat"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "photo": self.photo,
            "creates_join_request": self.creates_join_request,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeChat", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.photo = data.get("photo", None)
            data_class.creates_join_request = data.get("creates_join_request", False)

        return data_class


class LinkPreviewTypeDocument(TlObject, LinkPreviewType):
    r"""The link is a link to a general file

    Parameters:
        document (:class:`"types.Document"`):
            The document description

    """

    def __init__(self, document: Document = None) -> None:
        self.document: Union[Document, None] = document
        r"""The document description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeDocument"]:
        return "linkPreviewTypeDocument"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "document": self.document}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeDocument", None]:
        if data:
            data_class = cls()
            data_class.document = data.get("document", None)

        return data_class


class LinkPreviewTypeEmbeddedAnimationPlayer(TlObject, LinkPreviewType):
    r"""The link is a link to an animation player

    Parameters:
        url (:class:`str`):
            URL of the external animation player

        thumbnail (:class:`"types.Photo"`):
            Thumbnail of the animation; may be null if unknown

        duration (:class:`int`):
            Duration of the animation, in seconds

        width (:class:`int`):
            Expected width of the embedded player

        height (:class:`int`):
            Expected height of the embedded player

    """

    def __init__(
        self,
        url: str = "",
        thumbnail: Photo = None,
        duration: int = 0,
        width: int = 0,
        height: int = 0,
    ) -> None:
        self.url: Union[str, None] = url
        r"""URL of the external animation player"""
        self.thumbnail: Union[Photo, None] = thumbnail
        r"""Thumbnail of the animation; may be null if unknown"""
        self.duration: int = int(duration)
        r"""Duration of the animation, in seconds"""
        self.width: int = int(width)
        r"""Expected width of the embedded player"""
        self.height: int = int(height)
        r"""Expected height of the embedded player"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeEmbeddedAnimationPlayer"]:
        return "linkPreviewTypeEmbeddedAnimationPlayer"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "thumbnail": self.thumbnail,
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["LinkPreviewTypeEmbeddedAnimationPlayer", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))

        return data_class


class LinkPreviewTypeEmbeddedAudioPlayer(TlObject, LinkPreviewType):
    r"""The link is a link to an audio player

    Parameters:
        url (:class:`str`):
            URL of the external audio player

        thumbnail (:class:`"types.Photo"`):
            Thumbnail of the audio; may be null if unknown

        duration (:class:`int`):
            Duration of the audio, in seconds

        width (:class:`int`):
            Expected width of the embedded player

        height (:class:`int`):
            Expected height of the embedded player

    """

    def __init__(
        self,
        url: str = "",
        thumbnail: Photo = None,
        duration: int = 0,
        width: int = 0,
        height: int = 0,
    ) -> None:
        self.url: Union[str, None] = url
        r"""URL of the external audio player"""
        self.thumbnail: Union[Photo, None] = thumbnail
        r"""Thumbnail of the audio; may be null if unknown"""
        self.duration: int = int(duration)
        r"""Duration of the audio, in seconds"""
        self.width: int = int(width)
        r"""Expected width of the embedded player"""
        self.height: int = int(height)
        r"""Expected height of the embedded player"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeEmbeddedAudioPlayer"]:
        return "linkPreviewTypeEmbeddedAudioPlayer"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "thumbnail": self.thumbnail,
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeEmbeddedAudioPlayer", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))

        return data_class


class LinkPreviewTypeEmbeddedVideoPlayer(TlObject, LinkPreviewType):
    r"""The link is a link to a video player

    Parameters:
        url (:class:`str`):
            URL of the external video player

        thumbnail (:class:`"types.Photo"`):
            Thumbnail of the video; may be null if unknown

        duration (:class:`int`):
            Duration of the video, in seconds

        width (:class:`int`):
            Expected width of the embedded player

        height (:class:`int`):
            Expected height of the embedded player

    """

    def __init__(
        self,
        url: str = "",
        thumbnail: Photo = None,
        duration: int = 0,
        width: int = 0,
        height: int = 0,
    ) -> None:
        self.url: Union[str, None] = url
        r"""URL of the external video player"""
        self.thumbnail: Union[Photo, None] = thumbnail
        r"""Thumbnail of the video; may be null if unknown"""
        self.duration: int = int(duration)
        r"""Duration of the video, in seconds"""
        self.width: int = int(width)
        r"""Expected width of the embedded player"""
        self.height: int = int(height)
        r"""Expected height of the embedded player"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeEmbeddedVideoPlayer"]:
        return "linkPreviewTypeEmbeddedVideoPlayer"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "thumbnail": self.thumbnail,
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeEmbeddedVideoPlayer", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))

        return data_class


class LinkPreviewTypeExternalAudio(TlObject, LinkPreviewType):
    r"""The link is a link to an audio file

    Parameters:
        url (:class:`str`):
            URL of the audio file

        mime_type (:class:`str`):
            MIME type of the audio file

        duration (:class:`int`):
            Duration of the audio, in seconds; 0 if unknown

    """

    def __init__(self, url: str = "", mime_type: str = "", duration: int = 0) -> None:
        self.url: Union[str, None] = url
        r"""URL of the audio file"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the audio file"""
        self.duration: int = int(duration)
        r"""Duration of the audio, in seconds; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeExternalAudio"]:
        return "linkPreviewTypeExternalAudio"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "mime_type": self.mime_type,
            "duration": self.duration,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeExternalAudio", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.duration = int(data.get("duration", 0))

        return data_class


class LinkPreviewTypeExternalVideo(TlObject, LinkPreviewType):
    r"""The link is a link to a video file

    Parameters:
        url (:class:`str`):
            URL of the video file

        mime_type (:class:`str`):
            MIME type of the video file

        width (:class:`int`):
            Expected width of the video preview; 0 if unknown

        height (:class:`int`):
            Expected height of the video preview; 0 if unknown

        duration (:class:`int`):
            Duration of the video, in seconds; 0 if unknown

    """

    def __init__(
        self,
        url: str = "",
        mime_type: str = "",
        width: int = 0,
        height: int = 0,
        duration: int = 0,
    ) -> None:
        self.url: Union[str, None] = url
        r"""URL of the video file"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the video file"""
        self.width: int = int(width)
        r"""Expected width of the video preview; 0 if unknown"""
        self.height: int = int(height)
        r"""Expected height of the video preview; 0 if unknown"""
        self.duration: int = int(duration)
        r"""Duration of the video, in seconds; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeExternalVideo"]:
        return "linkPreviewTypeExternalVideo"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "mime_type": self.mime_type,
            "width": self.width,
            "height": self.height,
            "duration": self.duration,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeExternalVideo", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.duration = int(data.get("duration", 0))

        return data_class


class LinkPreviewTypeInvoice(TlObject, LinkPreviewType):
    r"""The link is a link to an invoice"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeInvoice"]:
        return "linkPreviewTypeInvoice"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeInvoice", None]:
        if data:
            data_class = cls()

        return data_class


class LinkPreviewTypeMessage(TlObject, LinkPreviewType):
    r"""The link is a link to a text or a poll Telegram message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeMessage"]:
        return "linkPreviewTypeMessage"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeMessage", None]:
        if data:
            data_class = cls()

        return data_class


class LinkPreviewTypePhoto(TlObject, LinkPreviewType):
    r"""The link is a link to a photo

    Parameters:
        photo (:class:`"types.Photo"`):
            The photo

    """

    def __init__(self, photo: Photo = None) -> None:
        self.photo: Union[Photo, None] = photo
        r"""The photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypePhoto"]:
        return "linkPreviewTypePhoto"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypePhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class LinkPreviewTypePremiumGiftCode(TlObject, LinkPreviewType):
    r"""The link is a link to a Telegram Premium gift code"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypePremiumGiftCode"]:
        return "linkPreviewTypePremiumGiftCode"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypePremiumGiftCode", None]:
        if data:
            data_class = cls()

        return data_class


class LinkPreviewTypeShareableChatFolder(TlObject, LinkPreviewType):
    r"""The link is a link to a shareable chat folder"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeShareableChatFolder"]:
        return "linkPreviewTypeShareableChatFolder"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeShareableChatFolder", None]:
        if data:
            data_class = cls()

        return data_class


class LinkPreviewTypeSticker(TlObject, LinkPreviewType):
    r"""The link is a link to a sticker

    Parameters:
        sticker (:class:`"types.Sticker"`):
            The sticker\. It can be an arbitrary WEBP image and can have dimensions bigger than 512

    """

    def __init__(self, sticker: Sticker = None) -> None:
        self.sticker: Union[Sticker, None] = sticker
        r"""The sticker\. It can be an arbitrary WEBP image and can have dimensions bigger than 512"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeSticker"]:
        return "linkPreviewTypeSticker"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sticker": self.sticker}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeSticker", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)

        return data_class


class LinkPreviewTypeStickerSet(TlObject, LinkPreviewType):
    r"""The link is a link to a sticker set

    Parameters:
        stickers (:class:`List["types.Sticker"]`):
            Up to 4 stickers from the sticker set

    """

    def __init__(self, stickers: List[Sticker] = None) -> None:
        self.stickers: List[Sticker] = stickers or []
        r"""Up to 4 stickers from the sticker set"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeStickerSet"]:
        return "linkPreviewTypeStickerSet"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "stickers": self.stickers}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeStickerSet", None]:
        if data:
            data_class = cls()
            data_class.stickers = data.get("stickers", None)

        return data_class


class LinkPreviewTypeStory(TlObject, LinkPreviewType):
    r"""The link is a link to a story\. Link preview description is unavailable

    Parameters:
        story_sender_chat_id (:class:`int`):
            The identifier of the chat that posted the story

        story_id (:class:`int`):
            Story identifier

    """

    def __init__(self, story_sender_chat_id: int = 0, story_id: int = 0) -> None:
        self.story_sender_chat_id: int = int(story_sender_chat_id)
        r"""The identifier of the chat that posted the story"""
        self.story_id: int = int(story_id)
        r"""Story identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeStory"]:
        return "linkPreviewTypeStory"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_sender_chat_id": self.story_sender_chat_id,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeStory", None]:
        if data:
            data_class = cls()
            data_class.story_sender_chat_id = int(data.get("story_sender_chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class LinkPreviewTypeSupergroupBoost(TlObject, LinkPreviewType):
    r"""The link is a link to boost a supergroup chat

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            Photo of the chat; may be null

    """

    def __init__(self, photo: ChatPhoto = None) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""Photo of the chat; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeSupergroupBoost"]:
        return "linkPreviewTypeSupergroupBoost"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeSupergroupBoost", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class LinkPreviewTypeTheme(TlObject, LinkPreviewType):
    r"""The link is a link to a cloud theme\. TDLib has no theme support yet

    Parameters:
        documents (:class:`List["types.Document"]`):
            The list of files with theme description

        settings (:class:`"types.ThemeSettings"`):
            Settings for the cloud theme; may be null if unknown

    """

    def __init__(
        self, documents: List[Document] = None, settings: ThemeSettings = None
    ) -> None:
        self.documents: List[Document] = documents or []
        r"""The list of files with theme description"""
        self.settings: Union[ThemeSettings, None] = settings
        r"""Settings for the cloud theme; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeTheme"]:
        return "linkPreviewTypeTheme"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "documents": self.documents,
            "settings": self.settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeTheme", None]:
        if data:
            data_class = cls()
            data_class.documents = data.get("documents", None)
            data_class.settings = data.get("settings", None)

        return data_class


class LinkPreviewTypeUnsupported(TlObject, LinkPreviewType):
    r"""The link preview type is unsupported yet"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeUnsupported"]:
        return "linkPreviewTypeUnsupported"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeUnsupported", None]:
        if data:
            data_class = cls()

        return data_class


class LinkPreviewTypeUpgradedGift(TlObject, LinkPreviewType):
    r"""The link is a link to an upgraded gift

    Parameters:
        gift (:class:`"types.UpgradedGift"`):
            The gift

    """

    def __init__(self, gift: UpgradedGift = None) -> None:
        self.gift: Union[UpgradedGift, None] = gift
        r"""The gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeUpgradedGift"]:
        return "linkPreviewTypeUpgradedGift"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "gift": self.gift}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.gift = data.get("gift", None)

        return data_class


class LinkPreviewTypeUser(TlObject, LinkPreviewType):
    r"""The link is a link to a user

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            Photo of the user; may be null if none

        is_bot (:class:`bool`):
            True, if the user is a bot

    """

    def __init__(self, photo: ChatPhoto = None, is_bot: bool = False) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""Photo of the user; may be null if none"""
        self.is_bot: bool = bool(is_bot)
        r"""True, if the user is a bot"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeUser"]:
        return "linkPreviewTypeUser"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo, "is_bot": self.is_bot}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeUser", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.is_bot = data.get("is_bot", False)

        return data_class


class LinkPreviewTypeVideo(TlObject, LinkPreviewType):
    r"""The link is a link to a video

    Parameters:
        video (:class:`"types.Video"`):
            The video description

        cover (:class:`"types.Photo"`):
            Cover of the video; may be null if none

        start_timestamp (:class:`int`):
            Timestamp from which the video playing must start, in seconds

    """

    def __init__(
        self, video: Video = None, cover: Photo = None, start_timestamp: int = 0
    ) -> None:
        self.video: Union[Video, None] = video
        r"""The video description"""
        self.cover: Union[Photo, None] = cover
        r"""Cover of the video; may be null if none"""
        self.start_timestamp: int = int(start_timestamp)
        r"""Timestamp from which the video playing must start, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeVideo"]:
        return "linkPreviewTypeVideo"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "cover": self.cover,
            "start_timestamp": self.start_timestamp,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.cover = data.get("cover", None)
            data_class.start_timestamp = int(data.get("start_timestamp", 0))

        return data_class


class LinkPreviewTypeVideoChat(TlObject, LinkPreviewType):
    r"""The link is a link to a video chat

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            Photo of the chat with the video chat; may be null if none

        is_live_stream (:class:`bool`):
            True, if the video chat is expected to be a live stream in a channel or a broadcast group

    """

    def __init__(self, photo: ChatPhoto = None, is_live_stream: bool = False) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""Photo of the chat with the video chat; may be null if none"""
        self.is_live_stream: bool = bool(is_live_stream)
        r"""True, if the video chat is expected to be a live stream in a channel or a broadcast group"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeVideoChat"]:
        return "linkPreviewTypeVideoChat"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "is_live_stream": self.is_live_stream,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeVideoChat", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.is_live_stream = data.get("is_live_stream", False)

        return data_class


class LinkPreviewTypeVideoNote(TlObject, LinkPreviewType):
    r"""The link is a link to a video note message

    Parameters:
        video_note (:class:`"types.VideoNote"`):
            The video note

    """

    def __init__(self, video_note: VideoNote = None) -> None:
        self.video_note: Union[VideoNote, None] = video_note
        r"""The video note"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeVideoNote"]:
        return "linkPreviewTypeVideoNote"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "video_note": self.video_note}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeVideoNote", None]:
        if data:
            data_class = cls()
            data_class.video_note = data.get("video_note", None)

        return data_class


class LinkPreviewTypeVoiceNote(TlObject, LinkPreviewType):
    r"""The link is a link to a voice note message

    Parameters:
        voice_note (:class:`"types.VoiceNote"`):
            The voice note

    """

    def __init__(self, voice_note: VoiceNote = None) -> None:
        self.voice_note: Union[VoiceNote, None] = voice_note
        r"""The voice note"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeVoiceNote"]:
        return "linkPreviewTypeVoiceNote"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "voice_note": self.voice_note}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.voice_note = data.get("voice_note", None)

        return data_class


class LinkPreviewTypeWebApp(TlObject, LinkPreviewType):
    r"""The link is a link to a Web App

    Parameters:
        photo (:class:`"types.Photo"`):
            Web App photo; may be null if none

    """

    def __init__(self, photo: Photo = None) -> None:
        self.photo: Union[Photo, None] = photo
        r"""Web App photo; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreviewTypeWebApp"]:
        return "linkPreviewTypeWebApp"

    def getClass(self) -> Literal["LinkPreviewType"]:
        return "LinkPreviewType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreviewTypeWebApp", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class LinkPreview(TlObject):
    r"""Describes a link preview

    Parameters:
        url (:class:`str`):
            Original URL of the link

        display_url (:class:`str`):
            URL to display

        site_name (:class:`str`):
            Short name of the site \(e\.g\., Google Docs, App Store\)

        title (:class:`str`):
            Title of the content

        description (:class:`"types.FormattedText"`):
            Description of the content

        author (:class:`str`):
            Author of the content

        type (:class:`"types.LinkPreviewType"`):
            Type of the link preview

        has_large_media (:class:`bool`):
            True, if size of media in the preview can be changed

        show_large_media (:class:`bool`):
            True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos

        show_media_above_description (:class:`bool`):
            True, if media must be shown above link preview description; otherwise, the media must be shown below the description

        skip_confirmation (:class:`bool`):
            True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear

        show_above_text (:class:`bool`):
            True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text

        instant_view_version (:class:`int`):
            Version of instant view \(currently, can be 1 or 2\) for the web page; 0 if none

    """

    def __init__(
        self,
        url: str = "",
        display_url: str = "",
        site_name: str = "",
        title: str = "",
        description: FormattedText = None,
        author: str = "",
        type: LinkPreviewType = None,
        has_large_media: bool = False,
        show_large_media: bool = False,
        show_media_above_description: bool = False,
        skip_confirmation: bool = False,
        show_above_text: bool = False,
        instant_view_version: int = 0,
    ) -> None:
        self.url: Union[str, None] = url
        r"""Original URL of the link"""
        self.display_url: Union[str, None] = display_url
        r"""URL to display"""
        self.site_name: Union[str, None] = site_name
        r"""Short name of the site \(e\.g\., Google Docs, App Store\)"""
        self.title: Union[str, None] = title
        r"""Title of the content"""
        self.description: Union[FormattedText, None] = description
        r"""Description of the content"""
        self.author: Union[str, None] = author
        r"""Author of the content"""
        self.type: Union[
            LinkPreviewTypeAlbum,
            LinkPreviewTypeAnimation,
            LinkPreviewTypeApp,
            LinkPreviewTypeArticle,
            LinkPreviewTypeAudio,
            LinkPreviewTypeBackground,
            LinkPreviewTypeChannelBoost,
            LinkPreviewTypeChat,
            LinkPreviewTypeDocument,
            LinkPreviewTypeEmbeddedAnimationPlayer,
            LinkPreviewTypeEmbeddedAudioPlayer,
            LinkPreviewTypeEmbeddedVideoPlayer,
            LinkPreviewTypeExternalAudio,
            LinkPreviewTypeExternalVideo,
            LinkPreviewTypeInvoice,
            LinkPreviewTypeMessage,
            LinkPreviewTypePhoto,
            LinkPreviewTypePremiumGiftCode,
            LinkPreviewTypeShareableChatFolder,
            LinkPreviewTypeSticker,
            LinkPreviewTypeStickerSet,
            LinkPreviewTypeStory,
            LinkPreviewTypeSupergroupBoost,
            LinkPreviewTypeTheme,
            LinkPreviewTypeUnsupported,
            LinkPreviewTypeUpgradedGift,
            LinkPreviewTypeUser,
            LinkPreviewTypeVideo,
            LinkPreviewTypeVideoChat,
            LinkPreviewTypeVideoNote,
            LinkPreviewTypeVoiceNote,
            LinkPreviewTypeWebApp,
            None,
        ] = type
        r"""Type of the link preview"""
        self.has_large_media: bool = bool(has_large_media)
        r"""True, if size of media in the preview can be changed"""
        self.show_large_media: bool = bool(show_large_media)
        r"""True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos"""
        self.show_media_above_description: bool = bool(show_media_above_description)
        r"""True, if media must be shown above link preview description; otherwise, the media must be shown below the description"""
        self.skip_confirmation: bool = bool(skip_confirmation)
        r"""True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear"""
        self.show_above_text: bool = bool(show_above_text)
        r"""True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text"""
        self.instant_view_version: int = int(instant_view_version)
        r"""Version of instant view \(currently, can be 1 or 2\) for the web page; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["linkPreview"]:
        return "linkPreview"

    def getClass(self) -> Literal["LinkPreview"]:
        return "LinkPreview"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "display_url": self.display_url,
            "site_name": self.site_name,
            "title": self.title,
            "description": self.description,
            "author": self.author,
            "type": self.type,
            "has_large_media": self.has_large_media,
            "show_large_media": self.show_large_media,
            "show_media_above_description": self.show_media_above_description,
            "skip_confirmation": self.skip_confirmation,
            "show_above_text": self.show_above_text,
            "instant_view_version": self.instant_view_version,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LinkPreview", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.display_url = data.get("display_url", "")
            data_class.site_name = data.get("site_name", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", None)
            data_class.author = data.get("author", "")
            data_class.type = data.get("type", None)
            data_class.has_large_media = data.get("has_large_media", False)
            data_class.show_large_media = data.get("show_large_media", False)
            data_class.show_media_above_description = data.get(
                "show_media_above_description", False
            )
            data_class.skip_confirmation = data.get("skip_confirmation", False)
            data_class.show_above_text = data.get("show_above_text", False)
            data_class.instant_view_version = int(data.get("instant_view_version", 0))

        return data_class


class CountryInfo(TlObject):
    r"""Contains information about a country

    Parameters:
        country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code

        name (:class:`str`):
            Native name of the country

        english_name (:class:`str`):
            English name of the country

        is_hidden (:class:`bool`):
            True, if the country must be hidden from the list of all countries

        calling_codes (:class:`List[str]`):
            List of country calling codes

    """

    def __init__(
        self,
        country_code: str = "",
        name: str = "",
        english_name: str = "",
        is_hidden: bool = False,
        calling_codes: List[str] = None,
    ) -> None:
        self.country_code: Union[str, None] = country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code"""
        self.name: Union[str, None] = name
        r"""Native name of the country"""
        self.english_name: Union[str, None] = english_name
        r"""English name of the country"""
        self.is_hidden: bool = bool(is_hidden)
        r"""True, if the country must be hidden from the list of all countries"""
        self.calling_codes: List[str] = calling_codes or []
        r"""List of country calling codes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["countryInfo"]:
        return "countryInfo"

    def getClass(self) -> Literal["CountryInfo"]:
        return "CountryInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "country_code": self.country_code,
            "name": self.name,
            "english_name": self.english_name,
            "is_hidden": self.is_hidden,
            "calling_codes": self.calling_codes,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CountryInfo", None]:
        if data:
            data_class = cls()
            data_class.country_code = data.get("country_code", "")
            data_class.name = data.get("name", "")
            data_class.english_name = data.get("english_name", "")
            data_class.is_hidden = data.get("is_hidden", False)
            data_class.calling_codes = data.get("calling_codes", None)

        return data_class


class Countries(TlObject):
    r"""Contains information about countries

    Parameters:
        countries (:class:`List["types.CountryInfo"]`):
            The list of countries

    """

    def __init__(self, countries: List[CountryInfo] = None) -> None:
        self.countries: List[CountryInfo] = countries or []
        r"""The list of countries"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["countries"]:
        return "countries"

    def getClass(self) -> Literal["Countries"]:
        return "Countries"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "countries": self.countries}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Countries", None]:
        if data:
            data_class = cls()
            data_class.countries = data.get("countries", None)

        return data_class


class PhoneNumberInfo(TlObject):
    r"""Contains information about a phone number

    Parameters:
        country (:class:`"types.CountryInfo"`):
            Information about the country to which the phone number belongs; may be null

        country_calling_code (:class:`str`):
            The part of the phone number denoting country calling code or its part

        formatted_phone_number (:class:`str`):
            The phone number without country calling code formatted accordingly to local rules\. Expected digits are returned as '\-', but even more digits might be entered by the user

        is_anonymous (:class:`bool`):
            True, if the phone number was bought at https://fragment\.com and isn't tied to a SIM card\. Information about the phone number can be received using getCollectibleItemInfo

    """

    def __init__(
        self,
        country: CountryInfo = None,
        country_calling_code: str = "",
        formatted_phone_number: str = "",
        is_anonymous: bool = False,
    ) -> None:
        self.country: Union[CountryInfo, None] = country
        r"""Information about the country to which the phone number belongs; may be null"""
        self.country_calling_code: Union[str, None] = country_calling_code
        r"""The part of the phone number denoting country calling code or its part"""
        self.formatted_phone_number: Union[str, None] = formatted_phone_number
        r"""The phone number without country calling code formatted accordingly to local rules\. Expected digits are returned as '\-', but even more digits might be entered by the user"""
        self.is_anonymous: bool = bool(is_anonymous)
        r"""True, if the phone number was bought at https://fragment\.com and isn't tied to a SIM card\. Information about the phone number can be received using getCollectibleItemInfo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["phoneNumberInfo"]:
        return "phoneNumberInfo"

    def getClass(self) -> Literal["PhoneNumberInfo"]:
        return "PhoneNumberInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "country": self.country,
            "country_calling_code": self.country_calling_code,
            "formatted_phone_number": self.formatted_phone_number,
            "is_anonymous": self.is_anonymous,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PhoneNumberInfo", None]:
        if data:
            data_class = cls()
            data_class.country = data.get("country", None)
            data_class.country_calling_code = data.get("country_calling_code", "")
            data_class.formatted_phone_number = data.get("formatted_phone_number", "")
            data_class.is_anonymous = data.get("is_anonymous", False)

        return data_class


class CollectibleItemTypeUsername(TlObject, CollectibleItemType):
    r"""A username

    Parameters:
        username (:class:`str`):
            The username

    """

    def __init__(self, username: str = "") -> None:
        self.username: Union[str, None] = username
        r"""The username"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["collectibleItemTypeUsername"]:
        return "collectibleItemTypeUsername"

    def getClass(self) -> Literal["CollectibleItemType"]:
        return "CollectibleItemType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "username": self.username}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CollectibleItemTypeUsername", None]:
        if data:
            data_class = cls()
            data_class.username = data.get("username", "")

        return data_class


class CollectibleItemTypePhoneNumber(TlObject, CollectibleItemType):
    r"""A phone number

    Parameters:
        phone_number (:class:`str`):
            The phone number

    """

    def __init__(self, phone_number: str = "") -> None:
        self.phone_number: Union[str, None] = phone_number
        r"""The phone number"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["collectibleItemTypePhoneNumber"]:
        return "collectibleItemTypePhoneNumber"

    def getClass(self) -> Literal["CollectibleItemType"]:
        return "CollectibleItemType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "phone_number": self.phone_number}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CollectibleItemTypePhoneNumber", None]:
        if data:
            data_class = cls()
            data_class.phone_number = data.get("phone_number", "")

        return data_class


class CollectibleItemInfo(TlObject):
    r"""Contains information about a collectible item and its last purchase

    Parameters:
        purchase_date (:class:`int`):
            Point in time \(Unix timestamp\) when the item was purchased

        currency (:class:`str`):
            Currency for the paid amount

        amount (:class:`int`):
            The paid amount, in the smallest units of the currency

        cryptocurrency (:class:`str`):
            Cryptocurrency used to pay for the item

        cryptocurrency_amount (:class:`int`):
            The paid amount, in the smallest units of the cryptocurrency

        url (:class:`str`):
            Individual URL for the item on https://fragment\.com

    """

    def __init__(
        self,
        purchase_date: int = 0,
        currency: str = "",
        amount: int = 0,
        cryptocurrency: str = "",
        cryptocurrency_amount: int = 0,
        url: str = "",
    ) -> None:
        self.purchase_date: int = int(purchase_date)
        r"""Point in time \(Unix timestamp\) when the item was purchased"""
        self.currency: Union[str, None] = currency
        r"""Currency for the paid amount"""
        self.amount: int = int(amount)
        r"""The paid amount, in the smallest units of the currency"""
        self.cryptocurrency: Union[str, None] = cryptocurrency
        r"""Cryptocurrency used to pay for the item"""
        self.cryptocurrency_amount: int = int(cryptocurrency_amount)
        r"""The paid amount, in the smallest units of the cryptocurrency"""
        self.url: Union[str, None] = url
        r"""Individual URL for the item on https://fragment\.com"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["collectibleItemInfo"]:
        return "collectibleItemInfo"

    def getClass(self) -> Literal["CollectibleItemInfo"]:
        return "CollectibleItemInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "purchase_date": self.purchase_date,
            "currency": self.currency,
            "amount": self.amount,
            "cryptocurrency": self.cryptocurrency,
            "cryptocurrency_amount": self.cryptocurrency_amount,
            "url": self.url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CollectibleItemInfo", None]:
        if data:
            data_class = cls()
            data_class.purchase_date = int(data.get("purchase_date", 0))
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.cryptocurrency = data.get("cryptocurrency", "")
            data_class.cryptocurrency_amount = int(data.get("cryptocurrency_amount", 0))
            data_class.url = data.get("url", "")

        return data_class


class BankCardActionOpenUrl(TlObject):
    r"""Describes an action associated with a bank card number

    Parameters:
        text (:class:`str`):
            Action text

        url (:class:`str`):
            The URL to be opened

    """

    def __init__(self, text: str = "", url: str = "") -> None:
        self.text: Union[str, None] = text
        r"""Action text"""
        self.url: Union[str, None] = url
        r"""The URL to be opened"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["bankCardActionOpenUrl"]:
        return "bankCardActionOpenUrl"

    def getClass(self) -> Literal["BankCardActionOpenUrl"]:
        return "BankCardActionOpenUrl"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BankCardActionOpenUrl", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.url = data.get("url", "")

        return data_class


class BankCardInfo(TlObject):
    r"""Information about a bank card

    Parameters:
        title (:class:`str`):
            Title of the bank card description

        actions (:class:`List["types.BankCardActionOpenUrl"]`):
            Actions that can be done with the bank card number

    """

    def __init__(
        self, title: str = "", actions: List[BankCardActionOpenUrl] = None
    ) -> None:
        self.title: Union[str, None] = title
        r"""Title of the bank card description"""
        self.actions: List[BankCardActionOpenUrl] = actions or []
        r"""Actions that can be done with the bank card number"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["bankCardInfo"]:
        return "bankCardInfo"

    def getClass(self) -> Literal["BankCardInfo"]:
        return "BankCardInfo"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title, "actions": self.actions}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BankCardInfo", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.actions = data.get("actions", None)

        return data_class


class Address(TlObject):
    r"""Describes an address

    Parameters:
        country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code

        state (:class:`str`):
            State, if applicable

        city (:class:`str`):
            City

        street_line1 (:class:`str`):
            First line of the address

        street_line2 (:class:`str`):
            Second line of the address

        postal_code (:class:`str`):
            Address postal code

    """

    def __init__(
        self,
        country_code: str = "",
        state: str = "",
        city: str = "",
        street_line1: str = "",
        street_line2: str = "",
        postal_code: str = "",
    ) -> None:
        self.country_code: Union[str, None] = country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code"""
        self.state: Union[str, None] = state
        r"""State, if applicable"""
        self.city: Union[str, None] = city
        r"""City"""
        self.street_line1: Union[str, None] = street_line1
        r"""First line of the address"""
        self.street_line2: Union[str, None] = street_line2
        r"""Second line of the address"""
        self.postal_code: Union[str, None] = postal_code
        r"""Address postal code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["address"]:
        return "address"

    def getClass(self) -> Literal["Address"]:
        return "Address"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "country_code": self.country_code,
            "state": self.state,
            "city": self.city,
            "street_line1": self.street_line1,
            "street_line2": self.street_line2,
            "postal_code": self.postal_code,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Address", None]:
        if data:
            data_class = cls()
            data_class.country_code = data.get("country_code", "")
            data_class.state = data.get("state", "")
            data_class.city = data.get("city", "")
            data_class.street_line1 = data.get("street_line1", "")
            data_class.street_line2 = data.get("street_line2", "")
            data_class.postal_code = data.get("postal_code", "")

        return data_class


class LocationAddress(TlObject):
    r"""Describes an address of a location

    Parameters:
        country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code

        state (:class:`str`):
            State, if applicable; empty if unknown

        city (:class:`str`):
            City; empty if unknown

        street (:class:`str`):
            The address; empty if unknown

    """

    def __init__(
        self, country_code: str = "", state: str = "", city: str = "", street: str = ""
    ) -> None:
        self.country_code: Union[str, None] = country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code"""
        self.state: Union[str, None] = state
        r"""State, if applicable; empty if unknown"""
        self.city: Union[str, None] = city
        r"""City; empty if unknown"""
        self.street: Union[str, None] = street
        r"""The address; empty if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["locationAddress"]:
        return "locationAddress"

    def getClass(self) -> Literal["LocationAddress"]:
        return "LocationAddress"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "country_code": self.country_code,
            "state": self.state,
            "city": self.city,
            "street": self.street,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LocationAddress", None]:
        if data:
            data_class = cls()
            data_class.country_code = data.get("country_code", "")
            data_class.state = data.get("state", "")
            data_class.city = data.get("city", "")
            data_class.street = data.get("street", "")

        return data_class


class LabeledPricePart(TlObject):
    r"""Portion of the price of a product \(e\.g\., \"delivery cost\", \"tax amount\"\)

    Parameters:
        label (:class:`str`):
            Label for this portion of the product price

        amount (:class:`int`):
            Currency amount in the smallest units of the currency

    """

    def __init__(self, label: str = "", amount: int = 0) -> None:
        self.label: Union[str, None] = label
        r"""Label for this portion of the product price"""
        self.amount: int = int(amount)
        r"""Currency amount in the smallest units of the currency"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["labeledPricePart"]:
        return "labeledPricePart"

    def getClass(self) -> Literal["LabeledPricePart"]:
        return "LabeledPricePart"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "label": self.label, "amount": self.amount}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LabeledPricePart", None]:
        if data:
            data_class = cls()
            data_class.label = data.get("label", "")
            data_class.amount = int(data.get("amount", 0))

        return data_class


class Invoice(TlObject):
    r"""Product invoice

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code

        price_parts (:class:`List["types.LabeledPricePart"]`):
            A list of objects used to calculate the total price of the product

        subscription_period (:class:`int`):
            The number of seconds between consecutive Telegram Star debiting for subscription invoices; 0 if the invoice doesn't create subscription

        max_tip_amount (:class:`int`):
            The maximum allowed amount of tip in the smallest units of the currency

        suggested_tip_amounts (:class:`List[int]`):
            Suggested amounts of tip in the smallest units of the currency

        recurring_payment_terms_of_service_url (:class:`str`):
            An HTTP URL with terms of service for recurring payments\. If non\-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay

        terms_of_service_url (:class:`str`):
            An HTTP URL with terms of service for non\-recurring payments\. If non\-empty, then the user must accept the terms of service before allowed to pay

        is_test (:class:`bool`):
            True, if the payment is a test payment

        need_name (:class:`bool`):
            True, if the user's name is needed for payment

        need_phone_number (:class:`bool`):
            True, if the user's phone number is needed for payment

        need_email_address (:class:`bool`):
            True, if the user's email address is needed for payment

        need_shipping_address (:class:`bool`):
            True, if the user's shipping address is needed for payment

        send_phone_number_to_provider (:class:`bool`):
            True, if the user's phone number will be sent to the provider

        send_email_address_to_provider (:class:`bool`):
            True, if the user's email address will be sent to the provider

        is_flexible (:class:`bool`):
            True, if the total price depends on the shipping method

    """

    def __init__(
        self,
        currency: str = "",
        price_parts: List[LabeledPricePart] = None,
        subscription_period: int = 0,
        max_tip_amount: int = 0,
        suggested_tip_amounts: List[int] = None,
        recurring_payment_terms_of_service_url: str = "",
        terms_of_service_url: str = "",
        is_test: bool = False,
        need_name: bool = False,
        need_phone_number: bool = False,
        need_email_address: bool = False,
        need_shipping_address: bool = False,
        send_phone_number_to_provider: bool = False,
        send_email_address_to_provider: bool = False,
        is_flexible: bool = False,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code"""
        self.price_parts: List[LabeledPricePart] = price_parts or []
        r"""A list of objects used to calculate the total price of the product"""
        self.subscription_period: int = int(subscription_period)
        r"""The number of seconds between consecutive Telegram Star debiting for subscription invoices; 0 if the invoice doesn't create subscription"""
        self.max_tip_amount: int = int(max_tip_amount)
        r"""The maximum allowed amount of tip in the smallest units of the currency"""
        self.suggested_tip_amounts: List[int] = suggested_tip_amounts or []
        r"""Suggested amounts of tip in the smallest units of the currency"""
        self.recurring_payment_terms_of_service_url: Union[str, None] = (
            recurring_payment_terms_of_service_url
        )
        r"""An HTTP URL with terms of service for recurring payments\. If non\-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay"""
        self.terms_of_service_url: Union[str, None] = terms_of_service_url
        r"""An HTTP URL with terms of service for non\-recurring payments\. If non\-empty, then the user must accept the terms of service before allowed to pay"""
        self.is_test: bool = bool(is_test)
        r"""True, if the payment is a test payment"""
        self.need_name: bool = bool(need_name)
        r"""True, if the user's name is needed for payment"""
        self.need_phone_number: bool = bool(need_phone_number)
        r"""True, if the user's phone number is needed for payment"""
        self.need_email_address: bool = bool(need_email_address)
        r"""True, if the user's email address is needed for payment"""
        self.need_shipping_address: bool = bool(need_shipping_address)
        r"""True, if the user's shipping address is needed for payment"""
        self.send_phone_number_to_provider: bool = bool(send_phone_number_to_provider)
        r"""True, if the user's phone number will be sent to the provider"""
        self.send_email_address_to_provider: bool = bool(send_email_address_to_provider)
        r"""True, if the user's email address will be sent to the provider"""
        self.is_flexible: bool = bool(is_flexible)
        r"""True, if the total price depends on the shipping method"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["invoice"]:
        return "invoice"

    def getClass(self) -> Literal["Invoice"]:
        return "Invoice"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "price_parts": self.price_parts,
            "subscription_period": self.subscription_period,
            "max_tip_amount": self.max_tip_amount,
            "suggested_tip_amounts": self.suggested_tip_amounts,
            "recurring_payment_terms_of_service_url": self.recurring_payment_terms_of_service_url,
            "terms_of_service_url": self.terms_of_service_url,
            "is_test": self.is_test,
            "need_name": self.need_name,
            "need_phone_number": self.need_phone_number,
            "need_email_address": self.need_email_address,
            "need_shipping_address": self.need_shipping_address,
            "send_phone_number_to_provider": self.send_phone_number_to_provider,
            "send_email_address_to_provider": self.send_email_address_to_provider,
            "is_flexible": self.is_flexible,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Invoice", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.price_parts = data.get("price_parts", None)
            data_class.subscription_period = int(data.get("subscription_period", 0))
            data_class.max_tip_amount = int(data.get("max_tip_amount", 0))
            data_class.suggested_tip_amounts = data.get("suggested_tip_amounts", None)
            data_class.recurring_payment_terms_of_service_url = data.get(
                "recurring_payment_terms_of_service_url", ""
            )
            data_class.terms_of_service_url = data.get("terms_of_service_url", "")
            data_class.is_test = data.get("is_test", False)
            data_class.need_name = data.get("need_name", False)
            data_class.need_phone_number = data.get("need_phone_number", False)
            data_class.need_email_address = data.get("need_email_address", False)
            data_class.need_shipping_address = data.get("need_shipping_address", False)
            data_class.send_phone_number_to_provider = data.get(
                "send_phone_number_to_provider", False
            )
            data_class.send_email_address_to_provider = data.get(
                "send_email_address_to_provider", False
            )
            data_class.is_flexible = data.get("is_flexible", False)

        return data_class


class OrderInfo(TlObject):
    r"""Order information

    Parameters:
        name (:class:`str`):
            Name of the user

        phone_number (:class:`str`):
            Phone number of the user

        email_address (:class:`str`):
            Email address of the user

        shipping_address (:class:`"types.Address"`):
            Shipping address for this order; may be null

    """

    def __init__(
        self,
        name: str = "",
        phone_number: str = "",
        email_address: str = "",
        shipping_address: Address = None,
    ) -> None:
        self.name: Union[str, None] = name
        r"""Name of the user"""
        self.phone_number: Union[str, None] = phone_number
        r"""Phone number of the user"""
        self.email_address: Union[str, None] = email_address
        r"""Email address of the user"""
        self.shipping_address: Union[Address, None] = shipping_address
        r"""Shipping address for this order; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["orderInfo"]:
        return "orderInfo"

    def getClass(self) -> Literal["OrderInfo"]:
        return "OrderInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "phone_number": self.phone_number,
            "email_address": self.email_address,
            "shipping_address": self.shipping_address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["OrderInfo", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.phone_number = data.get("phone_number", "")
            data_class.email_address = data.get("email_address", "")
            data_class.shipping_address = data.get("shipping_address", None)

        return data_class


class ShippingOption(TlObject):
    r"""One shipping option

    Parameters:
        id (:class:`str`):
            Shipping option identifier

        title (:class:`str`):
            Option title

        price_parts (:class:`List["types.LabeledPricePart"]`):
            A list of objects used to calculate the total shipping costs

    """

    def __init__(
        self, id: str = "", title: str = "", price_parts: List[LabeledPricePart] = None
    ) -> None:
        self.id: Union[str, None] = id
        r"""Shipping option identifier"""
        self.title: Union[str, None] = title
        r"""Option title"""
        self.price_parts: List[LabeledPricePart] = price_parts or []
        r"""A list of objects used to calculate the total shipping costs"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["shippingOption"]:
        return "shippingOption"

    def getClass(self) -> Literal["ShippingOption"]:
        return "ShippingOption"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "price_parts": self.price_parts,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ShippingOption", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")
            data_class.price_parts = data.get("price_parts", None)

        return data_class


class SavedCredentials(TlObject):
    r"""Contains information about saved payment credentials

    Parameters:
        id (:class:`str`):
            Unique identifier of the saved credentials

        title (:class:`str`):
            Title of the saved credentials

    """

    def __init__(self, id: str = "", title: str = "") -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the saved credentials"""
        self.title: Union[str, None] = title
        r"""Title of the saved credentials"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["savedCredentials"]:
        return "savedCredentials"

    def getClass(self) -> Literal["SavedCredentials"]:
        return "SavedCredentials"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id, "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SavedCredentials", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")

        return data_class


class InputCredentialsSaved(TlObject, InputCredentials):
    r"""Applies if a user chooses some previously saved payment credentials\. To use their previously saved credentials, the user must have a valid temporary password

    Parameters:
        saved_credentials_id (:class:`str`):
            Identifier of the saved credentials

    """

    def __init__(self, saved_credentials_id: str = "") -> None:
        self.saved_credentials_id: Union[str, None] = saved_credentials_id
        r"""Identifier of the saved credentials"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputCredentialsSaved"]:
        return "inputCredentialsSaved"

    def getClass(self) -> Literal["InputCredentials"]:
        return "InputCredentials"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "saved_credentials_id": self.saved_credentials_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputCredentialsSaved", None]:
        if data:
            data_class = cls()
            data_class.saved_credentials_id = data.get("saved_credentials_id", "")

        return data_class


class InputCredentialsNew(TlObject, InputCredentials):
    r"""Applies if a user enters new credentials on a payment provider website

    Parameters:
        data (:class:`str`):
            JSON\-encoded data with the credential identifier from the payment provider

        allow_save (:class:`bool`):
            True, if the credential identifier can be saved on the server side

    """

    def __init__(self, data: str = "", allow_save: bool = False) -> None:
        self.data: Union[str, None] = data
        r"""JSON\-encoded data with the credential identifier from the payment provider"""
        self.allow_save: bool = bool(allow_save)
        r"""True, if the credential identifier can be saved on the server side"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputCredentialsNew"]:
        return "inputCredentialsNew"

    def getClass(self) -> Literal["InputCredentials"]:
        return "InputCredentials"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "data": self.data,
            "allow_save": self.allow_save,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputCredentialsNew", None]:
        if data:
            data_class = cls()
            data_class.data = data.get("data", "")
            data_class.allow_save = data.get("allow_save", False)

        return data_class


class InputCredentialsApplePay(TlObject, InputCredentials):
    r"""Applies if a user enters new credentials using Apple Pay

    Parameters:
        data (:class:`str`):
            JSON\-encoded data with the credential identifier

    """

    def __init__(self, data: str = "") -> None:
        self.data: Union[str, None] = data
        r"""JSON\-encoded data with the credential identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputCredentialsApplePay"]:
        return "inputCredentialsApplePay"

    def getClass(self) -> Literal["InputCredentials"]:
        return "InputCredentials"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "data": self.data}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputCredentialsApplePay", None]:
        if data:
            data_class = cls()
            data_class.data = data.get("data", "")

        return data_class


class InputCredentialsGooglePay(TlObject, InputCredentials):
    r"""Applies if a user enters new credentials using Google Pay

    Parameters:
        data (:class:`str`):
            JSON\-encoded data with the credential identifier

    """

    def __init__(self, data: str = "") -> None:
        self.data: Union[str, None] = data
        r"""JSON\-encoded data with the credential identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputCredentialsGooglePay"]:
        return "inputCredentialsGooglePay"

    def getClass(self) -> Literal["InputCredentials"]:
        return "InputCredentials"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "data": self.data}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputCredentialsGooglePay", None]:
        if data:
            data_class = cls()
            data_class.data = data.get("data", "")

        return data_class


class PaymentProviderSmartGlocal(TlObject, PaymentProvider):
    r"""Smart Glocal payment provider

    Parameters:
        public_token (:class:`str`):
            Public payment token

        tokenize_url (:class:`str`):
            URL for sending card tokenization requests

    """

    def __init__(self, public_token: str = "", tokenize_url: str = "") -> None:
        self.public_token: Union[str, None] = public_token
        r"""Public payment token"""
        self.tokenize_url: Union[str, None] = tokenize_url
        r"""URL for sending card tokenization requests"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentProviderSmartGlocal"]:
        return "paymentProviderSmartGlocal"

    def getClass(self) -> Literal["PaymentProvider"]:
        return "PaymentProvider"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "public_token": self.public_token,
            "tokenize_url": self.tokenize_url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentProviderSmartGlocal", None]:
        if data:
            data_class = cls()
            data_class.public_token = data.get("public_token", "")
            data_class.tokenize_url = data.get("tokenize_url", "")

        return data_class


class PaymentProviderStripe(TlObject, PaymentProvider):
    r"""Stripe payment provider

    Parameters:
        publishable_key (:class:`str`):
            Stripe API publishable key

        need_country (:class:`bool`):
            True, if the user country must be provided

        need_postal_code (:class:`bool`):
            True, if the user ZIP/postal code must be provided

        need_cardholder_name (:class:`bool`):
            True, if the cardholder name must be provided

    """

    def __init__(
        self,
        publishable_key: str = "",
        need_country: bool = False,
        need_postal_code: bool = False,
        need_cardholder_name: bool = False,
    ) -> None:
        self.publishable_key: Union[str, None] = publishable_key
        r"""Stripe API publishable key"""
        self.need_country: bool = bool(need_country)
        r"""True, if the user country must be provided"""
        self.need_postal_code: bool = bool(need_postal_code)
        r"""True, if the user ZIP/postal code must be provided"""
        self.need_cardholder_name: bool = bool(need_cardholder_name)
        r"""True, if the cardholder name must be provided"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentProviderStripe"]:
        return "paymentProviderStripe"

    def getClass(self) -> Literal["PaymentProvider"]:
        return "PaymentProvider"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "publishable_key": self.publishable_key,
            "need_country": self.need_country,
            "need_postal_code": self.need_postal_code,
            "need_cardholder_name": self.need_cardholder_name,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentProviderStripe", None]:
        if data:
            data_class = cls()
            data_class.publishable_key = data.get("publishable_key", "")
            data_class.need_country = data.get("need_country", False)
            data_class.need_postal_code = data.get("need_postal_code", False)
            data_class.need_cardholder_name = data.get("need_cardholder_name", False)

        return data_class


class PaymentProviderOther(TlObject, PaymentProvider):
    r"""Some other payment provider, for which a web payment form must be shown

    Parameters:
        url (:class:`str`):
            Payment form URL

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""Payment form URL"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentProviderOther"]:
        return "paymentProviderOther"

    def getClass(self) -> Literal["PaymentProvider"]:
        return "PaymentProvider"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentProviderOther", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class PaymentOption(TlObject):
    r"""Describes an additional payment option

    Parameters:
        title (:class:`str`):
            Title for the payment option

        url (:class:`str`):
            Payment form URL to be opened in a web view

    """

    def __init__(self, title: str = "", url: str = "") -> None:
        self.title: Union[str, None] = title
        r"""Title for the payment option"""
        self.url: Union[str, None] = url
        r"""Payment form URL to be opened in a web view"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentOption"]:
        return "paymentOption"

    def getClass(self) -> Literal["PaymentOption"]:
        return "PaymentOption"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title, "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentOption", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.url = data.get("url", "")

        return data_class


class PaymentFormTypeRegular(TlObject, PaymentFormType):
    r"""The payment form is for a regular payment

    Parameters:
        invoice (:class:`"types.Invoice"`):
            Full information about the invoice

        payment_provider_user_id (:class:`int`):
            User identifier of the payment provider bot

        payment_provider (:class:`"types.PaymentProvider"`):
            Information about the payment provider

        additional_payment_options (:class:`List["types.PaymentOption"]`):
            The list of additional payment options

        saved_order_info (:class:`"types.OrderInfo"`):
            Saved server\-side order information; may be null

        saved_credentials (:class:`List["types.SavedCredentials"]`):
            The list of saved payment credentials

        can_save_credentials (:class:`bool`):
            True, if the user can choose to save credentials

        need_password (:class:`bool`):
            True, if the user will be able to save credentials, if sets up a 2\-step verification password

    """

    def __init__(
        self,
        invoice: Invoice = None,
        payment_provider_user_id: int = 0,
        payment_provider: PaymentProvider = None,
        additional_payment_options: List[PaymentOption] = None,
        saved_order_info: OrderInfo = None,
        saved_credentials: List[SavedCredentials] = None,
        can_save_credentials: bool = False,
        need_password: bool = False,
    ) -> None:
        self.invoice: Union[Invoice, None] = invoice
        r"""Full information about the invoice"""
        self.payment_provider_user_id: int = int(payment_provider_user_id)
        r"""User identifier of the payment provider bot"""
        self.payment_provider: Union[
            PaymentProviderSmartGlocal,
            PaymentProviderStripe,
            PaymentProviderOther,
            None,
        ] = payment_provider
        r"""Information about the payment provider"""
        self.additional_payment_options: List[PaymentOption] = (
            additional_payment_options or []
        )
        r"""The list of additional payment options"""
        self.saved_order_info: Union[OrderInfo, None] = saved_order_info
        r"""Saved server\-side order information; may be null"""
        self.saved_credentials: List[SavedCredentials] = saved_credentials or []
        r"""The list of saved payment credentials"""
        self.can_save_credentials: bool = bool(can_save_credentials)
        r"""True, if the user can choose to save credentials"""
        self.need_password: bool = bool(need_password)
        r"""True, if the user will be able to save credentials, if sets up a 2\-step verification password"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentFormTypeRegular"]:
        return "paymentFormTypeRegular"

    def getClass(self) -> Literal["PaymentFormType"]:
        return "PaymentFormType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "invoice": self.invoice,
            "payment_provider_user_id": self.payment_provider_user_id,
            "payment_provider": self.payment_provider,
            "additional_payment_options": self.additional_payment_options,
            "saved_order_info": self.saved_order_info,
            "saved_credentials": self.saved_credentials,
            "can_save_credentials": self.can_save_credentials,
            "need_password": self.need_password,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentFormTypeRegular", None]:
        if data:
            data_class = cls()
            data_class.invoice = data.get("invoice", None)
            data_class.payment_provider_user_id = int(
                data.get("payment_provider_user_id", 0)
            )
            data_class.payment_provider = data.get("payment_provider", None)
            data_class.additional_payment_options = data.get(
                "additional_payment_options", None
            )
            data_class.saved_order_info = data.get("saved_order_info", None)
            data_class.saved_credentials = data.get("saved_credentials", None)
            data_class.can_save_credentials = data.get("can_save_credentials", False)
            data_class.need_password = data.get("need_password", False)

        return data_class


class PaymentFormTypeStars(TlObject, PaymentFormType):
    r"""The payment form is for a payment in Telegram Stars

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars that will be paid

    """

    def __init__(self, star_count: int = 0) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that will be paid"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentFormTypeStars"]:
        return "paymentFormTypeStars"

    def getClass(self) -> Literal["PaymentFormType"]:
        return "PaymentFormType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "star_count": self.star_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentFormTypeStars", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class PaymentFormTypeStarSubscription(TlObject, PaymentFormType):
    r"""The payment form is for a payment in Telegram Stars for subscription

    Parameters:
        pricing (:class:`"types.StarSubscriptionPricing"`):
            Information about subscription plan

    """

    def __init__(self, pricing: StarSubscriptionPricing = None) -> None:
        self.pricing: Union[StarSubscriptionPricing, None] = pricing
        r"""Information about subscription plan"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentFormTypeStarSubscription"]:
        return "paymentFormTypeStarSubscription"

    def getClass(self) -> Literal["PaymentFormType"]:
        return "PaymentFormType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "pricing": self.pricing}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentFormTypeStarSubscription", None]:
        if data:
            data_class = cls()
            data_class.pricing = data.get("pricing", None)

        return data_class


class PaymentForm(TlObject):
    r"""Contains information about an invoice payment form

    Parameters:
        id (:class:`int`):
            The payment form identifier

        type (:class:`"types.PaymentFormType"`):
            Type of the payment form

        seller_bot_user_id (:class:`int`):
            User identifier of the seller bot

        product_info (:class:`"types.ProductInfo"`):
            Information about the product

    """

    def __init__(
        self,
        id: int = 0,
        type: PaymentFormType = None,
        seller_bot_user_id: int = 0,
        product_info: ProductInfo = None,
    ) -> None:
        self.id: int = int(id)
        r"""The payment form identifier"""
        self.type: Union[
            PaymentFormTypeRegular,
            PaymentFormTypeStars,
            PaymentFormTypeStarSubscription,
            None,
        ] = type
        r"""Type of the payment form"""
        self.seller_bot_user_id: int = int(seller_bot_user_id)
        r"""User identifier of the seller bot"""
        self.product_info: Union[ProductInfo, None] = product_info
        r"""Information about the product"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentForm"]:
        return "paymentForm"

    def getClass(self) -> Literal["PaymentForm"]:
        return "PaymentForm"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "type": self.type,
            "seller_bot_user_id": self.seller_bot_user_id,
            "product_info": self.product_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentForm", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.type = data.get("type", None)
            data_class.seller_bot_user_id = int(data.get("seller_bot_user_id", 0))
            data_class.product_info = data.get("product_info", None)

        return data_class


class ValidatedOrderInfo(TlObject):
    r"""Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options

    Parameters:
        order_info_id (:class:`str`):
            Temporary identifier of the order information

        shipping_options (:class:`List["types.ShippingOption"]`):
            Available shipping options

    """

    def __init__(
        self, order_info_id: str = "", shipping_options: List[ShippingOption] = None
    ) -> None:
        self.order_info_id: Union[str, None] = order_info_id
        r"""Temporary identifier of the order information"""
        self.shipping_options: List[ShippingOption] = shipping_options or []
        r"""Available shipping options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["validatedOrderInfo"]:
        return "validatedOrderInfo"

    def getClass(self) -> Literal["ValidatedOrderInfo"]:
        return "ValidatedOrderInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "order_info_id": self.order_info_id,
            "shipping_options": self.shipping_options,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ValidatedOrderInfo", None]:
        if data:
            data_class = cls()
            data_class.order_info_id = data.get("order_info_id", "")
            data_class.shipping_options = data.get("shipping_options", None)

        return data_class


class PaymentResult(TlObject):
    r"""Contains the result of a payment request

    Parameters:
        success (:class:`bool`):
            True, if the payment request was successful; otherwise, the verification\_url will be non\-empty

        verification_url (:class:`str`):
            URL for additional payment credentials verification

    """

    def __init__(self, success: bool = False, verification_url: str = "") -> None:
        self.success: bool = bool(success)
        r"""True, if the payment request was successful; otherwise, the verification\_url will be non\-empty"""
        self.verification_url: Union[str, None] = verification_url
        r"""URL for additional payment credentials verification"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentResult"]:
        return "paymentResult"

    def getClass(self) -> Literal["PaymentResult"]:
        return "PaymentResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "success": self.success,
            "verification_url": self.verification_url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentResult", None]:
        if data:
            data_class = cls()
            data_class.success = data.get("success", False)
            data_class.verification_url = data.get("verification_url", "")

        return data_class


class PaymentReceiptTypeRegular(TlObject, PaymentReceiptType):
    r"""The payment was done using a third\-party payment provider

    Parameters:
        payment_provider_user_id (:class:`int`):
            User identifier of the payment provider bot

        invoice (:class:`"types.Invoice"`):
            Information about the invoice

        order_info (:class:`"types.OrderInfo"`):
            Order information; may be null

        shipping_option (:class:`"types.ShippingOption"`):
            Chosen shipping option; may be null

        credentials_title (:class:`str`):
            Title of the saved credentials chosen by the buyer

        tip_amount (:class:`int`):
            The amount of tip chosen by the buyer in the smallest units of the currency

    """

    def __init__(
        self,
        payment_provider_user_id: int = 0,
        invoice: Invoice = None,
        order_info: OrderInfo = None,
        shipping_option: ShippingOption = None,
        credentials_title: str = "",
        tip_amount: int = 0,
    ) -> None:
        self.payment_provider_user_id: int = int(payment_provider_user_id)
        r"""User identifier of the payment provider bot"""
        self.invoice: Union[Invoice, None] = invoice
        r"""Information about the invoice"""
        self.order_info: Union[OrderInfo, None] = order_info
        r"""Order information; may be null"""
        self.shipping_option: Union[ShippingOption, None] = shipping_option
        r"""Chosen shipping option; may be null"""
        self.credentials_title: Union[str, None] = credentials_title
        r"""Title of the saved credentials chosen by the buyer"""
        self.tip_amount: int = int(tip_amount)
        r"""The amount of tip chosen by the buyer in the smallest units of the currency"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentReceiptTypeRegular"]:
        return "paymentReceiptTypeRegular"

    def getClass(self) -> Literal["PaymentReceiptType"]:
        return "PaymentReceiptType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "payment_provider_user_id": self.payment_provider_user_id,
            "invoice": self.invoice,
            "order_info": self.order_info,
            "shipping_option": self.shipping_option,
            "credentials_title": self.credentials_title,
            "tip_amount": self.tip_amount,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentReceiptTypeRegular", None]:
        if data:
            data_class = cls()
            data_class.payment_provider_user_id = int(
                data.get("payment_provider_user_id", 0)
            )
            data_class.invoice = data.get("invoice", None)
            data_class.order_info = data.get("order_info", None)
            data_class.shipping_option = data.get("shipping_option", None)
            data_class.credentials_title = data.get("credentials_title", "")
            data_class.tip_amount = int(data.get("tip_amount", 0))

        return data_class


class PaymentReceiptTypeStars(TlObject, PaymentReceiptType):
    r"""The payment was done using Telegram Stars

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars that were paid

        transaction_id (:class:`str`):
            Unique identifier of the transaction that can be used to dispute it

    """

    def __init__(self, star_count: int = 0, transaction_id: str = "") -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that were paid"""
        self.transaction_id: Union[str, None] = transaction_id
        r"""Unique identifier of the transaction that can be used to dispute it"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentReceiptTypeStars"]:
        return "paymentReceiptTypeStars"

    def getClass(self) -> Literal["PaymentReceiptType"]:
        return "PaymentReceiptType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_count": self.star_count,
            "transaction_id": self.transaction_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentReceiptTypeStars", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))
            data_class.transaction_id = data.get("transaction_id", "")

        return data_class


class PaymentReceipt(TlObject):
    r"""Contains information about a successful payment

    Parameters:
        product_info (:class:`"types.ProductInfo"`):
            Information about the product

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the payment was made

        seller_bot_user_id (:class:`int`):
            User identifier of the seller bot

        type (:class:`"types.PaymentReceiptType"`):
            Type of the payment receipt

    """

    def __init__(
        self,
        product_info: ProductInfo = None,
        date: int = 0,
        seller_bot_user_id: int = 0,
        type: PaymentReceiptType = None,
    ) -> None:
        self.product_info: Union[ProductInfo, None] = product_info
        r"""Information about the product"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the payment was made"""
        self.seller_bot_user_id: int = int(seller_bot_user_id)
        r"""User identifier of the seller bot"""
        self.type: Union[PaymentReceiptTypeRegular, PaymentReceiptTypeStars, None] = (
            type
        )
        r"""Type of the payment receipt"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paymentReceipt"]:
        return "paymentReceipt"

    def getClass(self) -> Literal["PaymentReceipt"]:
        return "PaymentReceipt"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "product_info": self.product_info,
            "date": self.date,
            "seller_bot_user_id": self.seller_bot_user_id,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaymentReceipt", None]:
        if data:
            data_class = cls()
            data_class.product_info = data.get("product_info", None)
            data_class.date = int(data.get("date", 0))
            data_class.seller_bot_user_id = int(data.get("seller_bot_user_id", 0))
            data_class.type = data.get("type", None)

        return data_class


class InputInvoiceMessage(TlObject, InputInvoice):
    r"""An invoice from a message of the type messageInvoice or paid media purchase from messagePaidMedia

    Parameters:
        chat_id (:class:`int`):
            Chat identifier of the message

        message_id (:class:`int`):
            Message identifier\. Use messageProperties\.can\_be\_paid to check whether the message can be used in the method

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier of the message"""
        self.message_id: int = int(message_id)
        r"""Message identifier\. Use messageProperties\.can\_be\_paid to check whether the message can be used in the method"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInvoiceMessage"]:
        return "inputInvoiceMessage"

    def getClass(self) -> Literal["InputInvoice"]:
        return "InputInvoice"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInvoiceMessage", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class InputInvoiceName(TlObject, InputInvoice):
    r"""An invoice from a link of the type internalLinkTypeInvoice

    Parameters:
        name (:class:`str`):
            Name of the invoice

    """

    def __init__(self, name: str = "") -> None:
        self.name: Union[str, None] = name
        r"""Name of the invoice"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInvoiceName"]:
        return "inputInvoiceName"

    def getClass(self) -> Literal["InputInvoice"]:
        return "InputInvoice"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInvoiceName", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")

        return data_class


class InputInvoiceTelegram(TlObject, InputInvoice):
    r"""An invoice for a payment toward Telegram; must not be used in the in\-store apps

    Parameters:
        purpose (:class:`"types.TelegramPaymentPurpose"`):
            Transaction purpose

    """

    def __init__(self, purpose: TelegramPaymentPurpose = None) -> None:
        self.purpose: Union[
            TelegramPaymentPurposePremiumGift,
            TelegramPaymentPurposePremiumGiftCodes,
            TelegramPaymentPurposePremiumGiveaway,
            TelegramPaymentPurposeStars,
            TelegramPaymentPurposeGiftedStars,
            TelegramPaymentPurposeStarGiveaway,
            TelegramPaymentPurposeJoinChat,
            None,
        ] = purpose
        r"""Transaction purpose"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInvoiceTelegram"]:
        return "inputInvoiceTelegram"

    def getClass(self) -> Literal["InputInvoice"]:
        return "InputInvoice"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "purpose": self.purpose}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInvoiceTelegram", None]:
        if data:
            data_class = cls()
            data_class.purpose = data.get("purpose", None)

        return data_class


class PaidMediaPreview(TlObject, PaidMedia):
    r"""The media is hidden until the invoice is paid

    Parameters:
        width (:class:`int`):
            Media width; 0 if unknown

        height (:class:`int`):
            Media height; 0 if unknown

        duration (:class:`int`):
            Media duration, in seconds; 0 if unknown

        minithumbnail (:class:`"types.Minithumbnail"`):
            Media minithumbnail; may be null

    """

    def __init__(
        self,
        width: int = 0,
        height: int = 0,
        duration: int = 0,
        minithumbnail: Minithumbnail = None,
    ) -> None:
        self.width: int = int(width)
        r"""Media width; 0 if unknown"""
        self.height: int = int(height)
        r"""Media height; 0 if unknown"""
        self.duration: int = int(duration)
        r"""Media duration, in seconds; 0 if unknown"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Media minithumbnail; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidMediaPreview"]:
        return "paidMediaPreview"

    def getClass(self) -> Literal["PaidMedia"]:
        return "PaidMedia"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "width": self.width,
            "height": self.height,
            "duration": self.duration,
            "minithumbnail": self.minithumbnail,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidMediaPreview", None]:
        if data:
            data_class = cls()
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.duration = int(data.get("duration", 0))
            data_class.minithumbnail = data.get("minithumbnail", None)

        return data_class


class PaidMediaPhoto(TlObject, PaidMedia):
    r"""The media is a photo

    Parameters:
        photo (:class:`"types.Photo"`):
            The photo

    """

    def __init__(self, photo: Photo = None) -> None:
        self.photo: Union[Photo, None] = photo
        r"""The photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidMediaPhoto"]:
        return "paidMediaPhoto"

    def getClass(self) -> Literal["PaidMedia"]:
        return "PaidMedia"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidMediaPhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class PaidMediaVideo(TlObject, PaidMedia):
    r"""The media is a video

    Parameters:
        video (:class:`"types.Video"`):
            The video

        cover (:class:`"types.Photo"`):
            Cover of the video; may be null if none

        start_timestamp (:class:`int`):
            Timestamp from which the video playing must start, in seconds

    """

    def __init__(
        self, video: Video = None, cover: Photo = None, start_timestamp: int = 0
    ) -> None:
        self.video: Union[Video, None] = video
        r"""The video"""
        self.cover: Union[Photo, None] = cover
        r"""Cover of the video; may be null if none"""
        self.start_timestamp: int = int(start_timestamp)
        r"""Timestamp from which the video playing must start, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidMediaVideo"]:
        return "paidMediaVideo"

    def getClass(self) -> Literal["PaidMedia"]:
        return "PaidMedia"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "cover": self.cover,
            "start_timestamp": self.start_timestamp,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidMediaVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.cover = data.get("cover", None)
            data_class.start_timestamp = int(data.get("start_timestamp", 0))

        return data_class


class PaidMediaUnsupported(TlObject, PaidMedia):
    r"""The media is unsupported"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["paidMediaUnsupported"]:
        return "paidMediaUnsupported"

    def getClass(self) -> Literal["PaidMedia"]:
        return "PaidMedia"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PaidMediaUnsupported", None]:
        if data:
            data_class = cls()

        return data_class


class GiveawayParameters(TlObject):
    r"""Describes parameters of a giveaway

    Parameters:
        boosted_chat_id (:class:`int`):
            Identifier of the supergroup or channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Telegram Premium subscription, or for the specified time\. If the chat is a channel, then can\_post\_messages right is required in the channel, otherwise, the user must be an administrator in the supergroup

        additional_chat_ids (:class:`List[int]`):
            Identifiers of other supergroup or channel chats that must be subscribed by the users to be eligible for the giveaway\. There can be up to getOption\(\"giveaway\_additional\_chat\_count\_max\"\) additional chats

        winners_selection_date (:class:`int`):
            Point in time \(Unix timestamp\) when the giveaway is expected to be performed; must be 60\-getOption\(\"giveaway\_duration\_max\"\) seconds in the future in scheduled giveaways

        only_new_members (:class:`bool`):
            True, if only new members of the chats will be eligible for the giveaway

        has_public_winners (:class:`bool`):
            True, if the list of winners of the giveaway will be available to everyone

        country_codes (:class:`List[str]`):
            The list of two\-letter ISO 3166\-1 alpha\-2 codes of countries, users from which will be eligible for the giveaway\. If empty, then all users can participate in the giveaway\. There can be up to getOption\(\"giveaway\_country\_count\_max\"\) chosen countries\. Users with phone number that was bought at https://fragment\.com can participate in any giveaway and the country code \"FT\" must not be specified in the list

        prize_description (:class:`str`):
            Additional description of the giveaway prize; 0\-128 characters

    """

    def __init__(
        self,
        boosted_chat_id: int = 0,
        additional_chat_ids: List[int] = None,
        winners_selection_date: int = 0,
        only_new_members: bool = False,
        has_public_winners: bool = False,
        country_codes: List[str] = None,
        prize_description: str = "",
    ) -> None:
        self.boosted_chat_id: int = int(boosted_chat_id)
        r"""Identifier of the supergroup or channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Telegram Premium subscription, or for the specified time\. If the chat is a channel, then can\_post\_messages right is required in the channel, otherwise, the user must be an administrator in the supergroup"""
        self.additional_chat_ids: List[int] = additional_chat_ids or []
        r"""Identifiers of other supergroup or channel chats that must be subscribed by the users to be eligible for the giveaway\. There can be up to getOption\(\"giveaway\_additional\_chat\_count\_max\"\) additional chats"""
        self.winners_selection_date: int = int(winners_selection_date)
        r"""Point in time \(Unix timestamp\) when the giveaway is expected to be performed; must be 60\-getOption\(\"giveaway\_duration\_max\"\) seconds in the future in scheduled giveaways"""
        self.only_new_members: bool = bool(only_new_members)
        r"""True, if only new members of the chats will be eligible for the giveaway"""
        self.has_public_winners: bool = bool(has_public_winners)
        r"""True, if the list of winners of the giveaway will be available to everyone"""
        self.country_codes: List[str] = country_codes or []
        r"""The list of two\-letter ISO 3166\-1 alpha\-2 codes of countries, users from which will be eligible for the giveaway\. If empty, then all users can participate in the giveaway\. There can be up to getOption\(\"giveaway\_country\_count\_max\"\) chosen countries\. Users with phone number that was bought at https://fragment\.com can participate in any giveaway and the country code \"FT\" must not be specified in the list"""
        self.prize_description: Union[str, None] = prize_description
        r"""Additional description of the giveaway prize; 0\-128 characters"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["giveawayParameters"]:
        return "giveawayParameters"

    def getClass(self) -> Literal["GiveawayParameters"]:
        return "GiveawayParameters"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "boosted_chat_id": self.boosted_chat_id,
            "additional_chat_ids": self.additional_chat_ids,
            "winners_selection_date": self.winners_selection_date,
            "only_new_members": self.only_new_members,
            "has_public_winners": self.has_public_winners,
            "country_codes": self.country_codes,
            "prize_description": self.prize_description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GiveawayParameters", None]:
        if data:
            data_class = cls()
            data_class.boosted_chat_id = int(data.get("boosted_chat_id", 0))
            data_class.additional_chat_ids = data.get("additional_chat_ids", None)
            data_class.winners_selection_date = int(
                data.get("winners_selection_date", 0)
            )
            data_class.only_new_members = data.get("only_new_members", False)
            data_class.has_public_winners = data.get("has_public_winners", False)
            data_class.country_codes = data.get("country_codes", None)
            data_class.prize_description = data.get("prize_description", "")

        return data_class


class DatedFile(TlObject):
    r"""File with the date it was uploaded

    Parameters:
        file (:class:`"types.File"`):
            The file

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the file was uploaded

    """

    def __init__(self, file: File = None, date: int = 0) -> None:
        self.file: Union[File, None] = file
        r"""The file"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the file was uploaded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["datedFile"]:
        return "datedFile"

    def getClass(self) -> Literal["DatedFile"]:
        return "DatedFile"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file": self.file, "date": self.date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DatedFile", None]:
        if data:
            data_class = cls()
            data_class.file = data.get("file", None)
            data_class.date = int(data.get("date", 0))

        return data_class


class PassportElementTypePersonalDetails(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's personal details"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypePersonalDetails"]:
        return "passportElementTypePersonalDetails"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypePersonalDetails", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypePassport(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's passport"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypePassport"]:
        return "passportElementTypePassport"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypePassport", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeDriverLicense(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's driver license"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeDriverLicense"]:
        return "passportElementTypeDriverLicense"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypeDriverLicense", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeIdentityCard(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's identity card"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeIdentityCard"]:
        return "passportElementTypeIdentityCard"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypeIdentityCard", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeInternalPassport(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's internal passport"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeInternalPassport"]:
        return "passportElementTypeInternalPassport"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementTypeInternalPassport", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeAddress(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's address"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeAddress"]:
        return "passportElementTypeAddress"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypeAddress", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeUtilityBill(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's utility bill"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeUtilityBill"]:
        return "passportElementTypeUtilityBill"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypeUtilityBill", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeBankStatement(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's bank statement"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeBankStatement"]:
        return "passportElementTypeBankStatement"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypeBankStatement", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeRentalAgreement(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's rental agreement"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeRentalAgreement"]:
        return "passportElementTypeRentalAgreement"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypeRentalAgreement", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypePassportRegistration(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the registration page of the user's passport"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypePassportRegistration"]:
        return "passportElementTypePassportRegistration"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementTypePassportRegistration", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeTemporaryRegistration(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's temporary registration"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeTemporaryRegistration"]:
        return "passportElementTypeTemporaryRegistration"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementTypeTemporaryRegistration", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypePhoneNumber(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's phone number"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypePhoneNumber"]:
        return "passportElementTypePhoneNumber"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypePhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementTypeEmailAddress(TlObject, PassportElementType):
    r"""A Telegram Passport element containing the user's email address"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTypeEmailAddress"]:
        return "passportElementTypeEmailAddress"

    def getClass(self) -> Literal["PassportElementType"]:
        return "PassportElementType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementTypeEmailAddress", None]:
        if data:
            data_class = cls()

        return data_class


class Date(TlObject):
    r"""Represents a date according to the Gregorian calendar

    Parameters:
        day (:class:`int`):
            Day of the month; 1\-31

        month (:class:`int`):
            Month; 1\-12

        year (:class:`int`):
            Year; 1\-9999

    """

    def __init__(self, day: int = 0, month: int = 0, year: int = 0) -> None:
        self.day: int = int(day)
        r"""Day of the month; 1\-31"""
        self.month: int = int(month)
        r"""Month; 1\-12"""
        self.year: int = int(year)
        r"""Year; 1\-9999"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["date"]:
        return "date"

    def getClass(self) -> Literal["Date"]:
        return "Date"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "day": self.day,
            "month": self.month,
            "year": self.year,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Date", None]:
        if data:
            data_class = cls()
            data_class.day = int(data.get("day", 0))
            data_class.month = int(data.get("month", 0))
            data_class.year = int(data.get("year", 0))

        return data_class


class PersonalDetails(TlObject):
    r"""Contains the user's personal details

    Parameters:
        first_name (:class:`str`):
            First name of the user written in English; 1\-255 characters

        middle_name (:class:`str`):
            Middle name of the user written in English; 0\-255 characters

        last_name (:class:`str`):
            Last name of the user written in English; 1\-255 characters

        native_first_name (:class:`str`):
            Native first name of the user; 1\-255 characters

        native_middle_name (:class:`str`):
            Native middle name of the user; 0\-255 characters

        native_last_name (:class:`str`):
            Native last name of the user; 1\-255 characters

        birthdate (:class:`"types.Date"`):
            Birthdate of the user

        gender (:class:`str`):
            Gender of the user, \"male\" or \"female\"

        country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code of the user's country

        residence_country_code (:class:`str`):
            A two\-letter ISO 3166\-1 alpha\-2 country code of the user's residence country

    """

    def __init__(
        self,
        first_name: str = "",
        middle_name: str = "",
        last_name: str = "",
        native_first_name: str = "",
        native_middle_name: str = "",
        native_last_name: str = "",
        birthdate: Date = None,
        gender: str = "",
        country_code: str = "",
        residence_country_code: str = "",
    ) -> None:
        self.first_name: Union[str, None] = first_name
        r"""First name of the user written in English; 1\-255 characters"""
        self.middle_name: Union[str, None] = middle_name
        r"""Middle name of the user written in English; 0\-255 characters"""
        self.last_name: Union[str, None] = last_name
        r"""Last name of the user written in English; 1\-255 characters"""
        self.native_first_name: Union[str, None] = native_first_name
        r"""Native first name of the user; 1\-255 characters"""
        self.native_middle_name: Union[str, None] = native_middle_name
        r"""Native middle name of the user; 0\-255 characters"""
        self.native_last_name: Union[str, None] = native_last_name
        r"""Native last name of the user; 1\-255 characters"""
        self.birthdate: Union[Date, None] = birthdate
        r"""Birthdate of the user"""
        self.gender: Union[str, None] = gender
        r"""Gender of the user, \"male\" or \"female\""""
        self.country_code: Union[str, None] = country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code of the user's country"""
        self.residence_country_code: Union[str, None] = residence_country_code
        r"""A two\-letter ISO 3166\-1 alpha\-2 country code of the user's residence country"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["personalDetails"]:
        return "personalDetails"

    def getClass(self) -> Literal["PersonalDetails"]:
        return "PersonalDetails"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "first_name": self.first_name,
            "middle_name": self.middle_name,
            "last_name": self.last_name,
            "native_first_name": self.native_first_name,
            "native_middle_name": self.native_middle_name,
            "native_last_name": self.native_last_name,
            "birthdate": self.birthdate,
            "gender": self.gender,
            "country_code": self.country_code,
            "residence_country_code": self.residence_country_code,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PersonalDetails", None]:
        if data:
            data_class = cls()
            data_class.first_name = data.get("first_name", "")
            data_class.middle_name = data.get("middle_name", "")
            data_class.last_name = data.get("last_name", "")
            data_class.native_first_name = data.get("native_first_name", "")
            data_class.native_middle_name = data.get("native_middle_name", "")
            data_class.native_last_name = data.get("native_last_name", "")
            data_class.birthdate = data.get("birthdate", None)
            data_class.gender = data.get("gender", "")
            data_class.country_code = data.get("country_code", "")
            data_class.residence_country_code = data.get("residence_country_code", "")

        return data_class


class IdentityDocument(TlObject):
    r"""An identity document

    Parameters:
        number (:class:`str`):
            Document number; 1\-24 characters

        expiration_date (:class:`"types.Date"`):
            Document expiration date; may be null if not applicable

        front_side (:class:`"types.DatedFile"`):
            Front side of the document

        reverse_side (:class:`"types.DatedFile"`):
            Reverse side of the document; only for driver license and identity card; may be null

        selfie (:class:`"types.DatedFile"`):
            Selfie with the document; may be null

        translation (:class:`List["types.DatedFile"]`):
            List of files containing a certified English translation of the document

    """

    def __init__(
        self,
        number: str = "",
        expiration_date: Date = None,
        front_side: DatedFile = None,
        reverse_side: DatedFile = None,
        selfie: DatedFile = None,
        translation: List[DatedFile] = None,
    ) -> None:
        self.number: Union[str, None] = number
        r"""Document number; 1\-24 characters"""
        self.expiration_date: Union[Date, None] = expiration_date
        r"""Document expiration date; may be null if not applicable"""
        self.front_side: Union[DatedFile, None] = front_side
        r"""Front side of the document"""
        self.reverse_side: Union[DatedFile, None] = reverse_side
        r"""Reverse side of the document; only for driver license and identity card; may be null"""
        self.selfie: Union[DatedFile, None] = selfie
        r"""Selfie with the document; may be null"""
        self.translation: List[DatedFile] = translation or []
        r"""List of files containing a certified English translation of the document"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["identityDocument"]:
        return "identityDocument"

    def getClass(self) -> Literal["IdentityDocument"]:
        return "IdentityDocument"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "number": self.number,
            "expiration_date": self.expiration_date,
            "front_side": self.front_side,
            "reverse_side": self.reverse_side,
            "selfie": self.selfie,
            "translation": self.translation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["IdentityDocument", None]:
        if data:
            data_class = cls()
            data_class.number = data.get("number", "")
            data_class.expiration_date = data.get("expiration_date", None)
            data_class.front_side = data.get("front_side", None)
            data_class.reverse_side = data.get("reverse_side", None)
            data_class.selfie = data.get("selfie", None)
            data_class.translation = data.get("translation", None)

        return data_class


class InputIdentityDocument(TlObject):
    r"""An identity document to be saved to Telegram Passport

    Parameters:
        number (:class:`str`):
            Document number; 1\-24 characters

        expiration_date (:class:`"types.Date"`):
            Document expiration date; pass null if not applicable

        front_side (:class:`"types.InputFile"`):
            Front side of the document

        reverse_side (:class:`"types.InputFile"`):
            Reverse side of the document; only for driver license and identity card; pass null otherwise

        selfie (:class:`"types.InputFile"`):
            Selfie with the document; pass null if unavailable

        translation (:class:`List["types.InputFile"]`):
            List of files containing a certified English translation of the document

    """

    def __init__(
        self,
        number: str = "",
        expiration_date: Date = None,
        front_side: InputFile = None,
        reverse_side: InputFile = None,
        selfie: InputFile = None,
        translation: List[InputFile] = None,
    ) -> None:
        self.number: Union[str, None] = number
        r"""Document number; 1\-24 characters"""
        self.expiration_date: Union[Date, None] = expiration_date
        r"""Document expiration date; pass null if not applicable"""
        self.front_side: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = front_side
        r"""Front side of the document"""
        self.reverse_side: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = reverse_side
        r"""Reverse side of the document; only for driver license and identity card; pass null otherwise"""
        self.selfie: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = selfie
        r"""Selfie with the document; pass null if unavailable"""
        self.translation: List[InputFile] = translation or []
        r"""List of files containing a certified English translation of the document"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputIdentityDocument"]:
        return "inputIdentityDocument"

    def getClass(self) -> Literal["InputIdentityDocument"]:
        return "InputIdentityDocument"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "number": self.number,
            "expiration_date": self.expiration_date,
            "front_side": self.front_side,
            "reverse_side": self.reverse_side,
            "selfie": self.selfie,
            "translation": self.translation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputIdentityDocument", None]:
        if data:
            data_class = cls()
            data_class.number = data.get("number", "")
            data_class.expiration_date = data.get("expiration_date", None)
            data_class.front_side = data.get("front_side", None)
            data_class.reverse_side = data.get("reverse_side", None)
            data_class.selfie = data.get("selfie", None)
            data_class.translation = data.get("translation", None)

        return data_class


class PersonalDocument(TlObject):
    r"""A personal document, containing some information about a user

    Parameters:
        files (:class:`List["types.DatedFile"]`):
            List of files containing the pages of the document

        translation (:class:`List["types.DatedFile"]`):
            List of files containing a certified English translation of the document

    """

    def __init__(
        self, files: List[DatedFile] = None, translation: List[DatedFile] = None
    ) -> None:
        self.files: List[DatedFile] = files or []
        r"""List of files containing the pages of the document"""
        self.translation: List[DatedFile] = translation or []
        r"""List of files containing a certified English translation of the document"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["personalDocument"]:
        return "personalDocument"

    def getClass(self) -> Literal["PersonalDocument"]:
        return "PersonalDocument"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "files": self.files,
            "translation": self.translation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PersonalDocument", None]:
        if data:
            data_class = cls()
            data_class.files = data.get("files", None)
            data_class.translation = data.get("translation", None)

        return data_class


class InputPersonalDocument(TlObject):
    r"""A personal document to be saved to Telegram Passport

    Parameters:
        files (:class:`List["types.InputFile"]`):
            List of files containing the pages of the document

        translation (:class:`List["types.InputFile"]`):
            List of files containing a certified English translation of the document

    """

    def __init__(
        self, files: List[InputFile] = None, translation: List[InputFile] = None
    ) -> None:
        self.files: List[InputFile] = files or []
        r"""List of files containing the pages of the document"""
        self.translation: List[InputFile] = translation or []
        r"""List of files containing a certified English translation of the document"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPersonalDocument"]:
        return "inputPersonalDocument"

    def getClass(self) -> Literal["InputPersonalDocument"]:
        return "InputPersonalDocument"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "files": self.files,
            "translation": self.translation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPersonalDocument", None]:
        if data:
            data_class = cls()
            data_class.files = data.get("files", None)
            data_class.translation = data.get("translation", None)

        return data_class


class PassportElementPersonalDetails(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's personal details

    Parameters:
        personal_details (:class:`"types.PersonalDetails"`):
            Personal details of the user

    """

    def __init__(self, personal_details: PersonalDetails = None) -> None:
        self.personal_details: Union[PersonalDetails, None] = personal_details
        r"""Personal details of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementPersonalDetails"]:
        return "passportElementPersonalDetails"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "personal_details": self.personal_details}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementPersonalDetails", None]:
        if data:
            data_class = cls()
            data_class.personal_details = data.get("personal_details", None)

        return data_class


class PassportElementPassport(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's passport

    Parameters:
        passport (:class:`"types.IdentityDocument"`):
            Passport

    """

    def __init__(self, passport: IdentityDocument = None) -> None:
        self.passport: Union[IdentityDocument, None] = passport
        r"""Passport"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementPassport"]:
        return "passportElementPassport"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "passport": self.passport}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementPassport", None]:
        if data:
            data_class = cls()
            data_class.passport = data.get("passport", None)

        return data_class


class PassportElementDriverLicense(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's driver license

    Parameters:
        driver_license (:class:`"types.IdentityDocument"`):
            Driver license

    """

    def __init__(self, driver_license: IdentityDocument = None) -> None:
        self.driver_license: Union[IdentityDocument, None] = driver_license
        r"""Driver license"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementDriverLicense"]:
        return "passportElementDriverLicense"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "driver_license": self.driver_license}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementDriverLicense", None]:
        if data:
            data_class = cls()
            data_class.driver_license = data.get("driver_license", None)

        return data_class


class PassportElementIdentityCard(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's identity card

    Parameters:
        identity_card (:class:`"types.IdentityDocument"`):
            Identity card

    """

    def __init__(self, identity_card: IdentityDocument = None) -> None:
        self.identity_card: Union[IdentityDocument, None] = identity_card
        r"""Identity card"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementIdentityCard"]:
        return "passportElementIdentityCard"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "identity_card": self.identity_card}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementIdentityCard", None]:
        if data:
            data_class = cls()
            data_class.identity_card = data.get("identity_card", None)

        return data_class


class PassportElementInternalPassport(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's internal passport

    Parameters:
        internal_passport (:class:`"types.IdentityDocument"`):
            Internal passport

    """

    def __init__(self, internal_passport: IdentityDocument = None) -> None:
        self.internal_passport: Union[IdentityDocument, None] = internal_passport
        r"""Internal passport"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementInternalPassport"]:
        return "passportElementInternalPassport"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "internal_passport": self.internal_passport}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementInternalPassport", None]:
        if data:
            data_class = cls()
            data_class.internal_passport = data.get("internal_passport", None)

        return data_class


class PassportElementAddress(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's address

    Parameters:
        address (:class:`"types.Address"`):
            Address

    """

    def __init__(self, address: Address = None) -> None:
        self.address: Union[Address, None] = address
        r"""Address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementAddress"]:
        return "passportElementAddress"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "address": self.address}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementAddress", None]:
        if data:
            data_class = cls()
            data_class.address = data.get("address", None)

        return data_class


class PassportElementUtilityBill(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's utility bill

    Parameters:
        utility_bill (:class:`"types.PersonalDocument"`):
            Utility bill

    """

    def __init__(self, utility_bill: PersonalDocument = None) -> None:
        self.utility_bill: Union[PersonalDocument, None] = utility_bill
        r"""Utility bill"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementUtilityBill"]:
        return "passportElementUtilityBill"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "utility_bill": self.utility_bill}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementUtilityBill", None]:
        if data:
            data_class = cls()
            data_class.utility_bill = data.get("utility_bill", None)

        return data_class


class PassportElementBankStatement(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's bank statement

    Parameters:
        bank_statement (:class:`"types.PersonalDocument"`):
            Bank statement

    """

    def __init__(self, bank_statement: PersonalDocument = None) -> None:
        self.bank_statement: Union[PersonalDocument, None] = bank_statement
        r"""Bank statement"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementBankStatement"]:
        return "passportElementBankStatement"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "bank_statement": self.bank_statement}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementBankStatement", None]:
        if data:
            data_class = cls()
            data_class.bank_statement = data.get("bank_statement", None)

        return data_class


class PassportElementRentalAgreement(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's rental agreement

    Parameters:
        rental_agreement (:class:`"types.PersonalDocument"`):
            Rental agreement

    """

    def __init__(self, rental_agreement: PersonalDocument = None) -> None:
        self.rental_agreement: Union[PersonalDocument, None] = rental_agreement
        r"""Rental agreement"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementRentalAgreement"]:
        return "passportElementRentalAgreement"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "rental_agreement": self.rental_agreement}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementRentalAgreement", None]:
        if data:
            data_class = cls()
            data_class.rental_agreement = data.get("rental_agreement", None)

        return data_class


class PassportElementPassportRegistration(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's passport registration pages

    Parameters:
        passport_registration (:class:`"types.PersonalDocument"`):
            Passport registration pages

    """

    def __init__(self, passport_registration: PersonalDocument = None) -> None:
        self.passport_registration: Union[PersonalDocument, None] = (
            passport_registration
        )
        r"""Passport registration pages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementPassportRegistration"]:
        return "passportElementPassportRegistration"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "passport_registration": self.passport_registration,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementPassportRegistration", None]:
        if data:
            data_class = cls()
            data_class.passport_registration = data.get("passport_registration", None)

        return data_class


class PassportElementTemporaryRegistration(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's temporary registration

    Parameters:
        temporary_registration (:class:`"types.PersonalDocument"`):
            Temporary registration

    """

    def __init__(self, temporary_registration: PersonalDocument = None) -> None:
        self.temporary_registration: Union[PersonalDocument, None] = (
            temporary_registration
        )
        r"""Temporary registration"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementTemporaryRegistration"]:
        return "passportElementTemporaryRegistration"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "temporary_registration": self.temporary_registration,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementTemporaryRegistration", None]:
        if data:
            data_class = cls()
            data_class.temporary_registration = data.get("temporary_registration", None)

        return data_class


class PassportElementPhoneNumber(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's phone number

    Parameters:
        phone_number (:class:`str`):
            Phone number

    """

    def __init__(self, phone_number: str = "") -> None:
        self.phone_number: Union[str, None] = phone_number
        r"""Phone number"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementPhoneNumber"]:
        return "passportElementPhoneNumber"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "phone_number": self.phone_number}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementPhoneNumber", None]:
        if data:
            data_class = cls()
            data_class.phone_number = data.get("phone_number", "")

        return data_class


class PassportElementEmailAddress(TlObject, PassportElement):
    r"""A Telegram Passport element containing the user's email address

    Parameters:
        email_address (:class:`str`):
            Email address

    """

    def __init__(self, email_address: str = "") -> None:
        self.email_address: Union[str, None] = email_address
        r"""Email address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementEmailAddress"]:
        return "passportElementEmailAddress"

    def getClass(self) -> Literal["PassportElement"]:
        return "PassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "email_address": self.email_address}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementEmailAddress", None]:
        if data:
            data_class = cls()
            data_class.email_address = data.get("email_address", "")

        return data_class


class InputPassportElementPersonalDetails(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's personal details

    Parameters:
        personal_details (:class:`"types.PersonalDetails"`):
            Personal details of the user

    """

    def __init__(self, personal_details: PersonalDetails = None) -> None:
        self.personal_details: Union[PersonalDetails, None] = personal_details
        r"""Personal details of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementPersonalDetails"]:
        return "inputPassportElementPersonalDetails"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "personal_details": self.personal_details}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementPersonalDetails", None]:
        if data:
            data_class = cls()
            data_class.personal_details = data.get("personal_details", None)

        return data_class


class InputPassportElementPassport(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's passport

    Parameters:
        passport (:class:`"types.InputIdentityDocument"`):
            The passport to be saved

    """

    def __init__(self, passport: InputIdentityDocument = None) -> None:
        self.passport: Union[InputIdentityDocument, None] = passport
        r"""The passport to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementPassport"]:
        return "inputPassportElementPassport"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "passport": self.passport}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementPassport", None]:
        if data:
            data_class = cls()
            data_class.passport = data.get("passport", None)

        return data_class


class InputPassportElementDriverLicense(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's driver license

    Parameters:
        driver_license (:class:`"types.InputIdentityDocument"`):
            The driver license to be saved

    """

    def __init__(self, driver_license: InputIdentityDocument = None) -> None:
        self.driver_license: Union[InputIdentityDocument, None] = driver_license
        r"""The driver license to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementDriverLicense"]:
        return "inputPassportElementDriverLicense"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "driver_license": self.driver_license}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementDriverLicense", None]:
        if data:
            data_class = cls()
            data_class.driver_license = data.get("driver_license", None)

        return data_class


class InputPassportElementIdentityCard(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's identity card

    Parameters:
        identity_card (:class:`"types.InputIdentityDocument"`):
            The identity card to be saved

    """

    def __init__(self, identity_card: InputIdentityDocument = None) -> None:
        self.identity_card: Union[InputIdentityDocument, None] = identity_card
        r"""The identity card to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementIdentityCard"]:
        return "inputPassportElementIdentityCard"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "identity_card": self.identity_card}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementIdentityCard", None]:
        if data:
            data_class = cls()
            data_class.identity_card = data.get("identity_card", None)

        return data_class


class InputPassportElementInternalPassport(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's internal passport

    Parameters:
        internal_passport (:class:`"types.InputIdentityDocument"`):
            The internal passport to be saved

    """

    def __init__(self, internal_passport: InputIdentityDocument = None) -> None:
        self.internal_passport: Union[InputIdentityDocument, None] = internal_passport
        r"""The internal passport to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementInternalPassport"]:
        return "inputPassportElementInternalPassport"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "internal_passport": self.internal_passport}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementInternalPassport", None]:
        if data:
            data_class = cls()
            data_class.internal_passport = data.get("internal_passport", None)

        return data_class


class InputPassportElementAddress(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's address

    Parameters:
        address (:class:`"types.Address"`):
            The address to be saved

    """

    def __init__(self, address: Address = None) -> None:
        self.address: Union[Address, None] = address
        r"""The address to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementAddress"]:
        return "inputPassportElementAddress"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "address": self.address}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementAddress", None]:
        if data:
            data_class = cls()
            data_class.address = data.get("address", None)

        return data_class


class InputPassportElementUtilityBill(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's utility bill

    Parameters:
        utility_bill (:class:`"types.InputPersonalDocument"`):
            The utility bill to be saved

    """

    def __init__(self, utility_bill: InputPersonalDocument = None) -> None:
        self.utility_bill: Union[InputPersonalDocument, None] = utility_bill
        r"""The utility bill to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementUtilityBill"]:
        return "inputPassportElementUtilityBill"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "utility_bill": self.utility_bill}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementUtilityBill", None]:
        if data:
            data_class = cls()
            data_class.utility_bill = data.get("utility_bill", None)

        return data_class


class InputPassportElementBankStatement(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's bank statement

    Parameters:
        bank_statement (:class:`"types.InputPersonalDocument"`):
            The bank statement to be saved

    """

    def __init__(self, bank_statement: InputPersonalDocument = None) -> None:
        self.bank_statement: Union[InputPersonalDocument, None] = bank_statement
        r"""The bank statement to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementBankStatement"]:
        return "inputPassportElementBankStatement"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "bank_statement": self.bank_statement}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementBankStatement", None]:
        if data:
            data_class = cls()
            data_class.bank_statement = data.get("bank_statement", None)

        return data_class


class InputPassportElementRentalAgreement(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's rental agreement

    Parameters:
        rental_agreement (:class:`"types.InputPersonalDocument"`):
            The rental agreement to be saved

    """

    def __init__(self, rental_agreement: InputPersonalDocument = None) -> None:
        self.rental_agreement: Union[InputPersonalDocument, None] = rental_agreement
        r"""The rental agreement to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementRentalAgreement"]:
        return "inputPassportElementRentalAgreement"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "rental_agreement": self.rental_agreement}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementRentalAgreement", None]:
        if data:
            data_class = cls()
            data_class.rental_agreement = data.get("rental_agreement", None)

        return data_class


class InputPassportElementPassportRegistration(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's passport registration

    Parameters:
        passport_registration (:class:`"types.InputPersonalDocument"`):
            The passport registration page to be saved

    """

    def __init__(self, passport_registration: InputPersonalDocument = None) -> None:
        self.passport_registration: Union[InputPersonalDocument, None] = (
            passport_registration
        )
        r"""The passport registration page to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementPassportRegistration"]:
        return "inputPassportElementPassportRegistration"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "passport_registration": self.passport_registration,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementPassportRegistration", None]:
        if data:
            data_class = cls()
            data_class.passport_registration = data.get("passport_registration", None)

        return data_class


class InputPassportElementTemporaryRegistration(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's temporary registration

    Parameters:
        temporary_registration (:class:`"types.InputPersonalDocument"`):
            The temporary registration document to be saved

    """

    def __init__(self, temporary_registration: InputPersonalDocument = None) -> None:
        self.temporary_registration: Union[InputPersonalDocument, None] = (
            temporary_registration
        )
        r"""The temporary registration document to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementTemporaryRegistration"]:
        return "inputPassportElementTemporaryRegistration"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "temporary_registration": self.temporary_registration,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementTemporaryRegistration", None]:
        if data:
            data_class = cls()
            data_class.temporary_registration = data.get("temporary_registration", None)

        return data_class


class InputPassportElementPhoneNumber(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's phone number

    Parameters:
        phone_number (:class:`str`):
            The phone number to be saved

    """

    def __init__(self, phone_number: str = "") -> None:
        self.phone_number: Union[str, None] = phone_number
        r"""The phone number to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementPhoneNumber"]:
        return "inputPassportElementPhoneNumber"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "phone_number": self.phone_number}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementPhoneNumber", None]:
        if data:
            data_class = cls()
            data_class.phone_number = data.get("phone_number", "")

        return data_class


class InputPassportElementEmailAddress(TlObject, InputPassportElement):
    r"""A Telegram Passport element to be saved containing the user's email address

    Parameters:
        email_address (:class:`str`):
            The email address to be saved

    """

    def __init__(self, email_address: str = "") -> None:
        self.email_address: Union[str, None] = email_address
        r"""The email address to be saved"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementEmailAddress"]:
        return "inputPassportElementEmailAddress"

    def getClass(self) -> Literal["InputPassportElement"]:
        return "InputPassportElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "email_address": self.email_address}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementEmailAddress", None]:
        if data:
            data_class = cls()
            data_class.email_address = data.get("email_address", "")

        return data_class


class PassportElements(TlObject):
    r"""Contains information about saved Telegram Passport elements

    Parameters:
        elements (:class:`List["types.PassportElement"]`):
            Telegram Passport elements

    """

    def __init__(self, elements: List[PassportElement] = None) -> None:
        self.elements: List[PassportElement] = elements or []
        r"""Telegram Passport elements"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElements"]:
        return "passportElements"

    def getClass(self) -> Literal["PassportElements"]:
        return "PassportElements"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "elements": self.elements}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElements", None]:
        if data:
            data_class = cls()
            data_class.elements = data.get("elements", None)

        return data_class


class PassportElementErrorSourceUnspecified(TlObject, PassportElementErrorSource):
    r"""The element contains an error in an unspecified place\. The error will be considered resolved when new data is added"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceUnspecified"]:
        return "passportElementErrorSourceUnspecified"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementErrorSourceUnspecified", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementErrorSourceDataField(TlObject, PassportElementErrorSource):
    r"""One of the data fields contains an error\. The error will be considered resolved when the value of the field changes

    Parameters:
        field_name (:class:`str`):
            Field name

    """

    def __init__(self, field_name: str = "") -> None:
        self.field_name: Union[str, None] = field_name
        r"""Field name"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceDataField"]:
        return "passportElementErrorSourceDataField"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "field_name": self.field_name}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementErrorSourceDataField", None]:
        if data:
            data_class = cls()
            data_class.field_name = data.get("field_name", "")

        return data_class


class PassportElementErrorSourceFrontSide(TlObject, PassportElementErrorSource):
    r"""The front side of the document contains an error\. The error will be considered resolved when the file with the front side changes"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceFrontSide"]:
        return "passportElementErrorSourceFrontSide"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementErrorSourceFrontSide", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementErrorSourceReverseSide(TlObject, PassportElementErrorSource):
    r"""The reverse side of the document contains an error\. The error will be considered resolved when the file with the reverse side changes"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceReverseSide"]:
        return "passportElementErrorSourceReverseSide"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementErrorSourceReverseSide", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementErrorSourceSelfie(TlObject, PassportElementErrorSource):
    r"""The selfie with the document contains an error\. The error will be considered resolved when the file with the selfie changes"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceSelfie"]:
        return "passportElementErrorSourceSelfie"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementErrorSourceSelfie", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementErrorSourceTranslationFile(TlObject, PassportElementErrorSource):
    r"""One of files with the translation of the document contains an error\. The error will be considered resolved when the file changes

    Parameters:
        file_index (:class:`int`):
            Index of a file with the error

    """

    def __init__(self, file_index: int = 0) -> None:
        self.file_index: int = int(file_index)
        r"""Index of a file with the error"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceTranslationFile"]:
        return "passportElementErrorSourceTranslationFile"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_index": self.file_index}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementErrorSourceTranslationFile", None]:
        if data:
            data_class = cls()
            data_class.file_index = int(data.get("file_index", 0))

        return data_class


class PassportElementErrorSourceTranslationFiles(TlObject, PassportElementErrorSource):
    r"""The translation of the document contains an error\. The error will be considered resolved when the list of translation files changes"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceTranslationFiles"]:
        return "passportElementErrorSourceTranslationFiles"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PassportElementErrorSourceTranslationFiles", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementErrorSourceFile(TlObject, PassportElementErrorSource):
    r"""The file contains an error\. The error will be considered resolved when the file changes

    Parameters:
        file_index (:class:`int`):
            Index of a file with the error

    """

    def __init__(self, file_index: int = 0) -> None:
        self.file_index: int = int(file_index)
        r"""Index of a file with the error"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceFile"]:
        return "passportElementErrorSourceFile"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_index": self.file_index}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementErrorSourceFile", None]:
        if data:
            data_class = cls()
            data_class.file_index = int(data.get("file_index", 0))

        return data_class


class PassportElementErrorSourceFiles(TlObject, PassportElementErrorSource):
    r"""The list of attached files contains an error\. The error will be considered resolved when the list of files changes"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementErrorSourceFiles"]:
        return "passportElementErrorSourceFiles"

    def getClass(self) -> Literal["PassportElementErrorSource"]:
        return "PassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementErrorSourceFiles", None]:
        if data:
            data_class = cls()

        return data_class


class PassportElementError(TlObject):
    r"""Contains the description of an error in a Telegram Passport element

    Parameters:
        type (:class:`"types.PassportElementType"`):
            Type of the Telegram Passport element which has the error

        message (:class:`str`):
            Error message

        source (:class:`"types.PassportElementErrorSource"`):
            Error source

    """

    def __init__(
        self,
        type: PassportElementType = None,
        message: str = "",
        source: PassportElementErrorSource = None,
    ) -> None:
        self.type: Union[
            PassportElementTypePersonalDetails,
            PassportElementTypePassport,
            PassportElementTypeDriverLicense,
            PassportElementTypeIdentityCard,
            PassportElementTypeInternalPassport,
            PassportElementTypeAddress,
            PassportElementTypeUtilityBill,
            PassportElementTypeBankStatement,
            PassportElementTypeRentalAgreement,
            PassportElementTypePassportRegistration,
            PassportElementTypeTemporaryRegistration,
            PassportElementTypePhoneNumber,
            PassportElementTypeEmailAddress,
            None,
        ] = type
        r"""Type of the Telegram Passport element which has the error"""
        self.message: Union[str, None] = message
        r"""Error message"""
        self.source: Union[
            PassportElementErrorSourceUnspecified,
            PassportElementErrorSourceDataField,
            PassportElementErrorSourceFrontSide,
            PassportElementErrorSourceReverseSide,
            PassportElementErrorSourceSelfie,
            PassportElementErrorSourceTranslationFile,
            PassportElementErrorSourceTranslationFiles,
            PassportElementErrorSourceFile,
            PassportElementErrorSourceFiles,
            None,
        ] = source
        r"""Error source"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementError"]:
        return "passportElementError"

    def getClass(self) -> Literal["PassportElementError"]:
        return "PassportElementError"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "message": self.message,
            "source": self.source,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementError", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.message = data.get("message", "")
            data_class.source = data.get("source", None)

        return data_class


class PassportSuitableElement(TlObject):
    r"""Contains information about a Telegram Passport element that was requested by a service

    Parameters:
        type (:class:`"types.PassportElementType"`):
            Type of the element

        is_selfie_required (:class:`bool`):
            True, if a selfie is required with the identity document

        is_translation_required (:class:`bool`):
            True, if a certified English translation is required with the document

        is_native_name_required (:class:`bool`):
            True, if personal details must include the user's name in the language of their country of residence

    """

    def __init__(
        self,
        type: PassportElementType = None,
        is_selfie_required: bool = False,
        is_translation_required: bool = False,
        is_native_name_required: bool = False,
    ) -> None:
        self.type: Union[
            PassportElementTypePersonalDetails,
            PassportElementTypePassport,
            PassportElementTypeDriverLicense,
            PassportElementTypeIdentityCard,
            PassportElementTypeInternalPassport,
            PassportElementTypeAddress,
            PassportElementTypeUtilityBill,
            PassportElementTypeBankStatement,
            PassportElementTypeRentalAgreement,
            PassportElementTypePassportRegistration,
            PassportElementTypeTemporaryRegistration,
            PassportElementTypePhoneNumber,
            PassportElementTypeEmailAddress,
            None,
        ] = type
        r"""Type of the element"""
        self.is_selfie_required: bool = bool(is_selfie_required)
        r"""True, if a selfie is required with the identity document"""
        self.is_translation_required: bool = bool(is_translation_required)
        r"""True, if a certified English translation is required with the document"""
        self.is_native_name_required: bool = bool(is_native_name_required)
        r"""True, if personal details must include the user's name in the language of their country of residence"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportSuitableElement"]:
        return "passportSuitableElement"

    def getClass(self) -> Literal["PassportSuitableElement"]:
        return "PassportSuitableElement"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "is_selfie_required": self.is_selfie_required,
            "is_translation_required": self.is_translation_required,
            "is_native_name_required": self.is_native_name_required,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportSuitableElement", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.is_selfie_required = data.get("is_selfie_required", False)
            data_class.is_translation_required = data.get(
                "is_translation_required", False
            )
            data_class.is_native_name_required = data.get(
                "is_native_name_required", False
            )

        return data_class


class PassportRequiredElement(TlObject):
    r"""Contains a description of the required Telegram Passport element that was requested by a service

    Parameters:
        suitable_elements (:class:`List["types.PassportSuitableElement"]`):
            List of Telegram Passport elements any of which is enough to provide

    """

    def __init__(self, suitable_elements: List[PassportSuitableElement] = None) -> None:
        self.suitable_elements: List[PassportSuitableElement] = suitable_elements or []
        r"""List of Telegram Passport elements any of which is enough to provide"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportRequiredElement"]:
        return "passportRequiredElement"

    def getClass(self) -> Literal["PassportRequiredElement"]:
        return "PassportRequiredElement"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "suitable_elements": self.suitable_elements}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportRequiredElement", None]:
        if data:
            data_class = cls()
            data_class.suitable_elements = data.get("suitable_elements", None)

        return data_class


class PassportAuthorizationForm(TlObject):
    r"""Contains information about a Telegram Passport authorization form that was requested

    Parameters:
        id (:class:`int`):
            Unique identifier of the authorization form

        required_elements (:class:`List["types.PassportRequiredElement"]`):
            Telegram Passport elements that must be provided to complete the form

        privacy_policy_url (:class:`str`):
            URL for the privacy policy of the service; may be empty

    """

    def __init__(
        self,
        id: int = 0,
        required_elements: List[PassportRequiredElement] = None,
        privacy_policy_url: str = "",
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the authorization form"""
        self.required_elements: List[PassportRequiredElement] = required_elements or []
        r"""Telegram Passport elements that must be provided to complete the form"""
        self.privacy_policy_url: Union[str, None] = privacy_policy_url
        r"""URL for the privacy policy of the service; may be empty"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportAuthorizationForm"]:
        return "passportAuthorizationForm"

    def getClass(self) -> Literal["PassportAuthorizationForm"]:
        return "PassportAuthorizationForm"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "required_elements": self.required_elements,
            "privacy_policy_url": self.privacy_policy_url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportAuthorizationForm", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.required_elements = data.get("required_elements", None)
            data_class.privacy_policy_url = data.get("privacy_policy_url", "")

        return data_class


class PassportElementsWithErrors(TlObject):
    r"""Contains information about a Telegram Passport elements and corresponding errors

    Parameters:
        elements (:class:`List["types.PassportElement"]`):
            Telegram Passport elements

        errors (:class:`List["types.PassportElementError"]`):
            Errors in the elements that are already available

    """

    def __init__(
        self,
        elements: List[PassportElement] = None,
        errors: List[PassportElementError] = None,
    ) -> None:
        self.elements: List[PassportElement] = elements or []
        r"""Telegram Passport elements"""
        self.errors: List[PassportElementError] = errors or []
        r"""Errors in the elements that are already available"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["passportElementsWithErrors"]:
        return "passportElementsWithErrors"

    def getClass(self) -> Literal["PassportElementsWithErrors"]:
        return "PassportElementsWithErrors"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "elements": self.elements,
            "errors": self.errors,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PassportElementsWithErrors", None]:
        if data:
            data_class = cls()
            data_class.elements = data.get("elements", None)
            data_class.errors = data.get("errors", None)

        return data_class


class EncryptedCredentials(TlObject):
    r"""Contains encrypted Telegram Passport data credentials

    Parameters:
        data (:class:`bytes`):
            The encrypted credentials

        hash (:class:`bytes`):
            The decrypted data hash

        secret (:class:`bytes`):
            Secret for data decryption, encrypted with the service's public key

    """

    def __init__(
        self, data: bytes = b"", hash: bytes = b"", secret: bytes = b""
    ) -> None:
        self.data: Union[bytes, None] = data
        r"""The encrypted credentials"""
        self.hash: Union[bytes, None] = hash
        r"""The decrypted data hash"""
        self.secret: Union[bytes, None] = secret
        r"""Secret for data decryption, encrypted with the service's public key"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["encryptedCredentials"]:
        return "encryptedCredentials"

    def getClass(self) -> Literal["EncryptedCredentials"]:
        return "EncryptedCredentials"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "data": self.data,
            "hash": self.hash,
            "secret": self.secret,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["EncryptedCredentials", None]:
        if data:
            data_class = cls()
            data_class.data = b64decode(data.get("data", b""))
            data_class.hash = b64decode(data.get("hash", b""))
            data_class.secret = b64decode(data.get("secret", b""))

        return data_class


class EncryptedPassportElement(TlObject):
    r"""Contains information about an encrypted Telegram Passport element; for bots only

    Parameters:
        type (:class:`"types.PassportElementType"`):
            Type of Telegram Passport element

        data (:class:`bytes`):
            Encrypted JSON\-encoded data about the user

        front_side (:class:`"types.DatedFile"`):
            The front side of an identity document

        reverse_side (:class:`"types.DatedFile"`):
            The reverse side of an identity document; may be null

        selfie (:class:`"types.DatedFile"`):
            Selfie with the document; may be null

        translation (:class:`List["types.DatedFile"]`):
            List of files containing a certified English translation of the document

        files (:class:`List["types.DatedFile"]`):
            List of attached files

        value (:class:`str`):
            Unencrypted data, phone number or email address

        hash (:class:`str`):
            Hash of the entire element

    """

    def __init__(
        self,
        type: PassportElementType = None,
        data: bytes = b"",
        front_side: DatedFile = None,
        reverse_side: DatedFile = None,
        selfie: DatedFile = None,
        translation: List[DatedFile] = None,
        files: List[DatedFile] = None,
        value: str = "",
        hash: str = "",
    ) -> None:
        self.type: Union[
            PassportElementTypePersonalDetails,
            PassportElementTypePassport,
            PassportElementTypeDriverLicense,
            PassportElementTypeIdentityCard,
            PassportElementTypeInternalPassport,
            PassportElementTypeAddress,
            PassportElementTypeUtilityBill,
            PassportElementTypeBankStatement,
            PassportElementTypeRentalAgreement,
            PassportElementTypePassportRegistration,
            PassportElementTypeTemporaryRegistration,
            PassportElementTypePhoneNumber,
            PassportElementTypeEmailAddress,
            None,
        ] = type
        r"""Type of Telegram Passport element"""
        self.data: Union[bytes, None] = data
        r"""Encrypted JSON\-encoded data about the user"""
        self.front_side: Union[DatedFile, None] = front_side
        r"""The front side of an identity document"""
        self.reverse_side: Union[DatedFile, None] = reverse_side
        r"""The reverse side of an identity document; may be null"""
        self.selfie: Union[DatedFile, None] = selfie
        r"""Selfie with the document; may be null"""
        self.translation: List[DatedFile] = translation or []
        r"""List of files containing a certified English translation of the document"""
        self.files: List[DatedFile] = files or []
        r"""List of attached files"""
        self.value: Union[str, None] = value
        r"""Unencrypted data, phone number or email address"""
        self.hash: Union[str, None] = hash
        r"""Hash of the entire element"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["encryptedPassportElement"]:
        return "encryptedPassportElement"

    def getClass(self) -> Literal["EncryptedPassportElement"]:
        return "EncryptedPassportElement"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "data": self.data,
            "front_side": self.front_side,
            "reverse_side": self.reverse_side,
            "selfie": self.selfie,
            "translation": self.translation,
            "files": self.files,
            "value": self.value,
            "hash": self.hash,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["EncryptedPassportElement", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.data = b64decode(data.get("data", b""))
            data_class.front_side = data.get("front_side", None)
            data_class.reverse_side = data.get("reverse_side", None)
            data_class.selfie = data.get("selfie", None)
            data_class.translation = data.get("translation", None)
            data_class.files = data.get("files", None)
            data_class.value = data.get("value", "")
            data_class.hash = data.get("hash", "")

        return data_class


class InputPassportElementErrorSourceUnspecified(
    TlObject, InputPassportElementErrorSource
):
    r"""The element contains an error in an unspecified place\. The error will be considered resolved when new data is added

    Parameters:
        element_hash (:class:`bytes`):
            Current hash of the entire element

    """

    def __init__(self, element_hash: bytes = b"") -> None:
        self.element_hash: Union[bytes, None] = element_hash
        r"""Current hash of the entire element"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceUnspecified"]:
        return "inputPassportElementErrorSourceUnspecified"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "element_hash": self.element_hash}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceUnspecified", None]:
        if data:
            data_class = cls()
            data_class.element_hash = b64decode(data.get("element_hash", b""))

        return data_class


class InputPassportElementErrorSourceDataField(
    TlObject, InputPassportElementErrorSource
):
    r"""A data field contains an error\. The error is considered resolved when the field's value changes

    Parameters:
        field_name (:class:`str`):
            Field name

        data_hash (:class:`bytes`):
            Current data hash

    """

    def __init__(self, field_name: str = "", data_hash: bytes = b"") -> None:
        self.field_name: Union[str, None] = field_name
        r"""Field name"""
        self.data_hash: Union[bytes, None] = data_hash
        r"""Current data hash"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceDataField"]:
        return "inputPassportElementErrorSourceDataField"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "field_name": self.field_name,
            "data_hash": self.data_hash,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceDataField", None]:
        if data:
            data_class = cls()
            data_class.field_name = data.get("field_name", "")
            data_class.data_hash = b64decode(data.get("data_hash", b""))

        return data_class


class InputPassportElementErrorSourceFrontSide(
    TlObject, InputPassportElementErrorSource
):
    r"""The front side of the document contains an error\. The error is considered resolved when the file with the front side of the document changes

    Parameters:
        file_hash (:class:`bytes`):
            Current hash of the file containing the front side

    """

    def __init__(self, file_hash: bytes = b"") -> None:
        self.file_hash: Union[bytes, None] = file_hash
        r"""Current hash of the file containing the front side"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceFrontSide"]:
        return "inputPassportElementErrorSourceFrontSide"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_hash": self.file_hash}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceFrontSide", None]:
        if data:
            data_class = cls()
            data_class.file_hash = b64decode(data.get("file_hash", b""))

        return data_class


class InputPassportElementErrorSourceReverseSide(
    TlObject, InputPassportElementErrorSource
):
    r"""The reverse side of the document contains an error\. The error is considered resolved when the file with the reverse side of the document changes

    Parameters:
        file_hash (:class:`bytes`):
            Current hash of the file containing the reverse side

    """

    def __init__(self, file_hash: bytes = b"") -> None:
        self.file_hash: Union[bytes, None] = file_hash
        r"""Current hash of the file containing the reverse side"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceReverseSide"]:
        return "inputPassportElementErrorSourceReverseSide"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_hash": self.file_hash}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceReverseSide", None]:
        if data:
            data_class = cls()
            data_class.file_hash = b64decode(data.get("file_hash", b""))

        return data_class


class InputPassportElementErrorSourceSelfie(TlObject, InputPassportElementErrorSource):
    r"""The selfie contains an error\. The error is considered resolved when the file with the selfie changes

    Parameters:
        file_hash (:class:`bytes`):
            Current hash of the file containing the selfie

    """

    def __init__(self, file_hash: bytes = b"") -> None:
        self.file_hash: Union[bytes, None] = file_hash
        r"""Current hash of the file containing the selfie"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceSelfie"]:
        return "inputPassportElementErrorSourceSelfie"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_hash": self.file_hash}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceSelfie", None]:
        if data:
            data_class = cls()
            data_class.file_hash = b64decode(data.get("file_hash", b""))

        return data_class


class InputPassportElementErrorSourceTranslationFile(
    TlObject, InputPassportElementErrorSource
):
    r"""One of the files containing the translation of the document contains an error\. The error is considered resolved when the file with the translation changes

    Parameters:
        file_hash (:class:`bytes`):
            Current hash of the file containing the translation

    """

    def __init__(self, file_hash: bytes = b"") -> None:
        self.file_hash: Union[bytes, None] = file_hash
        r"""Current hash of the file containing the translation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceTranslationFile"]:
        return "inputPassportElementErrorSourceTranslationFile"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_hash": self.file_hash}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceTranslationFile", None]:
        if data:
            data_class = cls()
            data_class.file_hash = b64decode(data.get("file_hash", b""))

        return data_class


class InputPassportElementErrorSourceTranslationFiles(
    TlObject, InputPassportElementErrorSource
):
    r"""The translation of the document contains an error\. The error is considered resolved when the list of files changes

    Parameters:
        file_hashes (:class:`List[bytes]`):
            Current hashes of all files with the translation

    """

    def __init__(self, file_hashes: List[bytes] = None) -> None:
        self.file_hashes: List[bytes] = file_hashes or []
        r"""Current hashes of all files with the translation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceTranslationFiles"]:
        return "inputPassportElementErrorSourceTranslationFiles"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_hashes": self.file_hashes}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceTranslationFiles", None]:
        if data:
            data_class = cls()
            data_class.file_hashes = data.get("file_hashes", None)

        return data_class


class InputPassportElementErrorSourceFile(TlObject, InputPassportElementErrorSource):
    r"""The file contains an error\. The error is considered resolved when the file changes

    Parameters:
        file_hash (:class:`bytes`):
            Current hash of the file which has the error

    """

    def __init__(self, file_hash: bytes = b"") -> None:
        self.file_hash: Union[bytes, None] = file_hash
        r"""Current hash of the file which has the error"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceFile"]:
        return "inputPassportElementErrorSourceFile"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_hash": self.file_hash}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceFile", None]:
        if data:
            data_class = cls()
            data_class.file_hash = b64decode(data.get("file_hash", b""))

        return data_class


class InputPassportElementErrorSourceFiles(TlObject, InputPassportElementErrorSource):
    r"""The list of attached files contains an error\. The error is considered resolved when the file list changes

    Parameters:
        file_hashes (:class:`List[bytes]`):
            Current hashes of all attached files

    """

    def __init__(self, file_hashes: List[bytes] = None) -> None:
        self.file_hashes: List[bytes] = file_hashes or []
        r"""Current hashes of all attached files"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementErrorSourceFiles"]:
        return "inputPassportElementErrorSourceFiles"

    def getClass(self) -> Literal["InputPassportElementErrorSource"]:
        return "InputPassportElementErrorSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_hashes": self.file_hashes}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputPassportElementErrorSourceFiles", None]:
        if data:
            data_class = cls()
            data_class.file_hashes = data.get("file_hashes", None)

        return data_class


class InputPassportElementError(TlObject):
    r"""Contains the description of an error in a Telegram Passport element; for bots only

    Parameters:
        type (:class:`"types.PassportElementType"`):
            Type of Telegram Passport element that has the error

        message (:class:`str`):
            Error message

        source (:class:`"types.InputPassportElementErrorSource"`):
            Error source

    """

    def __init__(
        self,
        type: PassportElementType = None,
        message: str = "",
        source: InputPassportElementErrorSource = None,
    ) -> None:
        self.type: Union[
            PassportElementTypePersonalDetails,
            PassportElementTypePassport,
            PassportElementTypeDriverLicense,
            PassportElementTypeIdentityCard,
            PassportElementTypeInternalPassport,
            PassportElementTypeAddress,
            PassportElementTypeUtilityBill,
            PassportElementTypeBankStatement,
            PassportElementTypeRentalAgreement,
            PassportElementTypePassportRegistration,
            PassportElementTypeTemporaryRegistration,
            PassportElementTypePhoneNumber,
            PassportElementTypeEmailAddress,
            None,
        ] = type
        r"""Type of Telegram Passport element that has the error"""
        self.message: Union[str, None] = message
        r"""Error message"""
        self.source: Union[
            InputPassportElementErrorSourceUnspecified,
            InputPassportElementErrorSourceDataField,
            InputPassportElementErrorSourceFrontSide,
            InputPassportElementErrorSourceReverseSide,
            InputPassportElementErrorSourceSelfie,
            InputPassportElementErrorSourceTranslationFile,
            InputPassportElementErrorSourceTranslationFiles,
            InputPassportElementErrorSourceFile,
            InputPassportElementErrorSourceFiles,
            None,
        ] = source
        r"""Error source"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPassportElementError"]:
        return "inputPassportElementError"

    def getClass(self) -> Literal["InputPassportElementError"]:
        return "InputPassportElementError"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "message": self.message,
            "source": self.source,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPassportElementError", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.message = data.get("message", "")
            data_class.source = data.get("source", None)

        return data_class


class MessageText(TlObject, MessageContent):
    r"""A text message

    Parameters:
        text (:class:`"types.FormattedText"`):
            Text of the message

        link_preview (:class:`"types.LinkPreview"`):
            A link preview attached to the message; may be null

        link_preview_options (:class:`"types.LinkPreviewOptions"`):
            Options which were used for generation of the link preview; may be null if default options were used

    """

    def __init__(
        self,
        text: FormattedText = None,
        link_preview: LinkPreview = None,
        link_preview_options: LinkPreviewOptions = None,
    ) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Text of the message"""
        self.link_preview: Union[LinkPreview, None] = link_preview
        r"""A link preview attached to the message; may be null"""
        self.link_preview_options: Union[LinkPreviewOptions, None] = (
            link_preview_options
        )
        r"""Options which were used for generation of the link preview; may be null if default options were used"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageText"]:
        return "messageText"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "link_preview": self.link_preview,
            "link_preview_options": self.link_preview_options,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageText", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.link_preview = data.get("link_preview", None)
            data_class.link_preview_options = data.get("link_preview_options", None)

        return data_class


class MessageAnimation(TlObject, MessageContent):
    r"""An animation message \(GIF\-style\)\.

    Parameters:
        animation (:class:`"types.Animation"`):
            The animation description

        caption (:class:`"types.FormattedText"`):
            Animation caption

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation

        has_spoiler (:class:`bool`):
            True, if the animation preview must be covered by a spoiler animation

        is_secret (:class:`bool`):
            True, if the animation thumbnail must be blurred and the animation must be shown only while tapped

    """

    def __init__(
        self,
        animation: Animation = None,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
        has_spoiler: bool = False,
        is_secret: bool = False,
    ) -> None:
        self.animation: Union[Animation, None] = animation
        r"""The animation description"""
        self.caption: Union[FormattedText, None] = caption
        r"""Animation caption"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation"""
        self.has_spoiler: bool = bool(has_spoiler)
        r"""True, if the animation preview must be covered by a spoiler animation"""
        self.is_secret: bool = bool(is_secret)
        r"""True, if the animation thumbnail must be blurred and the animation must be shown only while tapped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageAnimation"]:
        return "messageAnimation"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "animation": self.animation,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
            "has_spoiler": self.has_spoiler,
            "is_secret": self.is_secret,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageAnimation", None]:
        if data:
            data_class = cls()
            data_class.animation = data.get("animation", None)
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )
            data_class.has_spoiler = data.get("has_spoiler", False)
            data_class.is_secret = data.get("is_secret", False)

        return data_class


class MessageAudio(TlObject, MessageContent):
    r"""An audio message

    Parameters:
        audio (:class:`"types.Audio"`):
            The audio description

        caption (:class:`"types.FormattedText"`):
            Audio caption

    """

    def __init__(self, audio: Audio = None, caption: FormattedText = None) -> None:
        self.audio: Union[Audio, None] = audio
        r"""The audio description"""
        self.caption: Union[FormattedText, None] = caption
        r"""Audio caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageAudio"]:
        return "messageAudio"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "audio": self.audio, "caption": self.caption}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageAudio", None]:
        if data:
            data_class = cls()
            data_class.audio = data.get("audio", None)
            data_class.caption = data.get("caption", None)

        return data_class


class MessageDocument(TlObject, MessageContent):
    r"""A document message \(general file\)

    Parameters:
        document (:class:`"types.Document"`):
            The document description

        caption (:class:`"types.FormattedText"`):
            Document caption

    """

    def __init__(
        self, document: Document = None, caption: FormattedText = None
    ) -> None:
        self.document: Union[Document, None] = document
        r"""The document description"""
        self.caption: Union[FormattedText, None] = caption
        r"""Document caption"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageDocument"]:
        return "messageDocument"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "document": self.document,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageDocument", None]:
        if data:
            data_class = cls()
            data_class.document = data.get("document", None)
            data_class.caption = data.get("caption", None)

        return data_class


class MessagePaidMedia(TlObject, MessageContent):
    r"""A message with paid media

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars needed to buy access to the media in the message

        media (:class:`List["types.PaidMedia"]`):
            Information about the media

        caption (:class:`"types.FormattedText"`):
            Media caption

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the media; otherwise, the caption must be shown below the media

    """

    def __init__(
        self,
        star_count: int = 0,
        media: List[PaidMedia] = None,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
    ) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars needed to buy access to the media in the message"""
        self.media: List[PaidMedia] = media or []
        r"""Information about the media"""
        self.caption: Union[FormattedText, None] = caption
        r"""Media caption"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the media; otherwise, the caption must be shown below the media"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePaidMedia"]:
        return "messagePaidMedia"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_count": self.star_count,
            "media": self.media,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePaidMedia", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))
            data_class.media = data.get("media", None)
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )

        return data_class


class MessagePhoto(TlObject, MessageContent):
    r"""A photo message

    Parameters:
        photo (:class:`"types.Photo"`):
            The photo

        caption (:class:`"types.FormattedText"`):
            Photo caption

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo

        has_spoiler (:class:`bool`):
            True, if the photo preview must be covered by a spoiler animation

        is_secret (:class:`bool`):
            True, if the photo must be blurred and must be shown only while tapped

    """

    def __init__(
        self,
        photo: Photo = None,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
        has_spoiler: bool = False,
        is_secret: bool = False,
    ) -> None:
        self.photo: Union[Photo, None] = photo
        r"""The photo"""
        self.caption: Union[FormattedText, None] = caption
        r"""Photo caption"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo"""
        self.has_spoiler: bool = bool(has_spoiler)
        r"""True, if the photo preview must be covered by a spoiler animation"""
        self.is_secret: bool = bool(is_secret)
        r"""True, if the photo must be blurred and must be shown only while tapped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePhoto"]:
        return "messagePhoto"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
            "has_spoiler": self.has_spoiler,
            "is_secret": self.is_secret,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )
            data_class.has_spoiler = data.get("has_spoiler", False)
            data_class.is_secret = data.get("is_secret", False)

        return data_class


class MessageSticker(TlObject, MessageContent):
    r"""A sticker message

    Parameters:
        sticker (:class:`"types.Sticker"`):
            The sticker description

        is_premium (:class:`bool`):
            True, if premium animation of the sticker must be played

    """

    def __init__(self, sticker: Sticker = None, is_premium: bool = False) -> None:
        self.sticker: Union[Sticker, None] = sticker
        r"""The sticker description"""
        self.is_premium: bool = bool(is_premium)
        r"""True, if premium animation of the sticker must be played"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSticker"]:
        return "messageSticker"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker": self.sticker,
            "is_premium": self.is_premium,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSticker", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)
            data_class.is_premium = data.get("is_premium", False)

        return data_class


class MessageVideo(TlObject, MessageContent):
    r"""A video message

    Parameters:
        video (:class:`"types.Video"`):
            The video description

        alternative_videos (:class:`List["types.AlternativeVideo"]`):
            Alternative qualities of the video

        cover (:class:`"types.Photo"`):
            Cover of the video; may be null if none

        start_timestamp (:class:`int`):
            Timestamp from which the video playing must start, in seconds

        caption (:class:`"types.FormattedText"`):
            Video caption

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the video; otherwise, the caption must be shown below the video

        has_spoiler (:class:`bool`):
            True, if the video preview must be covered by a spoiler animation

        is_secret (:class:`bool`):
            True, if the video thumbnail must be blurred and the video must be shown only while tapped

    """

    def __init__(
        self,
        video: Video = None,
        alternative_videos: List[AlternativeVideo] = None,
        cover: Photo = None,
        start_timestamp: int = 0,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
        has_spoiler: bool = False,
        is_secret: bool = False,
    ) -> None:
        self.video: Union[Video, None] = video
        r"""The video description"""
        self.alternative_videos: List[AlternativeVideo] = alternative_videos or []
        r"""Alternative qualities of the video"""
        self.cover: Union[Photo, None] = cover
        r"""Cover of the video; may be null if none"""
        self.start_timestamp: int = int(start_timestamp)
        r"""Timestamp from which the video playing must start, in seconds"""
        self.caption: Union[FormattedText, None] = caption
        r"""Video caption"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the video; otherwise, the caption must be shown below the video"""
        self.has_spoiler: bool = bool(has_spoiler)
        r"""True, if the video preview must be covered by a spoiler animation"""
        self.is_secret: bool = bool(is_secret)
        r"""True, if the video thumbnail must be blurred and the video must be shown only while tapped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageVideo"]:
        return "messageVideo"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "alternative_videos": self.alternative_videos,
            "cover": self.cover,
            "start_timestamp": self.start_timestamp,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
            "has_spoiler": self.has_spoiler,
            "is_secret": self.is_secret,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.alternative_videos = data.get("alternative_videos", None)
            data_class.cover = data.get("cover", None)
            data_class.start_timestamp = int(data.get("start_timestamp", 0))
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )
            data_class.has_spoiler = data.get("has_spoiler", False)
            data_class.is_secret = data.get("is_secret", False)

        return data_class


class MessageVideoNote(TlObject, MessageContent):
    r"""A video note message

    Parameters:
        video_note (:class:`"types.VideoNote"`):
            The video note description

        is_viewed (:class:`bool`):
            True, if at least one of the recipients has viewed the video note

        is_secret (:class:`bool`):
            True, if the video note thumbnail must be blurred and the video note must be shown only while tapped

    """

    def __init__(
        self,
        video_note: VideoNote = None,
        is_viewed: bool = False,
        is_secret: bool = False,
    ) -> None:
        self.video_note: Union[VideoNote, None] = video_note
        r"""The video note description"""
        self.is_viewed: bool = bool(is_viewed)
        r"""True, if at least one of the recipients has viewed the video note"""
        self.is_secret: bool = bool(is_secret)
        r"""True, if the video note thumbnail must be blurred and the video note must be shown only while tapped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageVideoNote"]:
        return "messageVideoNote"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video_note": self.video_note,
            "is_viewed": self.is_viewed,
            "is_secret": self.is_secret,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageVideoNote", None]:
        if data:
            data_class = cls()
            data_class.video_note = data.get("video_note", None)
            data_class.is_viewed = data.get("is_viewed", False)
            data_class.is_secret = data.get("is_secret", False)

        return data_class


class MessageVoiceNote(TlObject, MessageContent):
    r"""A voice note message

    Parameters:
        voice_note (:class:`"types.VoiceNote"`):
            The voice note description

        caption (:class:`"types.FormattedText"`):
            Voice note caption

        is_listened (:class:`bool`):
            True, if at least one of the recipients has listened to the voice note

    """

    def __init__(
        self,
        voice_note: VoiceNote = None,
        caption: FormattedText = None,
        is_listened: bool = False,
    ) -> None:
        self.voice_note: Union[VoiceNote, None] = voice_note
        r"""The voice note description"""
        self.caption: Union[FormattedText, None] = caption
        r"""Voice note caption"""
        self.is_listened: bool = bool(is_listened)
        r"""True, if at least one of the recipients has listened to the voice note"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageVoiceNote"]:
        return "messageVoiceNote"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "voice_note": self.voice_note,
            "caption": self.caption,
            "is_listened": self.is_listened,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.voice_note = data.get("voice_note", None)
            data_class.caption = data.get("caption", None)
            data_class.is_listened = data.get("is_listened", False)

        return data_class


class MessageExpiredPhoto(TlObject, MessageContent):
    r"""A self\-destructed photo message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageExpiredPhoto"]:
        return "messageExpiredPhoto"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageExpiredPhoto", None]:
        if data:
            data_class = cls()

        return data_class


class MessageExpiredVideo(TlObject, MessageContent):
    r"""A self\-destructed video message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageExpiredVideo"]:
        return "messageExpiredVideo"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageExpiredVideo", None]:
        if data:
            data_class = cls()

        return data_class


class MessageExpiredVideoNote(TlObject, MessageContent):
    r"""A self\-destructed video note message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageExpiredVideoNote"]:
        return "messageExpiredVideoNote"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageExpiredVideoNote", None]:
        if data:
            data_class = cls()

        return data_class


class MessageExpiredVoiceNote(TlObject, MessageContent):
    r"""A self\-destructed voice note message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageExpiredVoiceNote"]:
        return "messageExpiredVoiceNote"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageExpiredVoiceNote", None]:
        if data:
            data_class = cls()

        return data_class


class MessageLocation(TlObject, MessageContent):
    r"""A message with a location

    Parameters:
        location (:class:`"types.Location"`):
            The location description

        live_period (:class:`int`):
            Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever

        expires_in (:class:`int`):
            Left time for which the location can be updated, in seconds\. If 0, then the location can't be updated anymore\. The update updateMessageContent is not sent when this field changes

        heading (:class:`int`):
            For live locations, a direction in which the location moves, in degrees; 1\-360\. If 0 the direction is unknown

        proximity_alert_radius (:class:`int`):
            For live locations, a maximum distance to another chat member for proximity alerts, in meters \(0\-100000\)\. 0 if the notification is disabled\. Available only to the message sender

    """

    def __init__(
        self,
        location: Location = None,
        live_period: int = 0,
        expires_in: int = 0,
        heading: int = 0,
        proximity_alert_radius: int = 0,
    ) -> None:
        self.location: Union[Location, None] = location
        r"""The location description"""
        self.live_period: int = int(live_period)
        r"""Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever"""
        self.expires_in: int = int(expires_in)
        r"""Left time for which the location can be updated, in seconds\. If 0, then the location can't be updated anymore\. The update updateMessageContent is not sent when this field changes"""
        self.heading: int = int(heading)
        r"""For live locations, a direction in which the location moves, in degrees; 1\-360\. If 0 the direction is unknown"""
        self.proximity_alert_radius: int = int(proximity_alert_radius)
        r"""For live locations, a maximum distance to another chat member for proximity alerts, in meters \(0\-100000\)\. 0 if the notification is disabled\. Available only to the message sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageLocation"]:
        return "messageLocation"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "live_period": self.live_period,
            "expires_in": self.expires_in,
            "heading": self.heading,
            "proximity_alert_radius": self.proximity_alert_radius,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageLocation", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.live_period = int(data.get("live_period", 0))
            data_class.expires_in = int(data.get("expires_in", 0))
            data_class.heading = int(data.get("heading", 0))
            data_class.proximity_alert_radius = int(
                data.get("proximity_alert_radius", 0)
            )

        return data_class


class MessageVenue(TlObject, MessageContent):
    r"""A message with information about a venue

    Parameters:
        venue (:class:`"types.Venue"`):
            The venue description

    """

    def __init__(self, venue: Venue = None) -> None:
        self.venue: Union[Venue, None] = venue
        r"""The venue description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageVenue"]:
        return "messageVenue"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "venue": self.venue}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageVenue", None]:
        if data:
            data_class = cls()
            data_class.venue = data.get("venue", None)

        return data_class


class MessageContact(TlObject, MessageContent):
    r"""A message with a user contact

    Parameters:
        contact (:class:`"types.Contact"`):
            The contact description

    """

    def __init__(self, contact: Contact = None) -> None:
        self.contact: Union[Contact, None] = contact
        r"""The contact description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageContact"]:
        return "messageContact"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "contact": self.contact}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageContact", None]:
        if data:
            data_class = cls()
            data_class.contact = data.get("contact", None)

        return data_class


class MessageAnimatedEmoji(TlObject, MessageContent):
    r"""A message with an animated emoji

    Parameters:
        animated_emoji (:class:`"types.AnimatedEmoji"`):
            The animated emoji

        emoji (:class:`str`):
            The corresponding emoji

    """

    def __init__(self, animated_emoji: AnimatedEmoji = None, emoji: str = "") -> None:
        self.animated_emoji: Union[AnimatedEmoji, None] = animated_emoji
        r"""The animated emoji"""
        self.emoji: Union[str, None] = emoji
        r"""The corresponding emoji"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageAnimatedEmoji"]:
        return "messageAnimatedEmoji"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "animated_emoji": self.animated_emoji,
            "emoji": self.emoji,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageAnimatedEmoji", None]:
        if data:
            data_class = cls()
            data_class.animated_emoji = data.get("animated_emoji", None)
            data_class.emoji = data.get("emoji", "")

        return data_class


class MessageDice(TlObject, MessageContent):
    r"""A dice message\. The dice value is randomly generated by the server

    Parameters:
        initial_state (:class:`"types.DiceStickers"`):
            The animated stickers with the initial dice animation; may be null if unknown\. The update updateMessageContent will be sent when the sticker became known

        final_state (:class:`"types.DiceStickers"`):
            The animated stickers with the final dice animation; may be null if unknown\. The update updateMessageContent will be sent when the sticker became known

        emoji (:class:`str`):
            Emoji on which the dice throw animation is based

        value (:class:`int`):
            The dice value\. If the value is 0, the dice don't have final state yet

        success_animation_frame_number (:class:`int`):
            Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded

    """

    def __init__(
        self,
        initial_state: DiceStickers = None,
        final_state: DiceStickers = None,
        emoji: str = "",
        value: int = 0,
        success_animation_frame_number: int = 0,
    ) -> None:
        self.initial_state: Union[
            DiceStickersRegular, DiceStickersSlotMachine, None
        ] = initial_state
        r"""The animated stickers with the initial dice animation; may be null if unknown\. The update updateMessageContent will be sent when the sticker became known"""
        self.final_state: Union[DiceStickersRegular, DiceStickersSlotMachine, None] = (
            final_state
        )
        r"""The animated stickers with the final dice animation; may be null if unknown\. The update updateMessageContent will be sent when the sticker became known"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji on which the dice throw animation is based"""
        self.value: int = int(value)
        r"""The dice value\. If the value is 0, the dice don't have final state yet"""
        self.success_animation_frame_number: int = int(success_animation_frame_number)
        r"""Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageDice"]:
        return "messageDice"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "initial_state": self.initial_state,
            "final_state": self.final_state,
            "emoji": self.emoji,
            "value": self.value,
            "success_animation_frame_number": self.success_animation_frame_number,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageDice", None]:
        if data:
            data_class = cls()
            data_class.initial_state = data.get("initial_state", None)
            data_class.final_state = data.get("final_state", None)
            data_class.emoji = data.get("emoji", "")
            data_class.value = int(data.get("value", 0))
            data_class.success_animation_frame_number = int(
                data.get("success_animation_frame_number", 0)
            )

        return data_class


class MessageGame(TlObject, MessageContent):
    r"""A message with a game

    Parameters:
        game (:class:`"types.Game"`):
            The game description

    """

    def __init__(self, game: Game = None) -> None:
        self.game: Union[Game, None] = game
        r"""The game description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGame"]:
        return "messageGame"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "game": self.game}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGame", None]:
        if data:
            data_class = cls()
            data_class.game = data.get("game", None)

        return data_class


class MessagePoll(TlObject, MessageContent):
    r"""A message with a poll

    Parameters:
        poll (:class:`"types.Poll"`):
            The poll description

    """

    def __init__(self, poll: Poll = None) -> None:
        self.poll: Union[Poll, None] = poll
        r"""The poll description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePoll"]:
        return "messagePoll"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "poll": self.poll}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePoll", None]:
        if data:
            data_class = cls()
            data_class.poll = data.get("poll", None)

        return data_class


class MessageStory(TlObject, MessageContent):
    r"""A message with a forwarded story

    Parameters:
        story_sender_chat_id (:class:`int`):
            Identifier of the chat that posted the story

        story_id (:class:`int`):
            Story identifier

        via_mention (:class:`bool`):
            True, if the story was automatically forwarded because of a mention of the user

    """

    def __init__(
        self,
        story_sender_chat_id: int = 0,
        story_id: int = 0,
        via_mention: bool = False,
    ) -> None:
        self.story_sender_chat_id: int = int(story_sender_chat_id)
        r"""Identifier of the chat that posted the story"""
        self.story_id: int = int(story_id)
        r"""Story identifier"""
        self.via_mention: bool = bool(via_mention)
        r"""True, if the story was automatically forwarded because of a mention of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageStory"]:
        return "messageStory"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_sender_chat_id": self.story_sender_chat_id,
            "story_id": self.story_id,
            "via_mention": self.via_mention,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageStory", None]:
        if data:
            data_class = cls()
            data_class.story_sender_chat_id = int(data.get("story_sender_chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))
            data_class.via_mention = data.get("via_mention", False)

        return data_class


class MessageInvoice(TlObject, MessageContent):
    r"""A message with an invoice from a bot\. Use getInternalLink with internalLinkTypeBotStart to share the invoice

    Parameters:
        product_info (:class:`"types.ProductInfo"`):
            Information about the product

        currency (:class:`str`):
            Currency for the product price

        total_amount (:class:`int`):
            Product total price in the smallest units of the currency

        start_parameter (:class:`str`):
            Unique invoice bot start\_parameter to be passed to getInternalLink

        is_test (:class:`bool`):
            True, if the invoice is a test invoice

        need_shipping_address (:class:`bool`):
            True, if the shipping address must be specified

        receipt_message_id (:class:`int`):
            The identifier of the message with the receipt, after the product has been purchased

        paid_media (:class:`"types.PaidMedia"`):
            Extended media attached to the invoice; may be null if none

        paid_media_caption (:class:`"types.FormattedText"`):
            Extended media caption; may be null if none

    """

    def __init__(
        self,
        product_info: ProductInfo = None,
        currency: str = "",
        total_amount: int = 0,
        start_parameter: str = "",
        is_test: bool = False,
        need_shipping_address: bool = False,
        receipt_message_id: int = 0,
        paid_media: PaidMedia = None,
        paid_media_caption: FormattedText = None,
    ) -> None:
        self.product_info: Union[ProductInfo, None] = product_info
        r"""Information about the product"""
        self.currency: Union[str, None] = currency
        r"""Currency for the product price"""
        self.total_amount: int = int(total_amount)
        r"""Product total price in the smallest units of the currency"""
        self.start_parameter: Union[str, None] = start_parameter
        r"""Unique invoice bot start\_parameter to be passed to getInternalLink"""
        self.is_test: bool = bool(is_test)
        r"""True, if the invoice is a test invoice"""
        self.need_shipping_address: bool = bool(need_shipping_address)
        r"""True, if the shipping address must be specified"""
        self.receipt_message_id: int = int(receipt_message_id)
        r"""The identifier of the message with the receipt, after the product has been purchased"""
        self.paid_media: Union[
            PaidMediaPreview, PaidMediaPhoto, PaidMediaVideo, PaidMediaUnsupported, None
        ] = paid_media
        r"""Extended media attached to the invoice; may be null if none"""
        self.paid_media_caption: Union[FormattedText, None] = paid_media_caption
        r"""Extended media caption; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageInvoice"]:
        return "messageInvoice"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "product_info": self.product_info,
            "currency": self.currency,
            "total_amount": self.total_amount,
            "start_parameter": self.start_parameter,
            "is_test": self.is_test,
            "need_shipping_address": self.need_shipping_address,
            "receipt_message_id": self.receipt_message_id,
            "paid_media": self.paid_media,
            "paid_media_caption": self.paid_media_caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageInvoice", None]:
        if data:
            data_class = cls()
            data_class.product_info = data.get("product_info", None)
            data_class.currency = data.get("currency", "")
            data_class.total_amount = int(data.get("total_amount", 0))
            data_class.start_parameter = data.get("start_parameter", "")
            data_class.is_test = data.get("is_test", False)
            data_class.need_shipping_address = data.get("need_shipping_address", False)
            data_class.receipt_message_id = int(data.get("receipt_message_id", 0))
            data_class.paid_media = data.get("paid_media", None)
            data_class.paid_media_caption = data.get("paid_media_caption", None)

        return data_class


class MessageCall(TlObject, MessageContent):
    r"""A message with information about an ended call

    Parameters:
        is_video (:class:`bool`):
            True, if the call was a video call

        discard_reason (:class:`"types.CallDiscardReason"`):
            Reason why the call was discarded

        duration (:class:`int`):
            Call duration, in seconds

    """

    def __init__(
        self,
        is_video: bool = False,
        discard_reason: CallDiscardReason = None,
        duration: int = 0,
    ) -> None:
        self.is_video: bool = bool(is_video)
        r"""True, if the call was a video call"""
        self.discard_reason: Union[
            CallDiscardReasonEmpty,
            CallDiscardReasonMissed,
            CallDiscardReasonDeclined,
            CallDiscardReasonDisconnected,
            CallDiscardReasonHungUp,
            CallDiscardReasonAllowGroupCall,
            None,
        ] = discard_reason
        r"""Reason why the call was discarded"""
        self.duration: int = int(duration)
        r"""Call duration, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageCall"]:
        return "messageCall"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_video": self.is_video,
            "discard_reason": self.discard_reason,
            "duration": self.duration,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageCall", None]:
        if data:
            data_class = cls()
            data_class.is_video = data.get("is_video", False)
            data_class.discard_reason = data.get("discard_reason", None)
            data_class.duration = int(data.get("duration", 0))

        return data_class


class MessageVideoChatScheduled(TlObject, MessageContent):
    r"""A new video chat was scheduled

    Parameters:
        group_call_id (:class:`int`):
            Identifier of the video chat\. The video chat can be received through the method getGroupCall

        start_date (:class:`int`):
            Point in time \(Unix timestamp\) when the group call is expected to be started by an administrator

    """

    def __init__(self, group_call_id: int = 0, start_date: int = 0) -> None:
        self.group_call_id: int = int(group_call_id)
        r"""Identifier of the video chat\. The video chat can be received through the method getGroupCall"""
        self.start_date: int = int(start_date)
        r"""Point in time \(Unix timestamp\) when the group call is expected to be started by an administrator"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageVideoChatScheduled"]:
        return "messageVideoChatScheduled"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "group_call_id": self.group_call_id,
            "start_date": self.start_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageVideoChatScheduled", None]:
        if data:
            data_class = cls()
            data_class.group_call_id = int(data.get("group_call_id", 0))
            data_class.start_date = int(data.get("start_date", 0))

        return data_class


class MessageVideoChatStarted(TlObject, MessageContent):
    r"""A newly created video chat

    Parameters:
        group_call_id (:class:`int`):
            Identifier of the video chat\. The video chat can be received through the method getGroupCall

    """

    def __init__(self, group_call_id: int = 0) -> None:
        self.group_call_id: int = int(group_call_id)
        r"""Identifier of the video chat\. The video chat can be received through the method getGroupCall"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageVideoChatStarted"]:
        return "messageVideoChatStarted"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "group_call_id": self.group_call_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageVideoChatStarted", None]:
        if data:
            data_class = cls()
            data_class.group_call_id = int(data.get("group_call_id", 0))

        return data_class


class MessageVideoChatEnded(TlObject, MessageContent):
    r"""A message with information about an ended video chat

    Parameters:
        duration (:class:`int`):
            Call duration, in seconds

    """

    def __init__(self, duration: int = 0) -> None:
        self.duration: int = int(duration)
        r"""Call duration, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageVideoChatEnded"]:
        return "messageVideoChatEnded"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "duration": self.duration}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageVideoChatEnded", None]:
        if data:
            data_class = cls()
            data_class.duration = int(data.get("duration", 0))

        return data_class


class MessageInviteVideoChatParticipants(TlObject, MessageContent):
    r"""A message with information about an invitation to a video chat

    Parameters:
        group_call_id (:class:`int`):
            Identifier of the video chat\. The video chat can be received through the method getGroupCall

        user_ids (:class:`List[int]`):
            Invited user identifiers

    """

    def __init__(self, group_call_id: int = 0, user_ids: List[int] = None) -> None:
        self.group_call_id: int = int(group_call_id)
        r"""Identifier of the video chat\. The video chat can be received through the method getGroupCall"""
        self.user_ids: List[int] = user_ids or []
        r"""Invited user identifiers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageInviteVideoChatParticipants"]:
        return "messageInviteVideoChatParticipants"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "group_call_id": self.group_call_id,
            "user_ids": self.user_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageInviteVideoChatParticipants", None]:
        if data:
            data_class = cls()
            data_class.group_call_id = int(data.get("group_call_id", 0))
            data_class.user_ids = data.get("user_ids", None)

        return data_class


class MessageBasicGroupChatCreate(TlObject, MessageContent):
    r"""A newly created basic group

    Parameters:
        title (:class:`str`):
            Title of the basic group

        member_user_ids (:class:`List[int]`):
            User identifiers of members in the basic group

    """

    def __init__(self, title: str = "", member_user_ids: List[int] = None) -> None:
        self.title: Union[str, None] = title
        r"""Title of the basic group"""
        self.member_user_ids: List[int] = member_user_ids or []
        r"""User identifiers of members in the basic group"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageBasicGroupChatCreate"]:
        return "messageBasicGroupChatCreate"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "member_user_ids": self.member_user_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageBasicGroupChatCreate", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.member_user_ids = data.get("member_user_ids", None)

        return data_class


class MessageSupergroupChatCreate(TlObject, MessageContent):
    r"""A newly created supergroup or channel

    Parameters:
        title (:class:`str`):
            Title of the supergroup or channel

    """

    def __init__(self, title: str = "") -> None:
        self.title: Union[str, None] = title
        r"""Title of the supergroup or channel"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSupergroupChatCreate"]:
        return "messageSupergroupChatCreate"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSupergroupChatCreate", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")

        return data_class


class MessageChatChangeTitle(TlObject, MessageContent):
    r"""An updated chat title

    Parameters:
        title (:class:`str`):
            New chat title

    """

    def __init__(self, title: str = "") -> None:
        self.title: Union[str, None] = title
        r"""New chat title"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatChangeTitle"]:
        return "messageChatChangeTitle"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatChangeTitle", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")

        return data_class


class MessageChatChangePhoto(TlObject, MessageContent):
    r"""An updated chat photo

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            New chat photo

    """

    def __init__(self, photo: ChatPhoto = None) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""New chat photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatChangePhoto"]:
        return "messageChatChangePhoto"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatChangePhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class MessageChatDeletePhoto(TlObject, MessageContent):
    r"""A deleted chat photo"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatDeletePhoto"]:
        return "messageChatDeletePhoto"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatDeletePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class MessageChatAddMembers(TlObject, MessageContent):
    r"""New chat members were added

    Parameters:
        member_user_ids (:class:`List[int]`):
            User identifiers of the new members

    """

    def __init__(self, member_user_ids: List[int] = None) -> None:
        self.member_user_ids: List[int] = member_user_ids or []
        r"""User identifiers of the new members"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatAddMembers"]:
        return "messageChatAddMembers"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "member_user_ids": self.member_user_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatAddMembers", None]:
        if data:
            data_class = cls()
            data_class.member_user_ids = data.get("member_user_ids", None)

        return data_class


class MessageChatJoinByLink(TlObject, MessageContent):
    r"""A new member joined the chat via an invite link"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatJoinByLink"]:
        return "messageChatJoinByLink"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatJoinByLink", None]:
        if data:
            data_class = cls()

        return data_class


class MessageChatJoinByRequest(TlObject, MessageContent):
    r"""A new member was accepted to the chat by an administrator"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatJoinByRequest"]:
        return "messageChatJoinByRequest"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatJoinByRequest", None]:
        if data:
            data_class = cls()

        return data_class


class MessageChatDeleteMember(TlObject, MessageContent):
    r"""A chat member was deleted

    Parameters:
        user_id (:class:`int`):
            User identifier of the deleted chat member

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier of the deleted chat member"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatDeleteMember"]:
        return "messageChatDeleteMember"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatDeleteMember", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class MessageChatUpgradeTo(TlObject, MessageContent):
    r"""A basic group was upgraded to a supergroup and was deactivated as the result

    Parameters:
        supergroup_id (:class:`int`):
            Identifier of the supergroup to which the basic group was upgraded

    """

    def __init__(self, supergroup_id: int = 0) -> None:
        self.supergroup_id: int = int(supergroup_id)
        r"""Identifier of the supergroup to which the basic group was upgraded"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatUpgradeTo"]:
        return "messageChatUpgradeTo"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "supergroup_id": self.supergroup_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatUpgradeTo", None]:
        if data:
            data_class = cls()
            data_class.supergroup_id = int(data.get("supergroup_id", 0))

        return data_class


class MessageChatUpgradeFrom(TlObject, MessageContent):
    r"""A supergroup has been created from a basic group

    Parameters:
        title (:class:`str`):
            Title of the newly created supergroup

        basic_group_id (:class:`int`):
            The identifier of the original basic group

    """

    def __init__(self, title: str = "", basic_group_id: int = 0) -> None:
        self.title: Union[str, None] = title
        r"""Title of the newly created supergroup"""
        self.basic_group_id: int = int(basic_group_id)
        r"""The identifier of the original basic group"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatUpgradeFrom"]:
        return "messageChatUpgradeFrom"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "basic_group_id": self.basic_group_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatUpgradeFrom", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.basic_group_id = int(data.get("basic_group_id", 0))

        return data_class


class MessagePinMessage(TlObject, MessageContent):
    r"""A message has been pinned

    Parameters:
        message_id (:class:`int`):
            Identifier of the pinned message, can be an identifier of a deleted message or 0

    """

    def __init__(self, message_id: int = 0) -> None:
        self.message_id: int = int(message_id)
        r"""Identifier of the pinned message, can be an identifier of a deleted message or 0"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePinMessage"]:
        return "messagePinMessage"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message_id": self.message_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePinMessage", None]:
        if data:
            data_class = cls()
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class MessageScreenshotTaken(TlObject, MessageContent):
    r"""A screenshot of a message in the chat has been taken"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageScreenshotTaken"]:
        return "messageScreenshotTaken"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageScreenshotTaken", None]:
        if data:
            data_class = cls()

        return data_class


class MessageChatSetBackground(TlObject, MessageContent):
    r"""A new background was set in the chat

    Parameters:
        old_background_message_id (:class:`int`):
            Identifier of the message with a previously set same background; 0 if none\. Can be an identifier of a deleted message

        background (:class:`"types.ChatBackground"`):
            The new background

        only_for_self (:class:`bool`):
            True, if the background was set only for self

    """

    def __init__(
        self,
        old_background_message_id: int = 0,
        background: ChatBackground = None,
        only_for_self: bool = False,
    ) -> None:
        self.old_background_message_id: int = int(old_background_message_id)
        r"""Identifier of the message with a previously set same background; 0 if none\. Can be an identifier of a deleted message"""
        self.background: Union[ChatBackground, None] = background
        r"""The new background"""
        self.only_for_self: bool = bool(only_for_self)
        r"""True, if the background was set only for self"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatSetBackground"]:
        return "messageChatSetBackground"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_background_message_id": self.old_background_message_id,
            "background": self.background,
            "only_for_self": self.only_for_self,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatSetBackground", None]:
        if data:
            data_class = cls()
            data_class.old_background_message_id = int(
                data.get("old_background_message_id", 0)
            )
            data_class.background = data.get("background", None)
            data_class.only_for_self = data.get("only_for_self", False)

        return data_class


class MessageChatSetTheme(TlObject, MessageContent):
    r"""A theme in the chat has been changed

    Parameters:
        theme_name (:class:`str`):
            If non\-empty, name of a new theme, set for the chat\. Otherwise, chat theme was reset to the default one

    """

    def __init__(self, theme_name: str = "") -> None:
        self.theme_name: Union[str, None] = theme_name
        r"""If non\-empty, name of a new theme, set for the chat\. Otherwise, chat theme was reset to the default one"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatSetTheme"]:
        return "messageChatSetTheme"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "theme_name": self.theme_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatSetTheme", None]:
        if data:
            data_class = cls()
            data_class.theme_name = data.get("theme_name", "")

        return data_class


class MessageChatSetMessageAutoDeleteTime(TlObject, MessageContent):
    r"""The auto\-delete or self\-destruct timer for messages in the chat has been changed

    Parameters:
        message_auto_delete_time (:class:`int`):
            New value auto\-delete or self\-destruct time, in seconds; 0 if disabled

        from_user_id (:class:`int`):
            If not 0, a user identifier, which default setting was automatically applied

    """

    def __init__(
        self, message_auto_delete_time: int = 0, from_user_id: int = 0
    ) -> None:
        self.message_auto_delete_time: int = int(message_auto_delete_time)
        r"""New value auto\-delete or self\-destruct time, in seconds; 0 if disabled"""
        self.from_user_id: int = int(from_user_id)
        r"""If not 0, a user identifier, which default setting was automatically applied"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatSetMessageAutoDeleteTime"]:
        return "messageChatSetMessageAutoDeleteTime"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_auto_delete_time": self.message_auto_delete_time,
            "from_user_id": self.from_user_id,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["MessageChatSetMessageAutoDeleteTime", None]:
        if data:
            data_class = cls()
            data_class.message_auto_delete_time = int(
                data.get("message_auto_delete_time", 0)
            )
            data_class.from_user_id = int(data.get("from_user_id", 0))

        return data_class


class MessageChatBoost(TlObject, MessageContent):
    r"""The chat was boosted by the sender of the message

    Parameters:
        boost_count (:class:`int`):
            Number of times the chat was boosted

    """

    def __init__(self, boost_count: int = 0) -> None:
        self.boost_count: int = int(boost_count)
        r"""Number of times the chat was boosted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatBoost"]:
        return "messageChatBoost"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "boost_count": self.boost_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatBoost", None]:
        if data:
            data_class = cls()
            data_class.boost_count = int(data.get("boost_count", 0))

        return data_class


class MessageForumTopicCreated(TlObject, MessageContent):
    r"""A forum topic has been created

    Parameters:
        name (:class:`str`):
            Name of the topic

        icon (:class:`"types.ForumTopicIcon"`):
            Icon of the topic

    """

    def __init__(self, name: str = "", icon: ForumTopicIcon = None) -> None:
        self.name: Union[str, None] = name
        r"""Name of the topic"""
        self.icon: Union[ForumTopicIcon, None] = icon
        r"""Icon of the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageForumTopicCreated"]:
        return "messageForumTopicCreated"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name, "icon": self.icon}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageForumTopicCreated", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.icon = data.get("icon", None)

        return data_class


class MessageForumTopicEdited(TlObject, MessageContent):
    r"""A forum topic has been edited

    Parameters:
        name (:class:`str`):
            If non\-empty, the new name of the topic

        edit_icon_custom_emoji_id (:class:`bool`):
            True, if icon's custom\_emoji\_id is changed

        icon_custom_emoji_id (:class:`int`):
            New unique identifier of the custom emoji shown on the topic icon; 0 if none\. Must be ignored if edit\_icon\_custom\_emoji\_id is false

    """

    def __init__(
        self,
        name: str = "",
        edit_icon_custom_emoji_id: bool = False,
        icon_custom_emoji_id: int = 0,
    ) -> None:
        self.name: Union[str, None] = name
        r"""If non\-empty, the new name of the topic"""
        self.edit_icon_custom_emoji_id: bool = bool(edit_icon_custom_emoji_id)
        r"""True, if icon's custom\_emoji\_id is changed"""
        self.icon_custom_emoji_id: int = int(icon_custom_emoji_id)
        r"""New unique identifier of the custom emoji shown on the topic icon; 0 if none\. Must be ignored if edit\_icon\_custom\_emoji\_id is false"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageForumTopicEdited"]:
        return "messageForumTopicEdited"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "edit_icon_custom_emoji_id": self.edit_icon_custom_emoji_id,
            "icon_custom_emoji_id": self.icon_custom_emoji_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageForumTopicEdited", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.edit_icon_custom_emoji_id = data.get(
                "edit_icon_custom_emoji_id", False
            )
            data_class.icon_custom_emoji_id = int(data.get("icon_custom_emoji_id", 0))

        return data_class


class MessageForumTopicIsClosedToggled(TlObject, MessageContent):
    r"""A forum topic has been closed or opened

    Parameters:
        is_closed (:class:`bool`):
            True, if the topic was closed; otherwise, the topic was reopened

    """

    def __init__(self, is_closed: bool = False) -> None:
        self.is_closed: bool = bool(is_closed)
        r"""True, if the topic was closed; otherwise, the topic was reopened"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageForumTopicIsClosedToggled"]:
        return "messageForumTopicIsClosedToggled"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_closed": self.is_closed}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageForumTopicIsClosedToggled", None]:
        if data:
            data_class = cls()
            data_class.is_closed = data.get("is_closed", False)

        return data_class


class MessageForumTopicIsHiddenToggled(TlObject, MessageContent):
    r"""A General forum topic has been hidden or unhidden

    Parameters:
        is_hidden (:class:`bool`):
            True, if the topic was hidden; otherwise, the topic was unhidden

    """

    def __init__(self, is_hidden: bool = False) -> None:
        self.is_hidden: bool = bool(is_hidden)
        r"""True, if the topic was hidden; otherwise, the topic was unhidden"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageForumTopicIsHiddenToggled"]:
        return "messageForumTopicIsHiddenToggled"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_hidden": self.is_hidden}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageForumTopicIsHiddenToggled", None]:
        if data:
            data_class = cls()
            data_class.is_hidden = data.get("is_hidden", False)

        return data_class


class MessageSuggestProfilePhoto(TlObject, MessageContent):
    r"""A profile photo was suggested to a user in a private chat

    Parameters:
        photo (:class:`"types.ChatPhoto"`):
            The suggested chat photo\. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo

    """

    def __init__(self, photo: ChatPhoto = None) -> None:
        self.photo: Union[ChatPhoto, None] = photo
        r"""The suggested chat photo\. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSuggestProfilePhoto"]:
        return "messageSuggestProfilePhoto"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSuggestProfilePhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class MessageCustomServiceAction(TlObject, MessageContent):
    r"""A non\-standard action has happened in the chat

    Parameters:
        text (:class:`str`):
            Message text to be shown in the chat

    """

    def __init__(self, text: str = "") -> None:
        self.text: Union[str, None] = text
        r"""Message text to be shown in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageCustomServiceAction"]:
        return "messageCustomServiceAction"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageCustomServiceAction", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")

        return data_class


class MessageGameScore(TlObject, MessageContent):
    r"""A new high score was achieved in a game

    Parameters:
        game_message_id (:class:`int`):
            Identifier of the message with the game, can be an identifier of a deleted message

        game_id (:class:`int`):
            Identifier of the game; may be different from the games presented in the message with the game

        score (:class:`int`):
            New score

    """

    def __init__(
        self, game_message_id: int = 0, game_id: int = 0, score: int = 0
    ) -> None:
        self.game_message_id: int = int(game_message_id)
        r"""Identifier of the message with the game, can be an identifier of a deleted message"""
        self.game_id: int = int(game_id)
        r"""Identifier of the game; may be different from the games presented in the message with the game"""
        self.score: int = int(score)
        r"""New score"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGameScore"]:
        return "messageGameScore"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "game_message_id": self.game_message_id,
            "game_id": self.game_id,
            "score": self.score,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGameScore", None]:
        if data:
            data_class = cls()
            data_class.game_message_id = int(data.get("game_message_id", 0))
            data_class.game_id = int(data.get("game_id", 0))
            data_class.score = int(data.get("score", 0))

        return data_class


class MessagePaymentSuccessful(TlObject, MessageContent):
    r"""A payment has been sent to a bot or a business account

    Parameters:
        invoice_chat_id (:class:`int`):
            Identifier of the chat, containing the corresponding invoice message

        invoice_message_id (:class:`int`):
            Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message

        currency (:class:`str`):
            Currency for the price of the product

        total_amount (:class:`int`):
            Total price for the product, in the smallest units of the currency

        subscription_until_date (:class:`int`):
            Point in time \(Unix timestamp\) when the subscription will expire; 0 if unknown or the payment isn't recurring

        is_recurring (:class:`bool`):
            True, if this is a recurring payment

        is_first_recurring (:class:`bool`):
            True, if this is the first recurring payment

        invoice_name (:class:`str`):
            Name of the invoice; may be empty if unknown

    """

    def __init__(
        self,
        invoice_chat_id: int = 0,
        invoice_message_id: int = 0,
        currency: str = "",
        total_amount: int = 0,
        subscription_until_date: int = 0,
        is_recurring: bool = False,
        is_first_recurring: bool = False,
        invoice_name: str = "",
    ) -> None:
        self.invoice_chat_id: int = int(invoice_chat_id)
        r"""Identifier of the chat, containing the corresponding invoice message"""
        self.invoice_message_id: int = int(invoice_message_id)
        r"""Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message"""
        self.currency: Union[str, None] = currency
        r"""Currency for the price of the product"""
        self.total_amount: int = int(total_amount)
        r"""Total price for the product, in the smallest units of the currency"""
        self.subscription_until_date: int = int(subscription_until_date)
        r"""Point in time \(Unix timestamp\) when the subscription will expire; 0 if unknown or the payment isn't recurring"""
        self.is_recurring: bool = bool(is_recurring)
        r"""True, if this is a recurring payment"""
        self.is_first_recurring: bool = bool(is_first_recurring)
        r"""True, if this is the first recurring payment"""
        self.invoice_name: Union[str, None] = invoice_name
        r"""Name of the invoice; may be empty if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePaymentSuccessful"]:
        return "messagePaymentSuccessful"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "invoice_chat_id": self.invoice_chat_id,
            "invoice_message_id": self.invoice_message_id,
            "currency": self.currency,
            "total_amount": self.total_amount,
            "subscription_until_date": self.subscription_until_date,
            "is_recurring": self.is_recurring,
            "is_first_recurring": self.is_first_recurring,
            "invoice_name": self.invoice_name,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePaymentSuccessful", None]:
        if data:
            data_class = cls()
            data_class.invoice_chat_id = int(data.get("invoice_chat_id", 0))
            data_class.invoice_message_id = int(data.get("invoice_message_id", 0))
            data_class.currency = data.get("currency", "")
            data_class.total_amount = int(data.get("total_amount", 0))
            data_class.subscription_until_date = int(
                data.get("subscription_until_date", 0)
            )
            data_class.is_recurring = data.get("is_recurring", False)
            data_class.is_first_recurring = data.get("is_first_recurring", False)
            data_class.invoice_name = data.get("invoice_name", "")

        return data_class


class MessagePaymentSuccessfulBot(TlObject, MessageContent):
    r"""A payment has been received by the bot or the business account

    Parameters:
        currency (:class:`str`):
            Currency for price of the product

        total_amount (:class:`int`):
            Total price for the product, in the smallest units of the currency

        subscription_until_date (:class:`int`):
            Point in time \(Unix timestamp\) when the subscription will expire; 0 if unknown or the payment isn't recurring

        is_recurring (:class:`bool`):
            True, if this is a recurring payment

        is_first_recurring (:class:`bool`):
            True, if this is the first recurring payment

        invoice_payload (:class:`bytes`):
            Invoice payload

        shipping_option_id (:class:`str`):
            Identifier of the shipping option chosen by the user; may be empty if not applicable; for bots only

        order_info (:class:`"types.OrderInfo"`):
            Information about the order; may be null; for bots only

        telegram_payment_charge_id (:class:`str`):
            Telegram payment identifier

        provider_payment_charge_id (:class:`str`):
            Provider payment identifier

    """

    def __init__(
        self,
        currency: str = "",
        total_amount: int = 0,
        subscription_until_date: int = 0,
        is_recurring: bool = False,
        is_first_recurring: bool = False,
        invoice_payload: bytes = b"",
        shipping_option_id: str = "",
        order_info: OrderInfo = None,
        telegram_payment_charge_id: str = "",
        provider_payment_charge_id: str = "",
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""Currency for price of the product"""
        self.total_amount: int = int(total_amount)
        r"""Total price for the product, in the smallest units of the currency"""
        self.subscription_until_date: int = int(subscription_until_date)
        r"""Point in time \(Unix timestamp\) when the subscription will expire; 0 if unknown or the payment isn't recurring"""
        self.is_recurring: bool = bool(is_recurring)
        r"""True, if this is a recurring payment"""
        self.is_first_recurring: bool = bool(is_first_recurring)
        r"""True, if this is the first recurring payment"""
        self.invoice_payload: Union[bytes, None] = invoice_payload
        r"""Invoice payload"""
        self.shipping_option_id: Union[str, None] = shipping_option_id
        r"""Identifier of the shipping option chosen by the user; may be empty if not applicable; for bots only"""
        self.order_info: Union[OrderInfo, None] = order_info
        r"""Information about the order; may be null; for bots only"""
        self.telegram_payment_charge_id: Union[str, None] = telegram_payment_charge_id
        r"""Telegram payment identifier"""
        self.provider_payment_charge_id: Union[str, None] = provider_payment_charge_id
        r"""Provider payment identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePaymentSuccessfulBot"]:
        return "messagePaymentSuccessfulBot"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "total_amount": self.total_amount,
            "subscription_until_date": self.subscription_until_date,
            "is_recurring": self.is_recurring,
            "is_first_recurring": self.is_first_recurring,
            "invoice_payload": self.invoice_payload,
            "shipping_option_id": self.shipping_option_id,
            "order_info": self.order_info,
            "telegram_payment_charge_id": self.telegram_payment_charge_id,
            "provider_payment_charge_id": self.provider_payment_charge_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePaymentSuccessfulBot", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.total_amount = int(data.get("total_amount", 0))
            data_class.subscription_until_date = int(
                data.get("subscription_until_date", 0)
            )
            data_class.is_recurring = data.get("is_recurring", False)
            data_class.is_first_recurring = data.get("is_first_recurring", False)
            data_class.invoice_payload = b64decode(data.get("invoice_payload", b""))
            data_class.shipping_option_id = data.get("shipping_option_id", "")
            data_class.order_info = data.get("order_info", None)
            data_class.telegram_payment_charge_id = data.get(
                "telegram_payment_charge_id", ""
            )
            data_class.provider_payment_charge_id = data.get(
                "provider_payment_charge_id", ""
            )

        return data_class


class MessagePaymentRefunded(TlObject, MessageContent):
    r"""A payment has been refunded

    Parameters:
        owner_id (:class:`"types.MessageSender"`):
            Identifier of the previous owner of the Telegram Stars that refunds them

        currency (:class:`str`):
            Currency for the price of the product

        total_amount (:class:`int`):
            Total price for the product, in the smallest units of the currency

        invoice_payload (:class:`bytes`):
            Invoice payload; only for bots

        telegram_payment_charge_id (:class:`str`):
            Telegram payment identifier

        provider_payment_charge_id (:class:`str`):
            Provider payment identifier

    """

    def __init__(
        self,
        owner_id: MessageSender = None,
        currency: str = "",
        total_amount: int = 0,
        invoice_payload: bytes = b"",
        telegram_payment_charge_id: str = "",
        provider_payment_charge_id: str = "",
    ) -> None:
        self.owner_id: Union[MessageSenderUser, MessageSenderChat, None] = owner_id
        r"""Identifier of the previous owner of the Telegram Stars that refunds them"""
        self.currency: Union[str, None] = currency
        r"""Currency for the price of the product"""
        self.total_amount: int = int(total_amount)
        r"""Total price for the product, in the smallest units of the currency"""
        self.invoice_payload: Union[bytes, None] = invoice_payload
        r"""Invoice payload; only for bots"""
        self.telegram_payment_charge_id: Union[str, None] = telegram_payment_charge_id
        r"""Telegram payment identifier"""
        self.provider_payment_charge_id: Union[str, None] = provider_payment_charge_id
        r"""Provider payment identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePaymentRefunded"]:
        return "messagePaymentRefunded"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "owner_id": self.owner_id,
            "currency": self.currency,
            "total_amount": self.total_amount,
            "invoice_payload": self.invoice_payload,
            "telegram_payment_charge_id": self.telegram_payment_charge_id,
            "provider_payment_charge_id": self.provider_payment_charge_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePaymentRefunded", None]:
        if data:
            data_class = cls()
            data_class.owner_id = data.get("owner_id", None)
            data_class.currency = data.get("currency", "")
            data_class.total_amount = int(data.get("total_amount", 0))
            data_class.invoice_payload = b64decode(data.get("invoice_payload", b""))
            data_class.telegram_payment_charge_id = data.get(
                "telegram_payment_charge_id", ""
            )
            data_class.provider_payment_charge_id = data.get(
                "provider_payment_charge_id", ""
            )

        return data_class


class MessageGiftedPremium(TlObject, MessageContent):
    r"""Telegram Premium was gifted to a user

    Parameters:
        gifter_user_id (:class:`int`):
            The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing

        receiver_user_id (:class:`int`):
            The identifier of a user that received Telegram Premium; 0 if the gift is incoming

        text (:class:`"types.FormattedText"`):
            Message added to the gifted Telegram Premium by the sender

        currency (:class:`str`):
            Currency for the paid amount

        amount (:class:`int`):
            The paid amount, in the smallest units of the currency

        cryptocurrency (:class:`str`):
            Cryptocurrency used to pay for the gift; may be empty if none

        cryptocurrency_amount (:class:`int`):
            The paid amount, in the smallest units of the cryptocurrency; 0 if none

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active

        sticker (:class:`"types.Sticker"`):
            A sticker to be shown in the message; may be null if unknown

    """

    def __init__(
        self,
        gifter_user_id: int = 0,
        receiver_user_id: int = 0,
        text: FormattedText = None,
        currency: str = "",
        amount: int = 0,
        cryptocurrency: str = "",
        cryptocurrency_amount: int = 0,
        month_count: int = 0,
        sticker: Sticker = None,
    ) -> None:
        self.gifter_user_id: int = int(gifter_user_id)
        r"""The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing"""
        self.receiver_user_id: int = int(receiver_user_id)
        r"""The identifier of a user that received Telegram Premium; 0 if the gift is incoming"""
        self.text: Union[FormattedText, None] = text
        r"""Message added to the gifted Telegram Premium by the sender"""
        self.currency: Union[str, None] = currency
        r"""Currency for the paid amount"""
        self.amount: int = int(amount)
        r"""The paid amount, in the smallest units of the currency"""
        self.cryptocurrency: Union[str, None] = cryptocurrency
        r"""Cryptocurrency used to pay for the gift; may be empty if none"""
        self.cryptocurrency_amount: int = int(cryptocurrency_amount)
        r"""The paid amount, in the smallest units of the cryptocurrency; 0 if none"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active"""
        self.sticker: Union[Sticker, None] = sticker
        r"""A sticker to be shown in the message; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGiftedPremium"]:
        return "messageGiftedPremium"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "gifter_user_id": self.gifter_user_id,
            "receiver_user_id": self.receiver_user_id,
            "text": self.text,
            "currency": self.currency,
            "amount": self.amount,
            "cryptocurrency": self.cryptocurrency,
            "cryptocurrency_amount": self.cryptocurrency_amount,
            "month_count": self.month_count,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGiftedPremium", None]:
        if data:
            data_class = cls()
            data_class.gifter_user_id = int(data.get("gifter_user_id", 0))
            data_class.receiver_user_id = int(data.get("receiver_user_id", 0))
            data_class.text = data.get("text", None)
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.cryptocurrency = data.get("cryptocurrency", "")
            data_class.cryptocurrency_amount = int(data.get("cryptocurrency_amount", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.sticker = data.get("sticker", None)

        return data_class


class MessagePremiumGiftCode(TlObject, MessageContent):
    r"""A Telegram Premium gift code was created for the user

    Parameters:
        creator_id (:class:`"types.MessageSender"`):
            Identifier of a chat or a user that created the gift code; may be null if unknown

        text (:class:`"types.FormattedText"`):
            Message added to the gift

        is_from_giveaway (:class:`bool`):
            True, if the gift code was created for a giveaway

        is_unclaimed (:class:`bool`):
            True, if the winner for the corresponding Telegram Premium subscription wasn't chosen

        currency (:class:`str`):
            Currency for the paid amount; empty if unknown

        amount (:class:`int`):
            The paid amount, in the smallest units of the currency; 0 if unknown

        cryptocurrency (:class:`str`):
            Cryptocurrency used to pay for the gift; may be empty if none or unknown

        cryptocurrency_amount (:class:`int`):
            The paid amount, in the smallest units of the cryptocurrency; 0 if unknown

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active after code activation

        sticker (:class:`"types.Sticker"`):
            A sticker to be shown in the message; may be null if unknown

        code (:class:`str`):
            The gift code

    """

    def __init__(
        self,
        creator_id: MessageSender = None,
        text: FormattedText = None,
        is_from_giveaway: bool = False,
        is_unclaimed: bool = False,
        currency: str = "",
        amount: int = 0,
        cryptocurrency: str = "",
        cryptocurrency_amount: int = 0,
        month_count: int = 0,
        sticker: Sticker = None,
        code: str = "",
    ) -> None:
        self.creator_id: Union[MessageSenderUser, MessageSenderChat, None] = creator_id
        r"""Identifier of a chat or a user that created the gift code; may be null if unknown"""
        self.text: Union[FormattedText, None] = text
        r"""Message added to the gift"""
        self.is_from_giveaway: bool = bool(is_from_giveaway)
        r"""True, if the gift code was created for a giveaway"""
        self.is_unclaimed: bool = bool(is_unclaimed)
        r"""True, if the winner for the corresponding Telegram Premium subscription wasn't chosen"""
        self.currency: Union[str, None] = currency
        r"""Currency for the paid amount; empty if unknown"""
        self.amount: int = int(amount)
        r"""The paid amount, in the smallest units of the currency; 0 if unknown"""
        self.cryptocurrency: Union[str, None] = cryptocurrency
        r"""Cryptocurrency used to pay for the gift; may be empty if none or unknown"""
        self.cryptocurrency_amount: int = int(cryptocurrency_amount)
        r"""The paid amount, in the smallest units of the cryptocurrency; 0 if unknown"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active after code activation"""
        self.sticker: Union[Sticker, None] = sticker
        r"""A sticker to be shown in the message; may be null if unknown"""
        self.code: Union[str, None] = code
        r"""The gift code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePremiumGiftCode"]:
        return "messagePremiumGiftCode"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "creator_id": self.creator_id,
            "text": self.text,
            "is_from_giveaway": self.is_from_giveaway,
            "is_unclaimed": self.is_unclaimed,
            "currency": self.currency,
            "amount": self.amount,
            "cryptocurrency": self.cryptocurrency,
            "cryptocurrency_amount": self.cryptocurrency_amount,
            "month_count": self.month_count,
            "sticker": self.sticker,
            "code": self.code,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePremiumGiftCode", None]:
        if data:
            data_class = cls()
            data_class.creator_id = data.get("creator_id", None)
            data_class.text = data.get("text", None)
            data_class.is_from_giveaway = data.get("is_from_giveaway", False)
            data_class.is_unclaimed = data.get("is_unclaimed", False)
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.cryptocurrency = data.get("cryptocurrency", "")
            data_class.cryptocurrency_amount = int(data.get("cryptocurrency_amount", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.sticker = data.get("sticker", None)
            data_class.code = data.get("code", "")

        return data_class


class MessageGiveawayCreated(TlObject, MessageContent):
    r"""A giveaway was created for the chat\. Use telegramPaymentPurposePremiumGiveaway, storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway to create a giveaway

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways

    """

    def __init__(self, star_count: int = 0) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGiveawayCreated"]:
        return "messageGiveawayCreated"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "star_count": self.star_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGiveawayCreated", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class MessageGiveaway(TlObject, MessageContent):
    r"""A giveaway

    Parameters:
        parameters (:class:`"types.GiveawayParameters"`):
            Giveaway parameters

        winner_count (:class:`int`):
            Number of users which will receive Telegram Premium subscription gift codes

        prize (:class:`"types.GiveawayPrize"`):
            Prize of the giveaway

        sticker (:class:`"types.Sticker"`):
            A sticker to be shown in the message; may be null if unknown

    """

    def __init__(
        self,
        parameters: GiveawayParameters = None,
        winner_count: int = 0,
        prize: GiveawayPrize = None,
        sticker: Sticker = None,
    ) -> None:
        self.parameters: Union[GiveawayParameters, None] = parameters
        r"""Giveaway parameters"""
        self.winner_count: int = int(winner_count)
        r"""Number of users which will receive Telegram Premium subscription gift codes"""
        self.prize: Union[GiveawayPrizePremium, GiveawayPrizeStars, None] = prize
        r"""Prize of the giveaway"""
        self.sticker: Union[Sticker, None] = sticker
        r"""A sticker to be shown in the message; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGiveaway"]:
        return "messageGiveaway"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "parameters": self.parameters,
            "winner_count": self.winner_count,
            "prize": self.prize,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGiveaway", None]:
        if data:
            data_class = cls()
            data_class.parameters = data.get("parameters", None)
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.prize = data.get("prize", None)
            data_class.sticker = data.get("sticker", None)

        return data_class


class MessageGiveawayCompleted(TlObject, MessageContent):
    r"""A giveaway without public winners has been completed for the chat

    Parameters:
        giveaway_message_id (:class:`int`):
            Identifier of the message with the giveaway; can be 0 if the message was deleted

        winner_count (:class:`int`):
            Number of winners in the giveaway

        is_star_giveaway (:class:`bool`):
            True, if the giveaway is a Telegram Star giveaway

        unclaimed_prize_count (:class:`int`):
            Number of undistributed prizes; for Telegram Premium giveaways only

    """

    def __init__(
        self,
        giveaway_message_id: int = 0,
        winner_count: int = 0,
        is_star_giveaway: bool = False,
        unclaimed_prize_count: int = 0,
    ) -> None:
        self.giveaway_message_id: int = int(giveaway_message_id)
        r"""Identifier of the message with the giveaway; can be 0 if the message was deleted"""
        self.winner_count: int = int(winner_count)
        r"""Number of winners in the giveaway"""
        self.is_star_giveaway: bool = bool(is_star_giveaway)
        r"""True, if the giveaway is a Telegram Star giveaway"""
        self.unclaimed_prize_count: int = int(unclaimed_prize_count)
        r"""Number of undistributed prizes; for Telegram Premium giveaways only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGiveawayCompleted"]:
        return "messageGiveawayCompleted"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "giveaway_message_id": self.giveaway_message_id,
            "winner_count": self.winner_count,
            "is_star_giveaway": self.is_star_giveaway,
            "unclaimed_prize_count": self.unclaimed_prize_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGiveawayCompleted", None]:
        if data:
            data_class = cls()
            data_class.giveaway_message_id = int(data.get("giveaway_message_id", 0))
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.is_star_giveaway = data.get("is_star_giveaway", False)
            data_class.unclaimed_prize_count = int(data.get("unclaimed_prize_count", 0))

        return data_class


class MessageGiveawayWinners(TlObject, MessageContent):
    r"""A giveaway with public winners has been completed for the chat

    Parameters:
        boosted_chat_id (:class:`int`):
            Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway

        giveaway_message_id (:class:`int`):
            Identifier of the message with the giveaway in the boosted chat

        additional_chat_count (:class:`int`):
            Number of other chats that participated in the giveaway

        actual_winners_selection_date (:class:`int`):
            Point in time \(Unix timestamp\) when the winners were selected\. May be bigger than winners selection date specified in parameters of the giveaway

        only_new_members (:class:`bool`):
            True, if only new members of the chats were eligible for the giveaway

        was_refunded (:class:`bool`):
            True, if the giveaway was canceled and was fully refunded

        prize (:class:`"types.GiveawayPrize"`):
            Prize of the giveaway

        prize_description (:class:`str`):
            Additional description of the giveaway prize

        winner_count (:class:`int`):
            Total number of winners in the giveaway

        winner_user_ids (:class:`List[int]`):
            Up to 100 user identifiers of the winners of the giveaway

        unclaimed_prize_count (:class:`int`):
            Number of undistributed prizes; for Telegram Premium giveaways only

    """

    def __init__(
        self,
        boosted_chat_id: int = 0,
        giveaway_message_id: int = 0,
        additional_chat_count: int = 0,
        actual_winners_selection_date: int = 0,
        only_new_members: bool = False,
        was_refunded: bool = False,
        prize: GiveawayPrize = None,
        prize_description: str = "",
        winner_count: int = 0,
        winner_user_ids: List[int] = None,
        unclaimed_prize_count: int = 0,
    ) -> None:
        self.boosted_chat_id: int = int(boosted_chat_id)
        r"""Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway"""
        self.giveaway_message_id: int = int(giveaway_message_id)
        r"""Identifier of the message with the giveaway in the boosted chat"""
        self.additional_chat_count: int = int(additional_chat_count)
        r"""Number of other chats that participated in the giveaway"""
        self.actual_winners_selection_date: int = int(actual_winners_selection_date)
        r"""Point in time \(Unix timestamp\) when the winners were selected\. May be bigger than winners selection date specified in parameters of the giveaway"""
        self.only_new_members: bool = bool(only_new_members)
        r"""True, if only new members of the chats were eligible for the giveaway"""
        self.was_refunded: bool = bool(was_refunded)
        r"""True, if the giveaway was canceled and was fully refunded"""
        self.prize: Union[GiveawayPrizePremium, GiveawayPrizeStars, None] = prize
        r"""Prize of the giveaway"""
        self.prize_description: Union[str, None] = prize_description
        r"""Additional description of the giveaway prize"""
        self.winner_count: int = int(winner_count)
        r"""Total number of winners in the giveaway"""
        self.winner_user_ids: List[int] = winner_user_ids or []
        r"""Up to 100 user identifiers of the winners of the giveaway"""
        self.unclaimed_prize_count: int = int(unclaimed_prize_count)
        r"""Number of undistributed prizes; for Telegram Premium giveaways only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGiveawayWinners"]:
        return "messageGiveawayWinners"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "boosted_chat_id": self.boosted_chat_id,
            "giveaway_message_id": self.giveaway_message_id,
            "additional_chat_count": self.additional_chat_count,
            "actual_winners_selection_date": self.actual_winners_selection_date,
            "only_new_members": self.only_new_members,
            "was_refunded": self.was_refunded,
            "prize": self.prize,
            "prize_description": self.prize_description,
            "winner_count": self.winner_count,
            "winner_user_ids": self.winner_user_ids,
            "unclaimed_prize_count": self.unclaimed_prize_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGiveawayWinners", None]:
        if data:
            data_class = cls()
            data_class.boosted_chat_id = int(data.get("boosted_chat_id", 0))
            data_class.giveaway_message_id = int(data.get("giveaway_message_id", 0))
            data_class.additional_chat_count = int(data.get("additional_chat_count", 0))
            data_class.actual_winners_selection_date = int(
                data.get("actual_winners_selection_date", 0)
            )
            data_class.only_new_members = data.get("only_new_members", False)
            data_class.was_refunded = data.get("was_refunded", False)
            data_class.prize = data.get("prize", None)
            data_class.prize_description = data.get("prize_description", "")
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.winner_user_ids = data.get("winner_user_ids", None)
            data_class.unclaimed_prize_count = int(data.get("unclaimed_prize_count", 0))

        return data_class


class MessageGiftedStars(TlObject, MessageContent):
    r"""Telegram Stars were gifted to a user

    Parameters:
        gifter_user_id (:class:`int`):
            The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing

        receiver_user_id (:class:`int`):
            The identifier of a user that received Telegram Stars; 0 if the gift is incoming

        currency (:class:`str`):
            Currency for the paid amount

        amount (:class:`int`):
            The paid amount, in the smallest units of the currency

        cryptocurrency (:class:`str`):
            Cryptocurrency used to pay for the gift; may be empty if none

        cryptocurrency_amount (:class:`int`):
            The paid amount, in the smallest units of the cryptocurrency; 0 if none

        star_count (:class:`int`):
            Number of Telegram Stars that were gifted

        transaction_id (:class:`str`):
            Identifier of the transaction for Telegram Stars purchase; for receiver only

        sticker (:class:`"types.Sticker"`):
            A sticker to be shown in the message; may be null if unknown

    """

    def __init__(
        self,
        gifter_user_id: int = 0,
        receiver_user_id: int = 0,
        currency: str = "",
        amount: int = 0,
        cryptocurrency: str = "",
        cryptocurrency_amount: int = 0,
        star_count: int = 0,
        transaction_id: str = "",
        sticker: Sticker = None,
    ) -> None:
        self.gifter_user_id: int = int(gifter_user_id)
        r"""The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing"""
        self.receiver_user_id: int = int(receiver_user_id)
        r"""The identifier of a user that received Telegram Stars; 0 if the gift is incoming"""
        self.currency: Union[str, None] = currency
        r"""Currency for the paid amount"""
        self.amount: int = int(amount)
        r"""The paid amount, in the smallest units of the currency"""
        self.cryptocurrency: Union[str, None] = cryptocurrency
        r"""Cryptocurrency used to pay for the gift; may be empty if none"""
        self.cryptocurrency_amount: int = int(cryptocurrency_amount)
        r"""The paid amount, in the smallest units of the cryptocurrency; 0 if none"""
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that were gifted"""
        self.transaction_id: Union[str, None] = transaction_id
        r"""Identifier of the transaction for Telegram Stars purchase; for receiver only"""
        self.sticker: Union[Sticker, None] = sticker
        r"""A sticker to be shown in the message; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGiftedStars"]:
        return "messageGiftedStars"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "gifter_user_id": self.gifter_user_id,
            "receiver_user_id": self.receiver_user_id,
            "currency": self.currency,
            "amount": self.amount,
            "cryptocurrency": self.cryptocurrency,
            "cryptocurrency_amount": self.cryptocurrency_amount,
            "star_count": self.star_count,
            "transaction_id": self.transaction_id,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGiftedStars", None]:
        if data:
            data_class = cls()
            data_class.gifter_user_id = int(data.get("gifter_user_id", 0))
            data_class.receiver_user_id = int(data.get("receiver_user_id", 0))
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.cryptocurrency = data.get("cryptocurrency", "")
            data_class.cryptocurrency_amount = int(data.get("cryptocurrency_amount", 0))
            data_class.star_count = int(data.get("star_count", 0))
            data_class.transaction_id = data.get("transaction_id", "")
            data_class.sticker = data.get("sticker", None)

        return data_class


class MessageGiveawayPrizeStars(TlObject, MessageContent):
    r"""A Telegram Stars were received by the current user from a giveaway

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars that were received

        transaction_id (:class:`str`):
            Identifier of the transaction for Telegram Stars credit

        boosted_chat_id (:class:`int`):
            Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway

        giveaway_message_id (:class:`int`):
            Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted

        is_unclaimed (:class:`bool`):
            True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat

        sticker (:class:`"types.Sticker"`):
            A sticker to be shown in the message; may be null if unknown

    """

    def __init__(
        self,
        star_count: int = 0,
        transaction_id: str = "",
        boosted_chat_id: int = 0,
        giveaway_message_id: int = 0,
        is_unclaimed: bool = False,
        sticker: Sticker = None,
    ) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that were received"""
        self.transaction_id: Union[str, None] = transaction_id
        r"""Identifier of the transaction for Telegram Stars credit"""
        self.boosted_chat_id: int = int(boosted_chat_id)
        r"""Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway"""
        self.giveaway_message_id: int = int(giveaway_message_id)
        r"""Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted"""
        self.is_unclaimed: bool = bool(is_unclaimed)
        r"""True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat"""
        self.sticker: Union[Sticker, None] = sticker
        r"""A sticker to be shown in the message; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGiveawayPrizeStars"]:
        return "messageGiveawayPrizeStars"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_count": self.star_count,
            "transaction_id": self.transaction_id,
            "boosted_chat_id": self.boosted_chat_id,
            "giveaway_message_id": self.giveaway_message_id,
            "is_unclaimed": self.is_unclaimed,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGiveawayPrizeStars", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))
            data_class.transaction_id = data.get("transaction_id", "")
            data_class.boosted_chat_id = int(data.get("boosted_chat_id", 0))
            data_class.giveaway_message_id = int(data.get("giveaway_message_id", 0))
            data_class.is_unclaimed = data.get("is_unclaimed", False)
            data_class.sticker = data.get("sticker", None)

        return data_class


class MessageGift(TlObject, MessageContent):
    r"""A regular gift was received or sent by the current user, or the current user was notified about a channel gift

    Parameters:
        gift (:class:`"types.Gift"`):
            The gift

        sender_id (:class:`"types.MessageSender"`):
            Sender of the gift

        received_gift_id (:class:`str`):
            Unique identifier of the received gift for the current user; only for the receiver of the gift

        text (:class:`"types.FormattedText"`):
            Message added to the gift

        sell_star_count (:class:`int`):
            Number of Telegram Stars that can be claimed by the receiver instead of the regular gift; 0 if the gift can't be sold by the receiver

        prepaid_upgrade_star_count (:class:`int`):
            Number of Telegram Stars that were paid by the sender for the ability to upgrade the gift

        is_private (:class:`bool`):
            True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone will be able to see them

        is_saved (:class:`bool`):
            True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift

        can_be_upgraded (:class:`bool`):
            True, if the gift can be upgraded to a unique gift; only for the receiver of the gift

        was_converted (:class:`bool`):
            True, if the gift was converted to Telegram Stars; only for the receiver of the gift

        was_upgraded (:class:`bool`):
            True, if the gift was upgraded to a unique gift

        was_refunded (:class:`bool`):
            True, if the gift was refunded and isn't available anymore

        upgraded_received_gift_id (:class:`str`):
            Identifier of the corresponding upgraded gift; may be empty if unknown\. Use getReceivedGift to get information about the gift

    """

    def __init__(
        self,
        gift: Gift = None,
        sender_id: MessageSender = None,
        received_gift_id: str = "",
        text: FormattedText = None,
        sell_star_count: int = 0,
        prepaid_upgrade_star_count: int = 0,
        is_private: bool = False,
        is_saved: bool = False,
        can_be_upgraded: bool = False,
        was_converted: bool = False,
        was_upgraded: bool = False,
        was_refunded: bool = False,
        upgraded_received_gift_id: str = "",
    ) -> None:
        self.gift: Union[Gift, None] = gift
        r"""The gift"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Sender of the gift"""
        self.received_gift_id: Union[str, None] = received_gift_id
        r"""Unique identifier of the received gift for the current user; only for the receiver of the gift"""
        self.text: Union[FormattedText, None] = text
        r"""Message added to the gift"""
        self.sell_star_count: int = int(sell_star_count)
        r"""Number of Telegram Stars that can be claimed by the receiver instead of the regular gift; 0 if the gift can't be sold by the receiver"""
        self.prepaid_upgrade_star_count: int = int(prepaid_upgrade_star_count)
        r"""Number of Telegram Stars that were paid by the sender for the ability to upgrade the gift"""
        self.is_private: bool = bool(is_private)
        r"""True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone will be able to see them"""
        self.is_saved: bool = bool(is_saved)
        r"""True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift"""
        self.can_be_upgraded: bool = bool(can_be_upgraded)
        r"""True, if the gift can be upgraded to a unique gift; only for the receiver of the gift"""
        self.was_converted: bool = bool(was_converted)
        r"""True, if the gift was converted to Telegram Stars; only for the receiver of the gift"""
        self.was_upgraded: bool = bool(was_upgraded)
        r"""True, if the gift was upgraded to a unique gift"""
        self.was_refunded: bool = bool(was_refunded)
        r"""True, if the gift was refunded and isn't available anymore"""
        self.upgraded_received_gift_id: Union[str, None] = upgraded_received_gift_id
        r"""Identifier of the corresponding upgraded gift; may be empty if unknown\. Use getReceivedGift to get information about the gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageGift"]:
        return "messageGift"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "gift": self.gift,
            "sender_id": self.sender_id,
            "received_gift_id": self.received_gift_id,
            "text": self.text,
            "sell_star_count": self.sell_star_count,
            "prepaid_upgrade_star_count": self.prepaid_upgrade_star_count,
            "is_private": self.is_private,
            "is_saved": self.is_saved,
            "can_be_upgraded": self.can_be_upgraded,
            "was_converted": self.was_converted,
            "was_upgraded": self.was_upgraded,
            "was_refunded": self.was_refunded,
            "upgraded_received_gift_id": self.upgraded_received_gift_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageGift", None]:
        if data:
            data_class = cls()
            data_class.gift = data.get("gift", None)
            data_class.sender_id = data.get("sender_id", None)
            data_class.received_gift_id = data.get("received_gift_id", "")
            data_class.text = data.get("text", None)
            data_class.sell_star_count = int(data.get("sell_star_count", 0))
            data_class.prepaid_upgrade_star_count = int(
                data.get("prepaid_upgrade_star_count", 0)
            )
            data_class.is_private = data.get("is_private", False)
            data_class.is_saved = data.get("is_saved", False)
            data_class.can_be_upgraded = data.get("can_be_upgraded", False)
            data_class.was_converted = data.get("was_converted", False)
            data_class.was_upgraded = data.get("was_upgraded", False)
            data_class.was_refunded = data.get("was_refunded", False)
            data_class.upgraded_received_gift_id = data.get(
                "upgraded_received_gift_id", ""
            )

        return data_class


class MessageUpgradedGift(TlObject, MessageContent):
    r"""An upgraded gift was received or sent by the current user, or the current user was notified about a channel gift

    Parameters:
        gift (:class:`"types.UpgradedGift"`):
            The gift

        sender_id (:class:`"types.MessageSender"`):
            Sender of the gift; may be null for anonymous gifts

        received_gift_id (:class:`str`):
            Unique identifier of the received gift for the current user; only for the receiver of the gift

        is_upgrade (:class:`bool`):
            True, if the gift was obtained by upgrading of a previously received gift; otherwise, this is a transferred gift

        is_saved (:class:`bool`):
            True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift

        can_be_transferred (:class:`bool`):
            True, if the gift can be transferred to another owner; only for the receiver of the gift

        was_transferred (:class:`bool`):
            True, if the gift was transferred to another owner; only for the receiver of the gift

        transfer_star_count (:class:`int`):
            Number of Telegram Stars that must be paid to transfer the upgraded gift; only for the receiver of the gift

        export_date (:class:`int`):
            Point in time \(Unix timestamp\) when the gift can be transferred to the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift

    """

    def __init__(
        self,
        gift: UpgradedGift = None,
        sender_id: MessageSender = None,
        received_gift_id: str = "",
        is_upgrade: bool = False,
        is_saved: bool = False,
        can_be_transferred: bool = False,
        was_transferred: bool = False,
        transfer_star_count: int = 0,
        export_date: int = 0,
    ) -> None:
        self.gift: Union[UpgradedGift, None] = gift
        r"""The gift"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Sender of the gift; may be null for anonymous gifts"""
        self.received_gift_id: Union[str, None] = received_gift_id
        r"""Unique identifier of the received gift for the current user; only for the receiver of the gift"""
        self.is_upgrade: bool = bool(is_upgrade)
        r"""True, if the gift was obtained by upgrading of a previously received gift; otherwise, this is a transferred gift"""
        self.is_saved: bool = bool(is_saved)
        r"""True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift"""
        self.can_be_transferred: bool = bool(can_be_transferred)
        r"""True, if the gift can be transferred to another owner; only for the receiver of the gift"""
        self.was_transferred: bool = bool(was_transferred)
        r"""True, if the gift was transferred to another owner; only for the receiver of the gift"""
        self.transfer_star_count: int = int(transfer_star_count)
        r"""Number of Telegram Stars that must be paid to transfer the upgraded gift; only for the receiver of the gift"""
        self.export_date: int = int(export_date)
        r"""Point in time \(Unix timestamp\) when the gift can be transferred to the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageUpgradedGift"]:
        return "messageUpgradedGift"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "gift": self.gift,
            "sender_id": self.sender_id,
            "received_gift_id": self.received_gift_id,
            "is_upgrade": self.is_upgrade,
            "is_saved": self.is_saved,
            "can_be_transferred": self.can_be_transferred,
            "was_transferred": self.was_transferred,
            "transfer_star_count": self.transfer_star_count,
            "export_date": self.export_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.gift = data.get("gift", None)
            data_class.sender_id = data.get("sender_id", None)
            data_class.received_gift_id = data.get("received_gift_id", "")
            data_class.is_upgrade = data.get("is_upgrade", False)
            data_class.is_saved = data.get("is_saved", False)
            data_class.can_be_transferred = data.get("can_be_transferred", False)
            data_class.was_transferred = data.get("was_transferred", False)
            data_class.transfer_star_count = int(data.get("transfer_star_count", 0))
            data_class.export_date = int(data.get("export_date", 0))

        return data_class


class MessageRefundedUpgradedGift(TlObject, MessageContent):
    r"""A gift which purchase, upgrade or transfer were refunded

    Parameters:
        gift (:class:`"types.Gift"`):
            The gift

        sender_id (:class:`"types.MessageSender"`):
            Sender of the gift

        is_upgrade (:class:`bool`):
            True, if the gift was obtained by upgrading of a previously received gift

    """

    def __init__(
        self,
        gift: Gift = None,
        sender_id: MessageSender = None,
        is_upgrade: bool = False,
    ) -> None:
        self.gift: Union[Gift, None] = gift
        r"""The gift"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Sender of the gift"""
        self.is_upgrade: bool = bool(is_upgrade)
        r"""True, if the gift was obtained by upgrading of a previously received gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageRefundedUpgradedGift"]:
        return "messageRefundedUpgradedGift"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "gift": self.gift,
            "sender_id": self.sender_id,
            "is_upgrade": self.is_upgrade,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageRefundedUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.gift = data.get("gift", None)
            data_class.sender_id = data.get("sender_id", None)
            data_class.is_upgrade = data.get("is_upgrade", False)

        return data_class


class MessagePaidMessagesRefunded(TlObject, MessageContent):
    r"""Paid messages were refunded

    Parameters:
        message_count (:class:`int`):
            The number of refunded messages

        star_count (:class:`int`):
            The number of refunded Telegram Stars

    """

    def __init__(self, message_count: int = 0, star_count: int = 0) -> None:
        self.message_count: int = int(message_count)
        r"""The number of refunded messages"""
        self.star_count: int = int(star_count)
        r"""The number of refunded Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePaidMessagesRefunded"]:
        return "messagePaidMessagesRefunded"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_count": self.message_count,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePaidMessagesRefunded", None]:
        if data:
            data_class = cls()
            data_class.message_count = int(data.get("message_count", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class MessagePaidMessagePriceChanged(TlObject, MessageContent):
    r"""A price for paid messages was changed in the supergroup chat

    Parameters:
        paid_message_star_count (:class:`int`):
            The new number of Telegram Stars that must be paid by non\-administrator users of the supergroup chat for each sent message

    """

    def __init__(self, paid_message_star_count: int = 0) -> None:
        self.paid_message_star_count: int = int(paid_message_star_count)
        r"""The new number of Telegram Stars that must be paid by non\-administrator users of the supergroup chat for each sent message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePaidMessagePriceChanged"]:
        return "messagePaidMessagePriceChanged"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "paid_message_star_count": self.paid_message_star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePaidMessagePriceChanged", None]:
        if data:
            data_class = cls()
            data_class.paid_message_star_count = int(
                data.get("paid_message_star_count", 0)
            )

        return data_class


class MessageContactRegistered(TlObject, MessageContent):
    r"""A contact has registered with Telegram"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageContactRegistered"]:
        return "messageContactRegistered"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageContactRegistered", None]:
        if data:
            data_class = cls()

        return data_class


class MessageUsersShared(TlObject, MessageContent):
    r"""The current user shared users, which were requested by the bot

    Parameters:
        users (:class:`List["types.SharedUser"]`):
            The shared users

        button_id (:class:`int`):
            Identifier of the keyboard button with the request

    """

    def __init__(self, users: List[SharedUser] = None, button_id: int = 0) -> None:
        self.users: List[SharedUser] = users or []
        r"""The shared users"""
        self.button_id: int = int(button_id)
        r"""Identifier of the keyboard button with the request"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageUsersShared"]:
        return "messageUsersShared"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "users": self.users,
            "button_id": self.button_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageUsersShared", None]:
        if data:
            data_class = cls()
            data_class.users = data.get("users", None)
            data_class.button_id = int(data.get("button_id", 0))

        return data_class


class MessageChatShared(TlObject, MessageContent):
    r"""The current user shared a chat, which was requested by the bot

    Parameters:
        chat (:class:`"types.SharedChat"`):
            The shared chat

        button_id (:class:`int`):
            Identifier of the keyboard button with the request

    """

    def __init__(self, chat: SharedChat = None, button_id: int = 0) -> None:
        self.chat: Union[SharedChat, None] = chat
        r"""The shared chat"""
        self.button_id: int = int(button_id)
        r"""Identifier of the keyboard button with the request"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageChatShared"]:
        return "messageChatShared"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat": self.chat, "button_id": self.button_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageChatShared", None]:
        if data:
            data_class = cls()
            data_class.chat = data.get("chat", None)
            data_class.button_id = int(data.get("button_id", 0))

        return data_class


class MessageBotWriteAccessAllowed(TlObject, MessageContent):
    r"""The user allowed the bot to send messages

    Parameters:
        reason (:class:`"types.BotWriteAccessAllowReason"`):
            The reason why the bot was allowed to write messages

    """

    def __init__(self, reason: BotWriteAccessAllowReason = None) -> None:
        self.reason: Union[
            BotWriteAccessAllowReasonConnectedWebsite,
            BotWriteAccessAllowReasonAddedToAttachmentMenu,
            BotWriteAccessAllowReasonLaunchedWebApp,
            BotWriteAccessAllowReasonAcceptedRequest,
            None,
        ] = reason
        r"""The reason why the bot was allowed to write messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageBotWriteAccessAllowed"]:
        return "messageBotWriteAccessAllowed"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "reason": self.reason}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageBotWriteAccessAllowed", None]:
        if data:
            data_class = cls()
            data_class.reason = data.get("reason", None)

        return data_class


class MessageWebAppDataSent(TlObject, MessageContent):
    r"""Data from a Web App has been sent to a bot

    Parameters:
        button_text (:class:`str`):
            Text of the keyboardButtonTypeWebApp button, which opened the Web App

    """

    def __init__(self, button_text: str = "") -> None:
        self.button_text: Union[str, None] = button_text
        r"""Text of the keyboardButtonTypeWebApp button, which opened the Web App"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageWebAppDataSent"]:
        return "messageWebAppDataSent"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "button_text": self.button_text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageWebAppDataSent", None]:
        if data:
            data_class = cls()
            data_class.button_text = data.get("button_text", "")

        return data_class


class MessageWebAppDataReceived(TlObject, MessageContent):
    r"""Data from a Web App has been received; for bots only

    Parameters:
        button_text (:class:`str`):
            Text of the keyboardButtonTypeWebApp button, which opened the Web App

        data (:class:`str`):
            The data

    """

    def __init__(self, button_text: str = "", data: str = "") -> None:
        self.button_text: Union[str, None] = button_text
        r"""Text of the keyboardButtonTypeWebApp button, which opened the Web App"""
        self.data: Union[str, None] = data
        r"""The data"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageWebAppDataReceived"]:
        return "messageWebAppDataReceived"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "button_text": self.button_text,
            "data": self.data,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageWebAppDataReceived", None]:
        if data:
            data_class = cls()
            data_class.button_text = data.get("button_text", "")
            data_class.data = data.get("data", "")

        return data_class


class MessagePassportDataSent(TlObject, MessageContent):
    r"""Telegram Passport data has been sent to a bot

    Parameters:
        types (:class:`List["types.PassportElementType"]`):
            List of Telegram Passport element types sent

    """

    def __init__(self, types: List[PassportElementType] = None) -> None:
        self.types: List[PassportElementType] = types or []
        r"""List of Telegram Passport element types sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePassportDataSent"]:
        return "messagePassportDataSent"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "types": self.types}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePassportDataSent", None]:
        if data:
            data_class = cls()
            data_class.types = data.get("types", None)

        return data_class


class MessagePassportDataReceived(TlObject, MessageContent):
    r"""Telegram Passport data has been received; for bots only

    Parameters:
        elements (:class:`List["types.EncryptedPassportElement"]`):
            List of received Telegram Passport elements

        credentials (:class:`"types.EncryptedCredentials"`):
            Encrypted data credentials

    """

    def __init__(
        self,
        elements: List[EncryptedPassportElement] = None,
        credentials: EncryptedCredentials = None,
    ) -> None:
        self.elements: List[EncryptedPassportElement] = elements or []
        r"""List of received Telegram Passport elements"""
        self.credentials: Union[EncryptedCredentials, None] = credentials
        r"""Encrypted data credentials"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messagePassportDataReceived"]:
        return "messagePassportDataReceived"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "elements": self.elements,
            "credentials": self.credentials,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessagePassportDataReceived", None]:
        if data:
            data_class = cls()
            data_class.elements = data.get("elements", None)
            data_class.credentials = data.get("credentials", None)

        return data_class


class MessageProximityAlertTriggered(TlObject, MessageContent):
    r"""A user in the chat came within proximity alert range

    Parameters:
        traveler_id (:class:`"types.MessageSender"`):
            The identifier of a user or chat that triggered the proximity alert

        watcher_id (:class:`"types.MessageSender"`):
            The identifier of a user or chat that subscribed for the proximity alert

        distance (:class:`int`):
            The distance between the users

    """

    def __init__(
        self,
        traveler_id: MessageSender = None,
        watcher_id: MessageSender = None,
        distance: int = 0,
    ) -> None:
        self.traveler_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            traveler_id
        )
        r"""The identifier of a user or chat that triggered the proximity alert"""
        self.watcher_id: Union[MessageSenderUser, MessageSenderChat, None] = watcher_id
        r"""The identifier of a user or chat that subscribed for the proximity alert"""
        self.distance: int = int(distance)
        r"""The distance between the users"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageProximityAlertTriggered"]:
        return "messageProximityAlertTriggered"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "traveler_id": self.traveler_id,
            "watcher_id": self.watcher_id,
            "distance": self.distance,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageProximityAlertTriggered", None]:
        if data:
            data_class = cls()
            data_class.traveler_id = data.get("traveler_id", None)
            data_class.watcher_id = data.get("watcher_id", None)
            data_class.distance = int(data.get("distance", 0))

        return data_class


class MessageUnsupported(TlObject, MessageContent):
    r"""A message content that is not supported in the current TDLib version"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageUnsupported"]:
        return "messageUnsupported"

    def getClass(self) -> Literal["MessageContent"]:
        return "MessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageUnsupported", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeMention(TlObject, TextEntityType):
    r"""A mention of a user, a supergroup, or a channel by their username"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeMention"]:
        return "textEntityTypeMention"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeMention", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeHashtag(TlObject, TextEntityType):
    r"""A hashtag text, beginning with \"\#\" and optionally containing a chat username at the end"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeHashtag"]:
        return "textEntityTypeHashtag"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeHashtag", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeCashtag(TlObject, TextEntityType):
    r"""A cashtag text, beginning with \"$\", consisting of capital English letters \(e\.g\., \"$USD\"\), and optionally containing a chat username at the end"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeCashtag"]:
        return "textEntityTypeCashtag"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeCashtag", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeBotCommand(TlObject, TextEntityType):
    r"""A bot command, beginning with \"/\" """

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeBotCommand"]:
        return "textEntityTypeBotCommand"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeBotCommand", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeUrl(TlObject, TextEntityType):
    r"""An HTTP URL"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeUrl"]:
        return "textEntityTypeUrl"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeUrl", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeEmailAddress(TlObject, TextEntityType):
    r"""An email address"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeEmailAddress"]:
        return "textEntityTypeEmailAddress"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeEmailAddress", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypePhoneNumber(TlObject, TextEntityType):
    r"""A phone number"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypePhoneNumber"]:
        return "textEntityTypePhoneNumber"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypePhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeBankCardNumber(TlObject, TextEntityType):
    r"""A bank card number\. The getBankCardInfo method can be used to get information about the bank card"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeBankCardNumber"]:
        return "textEntityTypeBankCardNumber"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeBankCardNumber", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeBold(TlObject, TextEntityType):
    r"""A bold text"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeBold"]:
        return "textEntityTypeBold"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeBold", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeItalic(TlObject, TextEntityType):
    r"""An italic text"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeItalic"]:
        return "textEntityTypeItalic"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeItalic", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeUnderline(TlObject, TextEntityType):
    r"""An underlined text"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeUnderline"]:
        return "textEntityTypeUnderline"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeUnderline", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeStrikethrough(TlObject, TextEntityType):
    r"""A strikethrough text"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeStrikethrough"]:
        return "textEntityTypeStrikethrough"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeStrikethrough", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeSpoiler(TlObject, TextEntityType):
    r"""A spoiler text"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeSpoiler"]:
        return "textEntityTypeSpoiler"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeSpoiler", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeCode(TlObject, TextEntityType):
    r"""Text that must be formatted as if inside a code HTML tag"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeCode"]:
        return "textEntityTypeCode"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeCode", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypePre(TlObject, TextEntityType):
    r"""Text that must be formatted as if inside a pre HTML tag"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypePre"]:
        return "textEntityTypePre"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypePre", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypePreCode(TlObject, TextEntityType):
    r"""Text that must be formatted as if inside pre, and code HTML tags

    Parameters:
        language (:class:`str`):
            Programming language of the code; as defined by the sender

    """

    def __init__(self, language: str = "") -> None:
        self.language: Union[str, None] = language
        r"""Programming language of the code; as defined by the sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypePreCode"]:
        return "textEntityTypePreCode"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "language": self.language}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypePreCode", None]:
        if data:
            data_class = cls()
            data_class.language = data.get("language", "")

        return data_class


class TextEntityTypeBlockQuote(TlObject, TextEntityType):
    r"""Text that must be formatted as if inside a blockquote HTML tag; not supported in secret chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeBlockQuote"]:
        return "textEntityTypeBlockQuote"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeBlockQuote", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeExpandableBlockQuote(TlObject, TextEntityType):
    r"""Text that must be formatted as if inside a blockquote HTML tag and collapsed by default to 3 lines with the ability to show full text; not supported in secret chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeExpandableBlockQuote"]:
        return "textEntityTypeExpandableBlockQuote"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeExpandableBlockQuote", None]:
        if data:
            data_class = cls()

        return data_class


class TextEntityTypeTextUrl(TlObject, TextEntityType):
    r"""A text description shown instead of a raw URL

    Parameters:
        url (:class:`str`):
            HTTP or tg:// URL to be opened when the link is clicked

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""HTTP or tg:// URL to be opened when the link is clicked"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeTextUrl"]:
        return "textEntityTypeTextUrl"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeTextUrl", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class TextEntityTypeMentionName(TlObject, TextEntityType):
    r"""A text shows instead of a raw mention of the user \(e\.g\., when the user has no username\)

    Parameters:
        user_id (:class:`int`):
            Identifier of the mentioned user

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the mentioned user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeMentionName"]:
        return "textEntityTypeMentionName"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeMentionName", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class TextEntityTypeCustomEmoji(TlObject, TextEntityType):
    r"""A custom emoji\. The text behind a custom emoji must be an emoji\. Only premium users can use premium custom emoji

    Parameters:
        custom_emoji_id (:class:`int`):
            Unique identifier of the custom emoji

    """

    def __init__(self, custom_emoji_id: int = 0) -> None:
        self.custom_emoji_id: int = int(custom_emoji_id)
        r"""Unique identifier of the custom emoji"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeCustomEmoji"]:
        return "textEntityTypeCustomEmoji"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "custom_emoji_id": self.custom_emoji_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeCustomEmoji", None]:
        if data:
            data_class = cls()
            data_class.custom_emoji_id = int(data.get("custom_emoji_id", 0))

        return data_class


class TextEntityTypeMediaTimestamp(TlObject, TextEntityType):
    r"""A media timestamp

    Parameters:
        media_timestamp (:class:`int`):
            Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds\. The media can be in the content or the link preview of the current message, or in the same places in the replied message

    """

    def __init__(self, media_timestamp: int = 0) -> None:
        self.media_timestamp: int = int(media_timestamp)
        r"""Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds\. The media can be in the content or the link preview of the current message, or in the same places in the replied message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textEntityTypeMediaTimestamp"]:
        return "textEntityTypeMediaTimestamp"

    def getClass(self) -> Literal["TextEntityType"]:
        return "TextEntityType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "media_timestamp": self.media_timestamp}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextEntityTypeMediaTimestamp", None]:
        if data:
            data_class = cls()
            data_class.media_timestamp = int(data.get("media_timestamp", 0))

        return data_class


class InputThumbnail(TlObject):
    r"""A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size

    Parameters:
        thumbnail (:class:`"types.InputFile"`):
            Thumbnail file to send\. Sending thumbnails by file\_id is currently not supported

        width (:class:`int`):
            Thumbnail width, usually shouldn't exceed 320\. Use 0 if unknown

        height (:class:`int`):
            Thumbnail height, usually shouldn't exceed 320\. Use 0 if unknown

    """

    def __init__(
        self, thumbnail: InputFile = None, width: int = 0, height: int = 0
    ) -> None:
        self.thumbnail: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = thumbnail
        r"""Thumbnail file to send\. Sending thumbnails by file\_id is currently not supported"""
        self.width: int = int(width)
        r"""Thumbnail width, usually shouldn't exceed 320\. Use 0 if unknown"""
        self.height: int = int(height)
        r"""Thumbnail height, usually shouldn't exceed 320\. Use 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputThumbnail"]:
        return "inputThumbnail"

    def getClass(self) -> Literal["InputThumbnail"]:
        return "InputThumbnail"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "thumbnail": self.thumbnail,
            "width": self.width,
            "height": self.height,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputThumbnail", None]:
        if data:
            data_class = cls()
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))

        return data_class


class InputPaidMediaTypePhoto(TlObject, InputPaidMediaType):
    r"""The media is a photo\. The photo must be at most 10 MB in size\. The photo's width and height must not exceed 10000 in total\. Width and height ratio must be at most 20"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPaidMediaTypePhoto"]:
        return "inputPaidMediaTypePhoto"

    def getClass(self) -> Literal["InputPaidMediaType"]:
        return "InputPaidMediaType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPaidMediaTypePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class InputPaidMediaTypeVideo(TlObject, InputPaidMediaType):
    r"""The media is a video

    Parameters:
        cover (:class:`"types.InputFile"`):
            Cover of the video; pass null to skip cover uploading

        start_timestamp (:class:`int`):
            Timestamp from which the video playing must start, in seconds

        duration (:class:`int`):
            Duration of the video, in seconds

        supports_streaming (:class:`bool`):
            True, if the video is expected to be streamed

    """

    def __init__(
        self,
        cover: InputFile = None,
        start_timestamp: int = 0,
        duration: int = 0,
        supports_streaming: bool = False,
    ) -> None:
        self.cover: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = cover
        r"""Cover of the video; pass null to skip cover uploading"""
        self.start_timestamp: int = int(start_timestamp)
        r"""Timestamp from which the video playing must start, in seconds"""
        self.duration: int = int(duration)
        r"""Duration of the video, in seconds"""
        self.supports_streaming: bool = bool(supports_streaming)
        r"""True, if the video is expected to be streamed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPaidMediaTypeVideo"]:
        return "inputPaidMediaTypeVideo"

    def getClass(self) -> Literal["InputPaidMediaType"]:
        return "InputPaidMediaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "cover": self.cover,
            "start_timestamp": self.start_timestamp,
            "duration": self.duration,
            "supports_streaming": self.supports_streaming,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPaidMediaTypeVideo", None]:
        if data:
            data_class = cls()
            data_class.cover = data.get("cover", None)
            data_class.start_timestamp = int(data.get("start_timestamp", 0))
            data_class.duration = int(data.get("duration", 0))
            data_class.supports_streaming = data.get("supports_streaming", False)

        return data_class


class InputPaidMedia(TlObject):
    r"""Describes a paid media to be sent

    Parameters:
        type (:class:`"types.InputPaidMediaType"`):
            Type of the media

        media (:class:`"types.InputFile"`):
            Photo or video to be sent

        thumbnail (:class:`"types.InputThumbnail"`):
            Media thumbnail; pass null to skip thumbnail uploading

        added_sticker_file_ids (:class:`List[int]`):
            File identifiers of the stickers added to the media, if applicable

        width (:class:`int`):
            Media width

        height (:class:`int`):
            Media height

    """

    def __init__(
        self,
        type: InputPaidMediaType = None,
        media: InputFile = None,
        thumbnail: InputThumbnail = None,
        added_sticker_file_ids: List[int] = None,
        width: int = 0,
        height: int = 0,
    ) -> None:
        self.type: Union[InputPaidMediaTypePhoto, InputPaidMediaTypeVideo, None] = type
        r"""Type of the media"""
        self.media: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = media
        r"""Photo or video to be sent"""
        self.thumbnail: Union[InputThumbnail, None] = thumbnail
        r"""Media thumbnail; pass null to skip thumbnail uploading"""
        self.added_sticker_file_ids: List[int] = added_sticker_file_ids or []
        r"""File identifiers of the stickers added to the media, if applicable"""
        self.width: int = int(width)
        r"""Media width"""
        self.height: int = int(height)
        r"""Media height"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputPaidMedia"]:
        return "inputPaidMedia"

    def getClass(self) -> Literal["InputPaidMedia"]:
        return "InputPaidMedia"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "media": self.media,
            "thumbnail": self.thumbnail,
            "added_sticker_file_ids": self.added_sticker_file_ids,
            "width": self.width,
            "height": self.height,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputPaidMedia", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.media = data.get("media", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.added_sticker_file_ids = data.get("added_sticker_file_ids", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))

        return data_class


class MessageSchedulingStateSendAtDate(TlObject, MessageSchedulingState):
    r"""The message will be sent at the specified date

    Parameters:
        send_date (:class:`int`):
            Point in time \(Unix timestamp\) when the message will be sent\. The date must be within 367 days in the future

    """

    def __init__(self, send_date: int = 0) -> None:
        self.send_date: int = int(send_date)
        r"""Point in time \(Unix timestamp\) when the message will be sent\. The date must be within 367 days in the future"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSchedulingStateSendAtDate"]:
        return "messageSchedulingStateSendAtDate"

    def getClass(self) -> Literal["MessageSchedulingState"]:
        return "MessageSchedulingState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "send_date": self.send_date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSchedulingStateSendAtDate", None]:
        if data:
            data_class = cls()
            data_class.send_date = int(data.get("send_date", 0))

        return data_class


class MessageSchedulingStateSendWhenOnline(TlObject, MessageSchedulingState):
    r"""The message will be sent when the other user is online\. Applicable to private chats only and when the exact online status of the other user is known"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSchedulingStateSendWhenOnline"]:
        return "messageSchedulingStateSendWhenOnline"

    def getClass(self) -> Literal["MessageSchedulingState"]:
        return "MessageSchedulingState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["MessageSchedulingStateSendWhenOnline", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSchedulingStateSendWhenVideoProcessed(TlObject, MessageSchedulingState):
    r"""The message will be sent when the video in the message is converted and optimized; can be used only by the server

    Parameters:
        send_date (:class:`int`):
            Approximate point in time \(Unix timestamp\) when the message is expected to be sent

    """

    def __init__(self, send_date: int = 0) -> None:
        self.send_date: int = int(send_date)
        r"""Approximate point in time \(Unix timestamp\) when the message is expected to be sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSchedulingStateSendWhenVideoProcessed"]:
        return "messageSchedulingStateSendWhenVideoProcessed"

    def getClass(self) -> Literal["MessageSchedulingState"]:
        return "MessageSchedulingState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "send_date": self.send_date}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["MessageSchedulingStateSendWhenVideoProcessed", None]:
        if data:
            data_class = cls()
            data_class.send_date = int(data.get("send_date", 0))

        return data_class


class MessageSelfDestructTypeTimer(TlObject, MessageSelfDestructType):
    r"""The message will be self\-destructed in the specified time after its content was opened

    Parameters:
        self_destruct_time (:class:`int`):
            The message's self\-destruct time, in seconds; must be between 0 and 60 in private chats

    """

    def __init__(self, self_destruct_time: int = 0) -> None:
        self.self_destruct_time: int = int(self_destruct_time)
        r"""The message's self\-destruct time, in seconds; must be between 0 and 60 in private chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSelfDestructTypeTimer"]:
        return "messageSelfDestructTypeTimer"

    def getClass(self) -> Literal["MessageSelfDestructType"]:
        return "MessageSelfDestructType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "self_destruct_time": self.self_destruct_time}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSelfDestructTypeTimer", None]:
        if data:
            data_class = cls()
            data_class.self_destruct_time = int(data.get("self_destruct_time", 0))

        return data_class


class MessageSelfDestructTypeImmediately(TlObject, MessageSelfDestructType):
    r"""The message can be opened only once and will be self\-destructed once closed"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSelfDestructTypeImmediately"]:
        return "messageSelfDestructTypeImmediately"

    def getClass(self) -> Literal["MessageSelfDestructType"]:
        return "MessageSelfDestructType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSelfDestructTypeImmediately", None]:
        if data:
            data_class = cls()

        return data_class


class MessageSendOptions(TlObject):
    r"""Options to be used when a message is sent

    Parameters:
        disable_notification (:class:`bool`):
            Pass true to disable notification for the message

        from_background (:class:`bool`):
            Pass true if the message is sent from the background

        protect_content (:class:`bool`):
            Pass true if the content of the message must be protected from forwarding and saving; for bots only

        allow_paid_broadcast (:class:`bool`):
            Pass true to allow the message to ignore regular broadcast limits for a small fee; for bots only

        paid_message_star_count (:class:`int`):
            The number of Telegram Stars the user agreed to pay to send the messages

        update_order_of_installed_sticker_sets (:class:`bool`):
            Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum

        scheduling_state (:class:`"types.MessageSchedulingState"`):
            Message scheduling state; pass null to send message immediately\. Messages sent to a secret chat, to a chat with paid messages, live location messages and self\-destructing messages can't be scheduled

        effect_id (:class:`int`):
            Identifier of the effect to apply to the message; pass 0 if none; applicable only to sendMessage and sendMessageAlbum in private chats

        sending_id (:class:`int`):
            Non\-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates

        only_preview (:class:`bool`):
            Pass true to get a fake message instead of actually sending them

    """

    def __init__(
        self,
        disable_notification: bool = False,
        from_background: bool = False,
        protect_content: bool = False,
        allow_paid_broadcast: bool = False,
        paid_message_star_count: int = 0,
        update_order_of_installed_sticker_sets: bool = False,
        scheduling_state: MessageSchedulingState = None,
        effect_id: int = 0,
        sending_id: int = 0,
        only_preview: bool = False,
    ) -> None:
        self.disable_notification: bool = bool(disable_notification)
        r"""Pass true to disable notification for the message"""
        self.from_background: bool = bool(from_background)
        r"""Pass true if the message is sent from the background"""
        self.protect_content: bool = bool(protect_content)
        r"""Pass true if the content of the message must be protected from forwarding and saving; for bots only"""
        self.allow_paid_broadcast: bool = bool(allow_paid_broadcast)
        r"""Pass true to allow the message to ignore regular broadcast limits for a small fee; for bots only"""
        self.paid_message_star_count: int = int(paid_message_star_count)
        r"""The number of Telegram Stars the user agreed to pay to send the messages"""
        self.update_order_of_installed_sticker_sets: bool = bool(
            update_order_of_installed_sticker_sets
        )
        r"""Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum"""
        self.scheduling_state: Union[
            MessageSchedulingStateSendAtDate,
            MessageSchedulingStateSendWhenOnline,
            MessageSchedulingStateSendWhenVideoProcessed,
            None,
        ] = scheduling_state
        r"""Message scheduling state; pass null to send message immediately\. Messages sent to a secret chat, to a chat with paid messages, live location messages and self\-destructing messages can't be scheduled"""
        self.effect_id: int = int(effect_id)
        r"""Identifier of the effect to apply to the message; pass 0 if none; applicable only to sendMessage and sendMessageAlbum in private chats"""
        self.sending_id: int = int(sending_id)
        r"""Non\-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates"""
        self.only_preview: bool = bool(only_preview)
        r"""Pass true to get a fake message instead of actually sending them"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageSendOptions"]:
        return "messageSendOptions"

    def getClass(self) -> Literal["MessageSendOptions"]:
        return "MessageSendOptions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "disable_notification": self.disable_notification,
            "from_background": self.from_background,
            "protect_content": self.protect_content,
            "allow_paid_broadcast": self.allow_paid_broadcast,
            "paid_message_star_count": self.paid_message_star_count,
            "update_order_of_installed_sticker_sets": self.update_order_of_installed_sticker_sets,
            "scheduling_state": self.scheduling_state,
            "effect_id": self.effect_id,
            "sending_id": self.sending_id,
            "only_preview": self.only_preview,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageSendOptions", None]:
        if data:
            data_class = cls()
            data_class.disable_notification = data.get("disable_notification", False)
            data_class.from_background = data.get("from_background", False)
            data_class.protect_content = data.get("protect_content", False)
            data_class.allow_paid_broadcast = data.get("allow_paid_broadcast", False)
            data_class.paid_message_star_count = int(
                data.get("paid_message_star_count", 0)
            )
            data_class.update_order_of_installed_sticker_sets = data.get(
                "update_order_of_installed_sticker_sets", False
            )
            data_class.scheduling_state = data.get("scheduling_state", None)
            data_class.effect_id = int(data.get("effect_id", 0))
            data_class.sending_id = int(data.get("sending_id", 0))
            data_class.only_preview = data.get("only_preview", False)

        return data_class


class MessageCopyOptions(TlObject):
    r"""Options to be used when a message content is copied without reference to the original sender\. Service messages, messages with messageInvoice, messagePaidMedia, messageGiveaway, or messageGiveawayWinners content can't be copied

    Parameters:
        send_copy (:class:`bool`):
            True, if content of the message needs to be copied without reference to the original sender\. Always true if the message is forwarded to a secret chat or is local\. Use messageProperties\.can\_be\_saved and messageProperties\.can\_be\_copied\_to\_secret\_chat to check whether the message is suitable

        replace_caption (:class:`bool`):
            True, if media caption of the message copy needs to be replaced\. Ignored if send\_copy is false

        new_caption (:class:`"types.FormattedText"`):
            New message caption; pass null to copy message without caption\. Ignored if replace\_caption is false

        new_show_caption_above_media (:class:`bool`):
            True, if new caption must be shown above the media; otherwise, new caption must be shown below the media; not supported in secret chats\. Ignored if replace\_caption is false

    """

    def __init__(
        self,
        send_copy: bool = False,
        replace_caption: bool = False,
        new_caption: FormattedText = None,
        new_show_caption_above_media: bool = False,
    ) -> None:
        self.send_copy: bool = bool(send_copy)
        r"""True, if content of the message needs to be copied without reference to the original sender\. Always true if the message is forwarded to a secret chat or is local\. Use messageProperties\.can\_be\_saved and messageProperties\.can\_be\_copied\_to\_secret\_chat to check whether the message is suitable"""
        self.replace_caption: bool = bool(replace_caption)
        r"""True, if media caption of the message copy needs to be replaced\. Ignored if send\_copy is false"""
        self.new_caption: Union[FormattedText, None] = new_caption
        r"""New message caption; pass null to copy message without caption\. Ignored if replace\_caption is false"""
        self.new_show_caption_above_media: bool = bool(new_show_caption_above_media)
        r"""True, if new caption must be shown above the media; otherwise, new caption must be shown below the media; not supported in secret chats\. Ignored if replace\_caption is false"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageCopyOptions"]:
        return "messageCopyOptions"

    def getClass(self) -> Literal["MessageCopyOptions"]:
        return "MessageCopyOptions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "send_copy": self.send_copy,
            "replace_caption": self.replace_caption,
            "new_caption": self.new_caption,
            "new_show_caption_above_media": self.new_show_caption_above_media,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageCopyOptions", None]:
        if data:
            data_class = cls()
            data_class.send_copy = data.get("send_copy", False)
            data_class.replace_caption = data.get("replace_caption", False)
            data_class.new_caption = data.get("new_caption", None)
            data_class.new_show_caption_above_media = data.get(
                "new_show_caption_above_media", False
            )

        return data_class


class InputMessageText(TlObject, InputMessageContent):
    r"""A text message

    Parameters:
        text (:class:`"types.FormattedText"`):
            Formatted text to be sent; 0\-getOption\(\"message\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually

        link_preview_options (:class:`"types.LinkPreviewOptions"`):
            Options to be used for generation of a link preview; may be null if none; pass null to use default link preview options

        clear_draft (:class:`bool`):
            True, if a chat message draft must be deleted

    """

    def __init__(
        self,
        text: FormattedText = None,
        link_preview_options: LinkPreviewOptions = None,
        clear_draft: bool = False,
    ) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Formatted text to be sent; 0\-getOption\(\"message\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually"""
        self.link_preview_options: Union[LinkPreviewOptions, None] = (
            link_preview_options
        )
        r"""Options to be used for generation of a link preview; may be null if none; pass null to use default link preview options"""
        self.clear_draft: bool = bool(clear_draft)
        r"""True, if a chat message draft must be deleted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageText"]:
        return "inputMessageText"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "link_preview_options": self.link_preview_options,
            "clear_draft": self.clear_draft,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageText", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.link_preview_options = data.get("link_preview_options", None)
            data_class.clear_draft = data.get("clear_draft", False)

        return data_class


class InputMessageAnimation(TlObject, InputMessageContent):
    r"""An animation message \(GIF\-style\)\.

    Parameters:
        animation (:class:`"types.InputFile"`):
            Animation file to be sent

        thumbnail (:class:`"types.InputThumbnail"`):
            Animation thumbnail; pass null to skip thumbnail uploading

        added_sticker_file_ids (:class:`List[int]`):
            File identifiers of the stickers added to the animation, if applicable

        duration (:class:`int`):
            Duration of the animation, in seconds

        width (:class:`int`):
            Width of the animation; may be replaced by the server

        height (:class:`int`):
            Height of the animation; may be replaced by the server

        caption (:class:`"types.FormattedText"`):
            Animation caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation; not supported in secret chats

        has_spoiler (:class:`bool`):
            True, if the animation preview must be covered by a spoiler animation; not supported in secret chats

    """

    def __init__(
        self,
        animation: InputFile = None,
        thumbnail: InputThumbnail = None,
        added_sticker_file_ids: List[int] = None,
        duration: int = 0,
        width: int = 0,
        height: int = 0,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
        has_spoiler: bool = False,
    ) -> None:
        self.animation: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = animation
        r"""Animation file to be sent"""
        self.thumbnail: Union[InputThumbnail, None] = thumbnail
        r"""Animation thumbnail; pass null to skip thumbnail uploading"""
        self.added_sticker_file_ids: List[int] = added_sticker_file_ids or []
        r"""File identifiers of the stickers added to the animation, if applicable"""
        self.duration: int = int(duration)
        r"""Duration of the animation, in seconds"""
        self.width: int = int(width)
        r"""Width of the animation; may be replaced by the server"""
        self.height: int = int(height)
        r"""Height of the animation; may be replaced by the server"""
        self.caption: Union[FormattedText, None] = caption
        r"""Animation caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation; not supported in secret chats"""
        self.has_spoiler: bool = bool(has_spoiler)
        r"""True, if the animation preview must be covered by a spoiler animation; not supported in secret chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageAnimation"]:
        return "inputMessageAnimation"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "animation": self.animation,
            "thumbnail": self.thumbnail,
            "added_sticker_file_ids": self.added_sticker_file_ids,
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
            "has_spoiler": self.has_spoiler,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageAnimation", None]:
        if data:
            data_class = cls()
            data_class.animation = data.get("animation", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.added_sticker_file_ids = data.get("added_sticker_file_ids", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )
            data_class.has_spoiler = data.get("has_spoiler", False)

        return data_class


class InputMessageAudio(TlObject, InputMessageContent):
    r"""An audio message

    Parameters:
        audio (:class:`"types.InputFile"`):
            Audio file to be sent

        album_cover_thumbnail (:class:`"types.InputThumbnail"`):
            Thumbnail of the cover for the album; pass null to skip thumbnail uploading

        duration (:class:`int`):
            Duration of the audio, in seconds; may be replaced by the server

        title (:class:`str`):
            Title of the audio; 0\-64 characters; may be replaced by the server

        performer (:class:`str`):
            Performer of the audio; 0\-64 characters, may be replaced by the server

        caption (:class:`"types.FormattedText"`):
            Audio caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

    """

    def __init__(
        self,
        audio: InputFile = None,
        album_cover_thumbnail: InputThumbnail = None,
        duration: int = 0,
        title: str = "",
        performer: str = "",
        caption: FormattedText = None,
    ) -> None:
        self.audio: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = audio
        r"""Audio file to be sent"""
        self.album_cover_thumbnail: Union[InputThumbnail, None] = album_cover_thumbnail
        r"""Thumbnail of the cover for the album; pass null to skip thumbnail uploading"""
        self.duration: int = int(duration)
        r"""Duration of the audio, in seconds; may be replaced by the server"""
        self.title: Union[str, None] = title
        r"""Title of the audio; 0\-64 characters; may be replaced by the server"""
        self.performer: Union[str, None] = performer
        r"""Performer of the audio; 0\-64 characters, may be replaced by the server"""
        self.caption: Union[FormattedText, None] = caption
        r"""Audio caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageAudio"]:
        return "inputMessageAudio"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "audio": self.audio,
            "album_cover_thumbnail": self.album_cover_thumbnail,
            "duration": self.duration,
            "title": self.title,
            "performer": self.performer,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageAudio", None]:
        if data:
            data_class = cls()
            data_class.audio = data.get("audio", None)
            data_class.album_cover_thumbnail = data.get("album_cover_thumbnail", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.title = data.get("title", "")
            data_class.performer = data.get("performer", "")
            data_class.caption = data.get("caption", None)

        return data_class


class InputMessageDocument(TlObject, InputMessageContent):
    r"""A document message \(general file\)

    Parameters:
        document (:class:`"types.InputFile"`):
            Document to be sent

        thumbnail (:class:`"types.InputThumbnail"`):
            Document thumbnail; pass null to skip thumbnail uploading

        disable_content_type_detection (:class:`bool`):
            Pass true to disable automatic file type detection and send the document as a file\. Always true for files sent to secret chats

        caption (:class:`"types.FormattedText"`):
            Document caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

    """

    def __init__(
        self,
        document: InputFile = None,
        thumbnail: InputThumbnail = None,
        disable_content_type_detection: bool = False,
        caption: FormattedText = None,
    ) -> None:
        self.document: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = document
        r"""Document to be sent"""
        self.thumbnail: Union[InputThumbnail, None] = thumbnail
        r"""Document thumbnail; pass null to skip thumbnail uploading"""
        self.disable_content_type_detection: bool = bool(disable_content_type_detection)
        r"""Pass true to disable automatic file type detection and send the document as a file\. Always true for files sent to secret chats"""
        self.caption: Union[FormattedText, None] = caption
        r"""Document caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageDocument"]:
        return "inputMessageDocument"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "document": self.document,
            "thumbnail": self.thumbnail,
            "disable_content_type_detection": self.disable_content_type_detection,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageDocument", None]:
        if data:
            data_class = cls()
            data_class.document = data.get("document", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.disable_content_type_detection = data.get(
                "disable_content_type_detection", False
            )
            data_class.caption = data.get("caption", None)

        return data_class


class InputMessagePaidMedia(TlObject, InputMessageContent):
    r"""A message with paid media; can be used only in channel chats with supergroupFullInfo\.has\_paid\_media\_allowed

    Parameters:
        star_count (:class:`int`):
            The number of Telegram Stars that must be paid to see the media; 1\-getOption\(\"paid\_media\_message\_star\_count\_max\"\)

        paid_media (:class:`List["types.InputPaidMedia"]`):
            The content of the paid media

        caption (:class:`"types.FormattedText"`):
            Message caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the media; otherwise, the caption must be shown below the media; not supported in secret chats

        payload (:class:`str`):
            Bot\-provided data for the paid media; bots only

    """

    def __init__(
        self,
        star_count: int = 0,
        paid_media: List[InputPaidMedia] = None,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
        payload: str = "",
    ) -> None:
        self.star_count: int = int(star_count)
        r"""The number of Telegram Stars that must be paid to see the media; 1\-getOption\(\"paid\_media\_message\_star\_count\_max\"\)"""
        self.paid_media: List[InputPaidMedia] = paid_media or []
        r"""The content of the paid media"""
        self.caption: Union[FormattedText, None] = caption
        r"""Message caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the media; otherwise, the caption must be shown below the media; not supported in secret chats"""
        self.payload: Union[str, None] = payload
        r"""Bot\-provided data for the paid media; bots only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessagePaidMedia"]:
        return "inputMessagePaidMedia"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_count": self.star_count,
            "paid_media": self.paid_media,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
            "payload": self.payload,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessagePaidMedia", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))
            data_class.paid_media = data.get("paid_media", None)
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )
            data_class.payload = data.get("payload", "")

        return data_class


class InputMessagePhoto(TlObject, InputMessageContent):
    r"""A photo message

    Parameters:
        photo (:class:`"types.InputFile"`):
            Photo to send\. The photo must be at most 10 MB in size\. The photo's width and height must not exceed 10000 in total\. Width and height ratio must be at most 20

        thumbnail (:class:`"types.InputThumbnail"`):
            Photo thumbnail to be sent; pass null to skip thumbnail uploading\. The thumbnail is sent to the other party only in secret chats

        added_sticker_file_ids (:class:`List[int]`):
            File identifiers of the stickers added to the photo, if applicable

        width (:class:`int`):
            Photo width

        height (:class:`int`):
            Photo height

        caption (:class:`"types.FormattedText"`):
            Photo caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo; not supported in secret chats

        self_destruct_type (:class:`"types.MessageSelfDestructType"`):
            Photo self\-destruct type; pass null if none; private chats only

        has_spoiler (:class:`bool`):
            True, if the photo preview must be covered by a spoiler animation; not supported in secret chats

    """

    def __init__(
        self,
        photo: InputFile = None,
        thumbnail: InputThumbnail = None,
        added_sticker_file_ids: List[int] = None,
        width: int = 0,
        height: int = 0,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
        self_destruct_type: MessageSelfDestructType = None,
        has_spoiler: bool = False,
    ) -> None:
        self.photo: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = photo
        r"""Photo to send\. The photo must be at most 10 MB in size\. The photo's width and height must not exceed 10000 in total\. Width and height ratio must be at most 20"""
        self.thumbnail: Union[InputThumbnail, None] = thumbnail
        r"""Photo thumbnail to be sent; pass null to skip thumbnail uploading\. The thumbnail is sent to the other party only in secret chats"""
        self.added_sticker_file_ids: List[int] = added_sticker_file_ids or []
        r"""File identifiers of the stickers added to the photo, if applicable"""
        self.width: int = int(width)
        r"""Photo width"""
        self.height: int = int(height)
        r"""Photo height"""
        self.caption: Union[FormattedText, None] = caption
        r"""Photo caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo; not supported in secret chats"""
        self.self_destruct_type: Union[
            MessageSelfDestructTypeTimer, MessageSelfDestructTypeImmediately, None
        ] = self_destruct_type
        r"""Photo self\-destruct type; pass null if none; private chats only"""
        self.has_spoiler: bool = bool(has_spoiler)
        r"""True, if the photo preview must be covered by a spoiler animation; not supported in secret chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessagePhoto"]:
        return "inputMessagePhoto"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "thumbnail": self.thumbnail,
            "added_sticker_file_ids": self.added_sticker_file_ids,
            "width": self.width,
            "height": self.height,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
            "self_destruct_type": self.self_destruct_type,
            "has_spoiler": self.has_spoiler,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessagePhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.added_sticker_file_ids = data.get("added_sticker_file_ids", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )
            data_class.self_destruct_type = data.get("self_destruct_type", None)
            data_class.has_spoiler = data.get("has_spoiler", False)

        return data_class


class InputMessageSticker(TlObject, InputMessageContent):
    r"""A sticker message

    Parameters:
        sticker (:class:`"types.InputFile"`):
            Sticker to be sent

        thumbnail (:class:`"types.InputThumbnail"`):
            Sticker thumbnail; pass null to skip thumbnail uploading

        width (:class:`int`):
            Sticker width

        height (:class:`int`):
            Sticker height

        emoji (:class:`str`):
            Emoji used to choose the sticker

    """

    def __init__(
        self,
        sticker: InputFile = None,
        thumbnail: InputThumbnail = None,
        width: int = 0,
        height: int = 0,
        emoji: str = "",
    ) -> None:
        self.sticker: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = sticker
        r"""Sticker to be sent"""
        self.thumbnail: Union[InputThumbnail, None] = thumbnail
        r"""Sticker thumbnail; pass null to skip thumbnail uploading"""
        self.width: int = int(width)
        r"""Sticker width"""
        self.height: int = int(height)
        r"""Sticker height"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji used to choose the sticker"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageSticker"]:
        return "inputMessageSticker"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker": self.sticker,
            "thumbnail": self.thumbnail,
            "width": self.width,
            "height": self.height,
            "emoji": self.emoji,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageSticker", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.emoji = data.get("emoji", "")

        return data_class


class InputMessageVideo(TlObject, InputMessageContent):
    r"""A video message

    Parameters:
        video (:class:`"types.InputFile"`):
            Video to be sent\. The video is expected to be re\-encoded to MPEG4 format with H\.264 codec by the sender

        thumbnail (:class:`"types.InputThumbnail"`):
            Video thumbnail; pass null to skip thumbnail uploading

        cover (:class:`"types.InputFile"`):
            Cover of the video; pass null to skip cover uploading; not supported in secret chats and for self\-destructing messages

        start_timestamp (:class:`int`):
            Timestamp from which the video playing must start, in seconds

        added_sticker_file_ids (:class:`List[int]`):
            File identifiers of the stickers added to the video, if applicable

        duration (:class:`int`):
            Duration of the video, in seconds

        width (:class:`int`):
            Video width

        height (:class:`int`):
            Video height

        supports_streaming (:class:`bool`):
            True, if the video is expected to be streamed

        caption (:class:`"types.FormattedText"`):
            Video caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

        show_caption_above_media (:class:`bool`):
            True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats

        self_destruct_type (:class:`"types.MessageSelfDestructType"`):
            Video self\-destruct type; pass null if none; private chats only

        has_spoiler (:class:`bool`):
            True, if the video preview must be covered by a spoiler animation; not supported in secret chats

    """

    def __init__(
        self,
        video: InputFile = None,
        thumbnail: InputThumbnail = None,
        cover: InputFile = None,
        start_timestamp: int = 0,
        added_sticker_file_ids: List[int] = None,
        duration: int = 0,
        width: int = 0,
        height: int = 0,
        supports_streaming: bool = False,
        caption: FormattedText = None,
        show_caption_above_media: bool = False,
        self_destruct_type: MessageSelfDestructType = None,
        has_spoiler: bool = False,
    ) -> None:
        self.video: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = video
        r"""Video to be sent\. The video is expected to be re\-encoded to MPEG4 format with H\.264 codec by the sender"""
        self.thumbnail: Union[InputThumbnail, None] = thumbnail
        r"""Video thumbnail; pass null to skip thumbnail uploading"""
        self.cover: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = cover
        r"""Cover of the video; pass null to skip cover uploading; not supported in secret chats and for self\-destructing messages"""
        self.start_timestamp: int = int(start_timestamp)
        r"""Timestamp from which the video playing must start, in seconds"""
        self.added_sticker_file_ids: List[int] = added_sticker_file_ids or []
        r"""File identifiers of the stickers added to the video, if applicable"""
        self.duration: int = int(duration)
        r"""Duration of the video, in seconds"""
        self.width: int = int(width)
        r"""Video width"""
        self.height: int = int(height)
        r"""Video height"""
        self.supports_streaming: bool = bool(supports_streaming)
        r"""True, if the video is expected to be streamed"""
        self.caption: Union[FormattedText, None] = caption
        r"""Video caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""
        self.show_caption_above_media: bool = bool(show_caption_above_media)
        r"""True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats"""
        self.self_destruct_type: Union[
            MessageSelfDestructTypeTimer, MessageSelfDestructTypeImmediately, None
        ] = self_destruct_type
        r"""Video self\-destruct type; pass null if none; private chats only"""
        self.has_spoiler: bool = bool(has_spoiler)
        r"""True, if the video preview must be covered by a spoiler animation; not supported in secret chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageVideo"]:
        return "inputMessageVideo"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "thumbnail": self.thumbnail,
            "cover": self.cover,
            "start_timestamp": self.start_timestamp,
            "added_sticker_file_ids": self.added_sticker_file_ids,
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
            "supports_streaming": self.supports_streaming,
            "caption": self.caption,
            "show_caption_above_media": self.show_caption_above_media,
            "self_destruct_type": self.self_destruct_type,
            "has_spoiler": self.has_spoiler,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.cover = data.get("cover", None)
            data_class.start_timestamp = int(data.get("start_timestamp", 0))
            data_class.added_sticker_file_ids = data.get("added_sticker_file_ids", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.supports_streaming = data.get("supports_streaming", False)
            data_class.caption = data.get("caption", None)
            data_class.show_caption_above_media = data.get(
                "show_caption_above_media", False
            )
            data_class.self_destruct_type = data.get("self_destruct_type", None)
            data_class.has_spoiler = data.get("has_spoiler", False)

        return data_class


class InputMessageVideoNote(TlObject, InputMessageContent):
    r"""A video note message

    Parameters:
        video_note (:class:`"types.InputFile"`):
            Video note to be sent\. The video is expected to be encoded to MPEG4 format with H\.264 codec and have no data outside of the visible circle

        thumbnail (:class:`"types.InputThumbnail"`):
            Video thumbnail; may be null if empty; pass null to skip thumbnail uploading

        duration (:class:`int`):
            Duration of the video, in seconds; 0\-60

        length (:class:`int`):
            Video width and height; must be positive and not greater than 640

        self_destruct_type (:class:`"types.MessageSelfDestructType"`):
            Video note self\-destruct type; may be null if none; pass null if none; private chats only

    """

    def __init__(
        self,
        video_note: InputFile = None,
        thumbnail: InputThumbnail = None,
        duration: int = 0,
        length: int = 0,
        self_destruct_type: MessageSelfDestructType = None,
    ) -> None:
        self.video_note: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = video_note
        r"""Video note to be sent\. The video is expected to be encoded to MPEG4 format with H\.264 codec and have no data outside of the visible circle"""
        self.thumbnail: Union[InputThumbnail, None] = thumbnail
        r"""Video thumbnail; may be null if empty; pass null to skip thumbnail uploading"""
        self.duration: int = int(duration)
        r"""Duration of the video, in seconds; 0\-60"""
        self.length: int = int(length)
        r"""Video width and height; must be positive and not greater than 640"""
        self.self_destruct_type: Union[
            MessageSelfDestructTypeTimer, MessageSelfDestructTypeImmediately, None
        ] = self_destruct_type
        r"""Video note self\-destruct type; may be null if none; pass null if none; private chats only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageVideoNote"]:
        return "inputMessageVideoNote"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video_note": self.video_note,
            "thumbnail": self.thumbnail,
            "duration": self.duration,
            "length": self.length,
            "self_destruct_type": self.self_destruct_type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageVideoNote", None]:
        if data:
            data_class = cls()
            data_class.video_note = data.get("video_note", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.length = int(data.get("length", 0))
            data_class.self_destruct_type = data.get("self_destruct_type", None)

        return data_class


class InputMessageVoiceNote(TlObject, InputMessageContent):
    r"""A voice note message

    Parameters:
        voice_note (:class:`"types.InputFile"`):
            Voice note to be sent\. The voice note must be encoded with the Opus codec and stored inside an OGG container with a single audio channel, or be in MP3 or M4A format as regular audio

        duration (:class:`int`):
            Duration of the voice note, in seconds

        waveform (:class:`bytes`):
            Waveform representation of the voice note in 5\-bit format

        caption (:class:`"types.FormattedText"`):
            Voice note caption; may be null if empty; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

        self_destruct_type (:class:`"types.MessageSelfDestructType"`):
            Voice note self\-destruct type; may be null if none; pass null if none; private chats only

    """

    def __init__(
        self,
        voice_note: InputFile = None,
        duration: int = 0,
        waveform: bytes = b"",
        caption: FormattedText = None,
        self_destruct_type: MessageSelfDestructType = None,
    ) -> None:
        self.voice_note: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = voice_note
        r"""Voice note to be sent\. The voice note must be encoded with the Opus codec and stored inside an OGG container with a single audio channel, or be in MP3 or M4A format as regular audio"""
        self.duration: int = int(duration)
        r"""Duration of the voice note, in seconds"""
        self.waveform: Union[bytes, None] = waveform
        r"""Waveform representation of the voice note in 5\-bit format"""
        self.caption: Union[FormattedText, None] = caption
        r"""Voice note caption; may be null if empty; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""
        self.self_destruct_type: Union[
            MessageSelfDestructTypeTimer, MessageSelfDestructTypeImmediately, None
        ] = self_destruct_type
        r"""Voice note self\-destruct type; may be null if none; pass null if none; private chats only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageVoiceNote"]:
        return "inputMessageVoiceNote"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "voice_note": self.voice_note,
            "duration": self.duration,
            "waveform": self.waveform,
            "caption": self.caption,
            "self_destruct_type": self.self_destruct_type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.voice_note = data.get("voice_note", None)
            data_class.duration = int(data.get("duration", 0))
            data_class.waveform = b64decode(data.get("waveform", b""))
            data_class.caption = data.get("caption", None)
            data_class.self_destruct_type = data.get("self_destruct_type", None)

        return data_class


class InputMessageLocation(TlObject, InputMessageContent):
    r"""A message with a location

    Parameters:
        location (:class:`"types.Location"`):
            Location to be sent

        live_period (:class:`int`):
            Period for which the location can be updated, in seconds; must be between 60 and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise

        heading (:class:`int`):
            For live locations, a direction in which the location moves, in degrees; 1\-360\. Pass 0 if unknown

        proximity_alert_radius (:class:`int`):
            For live locations, a maximum distance to another chat member for proximity alerts, in meters \(0\-100000\)\. Pass 0 if the notification is disabled\. Can't be enabled in channels and Saved Messages

    """

    def __init__(
        self,
        location: Location = None,
        live_period: int = 0,
        heading: int = 0,
        proximity_alert_radius: int = 0,
    ) -> None:
        self.location: Union[Location, None] = location
        r"""Location to be sent"""
        self.live_period: int = int(live_period)
        r"""Period for which the location can be updated, in seconds; must be between 60 and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise"""
        self.heading: int = int(heading)
        r"""For live locations, a direction in which the location moves, in degrees; 1\-360\. Pass 0 if unknown"""
        self.proximity_alert_radius: int = int(proximity_alert_radius)
        r"""For live locations, a maximum distance to another chat member for proximity alerts, in meters \(0\-100000\)\. Pass 0 if the notification is disabled\. Can't be enabled in channels and Saved Messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageLocation"]:
        return "inputMessageLocation"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "live_period": self.live_period,
            "heading": self.heading,
            "proximity_alert_radius": self.proximity_alert_radius,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageLocation", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.live_period = int(data.get("live_period", 0))
            data_class.heading = int(data.get("heading", 0))
            data_class.proximity_alert_radius = int(
                data.get("proximity_alert_radius", 0)
            )

        return data_class


class InputMessageVenue(TlObject, InputMessageContent):
    r"""A message with information about a venue

    Parameters:
        venue (:class:`"types.Venue"`):
            Venue to send

    """

    def __init__(self, venue: Venue = None) -> None:
        self.venue: Union[Venue, None] = venue
        r"""Venue to send"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageVenue"]:
        return "inputMessageVenue"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "venue": self.venue}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageVenue", None]:
        if data:
            data_class = cls()
            data_class.venue = data.get("venue", None)

        return data_class


class InputMessageContact(TlObject, InputMessageContent):
    r"""A message containing a user contact

    Parameters:
        contact (:class:`"types.Contact"`):
            Contact to send

    """

    def __init__(self, contact: Contact = None) -> None:
        self.contact: Union[Contact, None] = contact
        r"""Contact to send"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageContact"]:
        return "inputMessageContact"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "contact": self.contact}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageContact", None]:
        if data:
            data_class = cls()
            data_class.contact = data.get("contact", None)

        return data_class


class InputMessageDice(TlObject, InputMessageContent):
    r"""A dice message

    Parameters:
        emoji (:class:`str`):
            Emoji on which the dice throw animation is based

        clear_draft (:class:`bool`):
            True, if the chat message draft must be deleted

    """

    def __init__(self, emoji: str = "", clear_draft: bool = False) -> None:
        self.emoji: Union[str, None] = emoji
        r"""Emoji on which the dice throw animation is based"""
        self.clear_draft: bool = bool(clear_draft)
        r"""True, if the chat message draft must be deleted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageDice"]:
        return "inputMessageDice"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "emoji": self.emoji,
            "clear_draft": self.clear_draft,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageDice", None]:
        if data:
            data_class = cls()
            data_class.emoji = data.get("emoji", "")
            data_class.clear_draft = data.get("clear_draft", False)

        return data_class


class InputMessageGame(TlObject, InputMessageContent):
    r"""A message with a game; not supported for channels or secret chats

    Parameters:
        bot_user_id (:class:`int`):
            User identifier of the bot that owns the game

        game_short_name (:class:`str`):
            Short name of the game

    """

    def __init__(self, bot_user_id: int = 0, game_short_name: str = "") -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of the bot that owns the game"""
        self.game_short_name: Union[str, None] = game_short_name
        r"""Short name of the game"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageGame"]:
        return "inputMessageGame"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "game_short_name": self.game_short_name,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageGame", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.game_short_name = data.get("game_short_name", "")

        return data_class


class InputMessageInvoice(TlObject, InputMessageContent):
    r"""A message with an invoice; can be used only by bots

    Parameters:
        invoice (:class:`"types.Invoice"`):
            Invoice

        title (:class:`str`):
            Product title; 1\-32 characters

        description (:class:`str`):
            Product description; 0\-255 characters

        photo_url (:class:`str`):
            Product photo URL; optional

        photo_size (:class:`int`):
            Product photo size

        photo_width (:class:`int`):
            Product photo width

        photo_height (:class:`int`):
            Product photo height

        payload (:class:`bytes`):
            The invoice payload

        provider_token (:class:`str`):
            Payment provider token; may be empty for payments in Telegram Stars

        provider_data (:class:`str`):
            JSON\-encoded data about the invoice, which will be shared with the payment provider

        start_parameter (:class:`str`):
            Unique invoice bot deep link parameter for the generation of this invoice\. If empty, it would be possible to pay directly from forwards of the invoice message

        paid_media (:class:`"types.InputPaidMedia"`):
            The content of paid media attached to the invoice; pass null if none

        paid_media_caption (:class:`"types.FormattedText"`):
            Paid media caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters

    """

    def __init__(
        self,
        invoice: Invoice = None,
        title: str = "",
        description: str = "",
        photo_url: str = "",
        photo_size: int = 0,
        photo_width: int = 0,
        photo_height: int = 0,
        payload: bytes = b"",
        provider_token: str = "",
        provider_data: str = "",
        start_parameter: str = "",
        paid_media: InputPaidMedia = None,
        paid_media_caption: FormattedText = None,
    ) -> None:
        self.invoice: Union[Invoice, None] = invoice
        r"""Invoice"""
        self.title: Union[str, None] = title
        r"""Product title; 1\-32 characters"""
        self.description: Union[str, None] = description
        r"""Product description; 0\-255 characters"""
        self.photo_url: Union[str, None] = photo_url
        r"""Product photo URL; optional"""
        self.photo_size: int = int(photo_size)
        r"""Product photo size"""
        self.photo_width: int = int(photo_width)
        r"""Product photo width"""
        self.photo_height: int = int(photo_height)
        r"""Product photo height"""
        self.payload: Union[bytes, None] = payload
        r"""The invoice payload"""
        self.provider_token: Union[str, None] = provider_token
        r"""Payment provider token; may be empty for payments in Telegram Stars"""
        self.provider_data: Union[str, None] = provider_data
        r"""JSON\-encoded data about the invoice, which will be shared with the payment provider"""
        self.start_parameter: Union[str, None] = start_parameter
        r"""Unique invoice bot deep link parameter for the generation of this invoice\. If empty, it would be possible to pay directly from forwards of the invoice message"""
        self.paid_media: Union[InputPaidMedia, None] = paid_media
        r"""The content of paid media attached to the invoice; pass null if none"""
        self.paid_media_caption: Union[FormattedText, None] = paid_media_caption
        r"""Paid media caption; pass null to use an empty caption; 0\-getOption\(\"message\_caption\_length\_max\"\) characters"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageInvoice"]:
        return "inputMessageInvoice"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "invoice": self.invoice,
            "title": self.title,
            "description": self.description,
            "photo_url": self.photo_url,
            "photo_size": self.photo_size,
            "photo_width": self.photo_width,
            "photo_height": self.photo_height,
            "payload": self.payload,
            "provider_token": self.provider_token,
            "provider_data": self.provider_data,
            "start_parameter": self.start_parameter,
            "paid_media": self.paid_media,
            "paid_media_caption": self.paid_media_caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageInvoice", None]:
        if data:
            data_class = cls()
            data_class.invoice = data.get("invoice", None)
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.photo_url = data.get("photo_url", "")
            data_class.photo_size = int(data.get("photo_size", 0))
            data_class.photo_width = int(data.get("photo_width", 0))
            data_class.photo_height = int(data.get("photo_height", 0))
            data_class.payload = b64decode(data.get("payload", b""))
            data_class.provider_token = data.get("provider_token", "")
            data_class.provider_data = data.get("provider_data", "")
            data_class.start_parameter = data.get("start_parameter", "")
            data_class.paid_media = data.get("paid_media", None)
            data_class.paid_media_caption = data.get("paid_media_caption", None)

        return data_class


class InputMessagePoll(TlObject, InputMessageContent):
    r"""A message with a poll\. Polls can't be sent to secret chats\. Polls can be sent only to a private chat with a bot

    Parameters:
        question (:class:`"types.FormattedText"`):
            Poll question; 1\-255 characters \(up to 300 characters for bots\)\. Only custom emoji entities are allowed to be added and only by Premium users

        options (:class:`List["types.FormattedText"]`):
            List of poll answer options, 2\-10 strings 1\-100 characters each\. Only custom emoji entities are allowed to be added and only by Premium users

        is_anonymous (:class:`bool`):
            True, if the poll voters are anonymous\. Non\-anonymous polls can't be sent or forwarded to channels

        type (:class:`"types.PollType"`):
            Type of the poll

        open_period (:class:`int`):
            Amount of time the poll will be active after creation, in seconds; for bots only

        close_date (:class:`int`):
            Point in time \(Unix timestamp\) when the poll will automatically be closed; for bots only

        is_closed (:class:`bool`):
            True, if the poll needs to be sent already closed; for bots only

    """

    def __init__(
        self,
        question: FormattedText = None,
        options: List[FormattedText] = None,
        is_anonymous: bool = False,
        type: PollType = None,
        open_period: int = 0,
        close_date: int = 0,
        is_closed: bool = False,
    ) -> None:
        self.question: Union[FormattedText, None] = question
        r"""Poll question; 1\-255 characters \(up to 300 characters for bots\)\. Only custom emoji entities are allowed to be added and only by Premium users"""
        self.options: List[FormattedText] = options or []
        r"""List of poll answer options, 2\-10 strings 1\-100 characters each\. Only custom emoji entities are allowed to be added and only by Premium users"""
        self.is_anonymous: bool = bool(is_anonymous)
        r"""True, if the poll voters are anonymous\. Non\-anonymous polls can't be sent or forwarded to channels"""
        self.type: Union[PollTypeRegular, PollTypeQuiz, None] = type
        r"""Type of the poll"""
        self.open_period: int = int(open_period)
        r"""Amount of time the poll will be active after creation, in seconds; for bots only"""
        self.close_date: int = int(close_date)
        r"""Point in time \(Unix timestamp\) when the poll will automatically be closed; for bots only"""
        self.is_closed: bool = bool(is_closed)
        r"""True, if the poll needs to be sent already closed; for bots only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessagePoll"]:
        return "inputMessagePoll"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "question": self.question,
            "options": self.options,
            "is_anonymous": self.is_anonymous,
            "type": self.type,
            "open_period": self.open_period,
            "close_date": self.close_date,
            "is_closed": self.is_closed,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessagePoll", None]:
        if data:
            data_class = cls()
            data_class.question = data.get("question", None)
            data_class.options = data.get("options", None)
            data_class.is_anonymous = data.get("is_anonymous", False)
            data_class.type = data.get("type", None)
            data_class.open_period = int(data.get("open_period", 0))
            data_class.close_date = int(data.get("close_date", 0))
            data_class.is_closed = data.get("is_closed", False)

        return data_class


class InputMessageStory(TlObject, InputMessageContent):
    r"""A message with a forwarded story\. Stories can't be sent to secret chats\. A story can be forwarded only if story\.can\_be\_forwarded

    Parameters:
        story_sender_chat_id (:class:`int`):
            Identifier of the chat that posted the story

        story_id (:class:`int`):
            Story identifier

    """

    def __init__(self, story_sender_chat_id: int = 0, story_id: int = 0) -> None:
        self.story_sender_chat_id: int = int(story_sender_chat_id)
        r"""Identifier of the chat that posted the story"""
        self.story_id: int = int(story_id)
        r"""Story identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageStory"]:
        return "inputMessageStory"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_sender_chat_id": self.story_sender_chat_id,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageStory", None]:
        if data:
            data_class = cls()
            data_class.story_sender_chat_id = int(data.get("story_sender_chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class InputMessageForwarded(TlObject, InputMessageContent):
    r"""A forwarded message

    Parameters:
        from_chat_id (:class:`int`):
            Identifier for the chat this forwarded message came from

        message_id (:class:`int`):
            Identifier of the message to forward\. A message can be forwarded only if messageProperties\.can\_be\_forwarded

        in_game_share (:class:`bool`):
            Pass true if a game message is being shared from a launched game; applies only to game messages

        replace_video_start_timestamp (:class:`bool`):
            Pass true to replace video start timestamp in the forwarded message

        new_video_start_timestamp (:class:`int`):
            The new video start timestamp; ignored if replace\_video\_start\_timestamp \=\= false

        copy_options (:class:`"types.MessageCopyOptions"`):
            Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual

    """

    def __init__(
        self,
        from_chat_id: int = 0,
        message_id: int = 0,
        in_game_share: bool = False,
        replace_video_start_timestamp: bool = False,
        new_video_start_timestamp: int = 0,
        copy_options: MessageCopyOptions = None,
    ) -> None:
        self.from_chat_id: int = int(from_chat_id)
        r"""Identifier for the chat this forwarded message came from"""
        self.message_id: int = int(message_id)
        r"""Identifier of the message to forward\. A message can be forwarded only if messageProperties\.can\_be\_forwarded"""
        self.in_game_share: bool = bool(in_game_share)
        r"""Pass true if a game message is being shared from a launched game; applies only to game messages"""
        self.replace_video_start_timestamp: bool = bool(replace_video_start_timestamp)
        r"""Pass true to replace video start timestamp in the forwarded message"""
        self.new_video_start_timestamp: int = int(new_video_start_timestamp)
        r"""The new video start timestamp; ignored if replace\_video\_start\_timestamp \=\= false"""
        self.copy_options: Union[MessageCopyOptions, None] = copy_options
        r"""Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputMessageForwarded"]:
        return "inputMessageForwarded"

    def getClass(self) -> Literal["InputMessageContent"]:
        return "InputMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "from_chat_id": self.from_chat_id,
            "message_id": self.message_id,
            "in_game_share": self.in_game_share,
            "replace_video_start_timestamp": self.replace_video_start_timestamp,
            "new_video_start_timestamp": self.new_video_start_timestamp,
            "copy_options": self.copy_options,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputMessageForwarded", None]:
        if data:
            data_class = cls()
            data_class.from_chat_id = int(data.get("from_chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.in_game_share = data.get("in_game_share", False)
            data_class.replace_video_start_timestamp = data.get(
                "replace_video_start_timestamp", False
            )
            data_class.new_video_start_timestamp = int(
                data.get("new_video_start_timestamp", 0)
            )
            data_class.copy_options = data.get("copy_options", None)

        return data_class


class MessageProperties(TlObject):
    r"""Contains properties of a message and describes actions that can be done with the message right now

    Parameters:
        can_be_copied_to_secret_chat (:class:`bool`):
            True, if content of the message can be copied to a secret chat using inputMessageForwarded or forwardMessages with copy options

        can_be_deleted_only_for_self (:class:`bool`):
            True, if the message can be deleted only for the current user while other users will continue to see it using the method deleteMessages with revoke \=\= false

        can_be_deleted_for_all_users (:class:`bool`):
            True, if the message can be deleted for all users using the method deleteMessages with revoke \=\= true

        can_be_edited (:class:`bool`):
            True, if the message can be edited using the methods editMessageText, editMessageCaption, or editMessageReplyMarkup\. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message

        can_be_forwarded (:class:`bool`):
            True, if the message can be forwarded using inputMessageForwarded or forwardMessages

        can_be_paid (:class:`bool`):
            True, if the message can be paid using inputInvoiceMessage

        can_be_pinned (:class:`bool`):
            True, if the message can be pinned or unpinned in the chat using pinChatMessage or unpinChatMessage

        can_be_replied (:class:`bool`):
            True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage

        can_be_replied_in_another_chat (:class:`bool`):
            True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage

        can_be_saved (:class:`bool`):
            True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options

        can_be_shared_in_story (:class:`bool`):
            True, if the message can be shared in a story using inputStoryAreaTypeMessage

        can_edit_media (:class:`bool`):
            True, if the message can be edited using the method editMessageMedia

        can_edit_scheduling_state (:class:`bool`):
            True, if scheduling state of the message can be edited

        can_get_embedding_code (:class:`bool`):
            True, if code for message embedding can be received using getMessageEmbeddingCode

        can_get_link (:class:`bool`):
            True, if a link can be generated for the message using getMessageLink

        can_get_media_timestamp_links (:class:`bool`):
            True, if media timestamp links can be generated for media timestamp entities in the message text, caption or link preview description using getMessageLink

        can_get_message_thread (:class:`bool`):
            True, if information about the message thread is available through getMessageThread and getMessageThreadHistory

        can_get_read_date (:class:`bool`):
            True, if read date of the message can be received through getMessageReadDate

        can_get_statistics (:class:`bool`):
            True, if message statistics are available through getMessageStatistics and message forwards can be received using getMessagePublicForwards

        can_get_viewers (:class:`bool`):
            True, if chat members already viewed the message can be received through getMessageViewers

        can_recognize_speech (:class:`bool`):
            True, if speech can be recognized for the message through recognizeSpeech

        can_report_chat (:class:`bool`):
            True, if the message can be reported using reportChat

        can_report_reactions (:class:`bool`):
            True, if reactions on the message can be reported through reportMessageReactions

        can_report_supergroup_spam (:class:`bool`):
            True, if the message can be reported using reportSupergroupSpam

        can_set_fact_check (:class:`bool`):
            True, if fact check for the message can be changed through setMessageFactCheck

        need_show_statistics (:class:`bool`):
            True, if message statistics must be available from context menu of the message

    """

    def __init__(
        self,
        can_be_copied_to_secret_chat: bool = False,
        can_be_deleted_only_for_self: bool = False,
        can_be_deleted_for_all_users: bool = False,
        can_be_edited: bool = False,
        can_be_forwarded: bool = False,
        can_be_paid: bool = False,
        can_be_pinned: bool = False,
        can_be_replied: bool = False,
        can_be_replied_in_another_chat: bool = False,
        can_be_saved: bool = False,
        can_be_shared_in_story: bool = False,
        can_edit_media: bool = False,
        can_edit_scheduling_state: bool = False,
        can_get_embedding_code: bool = False,
        can_get_link: bool = False,
        can_get_media_timestamp_links: bool = False,
        can_get_message_thread: bool = False,
        can_get_read_date: bool = False,
        can_get_statistics: bool = False,
        can_get_viewers: bool = False,
        can_recognize_speech: bool = False,
        can_report_chat: bool = False,
        can_report_reactions: bool = False,
        can_report_supergroup_spam: bool = False,
        can_set_fact_check: bool = False,
        need_show_statistics: bool = False,
    ) -> None:
        self.can_be_copied_to_secret_chat: bool = bool(can_be_copied_to_secret_chat)
        r"""True, if content of the message can be copied to a secret chat using inputMessageForwarded or forwardMessages with copy options"""
        self.can_be_deleted_only_for_self: bool = bool(can_be_deleted_only_for_self)
        r"""True, if the message can be deleted only for the current user while other users will continue to see it using the method deleteMessages with revoke \=\= false"""
        self.can_be_deleted_for_all_users: bool = bool(can_be_deleted_for_all_users)
        r"""True, if the message can be deleted for all users using the method deleteMessages with revoke \=\= true"""
        self.can_be_edited: bool = bool(can_be_edited)
        r"""True, if the message can be edited using the methods editMessageText, editMessageCaption, or editMessageReplyMarkup\. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message"""
        self.can_be_forwarded: bool = bool(can_be_forwarded)
        r"""True, if the message can be forwarded using inputMessageForwarded or forwardMessages"""
        self.can_be_paid: bool = bool(can_be_paid)
        r"""True, if the message can be paid using inputInvoiceMessage"""
        self.can_be_pinned: bool = bool(can_be_pinned)
        r"""True, if the message can be pinned or unpinned in the chat using pinChatMessage or unpinChatMessage"""
        self.can_be_replied: bool = bool(can_be_replied)
        r"""True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage"""
        self.can_be_replied_in_another_chat: bool = bool(can_be_replied_in_another_chat)
        r"""True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage"""
        self.can_be_saved: bool = bool(can_be_saved)
        r"""True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options"""
        self.can_be_shared_in_story: bool = bool(can_be_shared_in_story)
        r"""True, if the message can be shared in a story using inputStoryAreaTypeMessage"""
        self.can_edit_media: bool = bool(can_edit_media)
        r"""True, if the message can be edited using the method editMessageMedia"""
        self.can_edit_scheduling_state: bool = bool(can_edit_scheduling_state)
        r"""True, if scheduling state of the message can be edited"""
        self.can_get_embedding_code: bool = bool(can_get_embedding_code)
        r"""True, if code for message embedding can be received using getMessageEmbeddingCode"""
        self.can_get_link: bool = bool(can_get_link)
        r"""True, if a link can be generated for the message using getMessageLink"""
        self.can_get_media_timestamp_links: bool = bool(can_get_media_timestamp_links)
        r"""True, if media timestamp links can be generated for media timestamp entities in the message text, caption or link preview description using getMessageLink"""
        self.can_get_message_thread: bool = bool(can_get_message_thread)
        r"""True, if information about the message thread is available through getMessageThread and getMessageThreadHistory"""
        self.can_get_read_date: bool = bool(can_get_read_date)
        r"""True, if read date of the message can be received through getMessageReadDate"""
        self.can_get_statistics: bool = bool(can_get_statistics)
        r"""True, if message statistics are available through getMessageStatistics and message forwards can be received using getMessagePublicForwards"""
        self.can_get_viewers: bool = bool(can_get_viewers)
        r"""True, if chat members already viewed the message can be received through getMessageViewers"""
        self.can_recognize_speech: bool = bool(can_recognize_speech)
        r"""True, if speech can be recognized for the message through recognizeSpeech"""
        self.can_report_chat: bool = bool(can_report_chat)
        r"""True, if the message can be reported using reportChat"""
        self.can_report_reactions: bool = bool(can_report_reactions)
        r"""True, if reactions on the message can be reported through reportMessageReactions"""
        self.can_report_supergroup_spam: bool = bool(can_report_supergroup_spam)
        r"""True, if the message can be reported using reportSupergroupSpam"""
        self.can_set_fact_check: bool = bool(can_set_fact_check)
        r"""True, if fact check for the message can be changed through setMessageFactCheck"""
        self.need_show_statistics: bool = bool(need_show_statistics)
        r"""True, if message statistics must be available from context menu of the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageProperties"]:
        return "messageProperties"

    def getClass(self) -> Literal["MessageProperties"]:
        return "MessageProperties"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "can_be_copied_to_secret_chat": self.can_be_copied_to_secret_chat,
            "can_be_deleted_only_for_self": self.can_be_deleted_only_for_self,
            "can_be_deleted_for_all_users": self.can_be_deleted_for_all_users,
            "can_be_edited": self.can_be_edited,
            "can_be_forwarded": self.can_be_forwarded,
            "can_be_paid": self.can_be_paid,
            "can_be_pinned": self.can_be_pinned,
            "can_be_replied": self.can_be_replied,
            "can_be_replied_in_another_chat": self.can_be_replied_in_another_chat,
            "can_be_saved": self.can_be_saved,
            "can_be_shared_in_story": self.can_be_shared_in_story,
            "can_edit_media": self.can_edit_media,
            "can_edit_scheduling_state": self.can_edit_scheduling_state,
            "can_get_embedding_code": self.can_get_embedding_code,
            "can_get_link": self.can_get_link,
            "can_get_media_timestamp_links": self.can_get_media_timestamp_links,
            "can_get_message_thread": self.can_get_message_thread,
            "can_get_read_date": self.can_get_read_date,
            "can_get_statistics": self.can_get_statistics,
            "can_get_viewers": self.can_get_viewers,
            "can_recognize_speech": self.can_recognize_speech,
            "can_report_chat": self.can_report_chat,
            "can_report_reactions": self.can_report_reactions,
            "can_report_supergroup_spam": self.can_report_supergroup_spam,
            "can_set_fact_check": self.can_set_fact_check,
            "need_show_statistics": self.need_show_statistics,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageProperties", None]:
        if data:
            data_class = cls()
            data_class.can_be_copied_to_secret_chat = data.get(
                "can_be_copied_to_secret_chat", False
            )
            data_class.can_be_deleted_only_for_self = data.get(
                "can_be_deleted_only_for_self", False
            )
            data_class.can_be_deleted_for_all_users = data.get(
                "can_be_deleted_for_all_users", False
            )
            data_class.can_be_edited = data.get("can_be_edited", False)
            data_class.can_be_forwarded = data.get("can_be_forwarded", False)
            data_class.can_be_paid = data.get("can_be_paid", False)
            data_class.can_be_pinned = data.get("can_be_pinned", False)
            data_class.can_be_replied = data.get("can_be_replied", False)
            data_class.can_be_replied_in_another_chat = data.get(
                "can_be_replied_in_another_chat", False
            )
            data_class.can_be_saved = data.get("can_be_saved", False)
            data_class.can_be_shared_in_story = data.get(
                "can_be_shared_in_story", False
            )
            data_class.can_edit_media = data.get("can_edit_media", False)
            data_class.can_edit_scheduling_state = data.get(
                "can_edit_scheduling_state", False
            )
            data_class.can_get_embedding_code = data.get(
                "can_get_embedding_code", False
            )
            data_class.can_get_link = data.get("can_get_link", False)
            data_class.can_get_media_timestamp_links = data.get(
                "can_get_media_timestamp_links", False
            )
            data_class.can_get_message_thread = data.get(
                "can_get_message_thread", False
            )
            data_class.can_get_read_date = data.get("can_get_read_date", False)
            data_class.can_get_statistics = data.get("can_get_statistics", False)
            data_class.can_get_viewers = data.get("can_get_viewers", False)
            data_class.can_recognize_speech = data.get("can_recognize_speech", False)
            data_class.can_report_chat = data.get("can_report_chat", False)
            data_class.can_report_reactions = data.get("can_report_reactions", False)
            data_class.can_report_supergroup_spam = data.get(
                "can_report_supergroup_spam", False
            )
            data_class.can_set_fact_check = data.get("can_set_fact_check", False)
            data_class.need_show_statistics = data.get("need_show_statistics", False)

        return data_class


class SearchMessagesFilterEmpty(TlObject, SearchMessagesFilter):
    r"""Returns all found messages, no filter is applied"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterEmpty"]:
        return "searchMessagesFilterEmpty"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterEmpty", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterAnimation(TlObject, SearchMessagesFilter):
    r"""Returns only animation messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterAnimation"]:
        return "searchMessagesFilterAnimation"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterAnimation", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterAudio(TlObject, SearchMessagesFilter):
    r"""Returns only audio messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterAudio"]:
        return "searchMessagesFilterAudio"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterAudio", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterDocument(TlObject, SearchMessagesFilter):
    r"""Returns only document messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterDocument"]:
        return "searchMessagesFilterDocument"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterDocument", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterPhoto(TlObject, SearchMessagesFilter):
    r"""Returns only photo messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterPhoto"]:
        return "searchMessagesFilterPhoto"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterPhoto", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterVideo(TlObject, SearchMessagesFilter):
    r"""Returns only video messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterVideo"]:
        return "searchMessagesFilterVideo"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterVideo", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterVoiceNote(TlObject, SearchMessagesFilter):
    r"""Returns only voice note messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterVoiceNote"]:
        return "searchMessagesFilterVoiceNote"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterVoiceNote", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterPhotoAndVideo(TlObject, SearchMessagesFilter):
    r"""Returns only photo and video messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterPhotoAndVideo"]:
        return "searchMessagesFilterPhotoAndVideo"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterPhotoAndVideo", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterUrl(TlObject, SearchMessagesFilter):
    r"""Returns only messages containing URLs"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterUrl"]:
        return "searchMessagesFilterUrl"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterUrl", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterChatPhoto(TlObject, SearchMessagesFilter):
    r"""Returns only messages containing chat photos"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterChatPhoto"]:
        return "searchMessagesFilterChatPhoto"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterChatPhoto", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterVideoNote(TlObject, SearchMessagesFilter):
    r"""Returns only video note messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterVideoNote"]:
        return "searchMessagesFilterVideoNote"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterVideoNote", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterVoiceAndVideoNote(TlObject, SearchMessagesFilter):
    r"""Returns only voice and video note messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterVoiceAndVideoNote"]:
        return "searchMessagesFilterVoiceAndVideoNote"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SearchMessagesFilterVoiceAndVideoNote", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterMention(TlObject, SearchMessagesFilter):
    r"""Returns only messages with mentions of the current user, or messages that are replies to their messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterMention"]:
        return "searchMessagesFilterMention"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterMention", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterUnreadMention(TlObject, SearchMessagesFilter):
    r"""Returns only messages with unread mentions of the current user, or messages that are replies to their messages\. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterUnreadMention"]:
        return "searchMessagesFilterUnreadMention"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterUnreadMention", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterUnreadReaction(TlObject, SearchMessagesFilter):
    r"""Returns only messages with unread reactions for the current user\. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterUnreadReaction"]:
        return "searchMessagesFilterUnreadReaction"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterUnreadReaction", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterFailedToSend(TlObject, SearchMessagesFilter):
    r"""Returns only failed to send messages\. This filter can be used only if the message database is used"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterFailedToSend"]:
        return "searchMessagesFilterFailedToSend"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterFailedToSend", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesFilterPinned(TlObject, SearchMessagesFilter):
    r"""Returns only pinned messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesFilterPinned"]:
        return "searchMessagesFilterPinned"

    def getClass(self) -> Literal["SearchMessagesFilter"]:
        return "SearchMessagesFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesFilterPinned", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesChatTypeFilterPrivate(TlObject, SearchMessagesChatTypeFilter):
    r"""Returns only messages in private chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesChatTypeFilterPrivate"]:
        return "searchMessagesChatTypeFilterPrivate"

    def getClass(self) -> Literal["SearchMessagesChatTypeFilter"]:
        return "SearchMessagesChatTypeFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SearchMessagesChatTypeFilterPrivate", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesChatTypeFilterGroup(TlObject, SearchMessagesChatTypeFilter):
    r"""Returns only messages in basic group and supergroup chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesChatTypeFilterGroup"]:
        return "searchMessagesChatTypeFilterGroup"

    def getClass(self) -> Literal["SearchMessagesChatTypeFilter"]:
        return "SearchMessagesChatTypeFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SearchMessagesChatTypeFilterGroup", None]:
        if data:
            data_class = cls()

        return data_class


class SearchMessagesChatTypeFilterChannel(TlObject, SearchMessagesChatTypeFilter):
    r"""Returns only messages in channel chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["searchMessagesChatTypeFilterChannel"]:
        return "searchMessagesChatTypeFilterChannel"

    def getClass(self) -> Literal["SearchMessagesChatTypeFilter"]:
        return "SearchMessagesChatTypeFilter"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SearchMessagesChatTypeFilterChannel", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionTyping(TlObject, ChatAction):
    r"""The user is typing a message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionTyping"]:
        return "chatActionTyping"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionTyping", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionRecordingVideo(TlObject, ChatAction):
    r"""The user is recording a video"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionRecordingVideo"]:
        return "chatActionRecordingVideo"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionRecordingVideo", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionUploadingVideo(TlObject, ChatAction):
    r"""The user is uploading a video

    Parameters:
        progress (:class:`int`):
            Upload progress, as a percentage

    """

    def __init__(self, progress: int = 0) -> None:
        self.progress: int = int(progress)
        r"""Upload progress, as a percentage"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionUploadingVideo"]:
        return "chatActionUploadingVideo"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "progress": self.progress}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionUploadingVideo", None]:
        if data:
            data_class = cls()
            data_class.progress = int(data.get("progress", 0))

        return data_class


class ChatActionRecordingVoiceNote(TlObject, ChatAction):
    r"""The user is recording a voice note"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionRecordingVoiceNote"]:
        return "chatActionRecordingVoiceNote"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionRecordingVoiceNote", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionUploadingVoiceNote(TlObject, ChatAction):
    r"""The user is uploading a voice note

    Parameters:
        progress (:class:`int`):
            Upload progress, as a percentage

    """

    def __init__(self, progress: int = 0) -> None:
        self.progress: int = int(progress)
        r"""Upload progress, as a percentage"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionUploadingVoiceNote"]:
        return "chatActionUploadingVoiceNote"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "progress": self.progress}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionUploadingVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.progress = int(data.get("progress", 0))

        return data_class


class ChatActionUploadingPhoto(TlObject, ChatAction):
    r"""The user is uploading a photo

    Parameters:
        progress (:class:`int`):
            Upload progress, as a percentage

    """

    def __init__(self, progress: int = 0) -> None:
        self.progress: int = int(progress)
        r"""Upload progress, as a percentage"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionUploadingPhoto"]:
        return "chatActionUploadingPhoto"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "progress": self.progress}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionUploadingPhoto", None]:
        if data:
            data_class = cls()
            data_class.progress = int(data.get("progress", 0))

        return data_class


class ChatActionUploadingDocument(TlObject, ChatAction):
    r"""The user is uploading a document

    Parameters:
        progress (:class:`int`):
            Upload progress, as a percentage

    """

    def __init__(self, progress: int = 0) -> None:
        self.progress: int = int(progress)
        r"""Upload progress, as a percentage"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionUploadingDocument"]:
        return "chatActionUploadingDocument"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "progress": self.progress}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionUploadingDocument", None]:
        if data:
            data_class = cls()
            data_class.progress = int(data.get("progress", 0))

        return data_class


class ChatActionChoosingSticker(TlObject, ChatAction):
    r"""The user is picking a sticker to send"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionChoosingSticker"]:
        return "chatActionChoosingSticker"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionChoosingSticker", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionChoosingLocation(TlObject, ChatAction):
    r"""The user is picking a location or venue to send"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionChoosingLocation"]:
        return "chatActionChoosingLocation"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionChoosingLocation", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionChoosingContact(TlObject, ChatAction):
    r"""The user is picking a contact to send"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionChoosingContact"]:
        return "chatActionChoosingContact"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionChoosingContact", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionStartPlayingGame(TlObject, ChatAction):
    r"""The user has started to play a game"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionStartPlayingGame"]:
        return "chatActionStartPlayingGame"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionStartPlayingGame", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionRecordingVideoNote(TlObject, ChatAction):
    r"""The user is recording a video note"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionRecordingVideoNote"]:
        return "chatActionRecordingVideoNote"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionRecordingVideoNote", None]:
        if data:
            data_class = cls()

        return data_class


class ChatActionUploadingVideoNote(TlObject, ChatAction):
    r"""The user is uploading a video note

    Parameters:
        progress (:class:`int`):
            Upload progress, as a percentage

    """

    def __init__(self, progress: int = 0) -> None:
        self.progress: int = int(progress)
        r"""Upload progress, as a percentage"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionUploadingVideoNote"]:
        return "chatActionUploadingVideoNote"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "progress": self.progress}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionUploadingVideoNote", None]:
        if data:
            data_class = cls()
            data_class.progress = int(data.get("progress", 0))

        return data_class


class ChatActionWatchingAnimations(TlObject, ChatAction):
    r"""The user is watching animations sent by the other party by clicking on an animated emoji

    Parameters:
        emoji (:class:`str`):
            The animated emoji

    """

    def __init__(self, emoji: str = "") -> None:
        self.emoji: Union[str, None] = emoji
        r"""The animated emoji"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionWatchingAnimations"]:
        return "chatActionWatchingAnimations"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emoji": self.emoji}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionWatchingAnimations", None]:
        if data:
            data_class = cls()
            data_class.emoji = data.get("emoji", "")

        return data_class


class ChatActionCancel(TlObject, ChatAction):
    r"""The user has canceled the previous action"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActionCancel"]:
        return "chatActionCancel"

    def getClass(self) -> Literal["ChatAction"]:
        return "ChatAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActionCancel", None]:
        if data:
            data_class = cls()

        return data_class


class UserStatusEmpty(TlObject, UserStatus):
    r"""The user's status has never been changed"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userStatusEmpty"]:
        return "userStatusEmpty"

    def getClass(self) -> Literal["UserStatus"]:
        return "UserStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserStatusEmpty", None]:
        if data:
            data_class = cls()

        return data_class


class UserStatusOnline(TlObject, UserStatus):
    r"""The user is online

    Parameters:
        expires (:class:`int`):
            Point in time \(Unix timestamp\) when the user's online status will expire

    """

    def __init__(self, expires: int = 0) -> None:
        self.expires: int = int(expires)
        r"""Point in time \(Unix timestamp\) when the user's online status will expire"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userStatusOnline"]:
        return "userStatusOnline"

    def getClass(self) -> Literal["UserStatus"]:
        return "UserStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "expires": self.expires}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserStatusOnline", None]:
        if data:
            data_class = cls()
            data_class.expires = int(data.get("expires", 0))

        return data_class


class UserStatusOffline(TlObject, UserStatus):
    r"""The user is offline

    Parameters:
        was_online (:class:`int`):
            Point in time \(Unix timestamp\) when the user was last online

    """

    def __init__(self, was_online: int = 0) -> None:
        self.was_online: int = int(was_online)
        r"""Point in time \(Unix timestamp\) when the user was last online"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userStatusOffline"]:
        return "userStatusOffline"

    def getClass(self) -> Literal["UserStatus"]:
        return "UserStatus"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "was_online": self.was_online}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserStatusOffline", None]:
        if data:
            data_class = cls()
            data_class.was_online = int(data.get("was_online", 0))

        return data_class


class UserStatusRecently(TlObject, UserStatus):
    r"""The user was online recently

    Parameters:
        by_my_privacy_settings (:class:`bool`):
            Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium

    """

    def __init__(self, by_my_privacy_settings: bool = False) -> None:
        self.by_my_privacy_settings: bool = bool(by_my_privacy_settings)
        r"""Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userStatusRecently"]:
        return "userStatusRecently"

    def getClass(self) -> Literal["UserStatus"]:
        return "UserStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "by_my_privacy_settings": self.by_my_privacy_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserStatusRecently", None]:
        if data:
            data_class = cls()
            data_class.by_my_privacy_settings = data.get(
                "by_my_privacy_settings", False
            )

        return data_class


class UserStatusLastWeek(TlObject, UserStatus):
    r"""The user is offline, but was online last week

    Parameters:
        by_my_privacy_settings (:class:`bool`):
            Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium

    """

    def __init__(self, by_my_privacy_settings: bool = False) -> None:
        self.by_my_privacy_settings: bool = bool(by_my_privacy_settings)
        r"""Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userStatusLastWeek"]:
        return "userStatusLastWeek"

    def getClass(self) -> Literal["UserStatus"]:
        return "UserStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "by_my_privacy_settings": self.by_my_privacy_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserStatusLastWeek", None]:
        if data:
            data_class = cls()
            data_class.by_my_privacy_settings = data.get(
                "by_my_privacy_settings", False
            )

        return data_class


class UserStatusLastMonth(TlObject, UserStatus):
    r"""The user is offline, but was online last month

    Parameters:
        by_my_privacy_settings (:class:`bool`):
            Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium

    """

    def __init__(self, by_my_privacy_settings: bool = False) -> None:
        self.by_my_privacy_settings: bool = bool(by_my_privacy_settings)
        r"""Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userStatusLastMonth"]:
        return "userStatusLastMonth"

    def getClass(self) -> Literal["UserStatus"]:
        return "UserStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "by_my_privacy_settings": self.by_my_privacy_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserStatusLastMonth", None]:
        if data:
            data_class = cls()
            data_class.by_my_privacy_settings = data.get(
                "by_my_privacy_settings", False
            )

        return data_class


class EmojiKeyword(TlObject):
    r"""Represents an emoji with its keyword

    Parameters:
        emoji (:class:`str`):
            The emoji

        keyword (:class:`str`):
            The keyword

    """

    def __init__(self, emoji: str = "", keyword: str = "") -> None:
        self.emoji: Union[str, None] = emoji
        r"""The emoji"""
        self.keyword: Union[str, None] = keyword
        r"""The keyword"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiKeyword"]:
        return "emojiKeyword"

    def getClass(self) -> Literal["EmojiKeyword"]:
        return "EmojiKeyword"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emoji": self.emoji, "keyword": self.keyword}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiKeyword", None]:
        if data:
            data_class = cls()
            data_class.emoji = data.get("emoji", "")
            data_class.keyword = data.get("keyword", "")

        return data_class


class EmojiKeywords(TlObject):
    r"""Represents a list of emojis with their keywords

    Parameters:
        emoji_keywords (:class:`List["types.EmojiKeyword"]`):
            List of emojis with their keywords

    """

    def __init__(self, emoji_keywords: List[EmojiKeyword] = None) -> None:
        self.emoji_keywords: List[EmojiKeyword] = emoji_keywords or []
        r"""List of emojis with their keywords"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiKeywords"]:
        return "emojiKeywords"

    def getClass(self) -> Literal["EmojiKeywords"]:
        return "EmojiKeywords"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emoji_keywords": self.emoji_keywords}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiKeywords", None]:
        if data:
            data_class = cls()
            data_class.emoji_keywords = data.get("emoji_keywords", None)

        return data_class


class Stickers(TlObject):
    r"""Represents a list of stickers

    Parameters:
        stickers (:class:`List["types.Sticker"]`):
            List of stickers

    """

    def __init__(self, stickers: List[Sticker] = None) -> None:
        self.stickers: List[Sticker] = stickers or []
        r"""List of stickers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickers"]:
        return "stickers"

    def getClass(self) -> Literal["Stickers"]:
        return "Stickers"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "stickers": self.stickers}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Stickers", None]:
        if data:
            data_class = cls()
            data_class.stickers = data.get("stickers", None)

        return data_class


class Emojis(TlObject):
    r"""Represents a list of emojis

    Parameters:
        emojis (:class:`List[str]`):
            List of emojis

    """

    def __init__(self, emojis: List[str] = None) -> None:
        self.emojis: List[str] = emojis or []
        r"""List of emojis"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojis"]:
        return "emojis"

    def getClass(self) -> Literal["Emojis"]:
        return "Emojis"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emojis": self.emojis}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Emojis", None]:
        if data:
            data_class = cls()
            data_class.emojis = data.get("emojis", None)

        return data_class


class StickerSet(TlObject):
    r"""Represents a sticker set

    Parameters:
        id (:class:`int`):
            Identifier of the sticker set

        title (:class:`str`):
            Title of the sticker set

        name (:class:`str`):
            Name of the sticker set

        thumbnail (:class:`"types.Thumbnail"`):
            Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null\. The file can be downloaded only before the thumbnail is changed

        thumbnail_outline (:class:`"types.Outline"`):
            Sticker set thumbnail's outline; may be null if unknown

        is_owned (:class:`bool`):
            True, if the sticker set is owned by the current user

        is_installed (:class:`bool`):
            True, if the sticker set has been installed by the current user

        is_archived (:class:`bool`):
            True, if the sticker set has been archived\. A sticker set can't be installed and archived simultaneously

        is_official (:class:`bool`):
            True, if the sticker set is official

        sticker_type (:class:`"types.StickerType"`):
            Type of the stickers in the set

        needs_repainting (:class:`bool`):
            True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only

        is_allowed_as_chat_emoji_status (:class:`bool`):
            True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only

        is_viewed (:class:`bool`):
            True for already viewed trending sticker sets

        stickers (:class:`List["types.Sticker"]`):
            List of stickers in this set

        emojis (:class:`List["types.Emojis"]`):
            A list of emojis corresponding to the stickers in the same order\. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object

    """

    def __init__(
        self,
        id: int = 0,
        title: str = "",
        name: str = "",
        thumbnail: Thumbnail = None,
        thumbnail_outline: Outline = None,
        is_owned: bool = False,
        is_installed: bool = False,
        is_archived: bool = False,
        is_official: bool = False,
        sticker_type: StickerType = None,
        needs_repainting: bool = False,
        is_allowed_as_chat_emoji_status: bool = False,
        is_viewed: bool = False,
        stickers: List[Sticker] = None,
        emojis: List[Emojis] = None,
    ) -> None:
        self.id: int = int(id)
        r"""Identifier of the sticker set"""
        self.title: Union[str, None] = title
        r"""Title of the sticker set"""
        self.name: Union[str, None] = name
        r"""Name of the sticker set"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null\. The file can be downloaded only before the thumbnail is changed"""
        self.thumbnail_outline: Union[Outline, None] = thumbnail_outline
        r"""Sticker set thumbnail's outline; may be null if unknown"""
        self.is_owned: bool = bool(is_owned)
        r"""True, if the sticker set is owned by the current user"""
        self.is_installed: bool = bool(is_installed)
        r"""True, if the sticker set has been installed by the current user"""
        self.is_archived: bool = bool(is_archived)
        r"""True, if the sticker set has been archived\. A sticker set can't be installed and archived simultaneously"""
        self.is_official: bool = bool(is_official)
        r"""True, if the sticker set is official"""
        self.sticker_type: Union[
            StickerTypeRegular, StickerTypeMask, StickerTypeCustomEmoji, None
        ] = sticker_type
        r"""Type of the stickers in the set"""
        self.needs_repainting: bool = bool(needs_repainting)
        r"""True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only"""
        self.is_allowed_as_chat_emoji_status: bool = bool(
            is_allowed_as_chat_emoji_status
        )
        r"""True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only"""
        self.is_viewed: bool = bool(is_viewed)
        r"""True for already viewed trending sticker sets"""
        self.stickers: List[Sticker] = stickers or []
        r"""List of stickers in this set"""
        self.emojis: List[Emojis] = emojis or []
        r"""A list of emojis corresponding to the stickers in the same order\. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerSet"]:
        return "stickerSet"

    def getClass(self) -> Literal["StickerSet"]:
        return "StickerSet"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "name": self.name,
            "thumbnail": self.thumbnail,
            "thumbnail_outline": self.thumbnail_outline,
            "is_owned": self.is_owned,
            "is_installed": self.is_installed,
            "is_archived": self.is_archived,
            "is_official": self.is_official,
            "sticker_type": self.sticker_type,
            "needs_repainting": self.needs_repainting,
            "is_allowed_as_chat_emoji_status": self.is_allowed_as_chat_emoji_status,
            "is_viewed": self.is_viewed,
            "stickers": self.stickers,
            "emojis": self.emojis,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerSet", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.title = data.get("title", "")
            data_class.name = data.get("name", "")
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.thumbnail_outline = data.get("thumbnail_outline", None)
            data_class.is_owned = data.get("is_owned", False)
            data_class.is_installed = data.get("is_installed", False)
            data_class.is_archived = data.get("is_archived", False)
            data_class.is_official = data.get("is_official", False)
            data_class.sticker_type = data.get("sticker_type", None)
            data_class.needs_repainting = data.get("needs_repainting", False)
            data_class.is_allowed_as_chat_emoji_status = data.get(
                "is_allowed_as_chat_emoji_status", False
            )
            data_class.is_viewed = data.get("is_viewed", False)
            data_class.stickers = data.get("stickers", None)
            data_class.emojis = data.get("emojis", None)

        return data_class


class StickerSetInfo(TlObject):
    r"""Represents short information about a sticker set

    Parameters:
        id (:class:`int`):
            Identifier of the sticker set

        title (:class:`str`):
            Title of the sticker set

        name (:class:`str`):
            Name of the sticker set

        thumbnail (:class:`"types.Thumbnail"`):
            Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null\. The file can be downloaded only before the thumbnail is changed

        thumbnail_outline (:class:`"types.Outline"`):
            Sticker set thumbnail's outline; may be null if unknown

        is_owned (:class:`bool`):
            True, if the sticker set is owned by the current user

        is_installed (:class:`bool`):
            True, if the sticker set has been installed by the current user

        is_archived (:class:`bool`):
            True, if the sticker set has been archived\. A sticker set can't be installed and archived simultaneously

        is_official (:class:`bool`):
            True, if the sticker set is official

        sticker_type (:class:`"types.StickerType"`):
            Type of the stickers in the set

        needs_repainting (:class:`bool`):
            True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only

        is_allowed_as_chat_emoji_status (:class:`bool`):
            True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only

        is_viewed (:class:`bool`):
            True for already viewed trending sticker sets

        size (:class:`int`):
            Total number of stickers in the set

        covers (:class:`List["types.Sticker"]`):
            Up to the first 5 stickers from the set, depending on the context\. If the application needs more stickers the full sticker set needs to be requested

    """

    def __init__(
        self,
        id: int = 0,
        title: str = "",
        name: str = "",
        thumbnail: Thumbnail = None,
        thumbnail_outline: Outline = None,
        is_owned: bool = False,
        is_installed: bool = False,
        is_archived: bool = False,
        is_official: bool = False,
        sticker_type: StickerType = None,
        needs_repainting: bool = False,
        is_allowed_as_chat_emoji_status: bool = False,
        is_viewed: bool = False,
        size: int = 0,
        covers: List[Sticker] = None,
    ) -> None:
        self.id: int = int(id)
        r"""Identifier of the sticker set"""
        self.title: Union[str, None] = title
        r"""Title of the sticker set"""
        self.name: Union[str, None] = name
        r"""Name of the sticker set"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null\. The file can be downloaded only before the thumbnail is changed"""
        self.thumbnail_outline: Union[Outline, None] = thumbnail_outline
        r"""Sticker set thumbnail's outline; may be null if unknown"""
        self.is_owned: bool = bool(is_owned)
        r"""True, if the sticker set is owned by the current user"""
        self.is_installed: bool = bool(is_installed)
        r"""True, if the sticker set has been installed by the current user"""
        self.is_archived: bool = bool(is_archived)
        r"""True, if the sticker set has been archived\. A sticker set can't be installed and archived simultaneously"""
        self.is_official: bool = bool(is_official)
        r"""True, if the sticker set is official"""
        self.sticker_type: Union[
            StickerTypeRegular, StickerTypeMask, StickerTypeCustomEmoji, None
        ] = sticker_type
        r"""Type of the stickers in the set"""
        self.needs_repainting: bool = bool(needs_repainting)
        r"""True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only"""
        self.is_allowed_as_chat_emoji_status: bool = bool(
            is_allowed_as_chat_emoji_status
        )
        r"""True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only"""
        self.is_viewed: bool = bool(is_viewed)
        r"""True for already viewed trending sticker sets"""
        self.size: int = int(size)
        r"""Total number of stickers in the set"""
        self.covers: List[Sticker] = covers or []
        r"""Up to the first 5 stickers from the set, depending on the context\. If the application needs more stickers the full sticker set needs to be requested"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerSetInfo"]:
        return "stickerSetInfo"

    def getClass(self) -> Literal["StickerSetInfo"]:
        return "StickerSetInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "name": self.name,
            "thumbnail": self.thumbnail,
            "thumbnail_outline": self.thumbnail_outline,
            "is_owned": self.is_owned,
            "is_installed": self.is_installed,
            "is_archived": self.is_archived,
            "is_official": self.is_official,
            "sticker_type": self.sticker_type,
            "needs_repainting": self.needs_repainting,
            "is_allowed_as_chat_emoji_status": self.is_allowed_as_chat_emoji_status,
            "is_viewed": self.is_viewed,
            "size": self.size,
            "covers": self.covers,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerSetInfo", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.title = data.get("title", "")
            data_class.name = data.get("name", "")
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.thumbnail_outline = data.get("thumbnail_outline", None)
            data_class.is_owned = data.get("is_owned", False)
            data_class.is_installed = data.get("is_installed", False)
            data_class.is_archived = data.get("is_archived", False)
            data_class.is_official = data.get("is_official", False)
            data_class.sticker_type = data.get("sticker_type", None)
            data_class.needs_repainting = data.get("needs_repainting", False)
            data_class.is_allowed_as_chat_emoji_status = data.get(
                "is_allowed_as_chat_emoji_status", False
            )
            data_class.is_viewed = data.get("is_viewed", False)
            data_class.size = int(data.get("size", 0))
            data_class.covers = data.get("covers", None)

        return data_class


class StickerSets(TlObject):
    r"""Represents a list of sticker sets

    Parameters:
        total_count (:class:`int`):
            Approximate total number of sticker sets found

        sets (:class:`List["types.StickerSetInfo"]`):
            List of sticker sets

    """

    def __init__(self, total_count: int = 0, sets: List[StickerSetInfo] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of sticker sets found"""
        self.sets: List[StickerSetInfo] = sets or []
        r"""List of sticker sets"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stickerSets"]:
        return "stickerSets"

    def getClass(self) -> Literal["StickerSets"]:
        return "StickerSets"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "sets": self.sets,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StickerSets", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.sets = data.get("sets", None)

        return data_class


class TrendingStickerSets(TlObject):
    r"""Represents a list of trending sticker sets

    Parameters:
        total_count (:class:`int`):
            Approximate total number of trending sticker sets

        sets (:class:`List["types.StickerSetInfo"]`):
            List of trending sticker sets

        is_premium (:class:`bool`):
            True, if the list contains sticker sets with premium stickers

    """

    def __init__(
        self,
        total_count: int = 0,
        sets: List[StickerSetInfo] = None,
        is_premium: bool = False,
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of trending sticker sets"""
        self.sets: List[StickerSetInfo] = sets or []
        r"""List of trending sticker sets"""
        self.is_premium: bool = bool(is_premium)
        r"""True, if the list contains sticker sets with premium stickers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["trendingStickerSets"]:
        return "trendingStickerSets"

    def getClass(self) -> Literal["TrendingStickerSets"]:
        return "TrendingStickerSets"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "sets": self.sets,
            "is_premium": self.is_premium,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TrendingStickerSets", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.sets = data.get("sets", None)
            data_class.is_premium = data.get("is_premium", False)

        return data_class


class EmojiCategorySourceSearch(TlObject, EmojiCategorySource):
    r"""The category contains a list of similar emoji to search for in getStickers and searchStickers for stickers, or getInlineQueryResults with the bot getOption\(\"animation\_search\_bot\_username\"\) for animations

    Parameters:
        emojis (:class:`List[str]`):
            List of emojis to search for

    """

    def __init__(self, emojis: List[str] = None) -> None:
        self.emojis: List[str] = emojis or []
        r"""List of emojis to search for"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategorySourceSearch"]:
        return "emojiCategorySourceSearch"

    def getClass(self) -> Literal["EmojiCategorySource"]:
        return "EmojiCategorySource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emojis": self.emojis}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategorySourceSearch", None]:
        if data:
            data_class = cls()
            data_class.emojis = data.get("emojis", None)

        return data_class


class EmojiCategorySourcePremium(TlObject, EmojiCategorySource):
    r"""The category contains premium stickers that must be found by getPremiumStickers"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategorySourcePremium"]:
        return "emojiCategorySourcePremium"

    def getClass(self) -> Literal["EmojiCategorySource"]:
        return "EmojiCategorySource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategorySourcePremium", None]:
        if data:
            data_class = cls()

        return data_class


class EmojiCategory(TlObject):
    r"""Describes an emoji category

    Parameters:
        name (:class:`str`):
            Name of the category

        icon (:class:`"types.Sticker"`):
            Custom emoji sticker, which represents icon of the category

        source (:class:`"types.EmojiCategorySource"`):
            Source of stickers for the emoji category

        is_greeting (:class:`bool`):
            True, if the category must be shown first when choosing a sticker for the start page

    """

    def __init__(
        self,
        name: str = "",
        icon: Sticker = None,
        source: EmojiCategorySource = None,
        is_greeting: bool = False,
    ) -> None:
        self.name: Union[str, None] = name
        r"""Name of the category"""
        self.icon: Union[Sticker, None] = icon
        r"""Custom emoji sticker, which represents icon of the category"""
        self.source: Union[
            EmojiCategorySourceSearch, EmojiCategorySourcePremium, None
        ] = source
        r"""Source of stickers for the emoji category"""
        self.is_greeting: bool = bool(is_greeting)
        r"""True, if the category must be shown first when choosing a sticker for the start page"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategory"]:
        return "emojiCategory"

    def getClass(self) -> Literal["EmojiCategory"]:
        return "EmojiCategory"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "icon": self.icon,
            "source": self.source,
            "is_greeting": self.is_greeting,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategory", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.icon = data.get("icon", None)
            data_class.source = data.get("source", None)
            data_class.is_greeting = data.get("is_greeting", False)

        return data_class


class EmojiCategories(TlObject):
    r"""Represents a list of emoji categories

    Parameters:
        categories (:class:`List["types.EmojiCategory"]`):
            List of categories

    """

    def __init__(self, categories: List[EmojiCategory] = None) -> None:
        self.categories: List[EmojiCategory] = categories or []
        r"""List of categories"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategories"]:
        return "emojiCategories"

    def getClass(self) -> Literal["EmojiCategories"]:
        return "EmojiCategories"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "categories": self.categories}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategories", None]:
        if data:
            data_class = cls()
            data_class.categories = data.get("categories", None)

        return data_class


class EmojiCategoryTypeDefault(TlObject, EmojiCategoryType):
    r"""The category must be used by default \(e\.g\., for custom emoji or animation search\)"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategoryTypeDefault"]:
        return "emojiCategoryTypeDefault"

    def getClass(self) -> Literal["EmojiCategoryType"]:
        return "EmojiCategoryType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategoryTypeDefault", None]:
        if data:
            data_class = cls()

        return data_class


class EmojiCategoryTypeRegularStickers(TlObject, EmojiCategoryType):
    r"""The category must be used by default for regular sticker selection\. It may contain greeting emoji category and premium stickers"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategoryTypeRegularStickers"]:
        return "emojiCategoryTypeRegularStickers"

    def getClass(self) -> Literal["EmojiCategoryType"]:
        return "EmojiCategoryType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategoryTypeRegularStickers", None]:
        if data:
            data_class = cls()

        return data_class


class EmojiCategoryTypeEmojiStatus(TlObject, EmojiCategoryType):
    r"""The category must be used for emoji status selection"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategoryTypeEmojiStatus"]:
        return "emojiCategoryTypeEmojiStatus"

    def getClass(self) -> Literal["EmojiCategoryType"]:
        return "EmojiCategoryType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategoryTypeEmojiStatus", None]:
        if data:
            data_class = cls()

        return data_class


class EmojiCategoryTypeChatPhoto(TlObject, EmojiCategoryType):
    r"""The category must be used for chat photo emoji selection"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiCategoryTypeChatPhoto"]:
        return "emojiCategoryTypeChatPhoto"

    def getClass(self) -> Literal["EmojiCategoryType"]:
        return "EmojiCategoryType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiCategoryTypeChatPhoto", None]:
        if data:
            data_class = cls()

        return data_class


class CurrentWeather(TlObject):
    r"""Describes the current weather

    Parameters:
        temperature (:class:`float`):
            Temperature, in degree Celsius

        emoji (:class:`str`):
            Emoji representing the weather

    """

    def __init__(self, temperature: float = 0.0, emoji: str = "") -> None:
        self.temperature: float = float(temperature)
        r"""Temperature, in degree Celsius"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji representing the weather"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["currentWeather"]:
        return "currentWeather"

    def getClass(self) -> Literal["CurrentWeather"]:
        return "CurrentWeather"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "temperature": self.temperature,
            "emoji": self.emoji,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CurrentWeather", None]:
        if data:
            data_class = cls()
            data_class.temperature = data.get("temperature", 0.0)
            data_class.emoji = data.get("emoji", "")

        return data_class


class StoryAreaPosition(TlObject):
    r"""Describes position of a clickable rectangle area on a story media

    Parameters:
        x_percentage (:class:`float`):
            The abscissa of the rectangle's center, as a percentage of the media width

        y_percentage (:class:`float`):
            The ordinate of the rectangle's center, as a percentage of the media height

        width_percentage (:class:`float`):
            The width of the rectangle, as a percentage of the media width

        height_percentage (:class:`float`):
            The height of the rectangle, as a percentage of the media height

        rotation_angle (:class:`float`):
            Clockwise rotation angle of the rectangle, in degrees; 0\-360

        corner_radius_percentage (:class:`float`):
            The radius of the rectangle corner rounding, as a percentage of the media width

    """

    def __init__(
        self,
        x_percentage: float = 0.0,
        y_percentage: float = 0.0,
        width_percentage: float = 0.0,
        height_percentage: float = 0.0,
        rotation_angle: float = 0.0,
        corner_radius_percentage: float = 0.0,
    ) -> None:
        self.x_percentage: float = float(x_percentage)
        r"""The abscissa of the rectangle's center, as a percentage of the media width"""
        self.y_percentage: float = float(y_percentage)
        r"""The ordinate of the rectangle's center, as a percentage of the media height"""
        self.width_percentage: float = float(width_percentage)
        r"""The width of the rectangle, as a percentage of the media width"""
        self.height_percentage: float = float(height_percentage)
        r"""The height of the rectangle, as a percentage of the media height"""
        self.rotation_angle: float = float(rotation_angle)
        r"""Clockwise rotation angle of the rectangle, in degrees; 0\-360"""
        self.corner_radius_percentage: float = float(corner_radius_percentage)
        r"""The radius of the rectangle corner rounding, as a percentage of the media width"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaPosition"]:
        return "storyAreaPosition"

    def getClass(self) -> Literal["StoryAreaPosition"]:
        return "StoryAreaPosition"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "x_percentage": self.x_percentage,
            "y_percentage": self.y_percentage,
            "width_percentage": self.width_percentage,
            "height_percentage": self.height_percentage,
            "rotation_angle": self.rotation_angle,
            "corner_radius_percentage": self.corner_radius_percentage,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaPosition", None]:
        if data:
            data_class = cls()
            data_class.x_percentage = data.get("x_percentage", 0.0)
            data_class.y_percentage = data.get("y_percentage", 0.0)
            data_class.width_percentage = data.get("width_percentage", 0.0)
            data_class.height_percentage = data.get("height_percentage", 0.0)
            data_class.rotation_angle = data.get("rotation_angle", 0.0)
            data_class.corner_radius_percentage = data.get(
                "corner_radius_percentage", 0.0
            )

        return data_class


class StoryAreaTypeLocation(TlObject, StoryAreaType):
    r"""An area pointing to a location

    Parameters:
        location (:class:`"types.Location"`):
            The location

        address (:class:`"types.LocationAddress"`):
            Address of the location; may be null if unknown

    """

    def __init__(
        self, location: Location = None, address: LocationAddress = None
    ) -> None:
        self.location: Union[Location, None] = location
        r"""The location"""
        self.address: Union[LocationAddress, None] = address
        r"""Address of the location; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaTypeLocation"]:
        return "storyAreaTypeLocation"

    def getClass(self) -> Literal["StoryAreaType"]:
        return "StoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "address": self.address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaTypeLocation", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.address = data.get("address", None)

        return data_class


class StoryAreaTypeVenue(TlObject, StoryAreaType):
    r"""An area pointing to a venue

    Parameters:
        venue (:class:`"types.Venue"`):
            Information about the venue

    """

    def __init__(self, venue: Venue = None) -> None:
        self.venue: Union[Venue, None] = venue
        r"""Information about the venue"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaTypeVenue"]:
        return "storyAreaTypeVenue"

    def getClass(self) -> Literal["StoryAreaType"]:
        return "StoryAreaType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "venue": self.venue}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaTypeVenue", None]:
        if data:
            data_class = cls()
            data_class.venue = data.get("venue", None)

        return data_class


class StoryAreaTypeSuggestedReaction(TlObject, StoryAreaType):
    r"""An area pointing to a suggested reaction\. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked

    Parameters:
        reaction_type (:class:`"types.ReactionType"`):
            Type of the reaction

        total_count (:class:`int`):
            Number of times the reaction was added

        is_dark (:class:`bool`):
            True, if reaction has a dark background

        is_flipped (:class:`bool`):
            True, if reaction corner is flipped

    """

    def __init__(
        self,
        reaction_type: ReactionType = None,
        total_count: int = 0,
        is_dark: bool = False,
        is_flipped: bool = False,
    ) -> None:
        self.reaction_type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = reaction_type
        r"""Type of the reaction"""
        self.total_count: int = int(total_count)
        r"""Number of times the reaction was added"""
        self.is_dark: bool = bool(is_dark)
        r"""True, if reaction has a dark background"""
        self.is_flipped: bool = bool(is_flipped)
        r"""True, if reaction corner is flipped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaTypeSuggestedReaction"]:
        return "storyAreaTypeSuggestedReaction"

    def getClass(self) -> Literal["StoryAreaType"]:
        return "StoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reaction_type": self.reaction_type,
            "total_count": self.total_count,
            "is_dark": self.is_dark,
            "is_flipped": self.is_flipped,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaTypeSuggestedReaction", None]:
        if data:
            data_class = cls()
            data_class.reaction_type = data.get("reaction_type", None)
            data_class.total_count = int(data.get("total_count", 0))
            data_class.is_dark = data.get("is_dark", False)
            data_class.is_flipped = data.get("is_flipped", False)

        return data_class


class StoryAreaTypeMessage(TlObject, StoryAreaType):
    r"""An area pointing to a message

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat with the message

        message_id (:class:`int`):
            Identifier of the message

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat with the message"""
        self.message_id: int = int(message_id)
        r"""Identifier of the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaTypeMessage"]:
        return "storyAreaTypeMessage"

    def getClass(self) -> Literal["StoryAreaType"]:
        return "StoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaTypeMessage", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class StoryAreaTypeLink(TlObject, StoryAreaType):
    r"""An area pointing to a HTTP or tg:// link

    Parameters:
        url (:class:`str`):
            HTTP or tg:// URL to be opened when the area is clicked

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""HTTP or tg:// URL to be opened when the area is clicked"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaTypeLink"]:
        return "storyAreaTypeLink"

    def getClass(self) -> Literal["StoryAreaType"]:
        return "StoryAreaType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaTypeLink", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class StoryAreaTypeWeather(TlObject, StoryAreaType):
    r"""An area with information about weather

    Parameters:
        temperature (:class:`float`):
            Temperature, in degree Celsius

        emoji (:class:`str`):
            Emoji representing the weather

        background_color (:class:`int`):
            A color of the area background in the ARGB format

    """

    def __init__(
        self, temperature: float = 0.0, emoji: str = "", background_color: int = 0
    ) -> None:
        self.temperature: float = float(temperature)
        r"""Temperature, in degree Celsius"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji representing the weather"""
        self.background_color: int = int(background_color)
        r"""A color of the area background in the ARGB format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaTypeWeather"]:
        return "storyAreaTypeWeather"

    def getClass(self) -> Literal["StoryAreaType"]:
        return "StoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "temperature": self.temperature,
            "emoji": self.emoji,
            "background_color": self.background_color,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaTypeWeather", None]:
        if data:
            data_class = cls()
            data_class.temperature = data.get("temperature", 0.0)
            data_class.emoji = data.get("emoji", "")
            data_class.background_color = int(data.get("background_color", 0))

        return data_class


class StoryAreaTypeUpgradedGift(TlObject, StoryAreaType):
    r"""An area with an upgraded gift

    Parameters:
        gift_name (:class:`str`):
            Unique name of the upgraded gift

    """

    def __init__(self, gift_name: str = "") -> None:
        self.gift_name: Union[str, None] = gift_name
        r"""Unique name of the upgraded gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyAreaTypeUpgradedGift"]:
        return "storyAreaTypeUpgradedGift"

    def getClass(self) -> Literal["StoryAreaType"]:
        return "StoryAreaType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "gift_name": self.gift_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryAreaTypeUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.gift_name = data.get("gift_name", "")

        return data_class


class StoryArea(TlObject):
    r"""Describes a clickable rectangle area on a story media

    Parameters:
        position (:class:`"types.StoryAreaPosition"`):
            Position of the area

        type (:class:`"types.StoryAreaType"`):
            Type of the area

    """

    def __init__(
        self, position: StoryAreaPosition = None, type: StoryAreaType = None
    ) -> None:
        self.position: Union[StoryAreaPosition, None] = position
        r"""Position of the area"""
        self.type: Union[
            StoryAreaTypeLocation,
            StoryAreaTypeVenue,
            StoryAreaTypeSuggestedReaction,
            StoryAreaTypeMessage,
            StoryAreaTypeLink,
            StoryAreaTypeWeather,
            StoryAreaTypeUpgradedGift,
            None,
        ] = type
        r"""Type of the area"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyArea"]:
        return "storyArea"

    def getClass(self) -> Literal["StoryArea"]:
        return "StoryArea"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "position": self.position, "type": self.type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryArea", None]:
        if data:
            data_class = cls()
            data_class.position = data.get("position", None)
            data_class.type = data.get("type", None)

        return data_class


class InputStoryAreaTypeLocation(TlObject, InputStoryAreaType):
    r"""An area pointing to a location

    Parameters:
        location (:class:`"types.Location"`):
            The location

        address (:class:`"types.LocationAddress"`):
            Address of the location; pass null if unknown

    """

    def __init__(
        self, location: Location = None, address: LocationAddress = None
    ) -> None:
        self.location: Union[Location, None] = location
        r"""The location"""
        self.address: Union[LocationAddress, None] = address
        r"""Address of the location; pass null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypeLocation"]:
        return "inputStoryAreaTypeLocation"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "location": self.location,
            "address": self.address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreaTypeLocation", None]:
        if data:
            data_class = cls()
            data_class.location = data.get("location", None)
            data_class.address = data.get("address", None)

        return data_class


class InputStoryAreaTypeFoundVenue(TlObject, InputStoryAreaType):
    r"""An area pointing to a venue found by the bot getOption\(\"venue\_search\_bot\_username\"\)

    Parameters:
        query_id (:class:`int`):
            Identifier of the inline query, used to found the venue

        result_id (:class:`str`):
            Identifier of the inline query result

    """

    def __init__(self, query_id: int = 0, result_id: str = "") -> None:
        self.query_id: int = int(query_id)
        r"""Identifier of the inline query, used to found the venue"""
        self.result_id: Union[str, None] = result_id
        r"""Identifier of the inline query result"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypeFoundVenue"]:
        return "inputStoryAreaTypeFoundVenue"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "query_id": self.query_id,
            "result_id": self.result_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreaTypeFoundVenue", None]:
        if data:
            data_class = cls()
            data_class.query_id = int(data.get("query_id", 0))
            data_class.result_id = data.get("result_id", "")

        return data_class


class InputStoryAreaTypePreviousVenue(TlObject, InputStoryAreaType):
    r"""An area pointing to a venue already added to the story

    Parameters:
        venue_provider (:class:`str`):
            Provider of the venue

        venue_id (:class:`str`):
            Identifier of the venue in the provider database

    """

    def __init__(self, venue_provider: str = "", venue_id: str = "") -> None:
        self.venue_provider: Union[str, None] = venue_provider
        r"""Provider of the venue"""
        self.venue_id: Union[str, None] = venue_id
        r"""Identifier of the venue in the provider database"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypePreviousVenue"]:
        return "inputStoryAreaTypePreviousVenue"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "venue_provider": self.venue_provider,
            "venue_id": self.venue_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreaTypePreviousVenue", None]:
        if data:
            data_class = cls()
            data_class.venue_provider = data.get("venue_provider", "")
            data_class.venue_id = data.get("venue_id", "")

        return data_class


class InputStoryAreaTypeSuggestedReaction(TlObject, InputStoryAreaType):
    r"""An area pointing to a suggested reaction

    Parameters:
        reaction_type (:class:`"types.ReactionType"`):
            Type of the reaction

        is_dark (:class:`bool`):
            True, if reaction has a dark background

        is_flipped (:class:`bool`):
            True, if reaction corner is flipped

    """

    def __init__(
        self,
        reaction_type: ReactionType = None,
        is_dark: bool = False,
        is_flipped: bool = False,
    ) -> None:
        self.reaction_type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = reaction_type
        r"""Type of the reaction"""
        self.is_dark: bool = bool(is_dark)
        r"""True, if reaction has a dark background"""
        self.is_flipped: bool = bool(is_flipped)
        r"""True, if reaction corner is flipped"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypeSuggestedReaction"]:
        return "inputStoryAreaTypeSuggestedReaction"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reaction_type": self.reaction_type,
            "is_dark": self.is_dark,
            "is_flipped": self.is_flipped,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InputStoryAreaTypeSuggestedReaction", None]:
        if data:
            data_class = cls()
            data_class.reaction_type = data.get("reaction_type", None)
            data_class.is_dark = data.get("is_dark", False)
            data_class.is_flipped = data.get("is_flipped", False)

        return data_class


class InputStoryAreaTypeMessage(TlObject, InputStoryAreaType):
    r"""An area pointing to a message

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat with the message\. Currently, the chat must be a supergroup or a channel chat

        message_id (:class:`int`):
            Identifier of the message\. Use messageProperties\.can\_be\_shared\_in\_story to check whether the message is suitable

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat with the message\. Currently, the chat must be a supergroup or a channel chat"""
        self.message_id: int = int(message_id)
        r"""Identifier of the message\. Use messageProperties\.can\_be\_shared\_in\_story to check whether the message is suitable"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypeMessage"]:
        return "inputStoryAreaTypeMessage"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreaTypeMessage", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class InputStoryAreaTypeLink(TlObject, InputStoryAreaType):
    r"""An area pointing to a HTTP or tg:// link

    Parameters:
        url (:class:`str`):
            HTTP or tg:// URL to be opened when the area is clicked

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""HTTP or tg:// URL to be opened when the area is clicked"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypeLink"]:
        return "inputStoryAreaTypeLink"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreaTypeLink", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class InputStoryAreaTypeWeather(TlObject, InputStoryAreaType):
    r"""An area with information about weather

    Parameters:
        temperature (:class:`float`):
            Temperature, in degree Celsius

        emoji (:class:`str`):
            Emoji representing the weather

        background_color (:class:`int`):
            A color of the area background in the ARGB format

    """

    def __init__(
        self, temperature: float = 0.0, emoji: str = "", background_color: int = 0
    ) -> None:
        self.temperature: float = float(temperature)
        r"""Temperature, in degree Celsius"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji representing the weather"""
        self.background_color: int = int(background_color)
        r"""A color of the area background in the ARGB format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypeWeather"]:
        return "inputStoryAreaTypeWeather"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "temperature": self.temperature,
            "emoji": self.emoji,
            "background_color": self.background_color,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreaTypeWeather", None]:
        if data:
            data_class = cls()
            data_class.temperature = data.get("temperature", 0.0)
            data_class.emoji = data.get("emoji", "")
            data_class.background_color = int(data.get("background_color", 0))

        return data_class


class InputStoryAreaTypeUpgradedGift(TlObject, InputStoryAreaType):
    r"""An area with an upgraded gift

    Parameters:
        gift_name (:class:`str`):
            Unique name of the upgraded gift

    """

    def __init__(self, gift_name: str = "") -> None:
        self.gift_name: Union[str, None] = gift_name
        r"""Unique name of the upgraded gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreaTypeUpgradedGift"]:
        return "inputStoryAreaTypeUpgradedGift"

    def getClass(self) -> Literal["InputStoryAreaType"]:
        return "InputStoryAreaType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "gift_name": self.gift_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreaTypeUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.gift_name = data.get("gift_name", "")

        return data_class


class InputStoryArea(TlObject):
    r"""Describes a clickable rectangle area on a story media to be added

    Parameters:
        position (:class:`"types.StoryAreaPosition"`):
            Position of the area

        type (:class:`"types.InputStoryAreaType"`):
            Type of the area

    """

    def __init__(
        self, position: StoryAreaPosition = None, type: InputStoryAreaType = None
    ) -> None:
        self.position: Union[StoryAreaPosition, None] = position
        r"""Position of the area"""
        self.type: Union[
            InputStoryAreaTypeLocation,
            InputStoryAreaTypeFoundVenue,
            InputStoryAreaTypePreviousVenue,
            InputStoryAreaTypeSuggestedReaction,
            InputStoryAreaTypeMessage,
            InputStoryAreaTypeLink,
            InputStoryAreaTypeWeather,
            InputStoryAreaTypeUpgradedGift,
            None,
        ] = type
        r"""Type of the area"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryArea"]:
        return "inputStoryArea"

    def getClass(self) -> Literal["InputStoryArea"]:
        return "InputStoryArea"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "position": self.position, "type": self.type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryArea", None]:
        if data:
            data_class = cls()
            data_class.position = data.get("position", None)
            data_class.type = data.get("type", None)

        return data_class


class InputStoryAreas(TlObject):
    r"""Contains a list of story areas to be added

    Parameters:
        areas (:class:`List["types.InputStoryArea"]`):
            List of input story areas\. Currently, a story can have up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up to getOption\(\"story\_suggested\_reaction\_area\_count\_max\"\) inputStoryAreaTypeSuggestedReaction areas, up to 1 inputStoryAreaTypeMessage area, up to getOption\(\"story\_link\_area\_count\_max\"\) inputStoryAreaTypeLink areas if the current user is a Telegram Premium user, up to 3 inputStoryAreaTypeWeather areas, and up to 1 inputStoryAreaTypeUpgradedGift area

    """

    def __init__(self, areas: List[InputStoryArea] = None) -> None:
        self.areas: List[InputStoryArea] = areas or []
        r"""List of input story areas\. Currently, a story can have up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up to getOption\(\"story\_suggested\_reaction\_area\_count\_max\"\) inputStoryAreaTypeSuggestedReaction areas, up to 1 inputStoryAreaTypeMessage area, up to getOption\(\"story\_link\_area\_count\_max\"\) inputStoryAreaTypeLink areas if the current user is a Telegram Premium user, up to 3 inputStoryAreaTypeWeather areas, and up to 1 inputStoryAreaTypeUpgradedGift area"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryAreas"]:
        return "inputStoryAreas"

    def getClass(self) -> Literal["InputStoryAreas"]:
        return "InputStoryAreas"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "areas": self.areas}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryAreas", None]:
        if data:
            data_class = cls()
            data_class.areas = data.get("areas", None)

        return data_class


class StoryVideo(TlObject):
    r"""Describes a video file sent in a story

    Parameters:
        duration (:class:`float`):
            Duration of the video, in seconds

        width (:class:`int`):
            Video width

        height (:class:`int`):
            Video height

        has_stickers (:class:`bool`):
            True, if stickers were added to the video\. The list of corresponding sticker sets can be received using getAttachedStickerSets

        is_animation (:class:`bool`):
            True, if the video has no sound

        minithumbnail (:class:`"types.Minithumbnail"`):
            Video minithumbnail; may be null

        thumbnail (:class:`"types.Thumbnail"`):
            Video thumbnail in JPEG or MPEG4 format; may be null

        preload_prefix_size (:class:`int`):
            Size of file prefix, which is expected to be preloaded, in bytes

        cover_frame_timestamp (:class:`float`):
            Timestamp of the frame used as video thumbnail

        video (:class:`"types.File"`):
            File containing the video

    """

    def __init__(
        self,
        duration: float = 0.0,
        width: int = 0,
        height: int = 0,
        has_stickers: bool = False,
        is_animation: bool = False,
        minithumbnail: Minithumbnail = None,
        thumbnail: Thumbnail = None,
        preload_prefix_size: int = 0,
        cover_frame_timestamp: float = 0.0,
        video: File = None,
    ) -> None:
        self.duration: float = float(duration)
        r"""Duration of the video, in seconds"""
        self.width: int = int(width)
        r"""Video width"""
        self.height: int = int(height)
        r"""Video height"""
        self.has_stickers: bool = bool(has_stickers)
        r"""True, if stickers were added to the video\. The list of corresponding sticker sets can be received using getAttachedStickerSets"""
        self.is_animation: bool = bool(is_animation)
        r"""True, if the video has no sound"""
        self.minithumbnail: Union[Minithumbnail, None] = minithumbnail
        r"""Video minithumbnail; may be null"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Video thumbnail in JPEG or MPEG4 format; may be null"""
        self.preload_prefix_size: int = int(preload_prefix_size)
        r"""Size of file prefix, which is expected to be preloaded, in bytes"""
        self.cover_frame_timestamp: float = float(cover_frame_timestamp)
        r"""Timestamp of the frame used as video thumbnail"""
        self.video: Union[File, None] = video
        r"""File containing the video"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyVideo"]:
        return "storyVideo"

    def getClass(self) -> Literal["StoryVideo"]:
        return "StoryVideo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "duration": self.duration,
            "width": self.width,
            "height": self.height,
            "has_stickers": self.has_stickers,
            "is_animation": self.is_animation,
            "minithumbnail": self.minithumbnail,
            "thumbnail": self.thumbnail,
            "preload_prefix_size": self.preload_prefix_size,
            "cover_frame_timestamp": self.cover_frame_timestamp,
            "video": self.video,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryVideo", None]:
        if data:
            data_class = cls()
            data_class.duration = data.get("duration", 0.0)
            data_class.width = int(data.get("width", 0))
            data_class.height = int(data.get("height", 0))
            data_class.has_stickers = data.get("has_stickers", False)
            data_class.is_animation = data.get("is_animation", False)
            data_class.minithumbnail = data.get("minithumbnail", None)
            data_class.thumbnail = data.get("thumbnail", None)
            data_class.preload_prefix_size = int(data.get("preload_prefix_size", 0))
            data_class.cover_frame_timestamp = data.get("cover_frame_timestamp", 0.0)
            data_class.video = data.get("video", None)

        return data_class


class StoryContentPhoto(TlObject, StoryContent):
    r"""A photo story

    Parameters:
        photo (:class:`"types.Photo"`):
            The photo

    """

    def __init__(self, photo: Photo = None) -> None:
        self.photo: Union[Photo, None] = photo
        r"""The photo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyContentPhoto"]:
        return "storyContentPhoto"

    def getClass(self) -> Literal["StoryContent"]:
        return "StoryContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryContentPhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)

        return data_class


class StoryContentVideo(TlObject, StoryContent):
    r"""A video story

    Parameters:
        video (:class:`"types.StoryVideo"`):
            The video in MPEG4 format

        alternative_video (:class:`"types.StoryVideo"`):
            Alternative version of the video in MPEG4 format, encoded with H\.264 codec; may be null

    """

    def __init__(
        self, video: StoryVideo = None, alternative_video: StoryVideo = None
    ) -> None:
        self.video: Union[StoryVideo, None] = video
        r"""The video in MPEG4 format"""
        self.alternative_video: Union[StoryVideo, None] = alternative_video
        r"""Alternative version of the video in MPEG4 format, encoded with H\.264 codec; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyContentVideo"]:
        return "storyContentVideo"

    def getClass(self) -> Literal["StoryContent"]:
        return "StoryContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "alternative_video": self.alternative_video,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryContentVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.alternative_video = data.get("alternative_video", None)

        return data_class


class StoryContentUnsupported(TlObject, StoryContent):
    r"""A story content that is not supported in the current TDLib version"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyContentUnsupported"]:
        return "storyContentUnsupported"

    def getClass(self) -> Literal["StoryContent"]:
        return "StoryContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryContentUnsupported", None]:
        if data:
            data_class = cls()

        return data_class


class InputStoryContentPhoto(TlObject, InputStoryContent):
    r"""A photo story

    Parameters:
        photo (:class:`"types.InputFile"`):
            Photo to send\. The photo must be at most 10 MB in size\. The photo size must be 1080x1920

        added_sticker_file_ids (:class:`List[int]`):
            File identifiers of the stickers added to the photo, if applicable

    """

    def __init__(
        self, photo: InputFile = None, added_sticker_file_ids: List[int] = None
    ) -> None:
        self.photo: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = photo
        r"""Photo to send\. The photo must be at most 10 MB in size\. The photo size must be 1080x1920"""
        self.added_sticker_file_ids: List[int] = added_sticker_file_ids or []
        r"""File identifiers of the stickers added to the photo, if applicable"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryContentPhoto"]:
        return "inputStoryContentPhoto"

    def getClass(self) -> Literal["InputStoryContent"]:
        return "InputStoryContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "added_sticker_file_ids": self.added_sticker_file_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryContentPhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.added_sticker_file_ids = data.get("added_sticker_file_ids", None)

        return data_class


class InputStoryContentVideo(TlObject, InputStoryContent):
    r"""A video story

    Parameters:
        video (:class:`"types.InputFile"`):
            Video to be sent\. The video size must be 720x1280\. The video must be streamable and stored in MPEG4 format, after encoding with H\.265 codec and key frames added each second

        added_sticker_file_ids (:class:`List[int]`):
            File identifiers of the stickers added to the video, if applicable

        duration (:class:`float`):
            Precise duration of the video, in seconds; 0\-60

        cover_frame_timestamp (:class:`float`):
            Timestamp of the frame, which will be used as video thumbnail

        is_animation (:class:`bool`):
            True, if the video has no sound

    """

    def __init__(
        self,
        video: InputFile = None,
        added_sticker_file_ids: List[int] = None,
        duration: float = 0.0,
        cover_frame_timestamp: float = 0.0,
        is_animation: bool = False,
    ) -> None:
        self.video: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = video
        r"""Video to be sent\. The video size must be 720x1280\. The video must be streamable and stored in MPEG4 format, after encoding with H\.265 codec and key frames added each second"""
        self.added_sticker_file_ids: List[int] = added_sticker_file_ids or []
        r"""File identifiers of the stickers added to the video, if applicable"""
        self.duration: float = float(duration)
        r"""Precise duration of the video, in seconds; 0\-60"""
        self.cover_frame_timestamp: float = float(cover_frame_timestamp)
        r"""Timestamp of the frame, which will be used as video thumbnail"""
        self.is_animation: bool = bool(is_animation)
        r"""True, if the video has no sound"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputStoryContentVideo"]:
        return "inputStoryContentVideo"

    def getClass(self) -> Literal["InputStoryContent"]:
        return "InputStoryContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "added_sticker_file_ids": self.added_sticker_file_ids,
            "duration": self.duration,
            "cover_frame_timestamp": self.cover_frame_timestamp,
            "is_animation": self.is_animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputStoryContentVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.added_sticker_file_ids = data.get("added_sticker_file_ids", None)
            data_class.duration = data.get("duration", 0.0)
            data_class.cover_frame_timestamp = data.get("cover_frame_timestamp", 0.0)
            data_class.is_animation = data.get("is_animation", False)

        return data_class


class StoryListMain(TlObject, StoryList):
    r"""The list of stories, shown in the main chat list and folder chat lists"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyListMain"]:
        return "storyListMain"

    def getClass(self) -> Literal["StoryList"]:
        return "StoryList"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryListMain", None]:
        if data:
            data_class = cls()

        return data_class


class StoryListArchive(TlObject, StoryList):
    r"""The list of stories, shown in the Arvhive chat list"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyListArchive"]:
        return "storyListArchive"

    def getClass(self) -> Literal["StoryList"]:
        return "StoryList"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryListArchive", None]:
        if data:
            data_class = cls()

        return data_class


class StoryOriginPublicStory(TlObject, StoryOrigin):
    r"""The original story was a public story with known sender

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat that posted original story

        story_id (:class:`int`):
            Story identifier of the original story

    """

    def __init__(self, chat_id: int = 0, story_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat that posted original story"""
        self.story_id: int = int(story_id)
        r"""Story identifier of the original story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyOriginPublicStory"]:
        return "storyOriginPublicStory"

    def getClass(self) -> Literal["StoryOrigin"]:
        return "StoryOrigin"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryOriginPublicStory", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class StoryOriginHiddenUser(TlObject, StoryOrigin):
    r"""The original story was sent by an unknown user

    Parameters:
        sender_name (:class:`str`):
            Name of the story sender

    """

    def __init__(self, sender_name: str = "") -> None:
        self.sender_name: Union[str, None] = sender_name
        r"""Name of the story sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyOriginHiddenUser"]:
        return "storyOriginHiddenUser"

    def getClass(self) -> Literal["StoryOrigin"]:
        return "StoryOrigin"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sender_name": self.sender_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryOriginHiddenUser", None]:
        if data:
            data_class = cls()
            data_class.sender_name = data.get("sender_name", "")

        return data_class


class StoryRepostInfo(TlObject):
    r"""Contains information about original story that was reposted

    Parameters:
        origin (:class:`"types.StoryOrigin"`):
            Origin of the story that was reposted

        is_content_modified (:class:`bool`):
            True, if story content was modified during reposting; otherwise, story wasn't modified

    """

    def __init__(
        self, origin: StoryOrigin = None, is_content_modified: bool = False
    ) -> None:
        self.origin: Union[StoryOriginPublicStory, StoryOriginHiddenUser, None] = origin
        r"""Origin of the story that was reposted"""
        self.is_content_modified: bool = bool(is_content_modified)
        r"""True, if story content was modified during reposting; otherwise, story wasn't modified"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyRepostInfo"]:
        return "storyRepostInfo"

    def getClass(self) -> Literal["StoryRepostInfo"]:
        return "StoryRepostInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "origin": self.origin,
            "is_content_modified": self.is_content_modified,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryRepostInfo", None]:
        if data:
            data_class = cls()
            data_class.origin = data.get("origin", None)
            data_class.is_content_modified = data.get("is_content_modified", False)

        return data_class


class StoryInteractionInfo(TlObject):
    r"""Contains information about interactions with a story

    Parameters:
        view_count (:class:`int`):
            Number of times the story was viewed

        forward_count (:class:`int`):
            Number of times the story was forwarded; 0 if none or unknown

        reaction_count (:class:`int`):
            Number of reactions added to the story; 0 if none or unknown

        recent_viewer_user_ids (:class:`List[int]`):
            Identifiers of at most 3 recent viewers of the story

    """

    def __init__(
        self,
        view_count: int = 0,
        forward_count: int = 0,
        reaction_count: int = 0,
        recent_viewer_user_ids: List[int] = None,
    ) -> None:
        self.view_count: int = int(view_count)
        r"""Number of times the story was viewed"""
        self.forward_count: int = int(forward_count)
        r"""Number of times the story was forwarded; 0 if none or unknown"""
        self.reaction_count: int = int(reaction_count)
        r"""Number of reactions added to the story; 0 if none or unknown"""
        self.recent_viewer_user_ids: List[int] = recent_viewer_user_ids or []
        r"""Identifiers of at most 3 recent viewers of the story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyInteractionInfo"]:
        return "storyInteractionInfo"

    def getClass(self) -> Literal["StoryInteractionInfo"]:
        return "StoryInteractionInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "view_count": self.view_count,
            "forward_count": self.forward_count,
            "reaction_count": self.reaction_count,
            "recent_viewer_user_ids": self.recent_viewer_user_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryInteractionInfo", None]:
        if data:
            data_class = cls()
            data_class.view_count = int(data.get("view_count", 0))
            data_class.forward_count = int(data.get("forward_count", 0))
            data_class.reaction_count = int(data.get("reaction_count", 0))
            data_class.recent_viewer_user_ids = data.get("recent_viewer_user_ids", None)

        return data_class


class Story(TlObject):
    r"""Represents a story

    Parameters:
        id (:class:`int`):
            Unique story identifier among stories of the given sender

        sender_chat_id (:class:`int`):
            Identifier of the chat that posted the story

        sender_id (:class:`"types.MessageSender"`):
            Identifier of the sender of the story; may be null if the story is posted on behalf of the sender\_chat\_id

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the story was published

        is_being_sent (:class:`bool`):
            True, if the story is being sent by the current user

        is_being_edited (:class:`bool`):
            True, if the story is being edited by the current user

        is_edited (:class:`bool`):
            True, if the story was edited

        is_posted_to_chat_page (:class:`bool`):
            True, if the story is saved in the sender's profile and will be available there after expiration

        is_visible_only_for_self (:class:`bool`):
            True, if the story is visible only for the current user

        can_be_deleted (:class:`bool`):
            True, if the story can be deleted

        can_be_edited (:class:`bool`):
            True, if the story can be edited

        can_be_forwarded (:class:`bool`):
            True, if the story can be forwarded as a message\. Otherwise, screenshots and saving of the story content must be also forbidden

        can_be_replied (:class:`bool`):
            True, if the story can be replied in the chat with the story sender

        can_toggle_is_posted_to_chat_page (:class:`bool`):
            True, if the story's is\_posted\_to\_chat\_page value can be changed

        can_get_statistics (:class:`bool`):
            True, if the story statistics are available through getStoryStatistics

        can_get_interactions (:class:`bool`):
            True, if interactions with the story can be received through getStoryInteractions

        has_expired_viewers (:class:`bool`):
            True, if users viewed the story can't be received, because the story has expired more than getOption\(\"story\_viewers\_expiration\_delay\"\) seconds ago

        repost_info (:class:`"types.StoryRepostInfo"`):
            Information about the original story; may be null if the story wasn't reposted

        interaction_info (:class:`"types.StoryInteractionInfo"`):
            Information about interactions with the story; may be null if the story isn't owned or there were no interactions

        chosen_reaction_type (:class:`"types.ReactionType"`):
            Type of the chosen reaction; may be null if none

        privacy_settings (:class:`"types.StoryPrivacySettings"`):
            Privacy rules affecting story visibility; may be approximate for non\-owned stories

        content (:class:`"types.StoryContent"`):
            Content of the story

        areas (:class:`List["types.StoryArea"]`):
            Clickable areas to be shown on the story content

        caption (:class:`"types.FormattedText"`):
            Caption of the story

    """

    def __init__(
        self,
        id: int = 0,
        sender_chat_id: int = 0,
        sender_id: MessageSender = None,
        date: int = 0,
        is_being_sent: bool = False,
        is_being_edited: bool = False,
        is_edited: bool = False,
        is_posted_to_chat_page: bool = False,
        is_visible_only_for_self: bool = False,
        can_be_deleted: bool = False,
        can_be_edited: bool = False,
        can_be_forwarded: bool = False,
        can_be_replied: bool = False,
        can_toggle_is_posted_to_chat_page: bool = False,
        can_get_statistics: bool = False,
        can_get_interactions: bool = False,
        has_expired_viewers: bool = False,
        repost_info: StoryRepostInfo = None,
        interaction_info: StoryInteractionInfo = None,
        chosen_reaction_type: ReactionType = None,
        privacy_settings: StoryPrivacySettings = None,
        content: StoryContent = None,
        areas: List[StoryArea] = None,
        caption: FormattedText = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique story identifier among stories of the given sender"""
        self.sender_chat_id: int = int(sender_chat_id)
        r"""Identifier of the chat that posted the story"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the sender of the story; may be null if the story is posted on behalf of the sender\_chat\_id"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the story was published"""
        self.is_being_sent: bool = bool(is_being_sent)
        r"""True, if the story is being sent by the current user"""
        self.is_being_edited: bool = bool(is_being_edited)
        r"""True, if the story is being edited by the current user"""
        self.is_edited: bool = bool(is_edited)
        r"""True, if the story was edited"""
        self.is_posted_to_chat_page: bool = bool(is_posted_to_chat_page)
        r"""True, if the story is saved in the sender's profile and will be available there after expiration"""
        self.is_visible_only_for_self: bool = bool(is_visible_only_for_self)
        r"""True, if the story is visible only for the current user"""
        self.can_be_deleted: bool = bool(can_be_deleted)
        r"""True, if the story can be deleted"""
        self.can_be_edited: bool = bool(can_be_edited)
        r"""True, if the story can be edited"""
        self.can_be_forwarded: bool = bool(can_be_forwarded)
        r"""True, if the story can be forwarded as a message\. Otherwise, screenshots and saving of the story content must be also forbidden"""
        self.can_be_replied: bool = bool(can_be_replied)
        r"""True, if the story can be replied in the chat with the story sender"""
        self.can_toggle_is_posted_to_chat_page: bool = bool(
            can_toggle_is_posted_to_chat_page
        )
        r"""True, if the story's is\_posted\_to\_chat\_page value can be changed"""
        self.can_get_statistics: bool = bool(can_get_statistics)
        r"""True, if the story statistics are available through getStoryStatistics"""
        self.can_get_interactions: bool = bool(can_get_interactions)
        r"""True, if interactions with the story can be received through getStoryInteractions"""
        self.has_expired_viewers: bool = bool(has_expired_viewers)
        r"""True, if users viewed the story can't be received, because the story has expired more than getOption\(\"story\_viewers\_expiration\_delay\"\) seconds ago"""
        self.repost_info: Union[StoryRepostInfo, None] = repost_info
        r"""Information about the original story; may be null if the story wasn't reposted"""
        self.interaction_info: Union[StoryInteractionInfo, None] = interaction_info
        r"""Information about interactions with the story; may be null if the story isn't owned or there were no interactions"""
        self.chosen_reaction_type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = chosen_reaction_type
        r"""Type of the chosen reaction; may be null if none"""
        self.privacy_settings: Union[
            StoryPrivacySettingsEveryone,
            StoryPrivacySettingsContacts,
            StoryPrivacySettingsCloseFriends,
            StoryPrivacySettingsSelectedUsers,
            None,
        ] = privacy_settings
        r"""Privacy rules affecting story visibility; may be approximate for non\-owned stories"""
        self.content: Union[
            StoryContentPhoto, StoryContentVideo, StoryContentUnsupported, None
        ] = content
        r"""Content of the story"""
        self.areas: List[StoryArea] = areas or []
        r"""Clickable areas to be shown on the story content"""
        self.caption: Union[FormattedText, None] = caption
        r"""Caption of the story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["story"]:
        return "story"

    def getClass(self) -> Literal["Story"]:
        return "Story"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_chat_id": self.sender_chat_id,
            "sender_id": self.sender_id,
            "date": self.date,
            "is_being_sent": self.is_being_sent,
            "is_being_edited": self.is_being_edited,
            "is_edited": self.is_edited,
            "is_posted_to_chat_page": self.is_posted_to_chat_page,
            "is_visible_only_for_self": self.is_visible_only_for_self,
            "can_be_deleted": self.can_be_deleted,
            "can_be_edited": self.can_be_edited,
            "can_be_forwarded": self.can_be_forwarded,
            "can_be_replied": self.can_be_replied,
            "can_toggle_is_posted_to_chat_page": self.can_toggle_is_posted_to_chat_page,
            "can_get_statistics": self.can_get_statistics,
            "can_get_interactions": self.can_get_interactions,
            "has_expired_viewers": self.has_expired_viewers,
            "repost_info": self.repost_info,
            "interaction_info": self.interaction_info,
            "chosen_reaction_type": self.chosen_reaction_type,
            "privacy_settings": self.privacy_settings,
            "content": self.content,
            "areas": self.areas,
            "caption": self.caption,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Story", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_chat_id = int(data.get("sender_chat_id", 0))
            data_class.sender_id = data.get("sender_id", None)
            data_class.date = int(data.get("date", 0))
            data_class.is_being_sent = data.get("is_being_sent", False)
            data_class.is_being_edited = data.get("is_being_edited", False)
            data_class.is_edited = data.get("is_edited", False)
            data_class.is_posted_to_chat_page = data.get(
                "is_posted_to_chat_page", False
            )
            data_class.is_visible_only_for_self = data.get(
                "is_visible_only_for_self", False
            )
            data_class.can_be_deleted = data.get("can_be_deleted", False)
            data_class.can_be_edited = data.get("can_be_edited", False)
            data_class.can_be_forwarded = data.get("can_be_forwarded", False)
            data_class.can_be_replied = data.get("can_be_replied", False)
            data_class.can_toggle_is_posted_to_chat_page = data.get(
                "can_toggle_is_posted_to_chat_page", False
            )
            data_class.can_get_statistics = data.get("can_get_statistics", False)
            data_class.can_get_interactions = data.get("can_get_interactions", False)
            data_class.has_expired_viewers = data.get("has_expired_viewers", False)
            data_class.repost_info = data.get("repost_info", None)
            data_class.interaction_info = data.get("interaction_info", None)
            data_class.chosen_reaction_type = data.get("chosen_reaction_type", None)
            data_class.privacy_settings = data.get("privacy_settings", None)
            data_class.content = data.get("content", None)
            data_class.areas = data.get("areas", None)
            data_class.caption = data.get("caption", None)

        return data_class


class Stories(TlObject):
    r"""Represents a list of stories

    Parameters:
        total_count (:class:`int`):
            Approximate total number of stories found

        stories (:class:`List["types.Story"]`):
            The list of stories

        pinned_story_ids (:class:`List[int]`):
            Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories with from\_story\_id \=\= 0

    """

    def __init__(
        self,
        total_count: int = 0,
        stories: List[Story] = None,
        pinned_story_ids: List[int] = None,
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of stories found"""
        self.stories: List[Story] = stories or []
        r"""The list of stories"""
        self.pinned_story_ids: List[int] = pinned_story_ids or []
        r"""Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories with from\_story\_id \=\= 0"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["stories"]:
        return "stories"

    def getClass(self) -> Literal["Stories"]:
        return "Stories"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "stories": self.stories,
            "pinned_story_ids": self.pinned_story_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Stories", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.stories = data.get("stories", None)
            data_class.pinned_story_ids = data.get("pinned_story_ids", None)

        return data_class


class FoundStories(TlObject):
    r"""Contains a list of stories found by a search

    Parameters:
        total_count (:class:`int`):
            Approximate total number of stories found

        stories (:class:`List["types.Story"]`):
            List of stories

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self, total_count: int = 0, stories: List[Story] = None, next_offset: str = ""
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of stories found"""
        self.stories: List[Story] = stories or []
        r"""List of stories"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundStories"]:
        return "foundStories"

    def getClass(self) -> Literal["FoundStories"]:
        return "FoundStories"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "stories": self.stories,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundStories", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.stories = data.get("stories", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class StoryFullId(TlObject):
    r"""Contains identifier of a story along with identifier of its sender

    Parameters:
        sender_chat_id (:class:`int`):
            Identifier of the chat that posted the story

        story_id (:class:`int`):
            Unique story identifier among stories of the given sender

    """

    def __init__(self, sender_chat_id: int = 0, story_id: int = 0) -> None:
        self.sender_chat_id: int = int(sender_chat_id)
        r"""Identifier of the chat that posted the story"""
        self.story_id: int = int(story_id)
        r"""Unique story identifier among stories of the given sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyFullId"]:
        return "storyFullId"

    def getClass(self) -> Literal["StoryFullId"]:
        return "StoryFullId"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender_chat_id": self.sender_chat_id,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryFullId", None]:
        if data:
            data_class = cls()
            data_class.sender_chat_id = int(data.get("sender_chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class StoryInfo(TlObject):
    r"""Contains basic information about a story

    Parameters:
        story_id (:class:`int`):
            Unique story identifier among stories of the given sender

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the story was published

        is_for_close_friends (:class:`bool`):
            True, if the story is available only to close friends

    """

    def __init__(
        self, story_id: int = 0, date: int = 0, is_for_close_friends: bool = False
    ) -> None:
        self.story_id: int = int(story_id)
        r"""Unique story identifier among stories of the given sender"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the story was published"""
        self.is_for_close_friends: bool = bool(is_for_close_friends)
        r"""True, if the story is available only to close friends"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyInfo"]:
        return "storyInfo"

    def getClass(self) -> Literal["StoryInfo"]:
        return "StoryInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_id": self.story_id,
            "date": self.date,
            "is_for_close_friends": self.is_for_close_friends,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryInfo", None]:
        if data:
            data_class = cls()
            data_class.story_id = int(data.get("story_id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.is_for_close_friends = data.get("is_for_close_friends", False)

        return data_class


class ChatActiveStories(TlObject):
    r"""Describes active stories posted by a chat

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat that posted the stories

        list (:class:`"types.StoryList"`):
            Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list

        order (:class:`int`):
            A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list\. Stories must be sorted by the pair \(order, story\_sender\_chat\_id\) in descending order

        max_read_story_id (:class:`int`):
            Identifier of the last read active story

        stories (:class:`List["types.StoryInfo"]`):
            Basic information about the stories; use getStory to get full information about the stories\. The stories are in chronological order \(i\.e\., in order of increasing story identifiers\)

    """

    def __init__(
        self,
        chat_id: int = 0,
        list: StoryList = None,
        order: int = 0,
        max_read_story_id: int = 0,
        stories: List[StoryInfo] = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat that posted the stories"""
        self.list: Union[StoryListMain, StoryListArchive, None] = list
        r"""Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list"""
        self.order: int = int(order)
        r"""A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list\. Stories must be sorted by the pair \(order, story\_sender\_chat\_id\) in descending order"""
        self.max_read_story_id: int = int(max_read_story_id)
        r"""Identifier of the last read active story"""
        self.stories: List[StoryInfo] = stories or []
        r"""Basic information about the stories; use getStory to get full information about the stories\. The stories are in chronological order \(i\.e\., in order of increasing story identifiers\)"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatActiveStories"]:
        return "chatActiveStories"

    def getClass(self) -> Literal["ChatActiveStories"]:
        return "ChatActiveStories"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "list": self.list,
            "order": self.order,
            "max_read_story_id": self.max_read_story_id,
            "stories": self.stories,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatActiveStories", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.list = data.get("list", None)
            data_class.order = int(data.get("order", 0))
            data_class.max_read_story_id = int(data.get("max_read_story_id", 0))
            data_class.stories = data.get("stories", None)

        return data_class


class StoryInteractionTypeView(TlObject, StoryInteractionType):
    r"""A view of the story

    Parameters:
        chosen_reaction_type (:class:`"types.ReactionType"`):
            Type of the reaction that was chosen by the viewer; may be null if none

    """

    def __init__(self, chosen_reaction_type: ReactionType = None) -> None:
        self.chosen_reaction_type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = chosen_reaction_type
        r"""Type of the reaction that was chosen by the viewer; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyInteractionTypeView"]:
        return "storyInteractionTypeView"

    def getClass(self) -> Literal["StoryInteractionType"]:
        return "StoryInteractionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chosen_reaction_type": self.chosen_reaction_type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryInteractionTypeView", None]:
        if data:
            data_class = cls()
            data_class.chosen_reaction_type = data.get("chosen_reaction_type", None)

        return data_class


class StoryInteractionTypeForward(TlObject, StoryInteractionType):
    r"""A forward of the story as a message

    Parameters:
        message (:class:`"types.Message"`):
            The message with story forward

    """

    def __init__(self, message: Message = None) -> None:
        self.message: Union[Message, None] = message
        r"""The message with story forward"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyInteractionTypeForward"]:
        return "storyInteractionTypeForward"

    def getClass(self) -> Literal["StoryInteractionType"]:
        return "StoryInteractionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message": self.message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryInteractionTypeForward", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)

        return data_class


class StoryInteractionTypeRepost(TlObject, StoryInteractionType):
    r"""A repost of the story as a story

    Parameters:
        story (:class:`"types.Story"`):
            The reposted story

    """

    def __init__(self, story: Story = None) -> None:
        self.story: Union[Story, None] = story
        r"""The reposted story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyInteractionTypeRepost"]:
        return "storyInteractionTypeRepost"

    def getClass(self) -> Literal["StoryInteractionType"]:
        return "StoryInteractionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "story": self.story}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryInteractionTypeRepost", None]:
        if data:
            data_class = cls()
            data_class.story = data.get("story", None)

        return data_class


class StoryInteraction(TlObject):
    r"""Represents interaction with a story

    Parameters:
        actor_id (:class:`"types.MessageSender"`):
            Identifier of the user or chat that made the interaction

        interaction_date (:class:`int`):
            Approximate point in time \(Unix timestamp\) when the interaction happened

        block_list (:class:`"types.BlockList"`):
            Block list to which the actor is added; may be null if none or for chat stories

        type (:class:`"types.StoryInteractionType"`):
            Type of the interaction

    """

    def __init__(
        self,
        actor_id: MessageSender = None,
        interaction_date: int = 0,
        block_list: BlockList = None,
        type: StoryInteractionType = None,
    ) -> None:
        self.actor_id: Union[MessageSenderUser, MessageSenderChat, None] = actor_id
        r"""Identifier of the user or chat that made the interaction"""
        self.interaction_date: int = int(interaction_date)
        r"""Approximate point in time \(Unix timestamp\) when the interaction happened"""
        self.block_list: Union[BlockListMain, BlockListStories, None] = block_list
        r"""Block list to which the actor is added; may be null if none or for chat stories"""
        self.type: Union[
            StoryInteractionTypeView,
            StoryInteractionTypeForward,
            StoryInteractionTypeRepost,
            None,
        ] = type
        r"""Type of the interaction"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyInteraction"]:
        return "storyInteraction"

    def getClass(self) -> Literal["StoryInteraction"]:
        return "StoryInteraction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "actor_id": self.actor_id,
            "interaction_date": self.interaction_date,
            "block_list": self.block_list,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryInteraction", None]:
        if data:
            data_class = cls()
            data_class.actor_id = data.get("actor_id", None)
            data_class.interaction_date = int(data.get("interaction_date", 0))
            data_class.block_list = data.get("block_list", None)
            data_class.type = data.get("type", None)

        return data_class


class StoryInteractions(TlObject):
    r"""Represents a list of interactions with a story

    Parameters:
        total_count (:class:`int`):
            Approximate total number of interactions found

        total_forward_count (:class:`int`):
            Approximate total number of found forwards and reposts; always 0 for chat stories

        total_reaction_count (:class:`int`):
            Approximate total number of found reactions; always 0 for chat stories

        interactions (:class:`List["types.StoryInteraction"]`):
            List of story interactions

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        total_forward_count: int = 0,
        total_reaction_count: int = 0,
        interactions: List[StoryInteraction] = None,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of interactions found"""
        self.total_forward_count: int = int(total_forward_count)
        r"""Approximate total number of found forwards and reposts; always 0 for chat stories"""
        self.total_reaction_count: int = int(total_reaction_count)
        r"""Approximate total number of found reactions; always 0 for chat stories"""
        self.interactions: List[StoryInteraction] = interactions or []
        r"""List of story interactions"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyInteractions"]:
        return "storyInteractions"

    def getClass(self) -> Literal["StoryInteractions"]:
        return "StoryInteractions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "total_forward_count": self.total_forward_count,
            "total_reaction_count": self.total_reaction_count,
            "interactions": self.interactions,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryInteractions", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.total_forward_count = int(data.get("total_forward_count", 0))
            data_class.total_reaction_count = int(data.get("total_reaction_count", 0))
            data_class.interactions = data.get("interactions", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class QuickReplyMessage(TlObject):
    r"""Describes a message that can be used for quick reply

    Parameters:
        id (:class:`int`):
            Unique message identifier among all quick replies

        sending_state (:class:`"types.MessageSendingState"`):
            The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent

        can_be_edited (:class:`bool`):
            True, if the message can be edited

        reply_to_message_id (:class:`int`):
            The identifier of the quick reply message to which the message replies; 0 if none

        via_bot_user_id (:class:`int`):
            If non\-zero, the user identifier of the bot through which this message was sent

        media_album_id (:class:`int`):
            Unique identifier of an album this message belongs to; 0 if none\. Only audios, documents, photos and videos can be grouped together in albums

        content (:class:`"types.MessageContent"`):
            Content of the message

        reply_markup (:class:`"types.ReplyMarkup"`):
            Inline keyboard reply markup for the message; may be null if none

    """

    def __init__(
        self,
        id: int = 0,
        sending_state: MessageSendingState = None,
        can_be_edited: bool = False,
        reply_to_message_id: int = 0,
        via_bot_user_id: int = 0,
        media_album_id: int = 0,
        content: MessageContent = None,
        reply_markup: ReplyMarkup = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique message identifier among all quick replies"""
        self.sending_state: Union[
            MessageSendingStatePending, MessageSendingStateFailed, None
        ] = sending_state
        r"""The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent"""
        self.can_be_edited: bool = bool(can_be_edited)
        r"""True, if the message can be edited"""
        self.reply_to_message_id: int = int(reply_to_message_id)
        r"""The identifier of the quick reply message to which the message replies; 0 if none"""
        self.via_bot_user_id: int = int(via_bot_user_id)
        r"""If non\-zero, the user identifier of the bot through which this message was sent"""
        self.media_album_id: int = int(media_album_id)
        r"""Unique identifier of an album this message belongs to; 0 if none\. Only audios, documents, photos and videos can be grouped together in albums"""
        self.content: Union[
            MessageText,
            MessageAnimation,
            MessageAudio,
            MessageDocument,
            MessagePaidMedia,
            MessagePhoto,
            MessageSticker,
            MessageVideo,
            MessageVideoNote,
            MessageVoiceNote,
            MessageExpiredPhoto,
            MessageExpiredVideo,
            MessageExpiredVideoNote,
            MessageExpiredVoiceNote,
            MessageLocation,
            MessageVenue,
            MessageContact,
            MessageAnimatedEmoji,
            MessageDice,
            MessageGame,
            MessagePoll,
            MessageStory,
            MessageInvoice,
            MessageCall,
            MessageVideoChatScheduled,
            MessageVideoChatStarted,
            MessageVideoChatEnded,
            MessageInviteVideoChatParticipants,
            MessageBasicGroupChatCreate,
            MessageSupergroupChatCreate,
            MessageChatChangeTitle,
            MessageChatChangePhoto,
            MessageChatDeletePhoto,
            MessageChatAddMembers,
            MessageChatJoinByLink,
            MessageChatJoinByRequest,
            MessageChatDeleteMember,
            MessageChatUpgradeTo,
            MessageChatUpgradeFrom,
            MessagePinMessage,
            MessageScreenshotTaken,
            MessageChatSetBackground,
            MessageChatSetTheme,
            MessageChatSetMessageAutoDeleteTime,
            MessageChatBoost,
            MessageForumTopicCreated,
            MessageForumTopicEdited,
            MessageForumTopicIsClosedToggled,
            MessageForumTopicIsHiddenToggled,
            MessageSuggestProfilePhoto,
            MessageCustomServiceAction,
            MessageGameScore,
            MessagePaymentSuccessful,
            MessagePaymentSuccessfulBot,
            MessagePaymentRefunded,
            MessageGiftedPremium,
            MessagePremiumGiftCode,
            MessageGiveawayCreated,
            MessageGiveaway,
            MessageGiveawayCompleted,
            MessageGiveawayWinners,
            MessageGiftedStars,
            MessageGiveawayPrizeStars,
            MessageGift,
            MessageUpgradedGift,
            MessageRefundedUpgradedGift,
            MessagePaidMessagesRefunded,
            MessagePaidMessagePriceChanged,
            MessageContactRegistered,
            MessageUsersShared,
            MessageChatShared,
            MessageBotWriteAccessAllowed,
            MessageWebAppDataSent,
            MessageWebAppDataReceived,
            MessagePassportDataSent,
            MessagePassportDataReceived,
            MessageProximityAlertTriggered,
            MessageUnsupported,
            None,
        ] = content
        r"""Content of the message"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""Inline keyboard reply markup for the message; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["quickReplyMessage"]:
        return "quickReplyMessage"

    def getClass(self) -> Literal["QuickReplyMessage"]:
        return "QuickReplyMessage"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sending_state": self.sending_state,
            "can_be_edited": self.can_be_edited,
            "reply_to_message_id": self.reply_to_message_id,
            "via_bot_user_id": self.via_bot_user_id,
            "media_album_id": self.media_album_id,
            "content": self.content,
            "reply_markup": self.reply_markup,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["QuickReplyMessage", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sending_state = data.get("sending_state", None)
            data_class.can_be_edited = data.get("can_be_edited", False)
            data_class.reply_to_message_id = int(data.get("reply_to_message_id", 0))
            data_class.via_bot_user_id = int(data.get("via_bot_user_id", 0))
            data_class.media_album_id = int(data.get("media_album_id", 0))
            data_class.content = data.get("content", None)
            data_class.reply_markup = data.get("reply_markup", None)

        return data_class


class QuickReplyMessages(TlObject):
    r"""Contains a list of quick reply messages

    Parameters:
        messages (:class:`List["types.QuickReplyMessage"]`):
            List of quick reply messages; messages may be null

    """

    def __init__(self, messages: List[QuickReplyMessage] = None) -> None:
        self.messages: List[QuickReplyMessage] = messages or []
        r"""List of quick reply messages; messages may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["quickReplyMessages"]:
        return "quickReplyMessages"

    def getClass(self) -> Literal["QuickReplyMessages"]:
        return "QuickReplyMessages"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "messages": self.messages}

    @classmethod
    def from_dict(cls, data: dict) -> Union["QuickReplyMessages", None]:
        if data:
            data_class = cls()
            data_class.messages = data.get("messages", None)

        return data_class


class QuickReplyShortcut(TlObject):
    r"""Describes a shortcut that can be used for a quick reply

    Parameters:
        id (:class:`int`):
            Unique shortcut identifier

        name (:class:`str`):
            The name of the shortcut that can be used to use the shortcut

        first_message (:class:`"types.QuickReplyMessage"`):
            The first shortcut message

        message_count (:class:`int`):
            The total number of messages in the shortcut

    """

    def __init__(
        self,
        id: int = 0,
        name: str = "",
        first_message: QuickReplyMessage = None,
        message_count: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Unique shortcut identifier"""
        self.name: Union[str, None] = name
        r"""The name of the shortcut that can be used to use the shortcut"""
        self.first_message: Union[QuickReplyMessage, None] = first_message
        r"""The first shortcut message"""
        self.message_count: int = int(message_count)
        r"""The total number of messages in the shortcut"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["quickReplyShortcut"]:
        return "quickReplyShortcut"

    def getClass(self) -> Literal["QuickReplyShortcut"]:
        return "QuickReplyShortcut"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "name": self.name,
            "first_message": self.first_message,
            "message_count": self.message_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["QuickReplyShortcut", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.name = data.get("name", "")
            data_class.first_message = data.get("first_message", None)
            data_class.message_count = int(data.get("message_count", 0))

        return data_class


class PublicForwardMessage(TlObject, PublicForward):
    r"""Contains a public forward as a message

    Parameters:
        message (:class:`"types.Message"`):
            Information about the message

    """

    def __init__(self, message: Message = None) -> None:
        self.message: Union[Message, None] = message
        r"""Information about the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["publicForwardMessage"]:
        return "publicForwardMessage"

    def getClass(self) -> Literal["PublicForward"]:
        return "PublicForward"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message": self.message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PublicForwardMessage", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)

        return data_class


class PublicForwardStory(TlObject, PublicForward):
    r"""Contains a public repost to a story

    Parameters:
        story (:class:`"types.Story"`):
            Information about the story

    """

    def __init__(self, story: Story = None) -> None:
        self.story: Union[Story, None] = story
        r"""Information about the story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["publicForwardStory"]:
        return "publicForwardStory"

    def getClass(self) -> Literal["PublicForward"]:
        return "PublicForward"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "story": self.story}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PublicForwardStory", None]:
        if data:
            data_class = cls()
            data_class.story = data.get("story", None)

        return data_class


class PublicForwards(TlObject):
    r"""Represents a list of public forwards and reposts as a story of a message or a story

    Parameters:
        total_count (:class:`int`):
            Approximate total number of messages and stories found

        forwards (:class:`List["types.PublicForward"]`):
            List of found public forwards and reposts

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        forwards: List[PublicForward] = None,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Approximate total number of messages and stories found"""
        self.forwards: List[PublicForward] = forwards or []
        r"""List of found public forwards and reposts"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["publicForwards"]:
        return "publicForwards"

    def getClass(self) -> Literal["PublicForwards"]:
        return "PublicForwards"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "forwards": self.forwards,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PublicForwards", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.forwards = data.get("forwards", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class BotMediaPreview(TlObject):
    r"""Describes media previews of a bot

    Parameters:
        date (:class:`int`):
            Point in time \(Unix timestamp\) when the preview was added or changed last time

        content (:class:`"types.StoryContent"`):
            Content of the preview

    """

    def __init__(self, date: int = 0, content: StoryContent = None) -> None:
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the preview was added or changed last time"""
        self.content: Union[
            StoryContentPhoto, StoryContentVideo, StoryContentUnsupported, None
        ] = content
        r"""Content of the preview"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botMediaPreview"]:
        return "botMediaPreview"

    def getClass(self) -> Literal["BotMediaPreview"]:
        return "BotMediaPreview"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "date": self.date, "content": self.content}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotMediaPreview", None]:
        if data:
            data_class = cls()
            data_class.date = int(data.get("date", 0))
            data_class.content = data.get("content", None)

        return data_class


class BotMediaPreviews(TlObject):
    r"""Contains a list of media previews of a bot

    Parameters:
        previews (:class:`List["types.BotMediaPreview"]`):
            List of media previews

    """

    def __init__(self, previews: List[BotMediaPreview] = None) -> None:
        self.previews: List[BotMediaPreview] = previews or []
        r"""List of media previews"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botMediaPreviews"]:
        return "botMediaPreviews"

    def getClass(self) -> Literal["BotMediaPreviews"]:
        return "BotMediaPreviews"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "previews": self.previews}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotMediaPreviews", None]:
        if data:
            data_class = cls()
            data_class.previews = data.get("previews", None)

        return data_class


class BotMediaPreviewInfo(TlObject):
    r"""Contains a list of media previews of a bot for the given language and the list of languages for which the bot has dedicated previews

    Parameters:
        previews (:class:`List["types.BotMediaPreview"]`):
            List of media previews

        language_codes (:class:`List[str]`):
            List of language codes for which the bot has dedicated previews

    """

    def __init__(
        self, previews: List[BotMediaPreview] = None, language_codes: List[str] = None
    ) -> None:
        self.previews: List[BotMediaPreview] = previews or []
        r"""List of media previews"""
        self.language_codes: List[str] = language_codes or []
        r"""List of language codes for which the bot has dedicated previews"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botMediaPreviewInfo"]:
        return "botMediaPreviewInfo"

    def getClass(self) -> Literal["BotMediaPreviewInfo"]:
        return "BotMediaPreviewInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "previews": self.previews,
            "language_codes": self.language_codes,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotMediaPreviewInfo", None]:
        if data:
            data_class = cls()
            data_class.previews = data.get("previews", None)
            data_class.language_codes = data.get("language_codes", None)

        return data_class


class ChatBoostLevelFeatures(TlObject):
    r"""Contains a list of features available on a specific chat boost level

    Parameters:
        level (:class:`int`):
            Target chat boost level

        story_per_day_count (:class:`int`):
            Number of stories that the chat can publish daily

        custom_emoji_reaction_count (:class:`int`):
            Number of custom emoji reactions that can be added to the list of available reactions

        title_color_count (:class:`int`):
            Number of custom colors for chat title

        profile_accent_color_count (:class:`int`):
            Number of custom colors for profile photo background

        can_set_profile_background_custom_emoji (:class:`bool`):
            True, if custom emoji for profile background can be set

        accent_color_count (:class:`int`):
            Number of custom colors for background of empty chat photo, replies to messages and link previews

        can_set_background_custom_emoji (:class:`bool`):
            True, if custom emoji for reply header and link preview background can be set

        can_set_emoji_status (:class:`bool`):
            True, if emoji status can be set

        chat_theme_background_count (:class:`int`):
            Number of chat theme backgrounds that can be set as chat background

        can_set_custom_background (:class:`bool`):
            True, if custom background can be set in the chat for all users

        can_set_custom_emoji_sticker_set (:class:`bool`):
            True, if custom emoji sticker set can be set for the chat

        can_recognize_speech (:class:`bool`):
            True, if speech recognition can be used for video note and voice note messages by all users

        can_disable_sponsored_messages (:class:`bool`):
            True, if sponsored messages can be disabled in the chat

    """

    def __init__(
        self,
        level: int = 0,
        story_per_day_count: int = 0,
        custom_emoji_reaction_count: int = 0,
        title_color_count: int = 0,
        profile_accent_color_count: int = 0,
        can_set_profile_background_custom_emoji: bool = False,
        accent_color_count: int = 0,
        can_set_background_custom_emoji: bool = False,
        can_set_emoji_status: bool = False,
        chat_theme_background_count: int = 0,
        can_set_custom_background: bool = False,
        can_set_custom_emoji_sticker_set: bool = False,
        can_recognize_speech: bool = False,
        can_disable_sponsored_messages: bool = False,
    ) -> None:
        self.level: int = int(level)
        r"""Target chat boost level"""
        self.story_per_day_count: int = int(story_per_day_count)
        r"""Number of stories that the chat can publish daily"""
        self.custom_emoji_reaction_count: int = int(custom_emoji_reaction_count)
        r"""Number of custom emoji reactions that can be added to the list of available reactions"""
        self.title_color_count: int = int(title_color_count)
        r"""Number of custom colors for chat title"""
        self.profile_accent_color_count: int = int(profile_accent_color_count)
        r"""Number of custom colors for profile photo background"""
        self.can_set_profile_background_custom_emoji: bool = bool(
            can_set_profile_background_custom_emoji
        )
        r"""True, if custom emoji for profile background can be set"""
        self.accent_color_count: int = int(accent_color_count)
        r"""Number of custom colors for background of empty chat photo, replies to messages and link previews"""
        self.can_set_background_custom_emoji: bool = bool(
            can_set_background_custom_emoji
        )
        r"""True, if custom emoji for reply header and link preview background can be set"""
        self.can_set_emoji_status: bool = bool(can_set_emoji_status)
        r"""True, if emoji status can be set"""
        self.chat_theme_background_count: int = int(chat_theme_background_count)
        r"""Number of chat theme backgrounds that can be set as chat background"""
        self.can_set_custom_background: bool = bool(can_set_custom_background)
        r"""True, if custom background can be set in the chat for all users"""
        self.can_set_custom_emoji_sticker_set: bool = bool(
            can_set_custom_emoji_sticker_set
        )
        r"""True, if custom emoji sticker set can be set for the chat"""
        self.can_recognize_speech: bool = bool(can_recognize_speech)
        r"""True, if speech recognition can be used for video note and voice note messages by all users"""
        self.can_disable_sponsored_messages: bool = bool(can_disable_sponsored_messages)
        r"""True, if sponsored messages can be disabled in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostLevelFeatures"]:
        return "chatBoostLevelFeatures"

    def getClass(self) -> Literal["ChatBoostLevelFeatures"]:
        return "ChatBoostLevelFeatures"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "level": self.level,
            "story_per_day_count": self.story_per_day_count,
            "custom_emoji_reaction_count": self.custom_emoji_reaction_count,
            "title_color_count": self.title_color_count,
            "profile_accent_color_count": self.profile_accent_color_count,
            "can_set_profile_background_custom_emoji": self.can_set_profile_background_custom_emoji,
            "accent_color_count": self.accent_color_count,
            "can_set_background_custom_emoji": self.can_set_background_custom_emoji,
            "can_set_emoji_status": self.can_set_emoji_status,
            "chat_theme_background_count": self.chat_theme_background_count,
            "can_set_custom_background": self.can_set_custom_background,
            "can_set_custom_emoji_sticker_set": self.can_set_custom_emoji_sticker_set,
            "can_recognize_speech": self.can_recognize_speech,
            "can_disable_sponsored_messages": self.can_disable_sponsored_messages,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostLevelFeatures", None]:
        if data:
            data_class = cls()
            data_class.level = int(data.get("level", 0))
            data_class.story_per_day_count = int(data.get("story_per_day_count", 0))
            data_class.custom_emoji_reaction_count = int(
                data.get("custom_emoji_reaction_count", 0)
            )
            data_class.title_color_count = int(data.get("title_color_count", 0))
            data_class.profile_accent_color_count = int(
                data.get("profile_accent_color_count", 0)
            )
            data_class.can_set_profile_background_custom_emoji = data.get(
                "can_set_profile_background_custom_emoji", False
            )
            data_class.accent_color_count = int(data.get("accent_color_count", 0))
            data_class.can_set_background_custom_emoji = data.get(
                "can_set_background_custom_emoji", False
            )
            data_class.can_set_emoji_status = data.get("can_set_emoji_status", False)
            data_class.chat_theme_background_count = int(
                data.get("chat_theme_background_count", 0)
            )
            data_class.can_set_custom_background = data.get(
                "can_set_custom_background", False
            )
            data_class.can_set_custom_emoji_sticker_set = data.get(
                "can_set_custom_emoji_sticker_set", False
            )
            data_class.can_recognize_speech = data.get("can_recognize_speech", False)
            data_class.can_disable_sponsored_messages = data.get(
                "can_disable_sponsored_messages", False
            )

        return data_class


class ChatBoostFeatures(TlObject):
    r"""Contains a list of features available on the first chat boost levels

    Parameters:
        features (:class:`List["types.ChatBoostLevelFeatures"]`):
            The list of features

        min_profile_background_custom_emoji_boost_level (:class:`int`):
            The minimum boost level required to set custom emoji for profile background

        min_background_custom_emoji_boost_level (:class:`int`):
            The minimum boost level required to set custom emoji for reply header and link preview background; for channel chats only

        min_emoji_status_boost_level (:class:`int`):
            The minimum boost level required to set emoji status

        min_chat_theme_background_boost_level (:class:`int`):
            The minimum boost level required to set a chat theme background as chat background

        min_custom_background_boost_level (:class:`int`):
            The minimum boost level required to set custom chat background

        min_custom_emoji_sticker_set_boost_level (:class:`int`):
            The minimum boost level required to set custom emoji sticker set for the chat; for supergroup chats only

        min_speech_recognition_boost_level (:class:`int`):
            The minimum boost level allowing to recognize speech in video note and voice note messages for non\-Premium users; for supergroup chats only

        min_sponsored_message_disable_boost_level (:class:`int`):
            The minimum boost level allowing to disable sponsored messages in the chat; for channel chats only

    """

    def __init__(
        self,
        features: List[ChatBoostLevelFeatures] = None,
        min_profile_background_custom_emoji_boost_level: int = 0,
        min_background_custom_emoji_boost_level: int = 0,
        min_emoji_status_boost_level: int = 0,
        min_chat_theme_background_boost_level: int = 0,
        min_custom_background_boost_level: int = 0,
        min_custom_emoji_sticker_set_boost_level: int = 0,
        min_speech_recognition_boost_level: int = 0,
        min_sponsored_message_disable_boost_level: int = 0,
    ) -> None:
        self.features: List[ChatBoostLevelFeatures] = features or []
        r"""The list of features"""
        self.min_profile_background_custom_emoji_boost_level: int = int(
            min_profile_background_custom_emoji_boost_level
        )
        r"""The minimum boost level required to set custom emoji for profile background"""
        self.min_background_custom_emoji_boost_level: int = int(
            min_background_custom_emoji_boost_level
        )
        r"""The minimum boost level required to set custom emoji for reply header and link preview background; for channel chats only"""
        self.min_emoji_status_boost_level: int = int(min_emoji_status_boost_level)
        r"""The minimum boost level required to set emoji status"""
        self.min_chat_theme_background_boost_level: int = int(
            min_chat_theme_background_boost_level
        )
        r"""The minimum boost level required to set a chat theme background as chat background"""
        self.min_custom_background_boost_level: int = int(
            min_custom_background_boost_level
        )
        r"""The minimum boost level required to set custom chat background"""
        self.min_custom_emoji_sticker_set_boost_level: int = int(
            min_custom_emoji_sticker_set_boost_level
        )
        r"""The minimum boost level required to set custom emoji sticker set for the chat; for supergroup chats only"""
        self.min_speech_recognition_boost_level: int = int(
            min_speech_recognition_boost_level
        )
        r"""The minimum boost level allowing to recognize speech in video note and voice note messages for non\-Premium users; for supergroup chats only"""
        self.min_sponsored_message_disable_boost_level: int = int(
            min_sponsored_message_disable_boost_level
        )
        r"""The minimum boost level allowing to disable sponsored messages in the chat; for channel chats only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostFeatures"]:
        return "chatBoostFeatures"

    def getClass(self) -> Literal["ChatBoostFeatures"]:
        return "ChatBoostFeatures"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "features": self.features,
            "min_profile_background_custom_emoji_boost_level": self.min_profile_background_custom_emoji_boost_level,
            "min_background_custom_emoji_boost_level": self.min_background_custom_emoji_boost_level,
            "min_emoji_status_boost_level": self.min_emoji_status_boost_level,
            "min_chat_theme_background_boost_level": self.min_chat_theme_background_boost_level,
            "min_custom_background_boost_level": self.min_custom_background_boost_level,
            "min_custom_emoji_sticker_set_boost_level": self.min_custom_emoji_sticker_set_boost_level,
            "min_speech_recognition_boost_level": self.min_speech_recognition_boost_level,
            "min_sponsored_message_disable_boost_level": self.min_sponsored_message_disable_boost_level,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostFeatures", None]:
        if data:
            data_class = cls()
            data_class.features = data.get("features", None)
            data_class.min_profile_background_custom_emoji_boost_level = int(
                data.get("min_profile_background_custom_emoji_boost_level", 0)
            )
            data_class.min_background_custom_emoji_boost_level = int(
                data.get("min_background_custom_emoji_boost_level", 0)
            )
            data_class.min_emoji_status_boost_level = int(
                data.get("min_emoji_status_boost_level", 0)
            )
            data_class.min_chat_theme_background_boost_level = int(
                data.get("min_chat_theme_background_boost_level", 0)
            )
            data_class.min_custom_background_boost_level = int(
                data.get("min_custom_background_boost_level", 0)
            )
            data_class.min_custom_emoji_sticker_set_boost_level = int(
                data.get("min_custom_emoji_sticker_set_boost_level", 0)
            )
            data_class.min_speech_recognition_boost_level = int(
                data.get("min_speech_recognition_boost_level", 0)
            )
            data_class.min_sponsored_message_disable_boost_level = int(
                data.get("min_sponsored_message_disable_boost_level", 0)
            )

        return data_class


class ChatBoostSourceGiftCode(TlObject, ChatBoostSource):
    r"""The chat created a Telegram Premium gift code for a user

    Parameters:
        user_id (:class:`int`):
            Identifier of a user, for which the gift code was created

        gift_code (:class:`str`):
            The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed

    """

    def __init__(self, user_id: int = 0, gift_code: str = "") -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of a user, for which the gift code was created"""
        self.gift_code: Union[str, None] = gift_code
        r"""The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostSourceGiftCode"]:
        return "chatBoostSourceGiftCode"

    def getClass(self) -> Literal["ChatBoostSource"]:
        return "ChatBoostSource"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "gift_code": self.gift_code,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostSourceGiftCode", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.gift_code = data.get("gift_code", "")

        return data_class


class ChatBoostSourceGiveaway(TlObject, ChatBoostSource):
    r"""The chat created a giveaway

    Parameters:
        user_id (:class:`int`):
            Identifier of a user that won in the giveaway; 0 if none

        gift_code (:class:`str`):
            The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise; for Telegram Premium giveways only

        star_count (:class:`int`):
            Number of Telegram Stars distributed among winners of the giveaway

        giveaway_message_id (:class:`int`):
            Identifier of the corresponding giveaway message; can be an identifier of a deleted message

        is_unclaimed (:class:`bool`):
            True, if the winner for the corresponding giveaway prize wasn't chosen, because there were not enough participants

    """

    def __init__(
        self,
        user_id: int = 0,
        gift_code: str = "",
        star_count: int = 0,
        giveaway_message_id: int = 0,
        is_unclaimed: bool = False,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of a user that won in the giveaway; 0 if none"""
        self.gift_code: Union[str, None] = gift_code
        r"""The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise; for Telegram Premium giveways only"""
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars distributed among winners of the giveaway"""
        self.giveaway_message_id: int = int(giveaway_message_id)
        r"""Identifier of the corresponding giveaway message; can be an identifier of a deleted message"""
        self.is_unclaimed: bool = bool(is_unclaimed)
        r"""True, if the winner for the corresponding giveaway prize wasn't chosen, because there were not enough participants"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostSourceGiveaway"]:
        return "chatBoostSourceGiveaway"

    def getClass(self) -> Literal["ChatBoostSource"]:
        return "ChatBoostSource"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "gift_code": self.gift_code,
            "star_count": self.star_count,
            "giveaway_message_id": self.giveaway_message_id,
            "is_unclaimed": self.is_unclaimed,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostSourceGiveaway", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.gift_code = data.get("gift_code", "")
            data_class.star_count = int(data.get("star_count", 0))
            data_class.giveaway_message_id = int(data.get("giveaway_message_id", 0))
            data_class.is_unclaimed = data.get("is_unclaimed", False)

        return data_class


class ChatBoostSourcePremium(TlObject, ChatBoostSource):
    r"""A user with Telegram Premium subscription or gifted Telegram Premium boosted the chat

    Parameters:
        user_id (:class:`int`):
            Identifier of the user

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostSourcePremium"]:
        return "chatBoostSourcePremium"

    def getClass(self) -> Literal["ChatBoostSource"]:
        return "ChatBoostSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostSourcePremium", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class PrepaidGiveaway(TlObject):
    r"""Describes a prepaid giveaway

    Parameters:
        id (:class:`int`):
            Unique identifier of the prepaid giveaway

        winner_count (:class:`int`):
            Number of users which will receive giveaway prize

        prize (:class:`"types.GiveawayPrize"`):
            Prize of the giveaway

        boost_count (:class:`int`):
            The number of boosts received by the chat from the giveaway; for Telegram Star giveaways only

        payment_date (:class:`int`):
            Point in time \(Unix timestamp\) when the giveaway was paid

    """

    def __init__(
        self,
        id: int = 0,
        winner_count: int = 0,
        prize: GiveawayPrize = None,
        boost_count: int = 0,
        payment_date: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the prepaid giveaway"""
        self.winner_count: int = int(winner_count)
        r"""Number of users which will receive giveaway prize"""
        self.prize: Union[GiveawayPrizePremium, GiveawayPrizeStars, None] = prize
        r"""Prize of the giveaway"""
        self.boost_count: int = int(boost_count)
        r"""The number of boosts received by the chat from the giveaway; for Telegram Star giveaways only"""
        self.payment_date: int = int(payment_date)
        r"""Point in time \(Unix timestamp\) when the giveaway was paid"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["prepaidGiveaway"]:
        return "prepaidGiveaway"

    def getClass(self) -> Literal["PrepaidGiveaway"]:
        return "PrepaidGiveaway"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "winner_count": self.winner_count,
            "prize": self.prize,
            "boost_count": self.boost_count,
            "payment_date": self.payment_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PrepaidGiveaway", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.prize = data.get("prize", None)
            data_class.boost_count = int(data.get("boost_count", 0))
            data_class.payment_date = int(data.get("payment_date", 0))

        return data_class


class ChatBoostStatus(TlObject):
    r"""Describes current boost status of a chat

    Parameters:
        boost_url (:class:`str`):
            An HTTP URL, which can be used to boost the chat

        applied_slot_ids (:class:`List[int]`):
            Identifiers of boost slots of the current user applied to the chat

        level (:class:`int`):
            Current boost level of the chat

        gift_code_boost_count (:class:`int`):
            The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat

        boost_count (:class:`int`):
            The number of boosts received by the chat

        current_level_boost_count (:class:`int`):
            The number of boosts added to reach the current level

        next_level_boost_count (:class:`int`):
            The number of boosts needed to reach the next level; 0 if the next level isn't available

        premium_member_count (:class:`int`):
            Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat

        premium_member_percentage (:class:`float`):
            A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat

        prepaid_giveaways (:class:`List["types.PrepaidGiveaway"]`):
            The list of prepaid giveaways available for the chat; only for chat administrators

    """

    def __init__(
        self,
        boost_url: str = "",
        applied_slot_ids: List[int] = None,
        level: int = 0,
        gift_code_boost_count: int = 0,
        boost_count: int = 0,
        current_level_boost_count: int = 0,
        next_level_boost_count: int = 0,
        premium_member_count: int = 0,
        premium_member_percentage: float = 0.0,
        prepaid_giveaways: List[PrepaidGiveaway] = None,
    ) -> None:
        self.boost_url: Union[str, None] = boost_url
        r"""An HTTP URL, which can be used to boost the chat"""
        self.applied_slot_ids: List[int] = applied_slot_ids or []
        r"""Identifiers of boost slots of the current user applied to the chat"""
        self.level: int = int(level)
        r"""Current boost level of the chat"""
        self.gift_code_boost_count: int = int(gift_code_boost_count)
        r"""The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat"""
        self.boost_count: int = int(boost_count)
        r"""The number of boosts received by the chat"""
        self.current_level_boost_count: int = int(current_level_boost_count)
        r"""The number of boosts added to reach the current level"""
        self.next_level_boost_count: int = int(next_level_boost_count)
        r"""The number of boosts needed to reach the next level; 0 if the next level isn't available"""
        self.premium_member_count: int = int(premium_member_count)
        r"""Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat"""
        self.premium_member_percentage: float = float(premium_member_percentage)
        r"""A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat"""
        self.prepaid_giveaways: List[PrepaidGiveaway] = prepaid_giveaways or []
        r"""The list of prepaid giveaways available for the chat; only for chat administrators"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostStatus"]:
        return "chatBoostStatus"

    def getClass(self) -> Literal["ChatBoostStatus"]:
        return "ChatBoostStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "boost_url": self.boost_url,
            "applied_slot_ids": self.applied_slot_ids,
            "level": self.level,
            "gift_code_boost_count": self.gift_code_boost_count,
            "boost_count": self.boost_count,
            "current_level_boost_count": self.current_level_boost_count,
            "next_level_boost_count": self.next_level_boost_count,
            "premium_member_count": self.premium_member_count,
            "premium_member_percentage": self.premium_member_percentage,
            "prepaid_giveaways": self.prepaid_giveaways,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostStatus", None]:
        if data:
            data_class = cls()
            data_class.boost_url = data.get("boost_url", "")
            data_class.applied_slot_ids = data.get("applied_slot_ids", None)
            data_class.level = int(data.get("level", 0))
            data_class.gift_code_boost_count = int(data.get("gift_code_boost_count", 0))
            data_class.boost_count = int(data.get("boost_count", 0))
            data_class.current_level_boost_count = int(
                data.get("current_level_boost_count", 0)
            )
            data_class.next_level_boost_count = int(
                data.get("next_level_boost_count", 0)
            )
            data_class.premium_member_count = int(data.get("premium_member_count", 0))
            data_class.premium_member_percentage = data.get(
                "premium_member_percentage", 0.0
            )
            data_class.prepaid_giveaways = data.get("prepaid_giveaways", None)

        return data_class


class ChatBoost(TlObject):
    r"""Describes a boost applied to a chat

    Parameters:
        id (:class:`str`):
            Unique identifier of the boost

        count (:class:`int`):
            The number of identical boosts applied

        source (:class:`"types.ChatBoostSource"`):
            Source of the boost

        start_date (:class:`int`):
            Point in time \(Unix timestamp\) when the chat was boosted

        expiration_date (:class:`int`):
            Point in time \(Unix timestamp\) when the boost will expire

    """

    def __init__(
        self,
        id: str = "",
        count: int = 0,
        source: ChatBoostSource = None,
        start_date: int = 0,
        expiration_date: int = 0,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the boost"""
        self.count: int = int(count)
        r"""The number of identical boosts applied"""
        self.source: Union[
            ChatBoostSourceGiftCode,
            ChatBoostSourceGiveaway,
            ChatBoostSourcePremium,
            None,
        ] = source
        r"""Source of the boost"""
        self.start_date: int = int(start_date)
        r"""Point in time \(Unix timestamp\) when the chat was boosted"""
        self.expiration_date: int = int(expiration_date)
        r"""Point in time \(Unix timestamp\) when the boost will expire"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoost"]:
        return "chatBoost"

    def getClass(self) -> Literal["ChatBoost"]:
        return "ChatBoost"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "count": self.count,
            "source": self.source,
            "start_date": self.start_date,
            "expiration_date": self.expiration_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoost", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.count = int(data.get("count", 0))
            data_class.source = data.get("source", None)
            data_class.start_date = int(data.get("start_date", 0))
            data_class.expiration_date = int(data.get("expiration_date", 0))

        return data_class


class FoundChatBoosts(TlObject):
    r"""Contains a list of boosts applied to a chat

    Parameters:
        total_count (:class:`int`):
            Total number of boosts applied to the chat

        boosts (:class:`List["types.ChatBoost"]`):
            List of boosts

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        boosts: List[ChatBoost] = None,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of boosts applied to the chat"""
        self.boosts: List[ChatBoost] = boosts or []
        r"""List of boosts"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundChatBoosts"]:
        return "foundChatBoosts"

    def getClass(self) -> Literal["FoundChatBoosts"]:
        return "FoundChatBoosts"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "boosts": self.boosts,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundChatBoosts", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.boosts = data.get("boosts", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class ChatBoostSlot(TlObject):
    r"""Describes a slot for chat boost

    Parameters:
        slot_id (:class:`int`):
            Unique identifier of the slot

        currently_boosted_chat_id (:class:`int`):
            Identifier of the currently boosted chat; 0 if none

        start_date (:class:`int`):
            Point in time \(Unix timestamp\) when the chat was boosted; 0 if none

        expiration_date (:class:`int`):
            Point in time \(Unix timestamp\) when the boost will expire

        cooldown_until_date (:class:`int`):
            Point in time \(Unix timestamp\) after which the boost can be used for another chat

    """

    def __init__(
        self,
        slot_id: int = 0,
        currently_boosted_chat_id: int = 0,
        start_date: int = 0,
        expiration_date: int = 0,
        cooldown_until_date: int = 0,
    ) -> None:
        self.slot_id: int = int(slot_id)
        r"""Unique identifier of the slot"""
        self.currently_boosted_chat_id: int = int(currently_boosted_chat_id)
        r"""Identifier of the currently boosted chat; 0 if none"""
        self.start_date: int = int(start_date)
        r"""Point in time \(Unix timestamp\) when the chat was boosted; 0 if none"""
        self.expiration_date: int = int(expiration_date)
        r"""Point in time \(Unix timestamp\) when the boost will expire"""
        self.cooldown_until_date: int = int(cooldown_until_date)
        r"""Point in time \(Unix timestamp\) after which the boost can be used for another chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostSlot"]:
        return "chatBoostSlot"

    def getClass(self) -> Literal["ChatBoostSlot"]:
        return "ChatBoostSlot"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "slot_id": self.slot_id,
            "currently_boosted_chat_id": self.currently_boosted_chat_id,
            "start_date": self.start_date,
            "expiration_date": self.expiration_date,
            "cooldown_until_date": self.cooldown_until_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostSlot", None]:
        if data:
            data_class = cls()
            data_class.slot_id = int(data.get("slot_id", 0))
            data_class.currently_boosted_chat_id = int(
                data.get("currently_boosted_chat_id", 0)
            )
            data_class.start_date = int(data.get("start_date", 0))
            data_class.expiration_date = int(data.get("expiration_date", 0))
            data_class.cooldown_until_date = int(data.get("cooldown_until_date", 0))

        return data_class


class ChatBoostSlots(TlObject):
    r"""Contains a list of chat boost slots

    Parameters:
        slots (:class:`List["types.ChatBoostSlot"]`):
            List of boost slots

    """

    def __init__(self, slots: List[ChatBoostSlot] = None) -> None:
        self.slots: List[ChatBoostSlot] = slots or []
        r"""List of boost slots"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostSlots"]:
        return "chatBoostSlots"

    def getClass(self) -> Literal["ChatBoostSlots"]:
        return "ChatBoostSlots"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "slots": self.slots}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostSlots", None]:
        if data:
            data_class = cls()
            data_class.slots = data.get("slots", None)

        return data_class


class ResendCodeReasonUserRequest(TlObject, ResendCodeReason):
    r"""The user requested to resend the code"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["resendCodeReasonUserRequest"]:
        return "resendCodeReasonUserRequest"

    def getClass(self) -> Literal["ResendCodeReason"]:
        return "ResendCodeReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ResendCodeReasonUserRequest", None]:
        if data:
            data_class = cls()

        return data_class


class ResendCodeReasonVerificationFailed(TlObject, ResendCodeReason):
    r"""The code is re\-sent, because device verification has failed

    Parameters:
        error_message (:class:`str`):
            Cause of the verification failure, for example, PLAY\_SERVICES\_NOT\_AVAILABLE, APNS\_RECEIVE\_TIMEOUT, or APNS\_INIT\_FAILED

    """

    def __init__(self, error_message: str = "") -> None:
        self.error_message: Union[str, None] = error_message
        r"""Cause of the verification failure, for example, PLAY\_SERVICES\_NOT\_AVAILABLE, APNS\_RECEIVE\_TIMEOUT, or APNS\_INIT\_FAILED"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["resendCodeReasonVerificationFailed"]:
        return "resendCodeReasonVerificationFailed"

    def getClass(self) -> Literal["ResendCodeReason"]:
        return "ResendCodeReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "error_message": self.error_message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ResendCodeReasonVerificationFailed", None]:
        if data:
            data_class = cls()
            data_class.error_message = data.get("error_message", "")

        return data_class


class CallDiscardReasonEmpty(TlObject, CallDiscardReason):
    r"""The call wasn't discarded, or the reason is unknown"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callDiscardReasonEmpty"]:
        return "callDiscardReasonEmpty"

    def getClass(self) -> Literal["CallDiscardReason"]:
        return "CallDiscardReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallDiscardReasonEmpty", None]:
        if data:
            data_class = cls()

        return data_class


class CallDiscardReasonMissed(TlObject, CallDiscardReason):
    r"""The call was ended before the conversation started\. It was canceled by the caller or missed by the other party"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callDiscardReasonMissed"]:
        return "callDiscardReasonMissed"

    def getClass(self) -> Literal["CallDiscardReason"]:
        return "CallDiscardReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallDiscardReasonMissed", None]:
        if data:
            data_class = cls()

        return data_class


class CallDiscardReasonDeclined(TlObject, CallDiscardReason):
    r"""The call was ended before the conversation started\. It was declined by the other party"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callDiscardReasonDeclined"]:
        return "callDiscardReasonDeclined"

    def getClass(self) -> Literal["CallDiscardReason"]:
        return "CallDiscardReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallDiscardReasonDeclined", None]:
        if data:
            data_class = cls()

        return data_class


class CallDiscardReasonDisconnected(TlObject, CallDiscardReason):
    r"""The call was ended during the conversation because the users were disconnected"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callDiscardReasonDisconnected"]:
        return "callDiscardReasonDisconnected"

    def getClass(self) -> Literal["CallDiscardReason"]:
        return "CallDiscardReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallDiscardReasonDisconnected", None]:
        if data:
            data_class = cls()

        return data_class


class CallDiscardReasonHungUp(TlObject, CallDiscardReason):
    r"""The call was ended because one of the parties hung up"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callDiscardReasonHungUp"]:
        return "callDiscardReasonHungUp"

    def getClass(self) -> Literal["CallDiscardReason"]:
        return "CallDiscardReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallDiscardReasonHungUp", None]:
        if data:
            data_class = cls()

        return data_class


class CallDiscardReasonAllowGroupCall(TlObject, CallDiscardReason):
    r"""The call was ended because it has been used successfully to transfer private encryption key for the associated group call

    Parameters:
        encrypted_group_call_key (:class:`bytes`):
            Encrypted using the call private key encryption key for the associated group call

    """

    def __init__(self, encrypted_group_call_key: bytes = b"") -> None:
        self.encrypted_group_call_key: Union[bytes, None] = encrypted_group_call_key
        r"""Encrypted using the call private key encryption key for the associated group call"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callDiscardReasonAllowGroupCall"]:
        return "callDiscardReasonAllowGroupCall"

    def getClass(self) -> Literal["CallDiscardReason"]:
        return "CallDiscardReason"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "encrypted_group_call_key": self.encrypted_group_call_key,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallDiscardReasonAllowGroupCall", None]:
        if data:
            data_class = cls()
            data_class.encrypted_group_call_key = b64decode(
                data.get("encrypted_group_call_key", b"")
            )

        return data_class


class CallProtocol(TlObject):
    r"""Specifies the supported call protocols

    Parameters:
        udp_p2p (:class:`bool`):
            True, if UDP peer\-to\-peer connections are supported

        udp_reflector (:class:`bool`):
            True, if connection through UDP reflectors is supported

        min_layer (:class:`int`):
            The minimum supported API layer; use 65

        max_layer (:class:`int`):
            The maximum supported API layer; use 92

        library_versions (:class:`List[str]`):
            List of supported tgcalls versions

    """

    def __init__(
        self,
        udp_p2p: bool = False,
        udp_reflector: bool = False,
        min_layer: int = 0,
        max_layer: int = 0,
        library_versions: List[str] = None,
    ) -> None:
        self.udp_p2p: bool = bool(udp_p2p)
        r"""True, if UDP peer\-to\-peer connections are supported"""
        self.udp_reflector: bool = bool(udp_reflector)
        r"""True, if connection through UDP reflectors is supported"""
        self.min_layer: int = int(min_layer)
        r"""The minimum supported API layer; use 65"""
        self.max_layer: int = int(max_layer)
        r"""The maximum supported API layer; use 92"""
        self.library_versions: List[str] = library_versions or []
        r"""List of supported tgcalls versions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProtocol"]:
        return "callProtocol"

    def getClass(self) -> Literal["CallProtocol"]:
        return "CallProtocol"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "udp_p2p": self.udp_p2p,
            "udp_reflector": self.udp_reflector,
            "min_layer": self.min_layer,
            "max_layer": self.max_layer,
            "library_versions": self.library_versions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProtocol", None]:
        if data:
            data_class = cls()
            data_class.udp_p2p = data.get("udp_p2p", False)
            data_class.udp_reflector = data.get("udp_reflector", False)
            data_class.min_layer = int(data.get("min_layer", 0))
            data_class.max_layer = int(data.get("max_layer", 0))
            data_class.library_versions = data.get("library_versions", None)

        return data_class


class CallServerTypeTelegramReflector(TlObject, CallServerType):
    r"""A Telegram call reflector

    Parameters:
        peer_tag (:class:`bytes`):
            A peer tag to be used with the reflector

        is_tcp (:class:`bool`):
            True, if the server uses TCP instead of UDP

    """

    def __init__(self, peer_tag: bytes = b"", is_tcp: bool = False) -> None:
        self.peer_tag: Union[bytes, None] = peer_tag
        r"""A peer tag to be used with the reflector"""
        self.is_tcp: bool = bool(is_tcp)
        r"""True, if the server uses TCP instead of UDP"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callServerTypeTelegramReflector"]:
        return "callServerTypeTelegramReflector"

    def getClass(self) -> Literal["CallServerType"]:
        return "CallServerType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "peer_tag": self.peer_tag,
            "is_tcp": self.is_tcp,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallServerTypeTelegramReflector", None]:
        if data:
            data_class = cls()
            data_class.peer_tag = b64decode(data.get("peer_tag", b""))
            data_class.is_tcp = data.get("is_tcp", False)

        return data_class


class CallServerTypeWebrtc(TlObject, CallServerType):
    r"""A WebRTC server

    Parameters:
        username (:class:`str`):
            Username to be used for authentication

        password (:class:`str`):
            Authentication password

        supports_turn (:class:`bool`):
            True, if the server supports TURN

        supports_stun (:class:`bool`):
            True, if the server supports STUN

    """

    def __init__(
        self,
        username: str = "",
        password: str = "",
        supports_turn: bool = False,
        supports_stun: bool = False,
    ) -> None:
        self.username: Union[str, None] = username
        r"""Username to be used for authentication"""
        self.password: Union[str, None] = password
        r"""Authentication password"""
        self.supports_turn: bool = bool(supports_turn)
        r"""True, if the server supports TURN"""
        self.supports_stun: bool = bool(supports_stun)
        r"""True, if the server supports STUN"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callServerTypeWebrtc"]:
        return "callServerTypeWebrtc"

    def getClass(self) -> Literal["CallServerType"]:
        return "CallServerType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "username": self.username,
            "password": self.password,
            "supports_turn": self.supports_turn,
            "supports_stun": self.supports_stun,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallServerTypeWebrtc", None]:
        if data:
            data_class = cls()
            data_class.username = data.get("username", "")
            data_class.password = data.get("password", "")
            data_class.supports_turn = data.get("supports_turn", False)
            data_class.supports_stun = data.get("supports_stun", False)

        return data_class


class CallServer(TlObject):
    r"""Describes a server for relaying call data

    Parameters:
        id (:class:`int`):
            Server identifier

        ip_address (:class:`str`):
            Server IPv4 address

        ipv6_address (:class:`str`):
            Server IPv6 address

        port (:class:`int`):
            Server port number

        type (:class:`"types.CallServerType"`):
            Server type

    """

    def __init__(
        self,
        id: int = 0,
        ip_address: str = "",
        ipv6_address: str = "",
        port: int = 0,
        type: CallServerType = None,
    ) -> None:
        self.id: int = int(id)
        r"""Server identifier"""
        self.ip_address: Union[str, None] = ip_address
        r"""Server IPv4 address"""
        self.ipv6_address: Union[str, None] = ipv6_address
        r"""Server IPv6 address"""
        self.port: int = int(port)
        r"""Server port number"""
        self.type: Union[
            CallServerTypeTelegramReflector, CallServerTypeWebrtc, None
        ] = type
        r"""Server type"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callServer"]:
        return "callServer"

    def getClass(self) -> Literal["CallServer"]:
        return "CallServer"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "ip_address": self.ip_address,
            "ipv6_address": self.ipv6_address,
            "port": self.port,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallServer", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.ip_address = data.get("ip_address", "")
            data_class.ipv6_address = data.get("ipv6_address", "")
            data_class.port = int(data.get("port", 0))
            data_class.type = data.get("type", None)

        return data_class


class CallId(TlObject):
    r"""Contains the call identifier

    Parameters:
        id (:class:`int`):
            Call identifier

    """

    def __init__(self, id: int = 0) -> None:
        self.id: int = int(id)
        r"""Call identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callId"]:
        return "callId"

    def getClass(self) -> Literal["CallId"]:
        return "CallId"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallId", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))

        return data_class


class GroupCallId(TlObject):
    r"""Contains the group call identifier

    Parameters:
        id (:class:`int`):
            Group call identifier

    """

    def __init__(self, id: int = 0) -> None:
        self.id: int = int(id)
        r"""Group call identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallId"]:
        return "groupCallId"

    def getClass(self) -> Literal["GroupCallId"]:
        return "GroupCallId"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallId", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))

        return data_class


class CallStatePending(TlObject, CallState):
    r"""The call is pending, waiting to be accepted by a user

    Parameters:
        is_created (:class:`bool`):
            True, if the call has already been created by the server

        is_received (:class:`bool`):
            True, if the call has already been received by the other party

    """

    def __init__(self, is_created: bool = False, is_received: bool = False) -> None:
        self.is_created: bool = bool(is_created)
        r"""True, if the call has already been created by the server"""
        self.is_received: bool = bool(is_received)
        r"""True, if the call has already been received by the other party"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callStatePending"]:
        return "callStatePending"

    def getClass(self) -> Literal["CallState"]:
        return "CallState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_created": self.is_created,
            "is_received": self.is_received,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallStatePending", None]:
        if data:
            data_class = cls()
            data_class.is_created = data.get("is_created", False)
            data_class.is_received = data.get("is_received", False)

        return data_class


class CallStateExchangingKeys(TlObject, CallState):
    r"""The call has been answered and encryption keys are being exchanged"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callStateExchangingKeys"]:
        return "callStateExchangingKeys"

    def getClass(self) -> Literal["CallState"]:
        return "CallState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallStateExchangingKeys", None]:
        if data:
            data_class = cls()

        return data_class


class CallStateReady(TlObject, CallState):
    r"""The call is ready to use

    Parameters:
        protocol (:class:`"types.CallProtocol"`):
            Call protocols supported by the other call participant

        servers (:class:`List["types.CallServer"]`):
            List of available call servers

        config (:class:`str`):
            A JSON\-encoded call config

        encryption_key (:class:`bytes`):
            Call encryption key

        emojis (:class:`List[str]`):
            Encryption key fingerprint represented as 4 emoji

        allow_p2p (:class:`bool`):
            True, if peer\-to\-peer connection is allowed by users privacy settings

        custom_parameters (:class:`str`):
            Custom JSON\-encoded call parameters to be passed to tgcalls

    """

    def __init__(
        self,
        protocol: CallProtocol = None,
        servers: List[CallServer] = None,
        config: str = "",
        encryption_key: bytes = b"",
        emojis: List[str] = None,
        allow_p2p: bool = False,
        custom_parameters: str = "",
    ) -> None:
        self.protocol: Union[CallProtocol, None] = protocol
        r"""Call protocols supported by the other call participant"""
        self.servers: List[CallServer] = servers or []
        r"""List of available call servers"""
        self.config: Union[str, None] = config
        r"""A JSON\-encoded call config"""
        self.encryption_key: Union[bytes, None] = encryption_key
        r"""Call encryption key"""
        self.emojis: List[str] = emojis or []
        r"""Encryption key fingerprint represented as 4 emoji"""
        self.allow_p2p: bool = bool(allow_p2p)
        r"""True, if peer\-to\-peer connection is allowed by users privacy settings"""
        self.custom_parameters: Union[str, None] = custom_parameters
        r"""Custom JSON\-encoded call parameters to be passed to tgcalls"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callStateReady"]:
        return "callStateReady"

    def getClass(self) -> Literal["CallState"]:
        return "CallState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "protocol": self.protocol,
            "servers": self.servers,
            "config": self.config,
            "encryption_key": self.encryption_key,
            "emojis": self.emojis,
            "allow_p2p": self.allow_p2p,
            "custom_parameters": self.custom_parameters,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallStateReady", None]:
        if data:
            data_class = cls()
            data_class.protocol = data.get("protocol", None)
            data_class.servers = data.get("servers", None)
            data_class.config = data.get("config", "")
            data_class.encryption_key = b64decode(data.get("encryption_key", b""))
            data_class.emojis = data.get("emojis", None)
            data_class.allow_p2p = data.get("allow_p2p", False)
            data_class.custom_parameters = data.get("custom_parameters", "")

        return data_class


class CallStateHangingUp(TlObject, CallState):
    r"""The call is hanging up after discardCall has been called"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callStateHangingUp"]:
        return "callStateHangingUp"

    def getClass(self) -> Literal["CallState"]:
        return "CallState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallStateHangingUp", None]:
        if data:
            data_class = cls()

        return data_class


class CallStateDiscarded(TlObject, CallState):
    r"""The call has ended successfully

    Parameters:
        reason (:class:`"types.CallDiscardReason"`):
            The reason why the call has ended

        need_rating (:class:`bool`):
            True, if the call rating must be sent to the server

        need_debug_information (:class:`bool`):
            True, if the call debug information must be sent to the server

        need_log (:class:`bool`):
            True, if the call log must be sent to the server

    """

    def __init__(
        self,
        reason: CallDiscardReason = None,
        need_rating: bool = False,
        need_debug_information: bool = False,
        need_log: bool = False,
    ) -> None:
        self.reason: Union[
            CallDiscardReasonEmpty,
            CallDiscardReasonMissed,
            CallDiscardReasonDeclined,
            CallDiscardReasonDisconnected,
            CallDiscardReasonHungUp,
            CallDiscardReasonAllowGroupCall,
            None,
        ] = reason
        r"""The reason why the call has ended"""
        self.need_rating: bool = bool(need_rating)
        r"""True, if the call rating must be sent to the server"""
        self.need_debug_information: bool = bool(need_debug_information)
        r"""True, if the call debug information must be sent to the server"""
        self.need_log: bool = bool(need_log)
        r"""True, if the call log must be sent to the server"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callStateDiscarded"]:
        return "callStateDiscarded"

    def getClass(self) -> Literal["CallState"]:
        return "CallState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reason": self.reason,
            "need_rating": self.need_rating,
            "need_debug_information": self.need_debug_information,
            "need_log": self.need_log,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallStateDiscarded", None]:
        if data:
            data_class = cls()
            data_class.reason = data.get("reason", None)
            data_class.need_rating = data.get("need_rating", False)
            data_class.need_debug_information = data.get(
                "need_debug_information", False
            )
            data_class.need_log = data.get("need_log", False)

        return data_class


class CallStateError(TlObject, CallState):
    r"""The call has ended with an error

    Parameters:
        error (:class:`"types.Error"`):
            Error\. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout

    """

    def __init__(self, error: Error = None) -> None:
        self.error: Union[Error, None] = error
        r"""Error\. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callStateError"]:
        return "callStateError"

    def getClass(self) -> Literal["CallState"]:
        return "CallState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "error": self.error}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallStateError", None]:
        if data:
            data_class = cls()
            data_class.error = data.get("error", None)

        return data_class


class GroupCallVideoQualityThumbnail(TlObject, GroupCallVideoQuality):
    r"""The worst available video quality"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallVideoQualityThumbnail"]:
        return "groupCallVideoQualityThumbnail"

    def getClass(self) -> Literal["GroupCallVideoQuality"]:
        return "GroupCallVideoQuality"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallVideoQualityThumbnail", None]:
        if data:
            data_class = cls()

        return data_class


class GroupCallVideoQualityMedium(TlObject, GroupCallVideoQuality):
    r"""The medium video quality"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallVideoQualityMedium"]:
        return "groupCallVideoQualityMedium"

    def getClass(self) -> Literal["GroupCallVideoQuality"]:
        return "GroupCallVideoQuality"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallVideoQualityMedium", None]:
        if data:
            data_class = cls()

        return data_class


class GroupCallVideoQualityFull(TlObject, GroupCallVideoQuality):
    r"""The best available video quality"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallVideoQualityFull"]:
        return "groupCallVideoQualityFull"

    def getClass(self) -> Literal["GroupCallVideoQuality"]:
        return "GroupCallVideoQuality"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallVideoQualityFull", None]:
        if data:
            data_class = cls()

        return data_class


class GroupCallStream(TlObject):
    r"""Describes an available stream in a group call

    Parameters:
        channel_id (:class:`int`):
            Identifier of an audio/video channel

        scale (:class:`int`):
            Scale of segment durations in the stream\. The duration is 1000/\(2\*\*scale\) milliseconds

        time_offset (:class:`int`):
            Point in time when the stream currently ends; Unix timestamp in milliseconds

    """

    def __init__(
        self, channel_id: int = 0, scale: int = 0, time_offset: int = 0
    ) -> None:
        self.channel_id: int = int(channel_id)
        r"""Identifier of an audio/video channel"""
        self.scale: int = int(scale)
        r"""Scale of segment durations in the stream\. The duration is 1000/\(2\*\*scale\) milliseconds"""
        self.time_offset: int = int(time_offset)
        r"""Point in time when the stream currently ends; Unix timestamp in milliseconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallStream"]:
        return "groupCallStream"

    def getClass(self) -> Literal["GroupCallStream"]:
        return "GroupCallStream"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "channel_id": self.channel_id,
            "scale": self.scale,
            "time_offset": self.time_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallStream", None]:
        if data:
            data_class = cls()
            data_class.channel_id = int(data.get("channel_id", 0))
            data_class.scale = int(data.get("scale", 0))
            data_class.time_offset = int(data.get("time_offset", 0))

        return data_class


class GroupCallStreams(TlObject):
    r"""Represents a list of group call streams

    Parameters:
        streams (:class:`List["types.GroupCallStream"]`):
            A list of group call streams

    """

    def __init__(self, streams: List[GroupCallStream] = None) -> None:
        self.streams: List[GroupCallStream] = streams or []
        r"""A list of group call streams"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallStreams"]:
        return "groupCallStreams"

    def getClass(self) -> Literal["GroupCallStreams"]:
        return "GroupCallStreams"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "streams": self.streams}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallStreams", None]:
        if data:
            data_class = cls()
            data_class.streams = data.get("streams", None)

        return data_class


class RtmpUrl(TlObject):
    r"""Represents an RTMP URL

    Parameters:
        url (:class:`str`):
            The URL

        stream_key (:class:`str`):
            Stream key

    """

    def __init__(self, url: str = "", stream_key: str = "") -> None:
        self.url: Union[str, None] = url
        r"""The URL"""
        self.stream_key: Union[str, None] = stream_key
        r"""Stream key"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["rtmpUrl"]:
        return "rtmpUrl"

    def getClass(self) -> Literal["RtmpUrl"]:
        return "RtmpUrl"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url, "stream_key": self.stream_key}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RtmpUrl", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.stream_key = data.get("stream_key", "")

        return data_class


class GroupCallRecentSpeaker(TlObject):
    r"""Describes a recently speaking participant in a group call

    Parameters:
        participant_id (:class:`"types.MessageSender"`):
            Group call participant identifier

        is_speaking (:class:`bool`):
            True, is the user has spoken recently

    """

    def __init__(
        self, participant_id: MessageSender = None, is_speaking: bool = False
    ) -> None:
        self.participant_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            participant_id
        )
        r"""Group call participant identifier"""
        self.is_speaking: bool = bool(is_speaking)
        r"""True, is the user has spoken recently"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallRecentSpeaker"]:
        return "groupCallRecentSpeaker"

    def getClass(self) -> Literal["GroupCallRecentSpeaker"]:
        return "GroupCallRecentSpeaker"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "participant_id": self.participant_id,
            "is_speaking": self.is_speaking,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallRecentSpeaker", None]:
        if data:
            data_class = cls()
            data_class.participant_id = data.get("participant_id", None)
            data_class.is_speaking = data.get("is_speaking", False)

        return data_class


class GroupCall(TlObject):
    r"""Describes a group call

    Parameters:
        id (:class:`int`):
            Group call identifier

        from_call_id (:class:`int`):
            Identifier of one\-to\-one call from which the group call was created; 0 if unknown

        title (:class:`str`):
            Group call title

        scheduled_start_date (:class:`int`):
            Point in time \(Unix timestamp\) when the group call is expected to be started by an administrator; 0 if it is already active or was ended

        enabled_start_notification (:class:`bool`):
            True, if the group call is scheduled and the current user will receive a notification when the group call starts

        is_active (:class:`bool`):
            True, if the call is active

        is_rtmp_stream (:class:`bool`):
            True, if the chat is an RTMP stream instead of an ordinary video chat

        is_joined (:class:`bool`):
            True, if the call is joined

        need_rejoin (:class:`bool`):
            True, if user was kicked from the call because of network loss and the call needs to be rejoined

        can_be_managed (:class:`bool`):
            True, if the current user can manage the group call

        participant_count (:class:`int`):
            Number of participants in the group call

        has_hidden_listeners (:class:`bool`):
            True, if group call participants, which are muted, aren't returned in participant list

        loaded_all_participants (:class:`bool`):
            True, if all group call participants are loaded

        recent_speakers (:class:`List["types.GroupCallRecentSpeaker"]`):
            At most 3 recently speaking users in the group call

        is_my_video_enabled (:class:`bool`):
            True, if the current user's video is enabled

        is_my_video_paused (:class:`bool`):
            True, if the current user's video is paused

        can_enable_video (:class:`bool`):
            True, if the current user can broadcast video or share screen

        mute_new_participants (:class:`bool`):
            True, if only group call administrators can unmute new participants

        can_toggle_mute_new_participants (:class:`bool`):
            True, if the current user can enable or disable mute\_new\_participants setting

        record_duration (:class:`int`):
            Duration of the ongoing group call recording, in seconds; 0 if none\. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on

        is_video_recorded (:class:`bool`):
            True, if a video file is being recorded for the call

        duration (:class:`int`):
            Call duration, in seconds; for ended calls only

    """

    def __init__(
        self,
        id: int = 0,
        from_call_id: int = 0,
        title: str = "",
        scheduled_start_date: int = 0,
        enabled_start_notification: bool = False,
        is_active: bool = False,
        is_rtmp_stream: bool = False,
        is_joined: bool = False,
        need_rejoin: bool = False,
        can_be_managed: bool = False,
        participant_count: int = 0,
        has_hidden_listeners: bool = False,
        loaded_all_participants: bool = False,
        recent_speakers: List[GroupCallRecentSpeaker] = None,
        is_my_video_enabled: bool = False,
        is_my_video_paused: bool = False,
        can_enable_video: bool = False,
        mute_new_participants: bool = False,
        can_toggle_mute_new_participants: bool = False,
        record_duration: int = 0,
        is_video_recorded: bool = False,
        duration: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Group call identifier"""
        self.from_call_id: int = int(from_call_id)
        r"""Identifier of one\-to\-one call from which the group call was created; 0 if unknown"""
        self.title: Union[str, None] = title
        r"""Group call title"""
        self.scheduled_start_date: int = int(scheduled_start_date)
        r"""Point in time \(Unix timestamp\) when the group call is expected to be started by an administrator; 0 if it is already active or was ended"""
        self.enabled_start_notification: bool = bool(enabled_start_notification)
        r"""True, if the group call is scheduled and the current user will receive a notification when the group call starts"""
        self.is_active: bool = bool(is_active)
        r"""True, if the call is active"""
        self.is_rtmp_stream: bool = bool(is_rtmp_stream)
        r"""True, if the chat is an RTMP stream instead of an ordinary video chat"""
        self.is_joined: bool = bool(is_joined)
        r"""True, if the call is joined"""
        self.need_rejoin: bool = bool(need_rejoin)
        r"""True, if user was kicked from the call because of network loss and the call needs to be rejoined"""
        self.can_be_managed: bool = bool(can_be_managed)
        r"""True, if the current user can manage the group call"""
        self.participant_count: int = int(participant_count)
        r"""Number of participants in the group call"""
        self.has_hidden_listeners: bool = bool(has_hidden_listeners)
        r"""True, if group call participants, which are muted, aren't returned in participant list"""
        self.loaded_all_participants: bool = bool(loaded_all_participants)
        r"""True, if all group call participants are loaded"""
        self.recent_speakers: List[GroupCallRecentSpeaker] = recent_speakers or []
        r"""At most 3 recently speaking users in the group call"""
        self.is_my_video_enabled: bool = bool(is_my_video_enabled)
        r"""True, if the current user's video is enabled"""
        self.is_my_video_paused: bool = bool(is_my_video_paused)
        r"""True, if the current user's video is paused"""
        self.can_enable_video: bool = bool(can_enable_video)
        r"""True, if the current user can broadcast video or share screen"""
        self.mute_new_participants: bool = bool(mute_new_participants)
        r"""True, if only group call administrators can unmute new participants"""
        self.can_toggle_mute_new_participants: bool = bool(
            can_toggle_mute_new_participants
        )
        r"""True, if the current user can enable or disable mute\_new\_participants setting"""
        self.record_duration: int = int(record_duration)
        r"""Duration of the ongoing group call recording, in seconds; 0 if none\. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on"""
        self.is_video_recorded: bool = bool(is_video_recorded)
        r"""True, if a video file is being recorded for the call"""
        self.duration: int = int(duration)
        r"""Call duration, in seconds; for ended calls only"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCall"]:
        return "groupCall"

    def getClass(self) -> Literal["GroupCall"]:
        return "GroupCall"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "from_call_id": self.from_call_id,
            "title": self.title,
            "scheduled_start_date": self.scheduled_start_date,
            "enabled_start_notification": self.enabled_start_notification,
            "is_active": self.is_active,
            "is_rtmp_stream": self.is_rtmp_stream,
            "is_joined": self.is_joined,
            "need_rejoin": self.need_rejoin,
            "can_be_managed": self.can_be_managed,
            "participant_count": self.participant_count,
            "has_hidden_listeners": self.has_hidden_listeners,
            "loaded_all_participants": self.loaded_all_participants,
            "recent_speakers": self.recent_speakers,
            "is_my_video_enabled": self.is_my_video_enabled,
            "is_my_video_paused": self.is_my_video_paused,
            "can_enable_video": self.can_enable_video,
            "mute_new_participants": self.mute_new_participants,
            "can_toggle_mute_new_participants": self.can_toggle_mute_new_participants,
            "record_duration": self.record_duration,
            "is_video_recorded": self.is_video_recorded,
            "duration": self.duration,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCall", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.from_call_id = int(data.get("from_call_id", 0))
            data_class.title = data.get("title", "")
            data_class.scheduled_start_date = int(data.get("scheduled_start_date", 0))
            data_class.enabled_start_notification = data.get(
                "enabled_start_notification", False
            )
            data_class.is_active = data.get("is_active", False)
            data_class.is_rtmp_stream = data.get("is_rtmp_stream", False)
            data_class.is_joined = data.get("is_joined", False)
            data_class.need_rejoin = data.get("need_rejoin", False)
            data_class.can_be_managed = data.get("can_be_managed", False)
            data_class.participant_count = int(data.get("participant_count", 0))
            data_class.has_hidden_listeners = data.get("has_hidden_listeners", False)
            data_class.loaded_all_participants = data.get(
                "loaded_all_participants", False
            )
            data_class.recent_speakers = data.get("recent_speakers", None)
            data_class.is_my_video_enabled = data.get("is_my_video_enabled", False)
            data_class.is_my_video_paused = data.get("is_my_video_paused", False)
            data_class.can_enable_video = data.get("can_enable_video", False)
            data_class.mute_new_participants = data.get("mute_new_participants", False)
            data_class.can_toggle_mute_new_participants = data.get(
                "can_toggle_mute_new_participants", False
            )
            data_class.record_duration = int(data.get("record_duration", 0))
            data_class.is_video_recorded = data.get("is_video_recorded", False)
            data_class.duration = int(data.get("duration", 0))

        return data_class


class GroupCallVideoSourceGroup(TlObject):
    r"""Describes a group of video synchronization source identifiers

    Parameters:
        semantics (:class:`str`):
            The semantics of sources, one of \"SIM\" or \"FID\"

        source_ids (:class:`List[int]`):
            The list of synchronization source identifiers

    """

    def __init__(self, semantics: str = "", source_ids: List[int] = None) -> None:
        self.semantics: Union[str, None] = semantics
        r"""The semantics of sources, one of \"SIM\" or \"FID\""""
        self.source_ids: List[int] = source_ids or []
        r"""The list of synchronization source identifiers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallVideoSourceGroup"]:
        return "groupCallVideoSourceGroup"

    def getClass(self) -> Literal["GroupCallVideoSourceGroup"]:
        return "GroupCallVideoSourceGroup"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "semantics": self.semantics,
            "source_ids": self.source_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallVideoSourceGroup", None]:
        if data:
            data_class = cls()
            data_class.semantics = data.get("semantics", "")
            data_class.source_ids = data.get("source_ids", None)

        return data_class


class GroupCallParticipantVideoInfo(TlObject):
    r"""Contains information about a group call participant's video channel

    Parameters:
        source_groups (:class:`List["types.GroupCallVideoSourceGroup"]`):
            List of synchronization source groups of the video

        endpoint_id (:class:`str`):
            Video channel endpoint identifier

        is_paused (:class:`bool`):
            True, if the video is paused\. This flag needs to be ignored, if new video frames are received

    """

    def __init__(
        self,
        source_groups: List[GroupCallVideoSourceGroup] = None,
        endpoint_id: str = "",
        is_paused: bool = False,
    ) -> None:
        self.source_groups: List[GroupCallVideoSourceGroup] = source_groups or []
        r"""List of synchronization source groups of the video"""
        self.endpoint_id: Union[str, None] = endpoint_id
        r"""Video channel endpoint identifier"""
        self.is_paused: bool = bool(is_paused)
        r"""True, if the video is paused\. This flag needs to be ignored, if new video frames are received"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallParticipantVideoInfo"]:
        return "groupCallParticipantVideoInfo"

    def getClass(self) -> Literal["GroupCallParticipantVideoInfo"]:
        return "GroupCallParticipantVideoInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "source_groups": self.source_groups,
            "endpoint_id": self.endpoint_id,
            "is_paused": self.is_paused,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallParticipantVideoInfo", None]:
        if data:
            data_class = cls()
            data_class.source_groups = data.get("source_groups", None)
            data_class.endpoint_id = data.get("endpoint_id", "")
            data_class.is_paused = data.get("is_paused", False)

        return data_class


class GroupCallParticipant(TlObject):
    r"""Represents a group call participant

    Parameters:
        participant_id (:class:`"types.MessageSender"`):
            Identifier of the group call participant

        audio_source_id (:class:`int`):
            User's audio channel synchronization source identifier

        screen_sharing_audio_source_id (:class:`int`):
            User's screen sharing audio channel synchronization source identifier

        video_info (:class:`"types.GroupCallParticipantVideoInfo"`):
            Information about user's video channel; may be null if there is no active video

        screen_sharing_video_info (:class:`"types.GroupCallParticipantVideoInfo"`):
            Information about user's screen sharing video channel; may be null if there is no active screen sharing video

        bio (:class:`str`):
            The participant user's bio or the participant chat's description

        is_current_user (:class:`bool`):
            True, if the participant is the current user

        is_speaking (:class:`bool`):
            True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking

        is_hand_raised (:class:`bool`):
            True, if the participant hand is raised

        can_be_muted_for_all_users (:class:`bool`):
            True, if the current user can mute the participant for all other group call participants

        can_be_unmuted_for_all_users (:class:`bool`):
            True, if the current user can allow the participant to unmute themselves or unmute the participant \(if the participant is the current user\)

        can_be_muted_for_current_user (:class:`bool`):
            True, if the current user can mute the participant only for self

        can_be_unmuted_for_current_user (:class:`bool`):
            True, if the current user can unmute the participant for self

        is_muted_for_all_users (:class:`bool`):
            True, if the participant is muted for all users

        is_muted_for_current_user (:class:`bool`):
            True, if the participant is muted for the current user

        can_unmute_self (:class:`bool`):
            True, if the participant is muted for all users, but can unmute themselves

        volume_level (:class:`int`):
            Participant's volume level; 1\-20000 in hundreds of percents

        order (:class:`str`):
            User's order in the group call participant list\. Orders must be compared lexicographically\. The bigger is order, the higher is user in the list\. If order is empty, the user must be removed from the participant list

    """

    def __init__(
        self,
        participant_id: MessageSender = None,
        audio_source_id: int = 0,
        screen_sharing_audio_source_id: int = 0,
        video_info: GroupCallParticipantVideoInfo = None,
        screen_sharing_video_info: GroupCallParticipantVideoInfo = None,
        bio: str = "",
        is_current_user: bool = False,
        is_speaking: bool = False,
        is_hand_raised: bool = False,
        can_be_muted_for_all_users: bool = False,
        can_be_unmuted_for_all_users: bool = False,
        can_be_muted_for_current_user: bool = False,
        can_be_unmuted_for_current_user: bool = False,
        is_muted_for_all_users: bool = False,
        is_muted_for_current_user: bool = False,
        can_unmute_self: bool = False,
        volume_level: int = 0,
        order: str = "",
    ) -> None:
        self.participant_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            participant_id
        )
        r"""Identifier of the group call participant"""
        self.audio_source_id: int = int(audio_source_id)
        r"""User's audio channel synchronization source identifier"""
        self.screen_sharing_audio_source_id: int = int(screen_sharing_audio_source_id)
        r"""User's screen sharing audio channel synchronization source identifier"""
        self.video_info: Union[GroupCallParticipantVideoInfo, None] = video_info
        r"""Information about user's video channel; may be null if there is no active video"""
        self.screen_sharing_video_info: Union[GroupCallParticipantVideoInfo, None] = (
            screen_sharing_video_info
        )
        r"""Information about user's screen sharing video channel; may be null if there is no active screen sharing video"""
        self.bio: Union[str, None] = bio
        r"""The participant user's bio or the participant chat's description"""
        self.is_current_user: bool = bool(is_current_user)
        r"""True, if the participant is the current user"""
        self.is_speaking: bool = bool(is_speaking)
        r"""True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking"""
        self.is_hand_raised: bool = bool(is_hand_raised)
        r"""True, if the participant hand is raised"""
        self.can_be_muted_for_all_users: bool = bool(can_be_muted_for_all_users)
        r"""True, if the current user can mute the participant for all other group call participants"""
        self.can_be_unmuted_for_all_users: bool = bool(can_be_unmuted_for_all_users)
        r"""True, if the current user can allow the participant to unmute themselves or unmute the participant \(if the participant is the current user\)"""
        self.can_be_muted_for_current_user: bool = bool(can_be_muted_for_current_user)
        r"""True, if the current user can mute the participant only for self"""
        self.can_be_unmuted_for_current_user: bool = bool(
            can_be_unmuted_for_current_user
        )
        r"""True, if the current user can unmute the participant for self"""
        self.is_muted_for_all_users: bool = bool(is_muted_for_all_users)
        r"""True, if the participant is muted for all users"""
        self.is_muted_for_current_user: bool = bool(is_muted_for_current_user)
        r"""True, if the participant is muted for the current user"""
        self.can_unmute_self: bool = bool(can_unmute_self)
        r"""True, if the participant is muted for all users, but can unmute themselves"""
        self.volume_level: int = int(volume_level)
        r"""Participant's volume level; 1\-20000 in hundreds of percents"""
        self.order: Union[str, None] = order
        r"""User's order in the group call participant list\. Orders must be compared lexicographically\. The bigger is order, the higher is user in the list\. If order is empty, the user must be removed from the participant list"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["groupCallParticipant"]:
        return "groupCallParticipant"

    def getClass(self) -> Literal["GroupCallParticipant"]:
        return "GroupCallParticipant"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "participant_id": self.participant_id,
            "audio_source_id": self.audio_source_id,
            "screen_sharing_audio_source_id": self.screen_sharing_audio_source_id,
            "video_info": self.video_info,
            "screen_sharing_video_info": self.screen_sharing_video_info,
            "bio": self.bio,
            "is_current_user": self.is_current_user,
            "is_speaking": self.is_speaking,
            "is_hand_raised": self.is_hand_raised,
            "can_be_muted_for_all_users": self.can_be_muted_for_all_users,
            "can_be_unmuted_for_all_users": self.can_be_unmuted_for_all_users,
            "can_be_muted_for_current_user": self.can_be_muted_for_current_user,
            "can_be_unmuted_for_current_user": self.can_be_unmuted_for_current_user,
            "is_muted_for_all_users": self.is_muted_for_all_users,
            "is_muted_for_current_user": self.is_muted_for_current_user,
            "can_unmute_self": self.can_unmute_self,
            "volume_level": self.volume_level,
            "order": self.order,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GroupCallParticipant", None]:
        if data:
            data_class = cls()
            data_class.participant_id = data.get("participant_id", None)
            data_class.audio_source_id = int(data.get("audio_source_id", 0))
            data_class.screen_sharing_audio_source_id = int(
                data.get("screen_sharing_audio_source_id", 0)
            )
            data_class.video_info = data.get("video_info", None)
            data_class.screen_sharing_video_info = data.get(
                "screen_sharing_video_info", None
            )
            data_class.bio = data.get("bio", "")
            data_class.is_current_user = data.get("is_current_user", False)
            data_class.is_speaking = data.get("is_speaking", False)
            data_class.is_hand_raised = data.get("is_hand_raised", False)
            data_class.can_be_muted_for_all_users = data.get(
                "can_be_muted_for_all_users", False
            )
            data_class.can_be_unmuted_for_all_users = data.get(
                "can_be_unmuted_for_all_users", False
            )
            data_class.can_be_muted_for_current_user = data.get(
                "can_be_muted_for_current_user", False
            )
            data_class.can_be_unmuted_for_current_user = data.get(
                "can_be_unmuted_for_current_user", False
            )
            data_class.is_muted_for_all_users = data.get(
                "is_muted_for_all_users", False
            )
            data_class.is_muted_for_current_user = data.get(
                "is_muted_for_current_user", False
            )
            data_class.can_unmute_self = data.get("can_unmute_self", False)
            data_class.volume_level = int(data.get("volume_level", 0))
            data_class.order = data.get("order", "")

        return data_class


class CallProblemEcho(TlObject, CallProblem):
    r"""The user heard their own voice"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemEcho"]:
        return "callProblemEcho"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemEcho", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemNoise(TlObject, CallProblem):
    r"""The user heard background noise"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemNoise"]:
        return "callProblemNoise"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemNoise", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemInterruptions(TlObject, CallProblem):
    r"""The other side kept disappearing"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemInterruptions"]:
        return "callProblemInterruptions"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemInterruptions", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemDistortedSpeech(TlObject, CallProblem):
    r"""The speech was distorted"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemDistortedSpeech"]:
        return "callProblemDistortedSpeech"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemDistortedSpeech", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemSilentLocal(TlObject, CallProblem):
    r"""The user couldn't hear the other side"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemSilentLocal"]:
        return "callProblemSilentLocal"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemSilentLocal", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemSilentRemote(TlObject, CallProblem):
    r"""The other side couldn't hear the user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemSilentRemote"]:
        return "callProblemSilentRemote"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemSilentRemote", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemDropped(TlObject, CallProblem):
    r"""The call ended unexpectedly"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemDropped"]:
        return "callProblemDropped"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemDropped", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemDistortedVideo(TlObject, CallProblem):
    r"""The video was distorted"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemDistortedVideo"]:
        return "callProblemDistortedVideo"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemDistortedVideo", None]:
        if data:
            data_class = cls()

        return data_class


class CallProblemPixelatedVideo(TlObject, CallProblem):
    r"""The video was pixelated"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callProblemPixelatedVideo"]:
        return "callProblemPixelatedVideo"

    def getClass(self) -> Literal["CallProblem"]:
        return "CallProblem"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallProblemPixelatedVideo", None]:
        if data:
            data_class = cls()

        return data_class


class Call(TlObject):
    r"""Describes a call

    Parameters:
        id (:class:`int`):
            Call identifier, not persistent

        user_id (:class:`int`):
            User identifier of the other call participant

        is_outgoing (:class:`bool`):
            True, if the call is outgoing

        is_video (:class:`bool`):
            True, if the call is a video call

        state (:class:`"types.CallState"`):
            Call state

        group_call_id (:class:`int`):
            Identifier of the group call associated with the call; 0 if the group call isn't created yet\. The group call can be received through the method getGroupCall

    """

    def __init__(
        self,
        id: int = 0,
        user_id: int = 0,
        is_outgoing: bool = False,
        is_video: bool = False,
        state: CallState = None,
        group_call_id: int = 0,
    ) -> None:
        self.id: int = int(id)
        r"""Call identifier, not persistent"""
        self.user_id: int = int(user_id)
        r"""User identifier of the other call participant"""
        self.is_outgoing: bool = bool(is_outgoing)
        r"""True, if the call is outgoing"""
        self.is_video: bool = bool(is_video)
        r"""True, if the call is a video call"""
        self.state: Union[
            CallStatePending,
            CallStateExchangingKeys,
            CallStateReady,
            CallStateHangingUp,
            CallStateDiscarded,
            CallStateError,
            None,
        ] = state
        r"""Call state"""
        self.group_call_id: int = int(group_call_id)
        r"""Identifier of the group call associated with the call; 0 if the group call isn't created yet\. The group call can be received through the method getGroupCall"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["call"]:
        return "call"

    def getClass(self) -> Literal["Call"]:
        return "Call"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "user_id": self.user_id,
            "is_outgoing": self.is_outgoing,
            "is_video": self.is_video,
            "state": self.state,
            "group_call_id": self.group_call_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Call", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.user_id = int(data.get("user_id", 0))
            data_class.is_outgoing = data.get("is_outgoing", False)
            data_class.is_video = data.get("is_video", False)
            data_class.state = data.get("state", None)
            data_class.group_call_id = int(data.get("group_call_id", 0))

        return data_class


class FirebaseAuthenticationSettingsAndroid(TlObject, FirebaseAuthenticationSettings):
    r"""Settings for Firebase Authentication in the official Android application"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["firebaseAuthenticationSettingsAndroid"]:
        return "firebaseAuthenticationSettingsAndroid"

    def getClass(self) -> Literal["FirebaseAuthenticationSettings"]:
        return "FirebaseAuthenticationSettings"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["FirebaseAuthenticationSettingsAndroid", None]:
        if data:
            data_class = cls()

        return data_class


class FirebaseAuthenticationSettingsIos(TlObject, FirebaseAuthenticationSettings):
    r"""Settings for Firebase Authentication in the official iOS application

    Parameters:
        device_token (:class:`str`):
            Device token from Apple Push Notification service

        is_app_sandbox (:class:`bool`):
            True, if App Sandbox is enabled

    """

    def __init__(self, device_token: str = "", is_app_sandbox: bool = False) -> None:
        self.device_token: Union[str, None] = device_token
        r"""Device token from Apple Push Notification service"""
        self.is_app_sandbox: bool = bool(is_app_sandbox)
        r"""True, if App Sandbox is enabled"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["firebaseAuthenticationSettingsIos"]:
        return "firebaseAuthenticationSettingsIos"

    def getClass(self) -> Literal["FirebaseAuthenticationSettings"]:
        return "FirebaseAuthenticationSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "device_token": self.device_token,
            "is_app_sandbox": self.is_app_sandbox,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FirebaseAuthenticationSettingsIos", None]:
        if data:
            data_class = cls()
            data_class.device_token = data.get("device_token", "")
            data_class.is_app_sandbox = data.get("is_app_sandbox", False)

        return data_class


class PhoneNumberAuthenticationSettings(TlObject):
    r"""Contains settings for the authentication of the user's phone number

    Parameters:
        allow_flash_call (:class:`bool`):
            Pass true if the authentication code may be sent via a flash call to the specified phone number

        allow_missed_call (:class:`bool`):
            Pass true if the authentication code may be sent via a missed call to the specified phone number

        is_current_phone_number (:class:`bool`):
            Pass true if the authenticated phone number is used on the current device

        has_unknown_phone_number (:class:`bool`):
            Pass true if there is a SIM card in the current device, but it is not possible to check whether phone number matches

        allow_sms_retriever_api (:class:`bool`):
            For official applications only\. True, if the application can use Android SMS Retriever API \(requires Google Play Services \>\= 10\.2\) to automatically receive the authentication code from the SMS\. See https://developers\.google\.com/identity/sms\-retriever/ for more details

        firebase_authentication_settings (:class:`"types.FirebaseAuthenticationSettings"`):
            For official Android and iOS applications only; pass null otherwise\. Settings for Firebase Authentication

        authentication_tokens (:class:`List[str]`):
            List of up to 20 authentication tokens, recently received in updateOption\(\"authentication\_token\"\) in previously logged out sessions

    """

    def __init__(
        self,
        allow_flash_call: bool = False,
        allow_missed_call: bool = False,
        is_current_phone_number: bool = False,
        has_unknown_phone_number: bool = False,
        allow_sms_retriever_api: bool = False,
        firebase_authentication_settings: FirebaseAuthenticationSettings = None,
        authentication_tokens: List[str] = None,
    ) -> None:
        self.allow_flash_call: bool = bool(allow_flash_call)
        r"""Pass true if the authentication code may be sent via a flash call to the specified phone number"""
        self.allow_missed_call: bool = bool(allow_missed_call)
        r"""Pass true if the authentication code may be sent via a missed call to the specified phone number"""
        self.is_current_phone_number: bool = bool(is_current_phone_number)
        r"""Pass true if the authenticated phone number is used on the current device"""
        self.has_unknown_phone_number: bool = bool(has_unknown_phone_number)
        r"""Pass true if there is a SIM card in the current device, but it is not possible to check whether phone number matches"""
        self.allow_sms_retriever_api: bool = bool(allow_sms_retriever_api)
        r"""For official applications only\. True, if the application can use Android SMS Retriever API \(requires Google Play Services \>\= 10\.2\) to automatically receive the authentication code from the SMS\. See https://developers\.google\.com/identity/sms\-retriever/ for more details"""
        self.firebase_authentication_settings: Union[
            FirebaseAuthenticationSettingsAndroid,
            FirebaseAuthenticationSettingsIos,
            None,
        ] = firebase_authentication_settings
        r"""For official Android and iOS applications only; pass null otherwise\. Settings for Firebase Authentication"""
        self.authentication_tokens: List[str] = authentication_tokens or []
        r"""List of up to 20 authentication tokens, recently received in updateOption\(\"authentication\_token\"\) in previously logged out sessions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["phoneNumberAuthenticationSettings"]:
        return "phoneNumberAuthenticationSettings"

    def getClass(self) -> Literal["PhoneNumberAuthenticationSettings"]:
        return "PhoneNumberAuthenticationSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "allow_flash_call": self.allow_flash_call,
            "allow_missed_call": self.allow_missed_call,
            "is_current_phone_number": self.is_current_phone_number,
            "has_unknown_phone_number": self.has_unknown_phone_number,
            "allow_sms_retriever_api": self.allow_sms_retriever_api,
            "firebase_authentication_settings": self.firebase_authentication_settings,
            "authentication_tokens": self.authentication_tokens,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PhoneNumberAuthenticationSettings", None]:
        if data:
            data_class = cls()
            data_class.allow_flash_call = data.get("allow_flash_call", False)
            data_class.allow_missed_call = data.get("allow_missed_call", False)
            data_class.is_current_phone_number = data.get(
                "is_current_phone_number", False
            )
            data_class.has_unknown_phone_number = data.get(
                "has_unknown_phone_number", False
            )
            data_class.allow_sms_retriever_api = data.get(
                "allow_sms_retriever_api", False
            )
            data_class.firebase_authentication_settings = data.get(
                "firebase_authentication_settings", None
            )
            data_class.authentication_tokens = data.get("authentication_tokens", None)

        return data_class


class AddedReaction(TlObject):
    r"""Represents a reaction applied to a message

    Parameters:
        type (:class:`"types.ReactionType"`):
            Type of the reaction

        sender_id (:class:`"types.MessageSender"`):
            Identifier of the chat member, applied the reaction

        is_outgoing (:class:`bool`):
            True, if the reaction was added by the current user

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the reaction was added

    """

    def __init__(
        self,
        type: ReactionType = None,
        sender_id: MessageSender = None,
        is_outgoing: bool = False,
        date: int = 0,
    ) -> None:
        self.type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = type
        r"""Type of the reaction"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the chat member, applied the reaction"""
        self.is_outgoing: bool = bool(is_outgoing)
        r"""True, if the reaction was added by the current user"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the reaction was added"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["addedReaction"]:
        return "addedReaction"

    def getClass(self) -> Literal["AddedReaction"]:
        return "AddedReaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "sender_id": self.sender_id,
            "is_outgoing": self.is_outgoing,
            "date": self.date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AddedReaction", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.sender_id = data.get("sender_id", None)
            data_class.is_outgoing = data.get("is_outgoing", False)
            data_class.date = int(data.get("date", 0))

        return data_class


class AddedReactions(TlObject):
    r"""Represents a list of reactions added to a message

    Parameters:
        total_count (:class:`int`):
            The total number of found reactions

        reactions (:class:`List["types.AddedReaction"]`):
            The list of added reactions

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        total_count: int = 0,
        reactions: List[AddedReaction] = None,
        next_offset: str = "",
    ) -> None:
        self.total_count: int = int(total_count)
        r"""The total number of found reactions"""
        self.reactions: List[AddedReaction] = reactions or []
        r"""The list of added reactions"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["addedReactions"]:
        return "addedReactions"

    def getClass(self) -> Literal["AddedReactions"]:
        return "AddedReactions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "reactions": self.reactions,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AddedReactions", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.reactions = data.get("reactions", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class AvailableReaction(TlObject):
    r"""Represents an available reaction

    Parameters:
        type (:class:`"types.ReactionType"`):
            Type of the reaction

        needs_premium (:class:`bool`):
            True, if Telegram Premium is needed to send the reaction

    """

    def __init__(self, type: ReactionType = None, needs_premium: bool = False) -> None:
        self.type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = type
        r"""Type of the reaction"""
        self.needs_premium: bool = bool(needs_premium)
        r"""True, if Telegram Premium is needed to send the reaction"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["availableReaction"]:
        return "availableReaction"

    def getClass(self) -> Literal["AvailableReaction"]:
        return "AvailableReaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "needs_premium": self.needs_premium,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AvailableReaction", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.needs_premium = data.get("needs_premium", False)

        return data_class


class AvailableReactions(TlObject):
    r"""Represents a list of reactions that can be added to a message

    Parameters:
        top_reactions (:class:`List["types.AvailableReaction"]`):
            List of reactions to be shown at the top

        recent_reactions (:class:`List["types.AvailableReaction"]`):
            List of recently used reactions

        popular_reactions (:class:`List["types.AvailableReaction"]`):
            List of popular reactions

        allow_custom_emoji (:class:`bool`):
            True, if any custom emoji reaction can be added by Telegram Premium subscribers

        are_tags (:class:`bool`):
            True, if the reactions will be tags and the message can be found by them

        unavailability_reason (:class:`"types.ReactionUnavailabilityReason"`):
            The reason why the current user can't add reactions to the message, despite some other users can; may be null if none

    """

    def __init__(
        self,
        top_reactions: List[AvailableReaction] = None,
        recent_reactions: List[AvailableReaction] = None,
        popular_reactions: List[AvailableReaction] = None,
        allow_custom_emoji: bool = False,
        are_tags: bool = False,
        unavailability_reason: ReactionUnavailabilityReason = None,
    ) -> None:
        self.top_reactions: List[AvailableReaction] = top_reactions or []
        r"""List of reactions to be shown at the top"""
        self.recent_reactions: List[AvailableReaction] = recent_reactions or []
        r"""List of recently used reactions"""
        self.popular_reactions: List[AvailableReaction] = popular_reactions or []
        r"""List of popular reactions"""
        self.allow_custom_emoji: bool = bool(allow_custom_emoji)
        r"""True, if any custom emoji reaction can be added by Telegram Premium subscribers"""
        self.are_tags: bool = bool(are_tags)
        r"""True, if the reactions will be tags and the message can be found by them"""
        self.unavailability_reason: Union[
            ReactionUnavailabilityReasonAnonymousAdministrator,
            ReactionUnavailabilityReasonGuest,
            None,
        ] = unavailability_reason
        r"""The reason why the current user can't add reactions to the message, despite some other users can; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["availableReactions"]:
        return "availableReactions"

    def getClass(self) -> Literal["AvailableReactions"]:
        return "AvailableReactions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "top_reactions": self.top_reactions,
            "recent_reactions": self.recent_reactions,
            "popular_reactions": self.popular_reactions,
            "allow_custom_emoji": self.allow_custom_emoji,
            "are_tags": self.are_tags,
            "unavailability_reason": self.unavailability_reason,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AvailableReactions", None]:
        if data:
            data_class = cls()
            data_class.top_reactions = data.get("top_reactions", None)
            data_class.recent_reactions = data.get("recent_reactions", None)
            data_class.popular_reactions = data.get("popular_reactions", None)
            data_class.allow_custom_emoji = data.get("allow_custom_emoji", False)
            data_class.are_tags = data.get("are_tags", False)
            data_class.unavailability_reason = data.get("unavailability_reason", None)

        return data_class


class EmojiReaction(TlObject):
    r"""Contains information about an emoji reaction

    Parameters:
        emoji (:class:`str`):
            Text representation of the reaction

        title (:class:`str`):
            Reaction title

        is_active (:class:`bool`):
            True, if the reaction can be added to new messages and enabled in chats

        static_icon (:class:`"types.Sticker"`):
            Static icon for the reaction

        appear_animation (:class:`"types.Sticker"`):
            Appear animation for the reaction

        select_animation (:class:`"types.Sticker"`):
            Select animation for the reaction

        activate_animation (:class:`"types.Sticker"`):
            Activate animation for the reaction

        effect_animation (:class:`"types.Sticker"`):
            Effect animation for the reaction

        around_animation (:class:`"types.Sticker"`):
            Around animation for the reaction; may be null

        center_animation (:class:`"types.Sticker"`):
            Center animation for the reaction; may be null

    """

    def __init__(
        self,
        emoji: str = "",
        title: str = "",
        is_active: bool = False,
        static_icon: Sticker = None,
        appear_animation: Sticker = None,
        select_animation: Sticker = None,
        activate_animation: Sticker = None,
        effect_animation: Sticker = None,
        around_animation: Sticker = None,
        center_animation: Sticker = None,
    ) -> None:
        self.emoji: Union[str, None] = emoji
        r"""Text representation of the reaction"""
        self.title: Union[str, None] = title
        r"""Reaction title"""
        self.is_active: bool = bool(is_active)
        r"""True, if the reaction can be added to new messages and enabled in chats"""
        self.static_icon: Union[Sticker, None] = static_icon
        r"""Static icon for the reaction"""
        self.appear_animation: Union[Sticker, None] = appear_animation
        r"""Appear animation for the reaction"""
        self.select_animation: Union[Sticker, None] = select_animation
        r"""Select animation for the reaction"""
        self.activate_animation: Union[Sticker, None] = activate_animation
        r"""Activate animation for the reaction"""
        self.effect_animation: Union[Sticker, None] = effect_animation
        r"""Effect animation for the reaction"""
        self.around_animation: Union[Sticker, None] = around_animation
        r"""Around animation for the reaction; may be null"""
        self.center_animation: Union[Sticker, None] = center_animation
        r"""Center animation for the reaction; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["emojiReaction"]:
        return "emojiReaction"

    def getClass(self) -> Literal["EmojiReaction"]:
        return "EmojiReaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "emoji": self.emoji,
            "title": self.title,
            "is_active": self.is_active,
            "static_icon": self.static_icon,
            "appear_animation": self.appear_animation,
            "select_animation": self.select_animation,
            "activate_animation": self.activate_animation,
            "effect_animation": self.effect_animation,
            "around_animation": self.around_animation,
            "center_animation": self.center_animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["EmojiReaction", None]:
        if data:
            data_class = cls()
            data_class.emoji = data.get("emoji", "")
            data_class.title = data.get("title", "")
            data_class.is_active = data.get("is_active", False)
            data_class.static_icon = data.get("static_icon", None)
            data_class.appear_animation = data.get("appear_animation", None)
            data_class.select_animation = data.get("select_animation", None)
            data_class.activate_animation = data.get("activate_animation", None)
            data_class.effect_animation = data.get("effect_animation", None)
            data_class.around_animation = data.get("around_animation", None)
            data_class.center_animation = data.get("center_animation", None)

        return data_class


class ReactionUnavailabilityReasonAnonymousAdministrator(
    TlObject, ReactionUnavailabilityReason
):
    r"""The user is an anonymous administrator in the supergroup, but isn't a creator of it, so they can't vote on behalf of the supergroup"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionUnavailabilityReasonAnonymousAdministrator"]:
        return "reactionUnavailabilityReasonAnonymousAdministrator"

    def getClass(self) -> Literal["ReactionUnavailabilityReason"]:
        return "ReactionUnavailabilityReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ReactionUnavailabilityReasonAnonymousAdministrator", None]:
        if data:
            data_class = cls()

        return data_class


class ReactionUnavailabilityReasonGuest(TlObject, ReactionUnavailabilityReason):
    r"""The user isn't a member of the supergroup and can't send messages and reactions there without joining"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reactionUnavailabilityReasonGuest"]:
        return "reactionUnavailabilityReasonGuest"

    def getClass(self) -> Literal["ReactionUnavailabilityReason"]:
        return "ReactionUnavailabilityReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReactionUnavailabilityReasonGuest", None]:
        if data:
            data_class = cls()

        return data_class


class Animations(TlObject):
    r"""Represents a list of animations

    Parameters:
        animations (:class:`List["types.Animation"]`):
            List of animations

    """

    def __init__(self, animations: List[Animation] = None) -> None:
        self.animations: List[Animation] = animations or []
        r"""List of animations"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["animations"]:
        return "animations"

    def getClass(self) -> Literal["Animations"]:
        return "Animations"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "animations": self.animations}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Animations", None]:
        if data:
            data_class = cls()
            data_class.animations = data.get("animations", None)

        return data_class


class DiceStickersRegular(TlObject, DiceStickers):
    r"""A regular animated sticker

    Parameters:
        sticker (:class:`"types.Sticker"`):
            The animated sticker with the dice animation

    """

    def __init__(self, sticker: Sticker = None) -> None:
        self.sticker: Union[Sticker, None] = sticker
        r"""The animated sticker with the dice animation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["diceStickersRegular"]:
        return "diceStickersRegular"

    def getClass(self) -> Literal["DiceStickers"]:
        return "DiceStickers"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sticker": self.sticker}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DiceStickersRegular", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)

        return data_class


class DiceStickersSlotMachine(TlObject, DiceStickers):
    r"""Animated stickers to be combined into a slot machine

    Parameters:
        background (:class:`"types.Sticker"`):
            The animated sticker with the slot machine background\. The background animation must start playing after all reel animations finish

        lever (:class:`"types.Sticker"`):
            The animated sticker with the lever animation\. The lever animation must play once in the initial dice state

        left_reel (:class:`"types.Sticker"`):
            The animated sticker with the left reel

        center_reel (:class:`"types.Sticker"`):
            The animated sticker with the center reel

        right_reel (:class:`"types.Sticker"`):
            The animated sticker with the right reel

    """

    def __init__(
        self,
        background: Sticker = None,
        lever: Sticker = None,
        left_reel: Sticker = None,
        center_reel: Sticker = None,
        right_reel: Sticker = None,
    ) -> None:
        self.background: Union[Sticker, None] = background
        r"""The animated sticker with the slot machine background\. The background animation must start playing after all reel animations finish"""
        self.lever: Union[Sticker, None] = lever
        r"""The animated sticker with the lever animation\. The lever animation must play once in the initial dice state"""
        self.left_reel: Union[Sticker, None] = left_reel
        r"""The animated sticker with the left reel"""
        self.center_reel: Union[Sticker, None] = center_reel
        r"""The animated sticker with the center reel"""
        self.right_reel: Union[Sticker, None] = right_reel
        r"""The animated sticker with the right reel"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["diceStickersSlotMachine"]:
        return "diceStickersSlotMachine"

    def getClass(self) -> Literal["DiceStickers"]:
        return "DiceStickers"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "background": self.background,
            "lever": self.lever,
            "left_reel": self.left_reel,
            "center_reel": self.center_reel,
            "right_reel": self.right_reel,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DiceStickersSlotMachine", None]:
        if data:
            data_class = cls()
            data_class.background = data.get("background", None)
            data_class.lever = data.get("lever", None)
            data_class.left_reel = data.get("left_reel", None)
            data_class.center_reel = data.get("center_reel", None)
            data_class.right_reel = data.get("right_reel", None)

        return data_class


class ImportedContacts(TlObject):
    r"""Represents the result of an importContacts request

    Parameters:
        user_ids (:class:`List[int]`):
            User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user

        importer_count (:class:`List[int]`):
            The number of users that imported the corresponding contact; 0 for already registered users or if unavailable

    """

    def __init__(
        self, user_ids: List[int] = None, importer_count: List[int] = None
    ) -> None:
        self.user_ids: List[int] = user_ids or []
        r"""User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user"""
        self.importer_count: List[int] = importer_count or []
        r"""The number of users that imported the corresponding contact; 0 for already registered users or if unavailable"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["importedContacts"]:
        return "importedContacts"

    def getClass(self) -> Literal["ImportedContacts"]:
        return "ImportedContacts"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_ids": self.user_ids,
            "importer_count": self.importer_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ImportedContacts", None]:
        if data:
            data_class = cls()
            data_class.user_ids = data.get("user_ids", None)
            data_class.importer_count = data.get("importer_count", None)

        return data_class


class SpeechRecognitionResultPending(TlObject, SpeechRecognitionResult):
    r"""The speech recognition is ongoing

    Parameters:
        partial_text (:class:`str`):
            Partially recognized text

    """

    def __init__(self, partial_text: str = "") -> None:
        self.partial_text: Union[str, None] = partial_text
        r"""Partially recognized text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["speechRecognitionResultPending"]:
        return "speechRecognitionResultPending"

    def getClass(self) -> Literal["SpeechRecognitionResult"]:
        return "SpeechRecognitionResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "partial_text": self.partial_text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SpeechRecognitionResultPending", None]:
        if data:
            data_class = cls()
            data_class.partial_text = data.get("partial_text", "")

        return data_class


class SpeechRecognitionResultText(TlObject, SpeechRecognitionResult):
    r"""The speech recognition successfully finished

    Parameters:
        text (:class:`str`):
            Recognized text

    """

    def __init__(self, text: str = "") -> None:
        self.text: Union[str, None] = text
        r"""Recognized text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["speechRecognitionResultText"]:
        return "speechRecognitionResultText"

    def getClass(self) -> Literal["SpeechRecognitionResult"]:
        return "SpeechRecognitionResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SpeechRecognitionResultText", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")

        return data_class


class SpeechRecognitionResultError(TlObject, SpeechRecognitionResult):
    r"""The speech recognition failed

    Parameters:
        error (:class:`"types.Error"`):
            Recognition error\. An error with a message \"MSG\_VOICE\_TOO\_LONG\" is returned when media duration is too big to be recognized

    """

    def __init__(self, error: Error = None) -> None:
        self.error: Union[Error, None] = error
        r"""Recognition error\. An error with a message \"MSG\_VOICE\_TOO\_LONG\" is returned when media duration is too big to be recognized"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["speechRecognitionResultError"]:
        return "speechRecognitionResultError"

    def getClass(self) -> Literal["SpeechRecognitionResult"]:
        return "SpeechRecognitionResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "error": self.error}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SpeechRecognitionResultError", None]:
        if data:
            data_class = cls()
            data_class.error = data.get("error", None)

        return data_class


class BusinessConnection(TlObject):
    r"""Describes a connection of the bot with a business account

    Parameters:
        id (:class:`str`):
            Unique identifier of the connection

        user_id (:class:`int`):
            Identifier of the business user that created the connection

        user_chat_id (:class:`int`):
            Chat identifier of the private chat with the user

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the connection was established

        rights (:class:`"types.BusinessBotRights"`):
            Rights of the bot; may be null if the connection was disabled

        is_enabled (:class:`bool`):
            True, if the connection is enabled; false otherwise

    """

    def __init__(
        self,
        id: str = "",
        user_id: int = 0,
        user_chat_id: int = 0,
        date: int = 0,
        rights: BusinessBotRights = None,
        is_enabled: bool = False,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the connection"""
        self.user_id: int = int(user_id)
        r"""Identifier of the business user that created the connection"""
        self.user_chat_id: int = int(user_chat_id)
        r"""Chat identifier of the private chat with the user"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the connection was established"""
        self.rights: Union[BusinessBotRights, None] = rights
        r"""Rights of the bot; may be null if the connection was disabled"""
        self.is_enabled: bool = bool(is_enabled)
        r"""True, if the connection is enabled; false otherwise"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessConnection"]:
        return "businessConnection"

    def getClass(self) -> Literal["BusinessConnection"]:
        return "BusinessConnection"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "user_id": self.user_id,
            "user_chat_id": self.user_chat_id,
            "date": self.date,
            "rights": self.rights,
            "is_enabled": self.is_enabled,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessConnection", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.user_id = int(data.get("user_id", 0))
            data_class.user_chat_id = int(data.get("user_chat_id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.rights = data.get("rights", None)
            data_class.is_enabled = data.get("is_enabled", False)

        return data_class


class AttachmentMenuBotColor(TlObject):
    r"""Describes a color to highlight a bot added to attachment menu

    Parameters:
        light_color (:class:`int`):
            Color in the RGB format for light themes

        dark_color (:class:`int`):
            Color in the RGB format for dark themes

    """

    def __init__(self, light_color: int = 0, dark_color: int = 0) -> None:
        self.light_color: int = int(light_color)
        r"""Color in the RGB format for light themes"""
        self.dark_color: int = int(dark_color)
        r"""Color in the RGB format for dark themes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["attachmentMenuBotColor"]:
        return "attachmentMenuBotColor"

    def getClass(self) -> Literal["AttachmentMenuBotColor"]:
        return "AttachmentMenuBotColor"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "light_color": self.light_color,
            "dark_color": self.dark_color,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AttachmentMenuBotColor", None]:
        if data:
            data_class = cls()
            data_class.light_color = int(data.get("light_color", 0))
            data_class.dark_color = int(data.get("dark_color", 0))

        return data_class


class AttachmentMenuBot(TlObject):
    r"""Represents a bot, which can be added to attachment or side menu

    Parameters:
        bot_user_id (:class:`int`):
            User identifier of the bot

        supports_self_chat (:class:`bool`):
            True, if the bot supports opening from attachment menu in the chat with the bot

        supports_user_chats (:class:`bool`):
            True, if the bot supports opening from attachment menu in private chats with ordinary users

        supports_bot_chats (:class:`bool`):
            True, if the bot supports opening from attachment menu in private chats with other bots

        supports_group_chats (:class:`bool`):
            True, if the bot supports opening from attachment menu in basic group and supergroup chats

        supports_channel_chats (:class:`bool`):
            True, if the bot supports opening from attachment menu in channel chats

        request_write_access (:class:`bool`):
            True, if the user must be asked for the permission to send messages to the bot

        is_added (:class:`bool`):
            True, if the bot was explicitly added by the user\. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed

        show_in_attachment_menu (:class:`bool`):
            True, if the bot must be shown in the attachment menu

        show_in_side_menu (:class:`bool`):
            True, if the bot must be shown in the side menu

        show_disclaimer_in_side_menu (:class:`bool`):
            True, if a disclaimer, why the bot is shown in the side menu, is needed

        name (:class:`str`):
            Name for the bot in attachment menu

        name_color (:class:`"types.AttachmentMenuBotColor"`):
            Color to highlight selected name of the bot if appropriate; may be null

        default_icon (:class:`"types.File"`):
            Default icon for the bot in SVG format; may be null

        ios_static_icon (:class:`"types.File"`):
            Icon for the bot in SVG format for the official iOS app; may be null

        ios_animated_icon (:class:`"types.File"`):
            Icon for the bot in TGS format for the official iOS app; may be null

        ios_side_menu_icon (:class:`"types.File"`):
            Icon for the bot in PNG format for the official iOS app side menu; may be null

        android_icon (:class:`"types.File"`):
            Icon for the bot in TGS format for the official Android app; may be null

        android_side_menu_icon (:class:`"types.File"`):
            Icon for the bot in SVG format for the official Android app side menu; may be null

        macos_icon (:class:`"types.File"`):
            Icon for the bot in TGS format for the official native macOS app; may be null

        macos_side_menu_icon (:class:`"types.File"`):
            Icon for the bot in PNG format for the official macOS app side menu; may be null

        icon_color (:class:`"types.AttachmentMenuBotColor"`):
            Color to highlight selected icon of the bot if appropriate; may be null

        web_app_placeholder (:class:`"types.File"`):
            Default placeholder for opened Web Apps in SVG format; may be null

    """

    def __init__(
        self,
        bot_user_id: int = 0,
        supports_self_chat: bool = False,
        supports_user_chats: bool = False,
        supports_bot_chats: bool = False,
        supports_group_chats: bool = False,
        supports_channel_chats: bool = False,
        request_write_access: bool = False,
        is_added: bool = False,
        show_in_attachment_menu: bool = False,
        show_in_side_menu: bool = False,
        show_disclaimer_in_side_menu: bool = False,
        name: str = "",
        name_color: AttachmentMenuBotColor = None,
        default_icon: File = None,
        ios_static_icon: File = None,
        ios_animated_icon: File = None,
        ios_side_menu_icon: File = None,
        android_icon: File = None,
        android_side_menu_icon: File = None,
        macos_icon: File = None,
        macos_side_menu_icon: File = None,
        icon_color: AttachmentMenuBotColor = None,
        web_app_placeholder: File = None,
    ) -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of the bot"""
        self.supports_self_chat: bool = bool(supports_self_chat)
        r"""True, if the bot supports opening from attachment menu in the chat with the bot"""
        self.supports_user_chats: bool = bool(supports_user_chats)
        r"""True, if the bot supports opening from attachment menu in private chats with ordinary users"""
        self.supports_bot_chats: bool = bool(supports_bot_chats)
        r"""True, if the bot supports opening from attachment menu in private chats with other bots"""
        self.supports_group_chats: bool = bool(supports_group_chats)
        r"""True, if the bot supports opening from attachment menu in basic group and supergroup chats"""
        self.supports_channel_chats: bool = bool(supports_channel_chats)
        r"""True, if the bot supports opening from attachment menu in channel chats"""
        self.request_write_access: bool = bool(request_write_access)
        r"""True, if the user must be asked for the permission to send messages to the bot"""
        self.is_added: bool = bool(is_added)
        r"""True, if the bot was explicitly added by the user\. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed"""
        self.show_in_attachment_menu: bool = bool(show_in_attachment_menu)
        r"""True, if the bot must be shown in the attachment menu"""
        self.show_in_side_menu: bool = bool(show_in_side_menu)
        r"""True, if the bot must be shown in the side menu"""
        self.show_disclaimer_in_side_menu: bool = bool(show_disclaimer_in_side_menu)
        r"""True, if a disclaimer, why the bot is shown in the side menu, is needed"""
        self.name: Union[str, None] = name
        r"""Name for the bot in attachment menu"""
        self.name_color: Union[AttachmentMenuBotColor, None] = name_color
        r"""Color to highlight selected name of the bot if appropriate; may be null"""
        self.default_icon: Union[File, None] = default_icon
        r"""Default icon for the bot in SVG format; may be null"""
        self.ios_static_icon: Union[File, None] = ios_static_icon
        r"""Icon for the bot in SVG format for the official iOS app; may be null"""
        self.ios_animated_icon: Union[File, None] = ios_animated_icon
        r"""Icon for the bot in TGS format for the official iOS app; may be null"""
        self.ios_side_menu_icon: Union[File, None] = ios_side_menu_icon
        r"""Icon for the bot in PNG format for the official iOS app side menu; may be null"""
        self.android_icon: Union[File, None] = android_icon
        r"""Icon for the bot in TGS format for the official Android app; may be null"""
        self.android_side_menu_icon: Union[File, None] = android_side_menu_icon
        r"""Icon for the bot in SVG format for the official Android app side menu; may be null"""
        self.macos_icon: Union[File, None] = macos_icon
        r"""Icon for the bot in TGS format for the official native macOS app; may be null"""
        self.macos_side_menu_icon: Union[File, None] = macos_side_menu_icon
        r"""Icon for the bot in PNG format for the official macOS app side menu; may be null"""
        self.icon_color: Union[AttachmentMenuBotColor, None] = icon_color
        r"""Color to highlight selected icon of the bot if appropriate; may be null"""
        self.web_app_placeholder: Union[File, None] = web_app_placeholder
        r"""Default placeholder for opened Web Apps in SVG format; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["attachmentMenuBot"]:
        return "attachmentMenuBot"

    def getClass(self) -> Literal["AttachmentMenuBot"]:
        return "AttachmentMenuBot"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "supports_self_chat": self.supports_self_chat,
            "supports_user_chats": self.supports_user_chats,
            "supports_bot_chats": self.supports_bot_chats,
            "supports_group_chats": self.supports_group_chats,
            "supports_channel_chats": self.supports_channel_chats,
            "request_write_access": self.request_write_access,
            "is_added": self.is_added,
            "show_in_attachment_menu": self.show_in_attachment_menu,
            "show_in_side_menu": self.show_in_side_menu,
            "show_disclaimer_in_side_menu": self.show_disclaimer_in_side_menu,
            "name": self.name,
            "name_color": self.name_color,
            "default_icon": self.default_icon,
            "ios_static_icon": self.ios_static_icon,
            "ios_animated_icon": self.ios_animated_icon,
            "ios_side_menu_icon": self.ios_side_menu_icon,
            "android_icon": self.android_icon,
            "android_side_menu_icon": self.android_side_menu_icon,
            "macos_icon": self.macos_icon,
            "macos_side_menu_icon": self.macos_side_menu_icon,
            "icon_color": self.icon_color,
            "web_app_placeholder": self.web_app_placeholder,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AttachmentMenuBot", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.supports_self_chat = data.get("supports_self_chat", False)
            data_class.supports_user_chats = data.get("supports_user_chats", False)
            data_class.supports_bot_chats = data.get("supports_bot_chats", False)
            data_class.supports_group_chats = data.get("supports_group_chats", False)
            data_class.supports_channel_chats = data.get(
                "supports_channel_chats", False
            )
            data_class.request_write_access = data.get("request_write_access", False)
            data_class.is_added = data.get("is_added", False)
            data_class.show_in_attachment_menu = data.get(
                "show_in_attachment_menu", False
            )
            data_class.show_in_side_menu = data.get("show_in_side_menu", False)
            data_class.show_disclaimer_in_side_menu = data.get(
                "show_disclaimer_in_side_menu", False
            )
            data_class.name = data.get("name", "")
            data_class.name_color = data.get("name_color", None)
            data_class.default_icon = data.get("default_icon", None)
            data_class.ios_static_icon = data.get("ios_static_icon", None)
            data_class.ios_animated_icon = data.get("ios_animated_icon", None)
            data_class.ios_side_menu_icon = data.get("ios_side_menu_icon", None)
            data_class.android_icon = data.get("android_icon", None)
            data_class.android_side_menu_icon = data.get("android_side_menu_icon", None)
            data_class.macos_icon = data.get("macos_icon", None)
            data_class.macos_side_menu_icon = data.get("macos_side_menu_icon", None)
            data_class.icon_color = data.get("icon_color", None)
            data_class.web_app_placeholder = data.get("web_app_placeholder", None)

        return data_class


class SentWebAppMessage(TlObject):
    r"""Information about the message sent by answerWebAppQuery

    Parameters:
        inline_message_id (:class:`str`):
            Identifier of the sent inline message, if known

    """

    def __init__(self, inline_message_id: str = "") -> None:
        self.inline_message_id: Union[str, None] = inline_message_id
        r"""Identifier of the sent inline message, if known"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sentWebAppMessage"]:
        return "sentWebAppMessage"

    def getClass(self) -> Literal["SentWebAppMessage"]:
        return "SentWebAppMessage"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "inline_message_id": self.inline_message_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SentWebAppMessage", None]:
        if data:
            data_class = cls()
            data_class.inline_message_id = data.get("inline_message_id", "")

        return data_class


class BotWriteAccessAllowReasonConnectedWebsite(TlObject, BotWriteAccessAllowReason):
    r"""The user connected a website by logging in using Telegram Login Widget on it

    Parameters:
        domain_name (:class:`str`):
            Domain name of the connected website

    """

    def __init__(self, domain_name: str = "") -> None:
        self.domain_name: Union[str, None] = domain_name
        r"""Domain name of the connected website"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botWriteAccessAllowReasonConnectedWebsite"]:
        return "botWriteAccessAllowReasonConnectedWebsite"

    def getClass(self) -> Literal["BotWriteAccessAllowReason"]:
        return "BotWriteAccessAllowReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "domain_name": self.domain_name}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["BotWriteAccessAllowReasonConnectedWebsite", None]:
        if data:
            data_class = cls()
            data_class.domain_name = data.get("domain_name", "")

        return data_class


class BotWriteAccessAllowReasonAddedToAttachmentMenu(
    TlObject, BotWriteAccessAllowReason
):
    r"""The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botWriteAccessAllowReasonAddedToAttachmentMenu"]:
        return "botWriteAccessAllowReasonAddedToAttachmentMenu"

    def getClass(self) -> Literal["BotWriteAccessAllowReason"]:
        return "BotWriteAccessAllowReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["BotWriteAccessAllowReasonAddedToAttachmentMenu", None]:
        if data:
            data_class = cls()

        return data_class


class BotWriteAccessAllowReasonLaunchedWebApp(TlObject, BotWriteAccessAllowReason):
    r"""The user launched a Web App using getWebAppLinkUrl

    Parameters:
        web_app (:class:`"types.WebApp"`):
            Information about the Web App

    """

    def __init__(self, web_app: WebApp = None) -> None:
        self.web_app: Union[WebApp, None] = web_app
        r"""Information about the Web App"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botWriteAccessAllowReasonLaunchedWebApp"]:
        return "botWriteAccessAllowReasonLaunchedWebApp"

    def getClass(self) -> Literal["BotWriteAccessAllowReason"]:
        return "BotWriteAccessAllowReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "web_app": self.web_app}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["BotWriteAccessAllowReasonLaunchedWebApp", None]:
        if data:
            data_class = cls()
            data_class.web_app = data.get("web_app", None)

        return data_class


class BotWriteAccessAllowReasonAcceptedRequest(TlObject, BotWriteAccessAllowReason):
    r"""The user accepted bot's request to send messages with allowBotToSendMessages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botWriteAccessAllowReasonAcceptedRequest"]:
        return "botWriteAccessAllowReasonAcceptedRequest"

    def getClass(self) -> Literal["BotWriteAccessAllowReason"]:
        return "BotWriteAccessAllowReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["BotWriteAccessAllowReasonAcceptedRequest", None]:
        if data:
            data_class = cls()

        return data_class


class HttpUrl(TlObject):
    r"""Contains an HTTP URL

    Parameters:
        url (:class:`str`):
            The URL

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""The URL"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["httpUrl"]:
        return "httpUrl"

    def getClass(self) -> Literal["HttpUrl"]:
        return "HttpUrl"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["HttpUrl", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class UserLink(TlObject):
    r"""Contains an HTTPS URL, which can be used to get information about a user

    Parameters:
        url (:class:`str`):
            The URL

        expires_in (:class:`int`):
            Left time for which the link is valid, in seconds; 0 if the link is a public username link

    """

    def __init__(self, url: str = "", expires_in: int = 0) -> None:
        self.url: Union[str, None] = url
        r"""The URL"""
        self.expires_in: int = int(expires_in)
        r"""Left time for which the link is valid, in seconds; 0 if the link is a public username link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userLink"]:
        return "userLink"

    def getClass(self) -> Literal["UserLink"]:
        return "UserLink"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url, "expires_in": self.expires_in}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserLink", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.expires_in = int(data.get("expires_in", 0))

        return data_class


class TargetChatTypes(TlObject):
    r"""Describes allowed types for the target chat

    Parameters:
        allow_user_chats (:class:`bool`):
            True, if private chats with ordinary users are allowed

        allow_bot_chats (:class:`bool`):
            True, if private chats with other bots are allowed

        allow_group_chats (:class:`bool`):
            True, if basic group and supergroup chats are allowed

        allow_channel_chats (:class:`bool`):
            True, if channel chats are allowed

    """

    def __init__(
        self,
        allow_user_chats: bool = False,
        allow_bot_chats: bool = False,
        allow_group_chats: bool = False,
        allow_channel_chats: bool = False,
    ) -> None:
        self.allow_user_chats: bool = bool(allow_user_chats)
        r"""True, if private chats with ordinary users are allowed"""
        self.allow_bot_chats: bool = bool(allow_bot_chats)
        r"""True, if private chats with other bots are allowed"""
        self.allow_group_chats: bool = bool(allow_group_chats)
        r"""True, if basic group and supergroup chats are allowed"""
        self.allow_channel_chats: bool = bool(allow_channel_chats)
        r"""True, if channel chats are allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["targetChatTypes"]:
        return "targetChatTypes"

    def getClass(self) -> Literal["TargetChatTypes"]:
        return "TargetChatTypes"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "allow_user_chats": self.allow_user_chats,
            "allow_bot_chats": self.allow_bot_chats,
            "allow_group_chats": self.allow_group_chats,
            "allow_channel_chats": self.allow_channel_chats,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TargetChatTypes", None]:
        if data:
            data_class = cls()
            data_class.allow_user_chats = data.get("allow_user_chats", False)
            data_class.allow_bot_chats = data.get("allow_bot_chats", False)
            data_class.allow_group_chats = data.get("allow_group_chats", False)
            data_class.allow_channel_chats = data.get("allow_channel_chats", False)

        return data_class


class TargetChatCurrent(TlObject, TargetChat):
    r"""The currently opened chat and forum topic must be kept"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["targetChatCurrent"]:
        return "targetChatCurrent"

    def getClass(self) -> Literal["TargetChat"]:
        return "TargetChat"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TargetChatCurrent", None]:
        if data:
            data_class = cls()

        return data_class


class TargetChatChosen(TlObject, TargetChat):
    r"""The chat needs to be chosen by the user among chats of the specified types

    Parameters:
        types (:class:`"types.TargetChatTypes"`):
            Allowed types for the chat

    """

    def __init__(self, types: TargetChatTypes = None) -> None:
        self.types: Union[TargetChatTypes, None] = types
        r"""Allowed types for the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["targetChatChosen"]:
        return "targetChatChosen"

    def getClass(self) -> Literal["TargetChat"]:
        return "TargetChat"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "types": self.types}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TargetChatChosen", None]:
        if data:
            data_class = cls()
            data_class.types = data.get("types", None)

        return data_class


class TargetChatInternalLink(TlObject, TargetChat):
    r"""The chat needs to be open with the provided internal link

    Parameters:
        link (:class:`"types.InternalLinkType"`):
            An internal link pointing to the chat

    """

    def __init__(self, link: InternalLinkType = None) -> None:
        self.link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = link
        r"""An internal link pointing to the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["targetChatInternalLink"]:
        return "targetChatInternalLink"

    def getClass(self) -> Literal["TargetChat"]:
        return "TargetChat"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "link": self.link}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TargetChatInternalLink", None]:
        if data:
            data_class = cls()
            data_class.link = data.get("link", None)

        return data_class


class InputInlineQueryResultAnimation(TlObject, InputInlineQueryResult):
    r"""Represents a link to an animated GIF or an animated \(i\.e\., without sound\) H\.264/MPEG\-4 AVC video

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        title (:class:`str`):
            Title of the query result

        thumbnail_url (:class:`str`):
            URL of the result thumbnail \(JPEG, GIF, or MPEG4\), if it exists

        thumbnail_mime_type (:class:`str`):
            MIME type of the video thumbnail\. If non\-empty, must be one of \"image/jpeg\", \"image/gif\" and \"video/mp4\"

        video_url (:class:`str`):
            The URL of the video file \(file size must not exceed 1MB\)

        video_mime_type (:class:`str`):
            MIME type of the video file\. Must be one of \"image/gif\" and \"video/mp4\"

        video_duration (:class:`int`):
            Duration of the video, in seconds

        video_width (:class:`int`):
            Width of the video

        video_height (:class:`int`):
            Height of the video

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        title: str = "",
        thumbnail_url: str = "",
        thumbnail_mime_type: str = "",
        video_url: str = "",
        video_mime_type: str = "",
        video_duration: int = 0,
        video_width: int = 0,
        video_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.title: Union[str, None] = title
        r"""Title of the query result"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""URL of the result thumbnail \(JPEG, GIF, or MPEG4\), if it exists"""
        self.thumbnail_mime_type: Union[str, None] = thumbnail_mime_type
        r"""MIME type of the video thumbnail\. If non\-empty, must be one of \"image/jpeg\", \"image/gif\" and \"video/mp4\""""
        self.video_url: Union[str, None] = video_url
        r"""The URL of the video file \(file size must not exceed 1MB\)"""
        self.video_mime_type: Union[str, None] = video_mime_type
        r"""MIME type of the video file\. Must be one of \"image/gif\" and \"video/mp4\""""
        self.video_duration: int = int(video_duration)
        r"""Duration of the video, in seconds"""
        self.video_width: int = int(video_width)
        r"""Width of the video"""
        self.video_height: int = int(video_height)
        r"""Height of the video"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultAnimation"]:
        return "inputInlineQueryResultAnimation"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "thumbnail_url": self.thumbnail_url,
            "thumbnail_mime_type": self.thumbnail_mime_type,
            "video_url": self.video_url,
            "video_mime_type": self.video_mime_type,
            "video_duration": self.video_duration,
            "video_width": self.video_width,
            "video_height": self.video_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultAnimation", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.thumbnail_mime_type = data.get("thumbnail_mime_type", "")
            data_class.video_url = data.get("video_url", "")
            data_class.video_mime_type = data.get("video_mime_type", "")
            data_class.video_duration = int(data.get("video_duration", 0))
            data_class.video_width = int(data.get("video_width", 0))
            data_class.video_height = int(data.get("video_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultArticle(TlObject, InputInlineQueryResult):
    r"""Represents a link to an article or web page

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        url (:class:`str`):
            URL of the result, if it exists

        title (:class:`str`):
            Title of the result

        description (:class:`str`):
            A short description of the result

        thumbnail_url (:class:`str`):
            URL of the result thumbnail, if it exists

        thumbnail_width (:class:`int`):
            Thumbnail width, if known

        thumbnail_height (:class:`int`):
            Thumbnail height, if known

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        url: str = "",
        title: str = "",
        description: str = "",
        thumbnail_url: str = "",
        thumbnail_width: int = 0,
        thumbnail_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.url: Union[str, None] = url
        r"""URL of the result, if it exists"""
        self.title: Union[str, None] = title
        r"""Title of the result"""
        self.description: Union[str, None] = description
        r"""A short description of the result"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""URL of the result thumbnail, if it exists"""
        self.thumbnail_width: int = int(thumbnail_width)
        r"""Thumbnail width, if known"""
        self.thumbnail_height: int = int(thumbnail_height)
        r"""Thumbnail height, if known"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultArticle"]:
        return "inputInlineQueryResultArticle"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "url": self.url,
            "title": self.title,
            "description": self.description,
            "thumbnail_url": self.thumbnail_url,
            "thumbnail_width": self.thumbnail_width,
            "thumbnail_height": self.thumbnail_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultArticle", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.url = data.get("url", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.thumbnail_width = int(data.get("thumbnail_width", 0))
            data_class.thumbnail_height = int(data.get("thumbnail_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultAudio(TlObject, InputInlineQueryResult):
    r"""Represents a link to an MP3 audio file

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        title (:class:`str`):
            Title of the audio file

        performer (:class:`str`):
            Performer of the audio file

        audio_url (:class:`str`):
            The URL of the audio file

        audio_duration (:class:`int`):
            Audio file duration, in seconds

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        title: str = "",
        performer: str = "",
        audio_url: str = "",
        audio_duration: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.title: Union[str, None] = title
        r"""Title of the audio file"""
        self.performer: Union[str, None] = performer
        r"""Performer of the audio file"""
        self.audio_url: Union[str, None] = audio_url
        r"""The URL of the audio file"""
        self.audio_duration: int = int(audio_duration)
        r"""Audio file duration, in seconds"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultAudio"]:
        return "inputInlineQueryResultAudio"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "performer": self.performer,
            "audio_url": self.audio_url,
            "audio_duration": self.audio_duration,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultAudio", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")
            data_class.performer = data.get("performer", "")
            data_class.audio_url = data.get("audio_url", "")
            data_class.audio_duration = int(data.get("audio_duration", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultContact(TlObject, InputInlineQueryResult):
    r"""Represents a user contact

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        contact (:class:`"types.Contact"`):
            User contact

        thumbnail_url (:class:`str`):
            URL of the result thumbnail, if it exists

        thumbnail_width (:class:`int`):
            Thumbnail width, if known

        thumbnail_height (:class:`int`):
            Thumbnail height, if known

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        contact: Contact = None,
        thumbnail_url: str = "",
        thumbnail_width: int = 0,
        thumbnail_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.contact: Union[Contact, None] = contact
        r"""User contact"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""URL of the result thumbnail, if it exists"""
        self.thumbnail_width: int = int(thumbnail_width)
        r"""Thumbnail width, if known"""
        self.thumbnail_height: int = int(thumbnail_height)
        r"""Thumbnail height, if known"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultContact"]:
        return "inputInlineQueryResultContact"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "contact": self.contact,
            "thumbnail_url": self.thumbnail_url,
            "thumbnail_width": self.thumbnail_width,
            "thumbnail_height": self.thumbnail_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultContact", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.contact = data.get("contact", None)
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.thumbnail_width = int(data.get("thumbnail_width", 0))
            data_class.thumbnail_height = int(data.get("thumbnail_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultDocument(TlObject, InputInlineQueryResult):
    r"""Represents a link to a file

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        title (:class:`str`):
            Title of the resulting file

        description (:class:`str`):
            Short description of the result, if known

        document_url (:class:`str`):
            URL of the file

        mime_type (:class:`str`):
            MIME type of the file content; only \"application/pdf\" and \"application/zip\" are currently allowed

        thumbnail_url (:class:`str`):
            The URL of the file thumbnail, if it exists

        thumbnail_width (:class:`int`):
            Width of the thumbnail

        thumbnail_height (:class:`int`):
            Height of the thumbnail

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        title: str = "",
        description: str = "",
        document_url: str = "",
        mime_type: str = "",
        thumbnail_url: str = "",
        thumbnail_width: int = 0,
        thumbnail_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.title: Union[str, None] = title
        r"""Title of the resulting file"""
        self.description: Union[str, None] = description
        r"""Short description of the result, if known"""
        self.document_url: Union[str, None] = document_url
        r"""URL of the file"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the file content; only \"application/pdf\" and \"application/zip\" are currently allowed"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""The URL of the file thumbnail, if it exists"""
        self.thumbnail_width: int = int(thumbnail_width)
        r"""Width of the thumbnail"""
        self.thumbnail_height: int = int(thumbnail_height)
        r"""Height of the thumbnail"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultDocument"]:
        return "inputInlineQueryResultDocument"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "document_url": self.document_url,
            "mime_type": self.mime_type,
            "thumbnail_url": self.thumbnail_url,
            "thumbnail_width": self.thumbnail_width,
            "thumbnail_height": self.thumbnail_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultDocument", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.document_url = data.get("document_url", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.thumbnail_width = int(data.get("thumbnail_width", 0))
            data_class.thumbnail_height = int(data.get("thumbnail_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultGame(TlObject, InputInlineQueryResult):
    r"""Represents a game

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        game_short_name (:class:`str`):
            Short name of the game

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

    """

    def __init__(
        self, id: str = "", game_short_name: str = "", reply_markup: ReplyMarkup = None
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.game_short_name: Union[str, None] = game_short_name
        r"""Short name of the game"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultGame"]:
        return "inputInlineQueryResultGame"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "game_short_name": self.game_short_name,
            "reply_markup": self.reply_markup,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultGame", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.game_short_name = data.get("game_short_name", "")
            data_class.reply_markup = data.get("reply_markup", None)

        return data_class


class InputInlineQueryResultLocation(TlObject, InputInlineQueryResult):
    r"""Represents a point on the map

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        location (:class:`"types.Location"`):
            Location result

        live_period (:class:`int`):
            Amount of time relative to the message sent time until the location can be updated, in seconds

        title (:class:`str`):
            Title of the result

        thumbnail_url (:class:`str`):
            URL of the result thumbnail, if it exists

        thumbnail_width (:class:`int`):
            Thumbnail width, if known

        thumbnail_height (:class:`int`):
            Thumbnail height, if known

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        location: Location = None,
        live_period: int = 0,
        title: str = "",
        thumbnail_url: str = "",
        thumbnail_width: int = 0,
        thumbnail_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.location: Union[Location, None] = location
        r"""Location result"""
        self.live_period: int = int(live_period)
        r"""Amount of time relative to the message sent time until the location can be updated, in seconds"""
        self.title: Union[str, None] = title
        r"""Title of the result"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""URL of the result thumbnail, if it exists"""
        self.thumbnail_width: int = int(thumbnail_width)
        r"""Thumbnail width, if known"""
        self.thumbnail_height: int = int(thumbnail_height)
        r"""Thumbnail height, if known"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultLocation"]:
        return "inputInlineQueryResultLocation"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "location": self.location,
            "live_period": self.live_period,
            "title": self.title,
            "thumbnail_url": self.thumbnail_url,
            "thumbnail_width": self.thumbnail_width,
            "thumbnail_height": self.thumbnail_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultLocation", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.location = data.get("location", None)
            data_class.live_period = int(data.get("live_period", 0))
            data_class.title = data.get("title", "")
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.thumbnail_width = int(data.get("thumbnail_width", 0))
            data_class.thumbnail_height = int(data.get("thumbnail_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultPhoto(TlObject, InputInlineQueryResult):
    r"""Represents link to a JPEG image

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        title (:class:`str`):
            Title of the result, if known

        description (:class:`str`):
            A short description of the result, if known

        thumbnail_url (:class:`str`):
            URL of the photo thumbnail, if it exists

        photo_url (:class:`str`):
            The URL of the JPEG photo \(photo size must not exceed 5MB\)

        photo_width (:class:`int`):
            Width of the photo

        photo_height (:class:`int`):
            Height of the photo

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        title: str = "",
        description: str = "",
        thumbnail_url: str = "",
        photo_url: str = "",
        photo_width: int = 0,
        photo_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.title: Union[str, None] = title
        r"""Title of the result, if known"""
        self.description: Union[str, None] = description
        r"""A short description of the result, if known"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""URL of the photo thumbnail, if it exists"""
        self.photo_url: Union[str, None] = photo_url
        r"""The URL of the JPEG photo \(photo size must not exceed 5MB\)"""
        self.photo_width: int = int(photo_width)
        r"""Width of the photo"""
        self.photo_height: int = int(photo_height)
        r"""Height of the photo"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultPhoto"]:
        return "inputInlineQueryResultPhoto"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "thumbnail_url": self.thumbnail_url,
            "photo_url": self.photo_url,
            "photo_width": self.photo_width,
            "photo_height": self.photo_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultPhoto", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.photo_url = data.get("photo_url", "")
            data_class.photo_width = int(data.get("photo_width", 0))
            data_class.photo_height = int(data.get("photo_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultSticker(TlObject, InputInlineQueryResult):
    r"""Represents a link to a WEBP, TGS, or WEBM sticker

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        thumbnail_url (:class:`str`):
            URL of the sticker thumbnail, if it exists

        sticker_url (:class:`str`):
            The URL of the WEBP, TGS, or WEBM sticker \(sticker file size must not exceed 5MB\)

        sticker_width (:class:`int`):
            Width of the sticker

        sticker_height (:class:`int`):
            Height of the sticker

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        thumbnail_url: str = "",
        sticker_url: str = "",
        sticker_width: int = 0,
        sticker_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""URL of the sticker thumbnail, if it exists"""
        self.sticker_url: Union[str, None] = sticker_url
        r"""The URL of the WEBP, TGS, or WEBM sticker \(sticker file size must not exceed 5MB\)"""
        self.sticker_width: int = int(sticker_width)
        r"""Width of the sticker"""
        self.sticker_height: int = int(sticker_height)
        r"""Height of the sticker"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultSticker"]:
        return "inputInlineQueryResultSticker"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "thumbnail_url": self.thumbnail_url,
            "sticker_url": self.sticker_url,
            "sticker_width": self.sticker_width,
            "sticker_height": self.sticker_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultSticker", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.sticker_url = data.get("sticker_url", "")
            data_class.sticker_width = int(data.get("sticker_width", 0))
            data_class.sticker_height = int(data.get("sticker_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultVenue(TlObject, InputInlineQueryResult):
    r"""Represents information about a venue

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        venue (:class:`"types.Venue"`):
            Venue result

        thumbnail_url (:class:`str`):
            URL of the result thumbnail, if it exists

        thumbnail_width (:class:`int`):
            Thumbnail width, if known

        thumbnail_height (:class:`int`):
            Thumbnail height, if known

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        venue: Venue = None,
        thumbnail_url: str = "",
        thumbnail_width: int = 0,
        thumbnail_height: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.venue: Union[Venue, None] = venue
        r"""Venue result"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""URL of the result thumbnail, if it exists"""
        self.thumbnail_width: int = int(thumbnail_width)
        r"""Thumbnail width, if known"""
        self.thumbnail_height: int = int(thumbnail_height)
        r"""Thumbnail height, if known"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultVenue"]:
        return "inputInlineQueryResultVenue"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "venue": self.venue,
            "thumbnail_url": self.thumbnail_url,
            "thumbnail_width": self.thumbnail_width,
            "thumbnail_height": self.thumbnail_height,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultVenue", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.venue = data.get("venue", None)
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.thumbnail_width = int(data.get("thumbnail_width", 0))
            data_class.thumbnail_height = int(data.get("thumbnail_height", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultVideo(TlObject, InputInlineQueryResult):
    r"""Represents a link to a page containing an embedded video player or a video file

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        title (:class:`str`):
            Title of the result

        description (:class:`str`):
            A short description of the result, if known

        thumbnail_url (:class:`str`):
            The URL of the video thumbnail \(JPEG\), if it exists

        video_url (:class:`str`):
            URL of the embedded video player or video file

        mime_type (:class:`str`):
            MIME type of the content of the video URL, only \"text/html\" or \"video/mp4\" are currently supported

        video_width (:class:`int`):
            Width of the video

        video_height (:class:`int`):
            Height of the video

        video_duration (:class:`int`):
            Video duration, in seconds

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        title: str = "",
        description: str = "",
        thumbnail_url: str = "",
        video_url: str = "",
        mime_type: str = "",
        video_width: int = 0,
        video_height: int = 0,
        video_duration: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.title: Union[str, None] = title
        r"""Title of the result"""
        self.description: Union[str, None] = description
        r"""A short description of the result, if known"""
        self.thumbnail_url: Union[str, None] = thumbnail_url
        r"""The URL of the video thumbnail \(JPEG\), if it exists"""
        self.video_url: Union[str, None] = video_url
        r"""URL of the embedded video player or video file"""
        self.mime_type: Union[str, None] = mime_type
        r"""MIME type of the content of the video URL, only \"text/html\" or \"video/mp4\" are currently supported"""
        self.video_width: int = int(video_width)
        r"""Width of the video"""
        self.video_height: int = int(video_height)
        r"""Height of the video"""
        self.video_duration: int = int(video_duration)
        r"""Video duration, in seconds"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultVideo"]:
        return "inputInlineQueryResultVideo"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "thumbnail_url": self.thumbnail_url,
            "video_url": self.video_url,
            "mime_type": self.mime_type,
            "video_width": self.video_width,
            "video_height": self.video_height,
            "video_duration": self.video_duration,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultVideo", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.thumbnail_url = data.get("thumbnail_url", "")
            data_class.video_url = data.get("video_url", "")
            data_class.mime_type = data.get("mime_type", "")
            data_class.video_width = int(data.get("video_width", 0))
            data_class.video_height = int(data.get("video_height", 0))
            data_class.video_duration = int(data.get("video_duration", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InputInlineQueryResultVoiceNote(TlObject, InputInlineQueryResult):
    r"""Represents a link to an opus\-encoded audio file within an OGG container, single channel audio

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        title (:class:`str`):
            Title of the voice note

        voice_note_url (:class:`str`):
            The URL of the voice note file

        voice_note_duration (:class:`int`):
            Duration of the voice note, in seconds

        reply_markup (:class:`"types.ReplyMarkup"`):
            The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null

        input_message_content (:class:`"types.InputMessageContent"`):
            The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact

    """

    def __init__(
        self,
        id: str = "",
        title: str = "",
        voice_note_url: str = "",
        voice_note_duration: int = 0,
        reply_markup: ReplyMarkup = None,
        input_message_content: InputMessageContent = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.title: Union[str, None] = title
        r"""Title of the voice note"""
        self.voice_note_url: Union[str, None] = voice_note_url
        r"""The URL of the voice note file"""
        self.voice_note_duration: int = int(voice_note_duration)
        r"""Duration of the voice note, in seconds"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""The message reply markup; pass null if none\. Must be of type replyMarkupInlineKeyboard or null"""
        self.input_message_content: Union[
            InputMessageText,
            InputMessageAnimation,
            InputMessageAudio,
            InputMessageDocument,
            InputMessagePaidMedia,
            InputMessagePhoto,
            InputMessageSticker,
            InputMessageVideo,
            InputMessageVideoNote,
            InputMessageVoiceNote,
            InputMessageLocation,
            InputMessageVenue,
            InputMessageContact,
            InputMessageDice,
            InputMessageGame,
            InputMessageInvoice,
            InputMessagePoll,
            InputMessageStory,
            InputMessageForwarded,
            None,
        ] = input_message_content
        r"""The content of the message to be sent\. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputInlineQueryResultVoiceNote"]:
        return "inputInlineQueryResultVoiceNote"

    def getClass(self) -> Literal["InputInlineQueryResult"]:
        return "InputInlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "title": self.title,
            "voice_note_url": self.voice_note_url,
            "voice_note_duration": self.voice_note_duration,
            "reply_markup": self.reply_markup,
            "input_message_content": self.input_message_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputInlineQueryResultVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.title = data.get("title", "")
            data_class.voice_note_url = data.get("voice_note_url", "")
            data_class.voice_note_duration = int(data.get("voice_note_duration", 0))
            data_class.reply_markup = data.get("reply_markup", None)
            data_class.input_message_content = data.get("input_message_content", None)

        return data_class


class InlineQueryResultArticle(TlObject, InlineQueryResult):
    r"""Represents a link to an article or web page

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        url (:class:`str`):
            URL of the result, if it exists

        title (:class:`str`):
            Title of the result

        description (:class:`str`):
            A short description of the result

        thumbnail (:class:`"types.Thumbnail"`):
            Result thumbnail in JPEG format; may be null

    """

    def __init__(
        self,
        id: str = "",
        url: str = "",
        title: str = "",
        description: str = "",
        thumbnail: Thumbnail = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.url: Union[str, None] = url
        r"""URL of the result, if it exists"""
        self.title: Union[str, None] = title
        r"""Title of the result"""
        self.description: Union[str, None] = description
        r"""A short description of the result"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Result thumbnail in JPEG format; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultArticle"]:
        return "inlineQueryResultArticle"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "url": self.url,
            "title": self.title,
            "description": self.description,
            "thumbnail": self.thumbnail,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultArticle", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.url = data.get("url", "")
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")
            data_class.thumbnail = data.get("thumbnail", None)

        return data_class


class InlineQueryResultContact(TlObject, InlineQueryResult):
    r"""Represents a user contact

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        contact (:class:`"types.Contact"`):
            A user contact

        thumbnail (:class:`"types.Thumbnail"`):
            Result thumbnail in JPEG format; may be null

    """

    def __init__(
        self, id: str = "", contact: Contact = None, thumbnail: Thumbnail = None
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.contact: Union[Contact, None] = contact
        r"""A user contact"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Result thumbnail in JPEG format; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultContact"]:
        return "inlineQueryResultContact"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "contact": self.contact,
            "thumbnail": self.thumbnail,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultContact", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.contact = data.get("contact", None)
            data_class.thumbnail = data.get("thumbnail", None)

        return data_class


class InlineQueryResultLocation(TlObject, InlineQueryResult):
    r"""Represents a point on the map

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        location (:class:`"types.Location"`):
            Location result

        title (:class:`str`):
            Title of the result

        thumbnail (:class:`"types.Thumbnail"`):
            Result thumbnail in JPEG format; may be null

    """

    def __init__(
        self,
        id: str = "",
        location: Location = None,
        title: str = "",
        thumbnail: Thumbnail = None,
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.location: Union[Location, None] = location
        r"""Location result"""
        self.title: Union[str, None] = title
        r"""Title of the result"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Result thumbnail in JPEG format; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultLocation"]:
        return "inlineQueryResultLocation"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "location": self.location,
            "title": self.title,
            "thumbnail": self.thumbnail,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultLocation", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.location = data.get("location", None)
            data_class.title = data.get("title", "")
            data_class.thumbnail = data.get("thumbnail", None)

        return data_class


class InlineQueryResultVenue(TlObject, InlineQueryResult):
    r"""Represents information about a venue

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        venue (:class:`"types.Venue"`):
            Venue result

        thumbnail (:class:`"types.Thumbnail"`):
            Result thumbnail in JPEG format; may be null

    """

    def __init__(
        self, id: str = "", venue: Venue = None, thumbnail: Thumbnail = None
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.venue: Union[Venue, None] = venue
        r"""Venue result"""
        self.thumbnail: Union[Thumbnail, None] = thumbnail
        r"""Result thumbnail in JPEG format; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultVenue"]:
        return "inlineQueryResultVenue"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "venue": self.venue,
            "thumbnail": self.thumbnail,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultVenue", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.venue = data.get("venue", None)
            data_class.thumbnail = data.get("thumbnail", None)

        return data_class


class InlineQueryResultGame(TlObject, InlineQueryResult):
    r"""Represents information about a game

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        game (:class:`"types.Game"`):
            Game result

    """

    def __init__(self, id: str = "", game: Game = None) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.game: Union[Game, None] = game
        r"""Game result"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultGame"]:
        return "inlineQueryResultGame"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id, "game": self.game}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultGame", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.game = data.get("game", None)

        return data_class


class InlineQueryResultAnimation(TlObject, InlineQueryResult):
    r"""Represents an animation file

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        animation (:class:`"types.Animation"`):
            Animation file

        title (:class:`str`):
            Animation title

    """

    def __init__(
        self, id: str = "", animation: Animation = None, title: str = ""
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.animation: Union[Animation, None] = animation
        r"""Animation file"""
        self.title: Union[str, None] = title
        r"""Animation title"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultAnimation"]:
        return "inlineQueryResultAnimation"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "animation": self.animation,
            "title": self.title,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultAnimation", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.animation = data.get("animation", None)
            data_class.title = data.get("title", "")

        return data_class


class InlineQueryResultAudio(TlObject, InlineQueryResult):
    r"""Represents an audio file

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        audio (:class:`"types.Audio"`):
            Audio file

    """

    def __init__(self, id: str = "", audio: Audio = None) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.audio: Union[Audio, None] = audio
        r"""Audio file"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultAudio"]:
        return "inlineQueryResultAudio"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id, "audio": self.audio}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultAudio", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.audio = data.get("audio", None)

        return data_class


class InlineQueryResultDocument(TlObject, InlineQueryResult):
    r"""Represents a document

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        document (:class:`"types.Document"`):
            Document

        title (:class:`str`):
            Document title

        description (:class:`str`):
            Document description

    """

    def __init__(
        self,
        id: str = "",
        document: Document = None,
        title: str = "",
        description: str = "",
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.document: Union[Document, None] = document
        r"""Document"""
        self.title: Union[str, None] = title
        r"""Document title"""
        self.description: Union[str, None] = description
        r"""Document description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultDocument"]:
        return "inlineQueryResultDocument"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "document": self.document,
            "title": self.title,
            "description": self.description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultDocument", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.document = data.get("document", None)
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")

        return data_class


class InlineQueryResultPhoto(TlObject, InlineQueryResult):
    r"""Represents a photo

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        photo (:class:`"types.Photo"`):
            Photo

        title (:class:`str`):
            Title of the result, if known

        description (:class:`str`):
            A short description of the result, if known

    """

    def __init__(
        self, id: str = "", photo: Photo = None, title: str = "", description: str = ""
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.photo: Union[Photo, None] = photo
        r"""Photo"""
        self.title: Union[str, None] = title
        r"""Title of the result, if known"""
        self.description: Union[str, None] = description
        r"""A short description of the result, if known"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultPhoto"]:
        return "inlineQueryResultPhoto"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "photo": self.photo,
            "title": self.title,
            "description": self.description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultPhoto", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.photo = data.get("photo", None)
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")

        return data_class


class InlineQueryResultSticker(TlObject, InlineQueryResult):
    r"""Represents a sticker

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        sticker (:class:`"types.Sticker"`):
            Sticker

    """

    def __init__(self, id: str = "", sticker: Sticker = None) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.sticker: Union[Sticker, None] = sticker
        r"""Sticker"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultSticker"]:
        return "inlineQueryResultSticker"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id, "sticker": self.sticker}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultSticker", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.sticker = data.get("sticker", None)

        return data_class


class InlineQueryResultVideo(TlObject, InlineQueryResult):
    r"""Represents a video

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        video (:class:`"types.Video"`):
            Video

        title (:class:`str`):
            Title of the video

        description (:class:`str`):
            Description of the video

    """

    def __init__(
        self, id: str = "", video: Video = None, title: str = "", description: str = ""
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.video: Union[Video, None] = video
        r"""Video"""
        self.title: Union[str, None] = title
        r"""Title of the video"""
        self.description: Union[str, None] = description
        r"""Description of the video"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultVideo"]:
        return "inlineQueryResultVideo"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "video": self.video,
            "title": self.title,
            "description": self.description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultVideo", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.video = data.get("video", None)
            data_class.title = data.get("title", "")
            data_class.description = data.get("description", "")

        return data_class


class InlineQueryResultVoiceNote(TlObject, InlineQueryResult):
    r"""Represents a voice note

    Parameters:
        id (:class:`str`):
            Unique identifier of the query result

        voice_note (:class:`"types.VoiceNote"`):
            Voice note

        title (:class:`str`):
            Title of the voice note

    """

    def __init__(
        self, id: str = "", voice_note: VoiceNote = None, title: str = ""
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier of the query result"""
        self.voice_note: Union[VoiceNote, None] = voice_note
        r"""Voice note"""
        self.title: Union[str, None] = title
        r"""Title of the voice note"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultVoiceNote"]:
        return "inlineQueryResultVoiceNote"

    def getClass(self) -> Literal["InlineQueryResult"]:
        return "InlineQueryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "voice_note": self.voice_note,
            "title": self.title,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.voice_note = data.get("voice_note", None)
            data_class.title = data.get("title", "")

        return data_class


class InlineQueryResultsButtonTypeStartBot(TlObject, InlineQueryResultsButtonType):
    r"""Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter

    Parameters:
        parameter (:class:`str`):
            The parameter for the bot start message

    """

    def __init__(self, parameter: str = "") -> None:
        self.parameter: Union[str, None] = parameter
        r"""The parameter for the bot start message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultsButtonTypeStartBot"]:
        return "inlineQueryResultsButtonTypeStartBot"

    def getClass(self) -> Literal["InlineQueryResultsButtonType"]:
        return "InlineQueryResultsButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "parameter": self.parameter}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InlineQueryResultsButtonTypeStartBot", None]:
        if data:
            data_class = cls()
            data_class.parameter = data.get("parameter", "")

        return data_class


class InlineQueryResultsButtonTypeWebApp(TlObject, InlineQueryResultsButtonType):
    r"""Describes the button that opens a Web App by calling getWebAppUrl

    Parameters:
        url (:class:`str`):
            An HTTP URL to pass to getWebAppUrl

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""An HTTP URL to pass to getWebAppUrl"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultsButtonTypeWebApp"]:
        return "inlineQueryResultsButtonTypeWebApp"

    def getClass(self) -> Literal["InlineQueryResultsButtonType"]:
        return "InlineQueryResultsButtonType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultsButtonTypeWebApp", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class InlineQueryResultsButton(TlObject):
    r"""Represents a button to be shown above inline query results

    Parameters:
        text (:class:`str`):
            The text of the button

        type (:class:`"types.InlineQueryResultsButtonType"`):
            Type of the button

    """

    def __init__(
        self, text: str = "", type: InlineQueryResultsButtonType = None
    ) -> None:
        self.text: Union[str, None] = text
        r"""The text of the button"""
        self.type: Union[
            InlineQueryResultsButtonTypeStartBot,
            InlineQueryResultsButtonTypeWebApp,
            None,
        ] = type
        r"""Type of the button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResultsButton"]:
        return "inlineQueryResultsButton"

    def getClass(self) -> Literal["InlineQueryResultsButton"]:
        return "InlineQueryResultsButton"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "type": self.type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResultsButton", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.type = data.get("type", None)

        return data_class


class InlineQueryResults(TlObject):
    r"""Represents the results of the inline query\. Use sendInlineQueryResultMessage to send the result of the query

    Parameters:
        inline_query_id (:class:`int`):
            Unique identifier of the inline query

        button (:class:`"types.InlineQueryResultsButton"`):
            Button to be shown above inline query results; may be null

        results (:class:`List["types.InlineQueryResult"]`):
            Results of the query

        next_offset (:class:`str`):
            The offset for the next request\. If empty, then there are no more results

    """

    def __init__(
        self,
        inline_query_id: int = 0,
        button: InlineQueryResultsButton = None,
        results: List[InlineQueryResult] = None,
        next_offset: str = "",
    ) -> None:
        self.inline_query_id: int = int(inline_query_id)
        r"""Unique identifier of the inline query"""
        self.button: Union[InlineQueryResultsButton, None] = button
        r"""Button to be shown above inline query results; may be null"""
        self.results: List[InlineQueryResult] = results or []
        r"""Results of the query"""
        self.next_offset: Union[str, None] = next_offset
        r"""The offset for the next request\. If empty, then there are no more results"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inlineQueryResults"]:
        return "inlineQueryResults"

    def getClass(self) -> Literal["InlineQueryResults"]:
        return "InlineQueryResults"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "inline_query_id": self.inline_query_id,
            "button": self.button,
            "results": self.results,
            "next_offset": self.next_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InlineQueryResults", None]:
        if data:
            data_class = cls()
            data_class.inline_query_id = int(data.get("inline_query_id", 0))
            data_class.button = data.get("button", None)
            data_class.results = data.get("results", None)
            data_class.next_offset = data.get("next_offset", "")

        return data_class


class PreparedInlineMessageId(TlObject):
    r"""Represents an inline message that can be sent via the bot

    Parameters:
        id (:class:`str`):
            Unique identifier for the message

        expiration_date (:class:`int`):
            Point in time \(Unix timestamp\) when the message can't be used anymore

    """

    def __init__(self, id: str = "", expiration_date: int = 0) -> None:
        self.id: Union[str, None] = id
        r"""Unique identifier for the message"""
        self.expiration_date: int = int(expiration_date)
        r"""Point in time \(Unix timestamp\) when the message can't be used anymore"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["preparedInlineMessageId"]:
        return "preparedInlineMessageId"

    def getClass(self) -> Literal["PreparedInlineMessageId"]:
        return "PreparedInlineMessageId"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "expiration_date": self.expiration_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PreparedInlineMessageId", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.expiration_date = int(data.get("expiration_date", 0))

        return data_class


class PreparedInlineMessage(TlObject):
    r"""Represents a ready to send inline message\. Use sendInlineQueryResultMessage to send the message

    Parameters:
        inline_query_id (:class:`int`):
            Unique identifier of the inline query to pass to sendInlineQueryResultMessage

        result (:class:`"types.InlineQueryResult"`):
            Resulted inline message of the query

        chat_types (:class:`"types.TargetChatTypes"`):
            Types of the chats to which the message can be sent

    """

    def __init__(
        self,
        inline_query_id: int = 0,
        result: InlineQueryResult = None,
        chat_types: TargetChatTypes = None,
    ) -> None:
        self.inline_query_id: int = int(inline_query_id)
        r"""Unique identifier of the inline query to pass to sendInlineQueryResultMessage"""
        self.result: Union[
            InlineQueryResultArticle,
            InlineQueryResultContact,
            InlineQueryResultLocation,
            InlineQueryResultVenue,
            InlineQueryResultGame,
            InlineQueryResultAnimation,
            InlineQueryResultAudio,
            InlineQueryResultDocument,
            InlineQueryResultPhoto,
            InlineQueryResultSticker,
            InlineQueryResultVideo,
            InlineQueryResultVoiceNote,
            None,
        ] = result
        r"""Resulted inline message of the query"""
        self.chat_types: Union[TargetChatTypes, None] = chat_types
        r"""Types of the chats to which the message can be sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["preparedInlineMessage"]:
        return "preparedInlineMessage"

    def getClass(self) -> Literal["PreparedInlineMessage"]:
        return "PreparedInlineMessage"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "inline_query_id": self.inline_query_id,
            "result": self.result,
            "chat_types": self.chat_types,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PreparedInlineMessage", None]:
        if data:
            data_class = cls()
            data_class.inline_query_id = int(data.get("inline_query_id", 0))
            data_class.result = data.get("result", None)
            data_class.chat_types = data.get("chat_types", None)

        return data_class


class CallbackQueryPayloadData(TlObject, CallbackQueryPayload):
    r"""The payload for a general callback button

    Parameters:
        data (:class:`bytes`):
            Data that was attached to the callback button

    """

    def __init__(self, data: bytes = b"") -> None:
        self.data: Union[bytes, None] = data
        r"""Data that was attached to the callback button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callbackQueryPayloadData"]:
        return "callbackQueryPayloadData"

    def getClass(self) -> Literal["CallbackQueryPayload"]:
        return "CallbackQueryPayload"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "data": self.data}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallbackQueryPayloadData", None]:
        if data:
            data_class = cls()
            data_class.data = b64decode(data.get("data", b""))

        return data_class


class CallbackQueryPayloadDataWithPassword(TlObject, CallbackQueryPayload):
    r"""The payload for a callback button requiring password

    Parameters:
        password (:class:`str`):
            The 2\-step verification password for the current user

        data (:class:`bytes`):
            Data that was attached to the callback button

    """

    def __init__(self, password: str = "", data: bytes = b"") -> None:
        self.password: Union[str, None] = password
        r"""The 2\-step verification password for the current user"""
        self.data: Union[bytes, None] = data
        r"""Data that was attached to the callback button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callbackQueryPayloadDataWithPassword"]:
        return "callbackQueryPayloadDataWithPassword"

    def getClass(self) -> Literal["CallbackQueryPayload"]:
        return "CallbackQueryPayload"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "password": self.password, "data": self.data}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CallbackQueryPayloadDataWithPassword", None]:
        if data:
            data_class = cls()
            data_class.password = data.get("password", "")
            data_class.data = b64decode(data.get("data", b""))

        return data_class


class CallbackQueryPayloadGame(TlObject, CallbackQueryPayload):
    r"""The payload for a game callback button

    Parameters:
        game_short_name (:class:`str`):
            A short name of the game that was attached to the callback button

    """

    def __init__(self, game_short_name: str = "") -> None:
        self.game_short_name: Union[str, None] = game_short_name
        r"""A short name of the game that was attached to the callback button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callbackQueryPayloadGame"]:
        return "callbackQueryPayloadGame"

    def getClass(self) -> Literal["CallbackQueryPayload"]:
        return "CallbackQueryPayload"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "game_short_name": self.game_short_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallbackQueryPayloadGame", None]:
        if data:
            data_class = cls()
            data_class.game_short_name = data.get("game_short_name", "")

        return data_class


class CallbackQueryAnswer(TlObject):
    r"""Contains a bot's answer to a callback query

    Parameters:
        text (:class:`str`):
            Text of the answer

        show_alert (:class:`bool`):
            True, if an alert must be shown to the user instead of a toast notification

        url (:class:`str`):
            URL to be opened

    """

    def __init__(self, text: str = "", show_alert: bool = False, url: str = "") -> None:
        self.text: Union[str, None] = text
        r"""Text of the answer"""
        self.show_alert: bool = bool(show_alert)
        r"""True, if an alert must be shown to the user instead of a toast notification"""
        self.url: Union[str, None] = url
        r"""URL to be opened"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["callbackQueryAnswer"]:
        return "callbackQueryAnswer"

    def getClass(self) -> Literal["CallbackQueryAnswer"]:
        return "CallbackQueryAnswer"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "show_alert": self.show_alert,
            "url": self.url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["CallbackQueryAnswer", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.show_alert = data.get("show_alert", False)
            data_class.url = data.get("url", "")

        return data_class


class CustomRequestResult(TlObject):
    r"""Contains the result of a custom request

    Parameters:
        result (:class:`str`):
            A JSON\-serialized result

    """

    def __init__(self, result: str = "") -> None:
        self.result: Union[str, None] = result
        r"""A JSON\-serialized result"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["customRequestResult"]:
        return "customRequestResult"

    def getClass(self) -> Literal["CustomRequestResult"]:
        return "CustomRequestResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "result": self.result}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CustomRequestResult", None]:
        if data:
            data_class = cls()
            data_class.result = data.get("result", "")

        return data_class


class GameHighScore(TlObject):
    r"""Contains one row of the game high score table

    Parameters:
        position (:class:`int`):
            Position in the high score table

        user_id (:class:`int`):
            User identifier

        score (:class:`int`):
            User score

    """

    def __init__(self, position: int = 0, user_id: int = 0, score: int = 0) -> None:
        self.position: int = int(position)
        r"""Position in the high score table"""
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.score: int = int(score)
        r"""User score"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["gameHighScore"]:
        return "gameHighScore"

    def getClass(self) -> Literal["GameHighScore"]:
        return "GameHighScore"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "position": self.position,
            "user_id": self.user_id,
            "score": self.score,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["GameHighScore", None]:
        if data:
            data_class = cls()
            data_class.position = int(data.get("position", 0))
            data_class.user_id = int(data.get("user_id", 0))
            data_class.score = int(data.get("score", 0))

        return data_class


class GameHighScores(TlObject):
    r"""Contains a list of game high scores

    Parameters:
        scores (:class:`List["types.GameHighScore"]`):
            A list of game high scores

    """

    def __init__(self, scores: List[GameHighScore] = None) -> None:
        self.scores: List[GameHighScore] = scores or []
        r"""A list of game high scores"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["gameHighScores"]:
        return "gameHighScores"

    def getClass(self) -> Literal["GameHighScores"]:
        return "GameHighScores"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "scores": self.scores}

    @classmethod
    def from_dict(cls, data: dict) -> Union["GameHighScores", None]:
        if data:
            data_class = cls()
            data_class.scores = data.get("scores", None)

        return data_class


class ChatEventMessageEdited(TlObject, ChatEventAction):
    r"""A message was edited

    Parameters:
        old_message (:class:`"types.Message"`):
            The original message before the edit

        new_message (:class:`"types.Message"`):
            The message after it was edited

    """

    def __init__(
        self, old_message: Message = None, new_message: Message = None
    ) -> None:
        self.old_message: Union[Message, None] = old_message
        r"""The original message before the edit"""
        self.new_message: Union[Message, None] = new_message
        r"""The message after it was edited"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMessageEdited"]:
        return "chatEventMessageEdited"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_message": self.old_message,
            "new_message": self.new_message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMessageEdited", None]:
        if data:
            data_class = cls()
            data_class.old_message = data.get("old_message", None)
            data_class.new_message = data.get("new_message", None)

        return data_class


class ChatEventMessageDeleted(TlObject, ChatEventAction):
    r"""A message was deleted

    Parameters:
        message (:class:`"types.Message"`):
            Deleted message

        can_report_anti_spam_false_positive (:class:`bool`):
            True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive

    """

    def __init__(
        self, message: Message = None, can_report_anti_spam_false_positive: bool = False
    ) -> None:
        self.message: Union[Message, None] = message
        r"""Deleted message"""
        self.can_report_anti_spam_false_positive: bool = bool(
            can_report_anti_spam_false_positive
        )
        r"""True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMessageDeleted"]:
        return "chatEventMessageDeleted"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message": self.message,
            "can_report_anti_spam_false_positive": self.can_report_anti_spam_false_positive,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMessageDeleted", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)
            data_class.can_report_anti_spam_false_positive = data.get(
                "can_report_anti_spam_false_positive", False
            )

        return data_class


class ChatEventMessagePinned(TlObject, ChatEventAction):
    r"""A message was pinned

    Parameters:
        message (:class:`"types.Message"`):
            Pinned message

    """

    def __init__(self, message: Message = None) -> None:
        self.message: Union[Message, None] = message
        r"""Pinned message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMessagePinned"]:
        return "chatEventMessagePinned"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message": self.message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMessagePinned", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)

        return data_class


class ChatEventMessageUnpinned(TlObject, ChatEventAction):
    r"""A message was unpinned

    Parameters:
        message (:class:`"types.Message"`):
            Unpinned message

    """

    def __init__(self, message: Message = None) -> None:
        self.message: Union[Message, None] = message
        r"""Unpinned message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMessageUnpinned"]:
        return "chatEventMessageUnpinned"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message": self.message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMessageUnpinned", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)

        return data_class


class ChatEventPollStopped(TlObject, ChatEventAction):
    r"""A poll in a message was stopped

    Parameters:
        message (:class:`"types.Message"`):
            The message with the poll

    """

    def __init__(self, message: Message = None) -> None:
        self.message: Union[Message, None] = message
        r"""The message with the poll"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventPollStopped"]:
        return "chatEventPollStopped"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message": self.message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventPollStopped", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)

        return data_class


class ChatEventMemberJoined(TlObject, ChatEventAction):
    r"""A new member joined the chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberJoined"]:
        return "chatEventMemberJoined"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMemberJoined", None]:
        if data:
            data_class = cls()

        return data_class


class ChatEventMemberJoinedByInviteLink(TlObject, ChatEventAction):
    r"""A new member joined the chat via an invite link

    Parameters:
        invite_link (:class:`"types.ChatInviteLink"`):
            Invite link used to join the chat

        via_chat_folder_invite_link (:class:`bool`):
            True, if the user has joined the chat using an invite link for a chat folder

    """

    def __init__(
        self,
        invite_link: ChatInviteLink = None,
        via_chat_folder_invite_link: bool = False,
    ) -> None:
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""Invite link used to join the chat"""
        self.via_chat_folder_invite_link: bool = bool(via_chat_folder_invite_link)
        r"""True, if the user has joined the chat using an invite link for a chat folder"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberJoinedByInviteLink"]:
        return "chatEventMemberJoinedByInviteLink"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "invite_link": self.invite_link,
            "via_chat_folder_invite_link": self.via_chat_folder_invite_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMemberJoinedByInviteLink", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", None)
            data_class.via_chat_folder_invite_link = data.get(
                "via_chat_folder_invite_link", False
            )

        return data_class


class ChatEventMemberJoinedByRequest(TlObject, ChatEventAction):
    r"""A new member was accepted to the chat by an administrator

    Parameters:
        approver_user_id (:class:`int`):
            User identifier of the chat administrator, approved user join request

        invite_link (:class:`"types.ChatInviteLink"`):
            Invite link used to join the chat; may be null

    """

    def __init__(
        self, approver_user_id: int = 0, invite_link: ChatInviteLink = None
    ) -> None:
        self.approver_user_id: int = int(approver_user_id)
        r"""User identifier of the chat administrator, approved user join request"""
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""Invite link used to join the chat; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberJoinedByRequest"]:
        return "chatEventMemberJoinedByRequest"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "approver_user_id": self.approver_user_id,
            "invite_link": self.invite_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMemberJoinedByRequest", None]:
        if data:
            data_class = cls()
            data_class.approver_user_id = int(data.get("approver_user_id", 0))
            data_class.invite_link = data.get("invite_link", None)

        return data_class


class ChatEventMemberInvited(TlObject, ChatEventAction):
    r"""A new chat member was invited

    Parameters:
        user_id (:class:`int`):
            New member user identifier

        status (:class:`"types.ChatMemberStatus"`):
            New member status

    """

    def __init__(self, user_id: int = 0, status: ChatMemberStatus = None) -> None:
        self.user_id: int = int(user_id)
        r"""New member user identifier"""
        self.status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = status
        r"""New member status"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberInvited"]:
        return "chatEventMemberInvited"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id, "status": self.status}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMemberInvited", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.status = data.get("status", None)

        return data_class


class ChatEventMemberLeft(TlObject, ChatEventAction):
    r"""A member left the chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberLeft"]:
        return "chatEventMemberLeft"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMemberLeft", None]:
        if data:
            data_class = cls()

        return data_class


class ChatEventMemberPromoted(TlObject, ChatEventAction):
    r"""A chat member has gained/lost administrator status, or the list of their administrator privileges has changed

    Parameters:
        user_id (:class:`int`):
            Affected chat member user identifier

        old_status (:class:`"types.ChatMemberStatus"`):
            Previous status of the chat member

        new_status (:class:`"types.ChatMemberStatus"`):
            New status of the chat member

    """

    def __init__(
        self,
        user_id: int = 0,
        old_status: ChatMemberStatus = None,
        new_status: ChatMemberStatus = None,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Affected chat member user identifier"""
        self.old_status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = old_status
        r"""Previous status of the chat member"""
        self.new_status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = new_status
        r"""New status of the chat member"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberPromoted"]:
        return "chatEventMemberPromoted"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "old_status": self.old_status,
            "new_status": self.new_status,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMemberPromoted", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.old_status = data.get("old_status", None)
            data_class.new_status = data.get("new_status", None)

        return data_class


class ChatEventMemberRestricted(TlObject, ChatEventAction):
    r"""A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed

    Parameters:
        member_id (:class:`"types.MessageSender"`):
            Affected chat member identifier

        old_status (:class:`"types.ChatMemberStatus"`):
            Previous status of the chat member

        new_status (:class:`"types.ChatMemberStatus"`):
            New status of the chat member

    """

    def __init__(
        self,
        member_id: MessageSender = None,
        old_status: ChatMemberStatus = None,
        new_status: ChatMemberStatus = None,
    ) -> None:
        self.member_id: Union[MessageSenderUser, MessageSenderChat, None] = member_id
        r"""Affected chat member identifier"""
        self.old_status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = old_status
        r"""Previous status of the chat member"""
        self.new_status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = new_status
        r"""New status of the chat member"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberRestricted"]:
        return "chatEventMemberRestricted"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "member_id": self.member_id,
            "old_status": self.old_status,
            "new_status": self.new_status,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventMemberRestricted", None]:
        if data:
            data_class = cls()
            data_class.member_id = data.get("member_id", None)
            data_class.old_status = data.get("old_status", None)
            data_class.new_status = data.get("new_status", None)

        return data_class


class ChatEventMemberSubscriptionExtended(TlObject, ChatEventAction):
    r"""A chat member extended their subscription to the chat

    Parameters:
        user_id (:class:`int`):
            Affected chat member user identifier

        old_status (:class:`"types.ChatMemberStatus"`):
            Previous status of the chat member

        new_status (:class:`"types.ChatMemberStatus"`):
            New status of the chat member

    """

    def __init__(
        self,
        user_id: int = 0,
        old_status: ChatMemberStatus = None,
        new_status: ChatMemberStatus = None,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Affected chat member user identifier"""
        self.old_status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = old_status
        r"""Previous status of the chat member"""
        self.new_status: Union[
            ChatMemberStatusCreator,
            ChatMemberStatusAdministrator,
            ChatMemberStatusMember,
            ChatMemberStatusRestricted,
            ChatMemberStatusLeft,
            ChatMemberStatusBanned,
            None,
        ] = new_status
        r"""New status of the chat member"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMemberSubscriptionExtended"]:
        return "chatEventMemberSubscriptionExtended"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "old_status": self.old_status,
            "new_status": self.new_status,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventMemberSubscriptionExtended", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.old_status = data.get("old_status", None)
            data_class.new_status = data.get("new_status", None)

        return data_class


class ChatEventAvailableReactionsChanged(TlObject, ChatEventAction):
    r"""The chat available reactions were changed

    Parameters:
        old_available_reactions (:class:`"types.ChatAvailableReactions"`):
            Previous chat available reactions

        new_available_reactions (:class:`"types.ChatAvailableReactions"`):
            New chat available reactions

    """

    def __init__(
        self,
        old_available_reactions: ChatAvailableReactions = None,
        new_available_reactions: ChatAvailableReactions = None,
    ) -> None:
        self.old_available_reactions: Union[
            ChatAvailableReactionsAll, ChatAvailableReactionsSome, None
        ] = old_available_reactions
        r"""Previous chat available reactions"""
        self.new_available_reactions: Union[
            ChatAvailableReactionsAll, ChatAvailableReactionsSome, None
        ] = new_available_reactions
        r"""New chat available reactions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventAvailableReactionsChanged"]:
        return "chatEventAvailableReactionsChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_available_reactions": self.old_available_reactions,
            "new_available_reactions": self.new_available_reactions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventAvailableReactionsChanged", None]:
        if data:
            data_class = cls()
            data_class.old_available_reactions = data.get(
                "old_available_reactions", None
            )
            data_class.new_available_reactions = data.get(
                "new_available_reactions", None
            )

        return data_class


class ChatEventBackgroundChanged(TlObject, ChatEventAction):
    r"""The chat background was changed

    Parameters:
        old_background (:class:`"types.ChatBackground"`):
            Previous background; may be null if none

        new_background (:class:`"types.ChatBackground"`):
            New background; may be null if none

    """

    def __init__(
        self,
        old_background: ChatBackground = None,
        new_background: ChatBackground = None,
    ) -> None:
        self.old_background: Union[ChatBackground, None] = old_background
        r"""Previous background; may be null if none"""
        self.new_background: Union[ChatBackground, None] = new_background
        r"""New background; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventBackgroundChanged"]:
        return "chatEventBackgroundChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_background": self.old_background,
            "new_background": self.new_background,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventBackgroundChanged", None]:
        if data:
            data_class = cls()
            data_class.old_background = data.get("old_background", None)
            data_class.new_background = data.get("new_background", None)

        return data_class


class ChatEventDescriptionChanged(TlObject, ChatEventAction):
    r"""The chat description was changed

    Parameters:
        old_description (:class:`str`):
            Previous chat description

        new_description (:class:`str`):
            New chat description

    """

    def __init__(self, old_description: str = "", new_description: str = "") -> None:
        self.old_description: Union[str, None] = old_description
        r"""Previous chat description"""
        self.new_description: Union[str, None] = new_description
        r"""New chat description"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventDescriptionChanged"]:
        return "chatEventDescriptionChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_description": self.old_description,
            "new_description": self.new_description,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventDescriptionChanged", None]:
        if data:
            data_class = cls()
            data_class.old_description = data.get("old_description", "")
            data_class.new_description = data.get("new_description", "")

        return data_class


class ChatEventEmojiStatusChanged(TlObject, ChatEventAction):
    r"""The chat emoji status was changed

    Parameters:
        old_emoji_status (:class:`"types.EmojiStatus"`):
            Previous emoji status; may be null if none

        new_emoji_status (:class:`"types.EmojiStatus"`):
            New emoji status; may be null if none

    """

    def __init__(
        self, old_emoji_status: EmojiStatus = None, new_emoji_status: EmojiStatus = None
    ) -> None:
        self.old_emoji_status: Union[EmojiStatus, None] = old_emoji_status
        r"""Previous emoji status; may be null if none"""
        self.new_emoji_status: Union[EmojiStatus, None] = new_emoji_status
        r"""New emoji status; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventEmojiStatusChanged"]:
        return "chatEventEmojiStatusChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_emoji_status": self.old_emoji_status,
            "new_emoji_status": self.new_emoji_status,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventEmojiStatusChanged", None]:
        if data:
            data_class = cls()
            data_class.old_emoji_status = data.get("old_emoji_status", None)
            data_class.new_emoji_status = data.get("new_emoji_status", None)

        return data_class


class ChatEventLinkedChatChanged(TlObject, ChatEventAction):
    r"""The linked chat of a supergroup was changed

    Parameters:
        old_linked_chat_id (:class:`int`):
            Previous supergroup linked chat identifier

        new_linked_chat_id (:class:`int`):
            New supergroup linked chat identifier

    """

    def __init__(
        self, old_linked_chat_id: int = 0, new_linked_chat_id: int = 0
    ) -> None:
        self.old_linked_chat_id: int = int(old_linked_chat_id)
        r"""Previous supergroup linked chat identifier"""
        self.new_linked_chat_id: int = int(new_linked_chat_id)
        r"""New supergroup linked chat identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventLinkedChatChanged"]:
        return "chatEventLinkedChatChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_linked_chat_id": self.old_linked_chat_id,
            "new_linked_chat_id": self.new_linked_chat_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventLinkedChatChanged", None]:
        if data:
            data_class = cls()
            data_class.old_linked_chat_id = int(data.get("old_linked_chat_id", 0))
            data_class.new_linked_chat_id = int(data.get("new_linked_chat_id", 0))

        return data_class


class ChatEventLocationChanged(TlObject, ChatEventAction):
    r"""The supergroup location was changed

    Parameters:
        old_location (:class:`"types.ChatLocation"`):
            Previous location; may be null

        new_location (:class:`"types.ChatLocation"`):
            New location; may be null

    """

    def __init__(
        self, old_location: ChatLocation = None, new_location: ChatLocation = None
    ) -> None:
        self.old_location: Union[ChatLocation, None] = old_location
        r"""Previous location; may be null"""
        self.new_location: Union[ChatLocation, None] = new_location
        r"""New location; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventLocationChanged"]:
        return "chatEventLocationChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_location": self.old_location,
            "new_location": self.new_location,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventLocationChanged", None]:
        if data:
            data_class = cls()
            data_class.old_location = data.get("old_location", None)
            data_class.new_location = data.get("new_location", None)

        return data_class


class ChatEventMessageAutoDeleteTimeChanged(TlObject, ChatEventAction):
    r"""The message auto\-delete timer was changed

    Parameters:
        old_message_auto_delete_time (:class:`int`):
            Previous value of message\_auto\_delete\_time

        new_message_auto_delete_time (:class:`int`):
            New value of message\_auto\_delete\_time

    """

    def __init__(
        self,
        old_message_auto_delete_time: int = 0,
        new_message_auto_delete_time: int = 0,
    ) -> None:
        self.old_message_auto_delete_time: int = int(old_message_auto_delete_time)
        r"""Previous value of message\_auto\_delete\_time"""
        self.new_message_auto_delete_time: int = int(new_message_auto_delete_time)
        r"""New value of message\_auto\_delete\_time"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventMessageAutoDeleteTimeChanged"]:
        return "chatEventMessageAutoDeleteTimeChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_message_auto_delete_time": self.old_message_auto_delete_time,
            "new_message_auto_delete_time": self.new_message_auto_delete_time,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventMessageAutoDeleteTimeChanged", None]:
        if data:
            data_class = cls()
            data_class.old_message_auto_delete_time = int(
                data.get("old_message_auto_delete_time", 0)
            )
            data_class.new_message_auto_delete_time = int(
                data.get("new_message_auto_delete_time", 0)
            )

        return data_class


class ChatEventPermissionsChanged(TlObject, ChatEventAction):
    r"""The chat permissions were changed

    Parameters:
        old_permissions (:class:`"types.ChatPermissions"`):
            Previous chat permissions

        new_permissions (:class:`"types.ChatPermissions"`):
            New chat permissions

    """

    def __init__(
        self,
        old_permissions: ChatPermissions = None,
        new_permissions: ChatPermissions = None,
    ) -> None:
        self.old_permissions: Union[ChatPermissions, None] = old_permissions
        r"""Previous chat permissions"""
        self.new_permissions: Union[ChatPermissions, None] = new_permissions
        r"""New chat permissions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventPermissionsChanged"]:
        return "chatEventPermissionsChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_permissions": self.old_permissions,
            "new_permissions": self.new_permissions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventPermissionsChanged", None]:
        if data:
            data_class = cls()
            data_class.old_permissions = data.get("old_permissions", None)
            data_class.new_permissions = data.get("new_permissions", None)

        return data_class


class ChatEventPhotoChanged(TlObject, ChatEventAction):
    r"""The chat photo was changed

    Parameters:
        old_photo (:class:`"types.ChatPhoto"`):
            Previous chat photo value; may be null

        new_photo (:class:`"types.ChatPhoto"`):
            New chat photo value; may be null

    """

    def __init__(
        self, old_photo: ChatPhoto = None, new_photo: ChatPhoto = None
    ) -> None:
        self.old_photo: Union[ChatPhoto, None] = old_photo
        r"""Previous chat photo value; may be null"""
        self.new_photo: Union[ChatPhoto, None] = new_photo
        r"""New chat photo value; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventPhotoChanged"]:
        return "chatEventPhotoChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_photo": self.old_photo,
            "new_photo": self.new_photo,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventPhotoChanged", None]:
        if data:
            data_class = cls()
            data_class.old_photo = data.get("old_photo", None)
            data_class.new_photo = data.get("new_photo", None)

        return data_class


class ChatEventSlowModeDelayChanged(TlObject, ChatEventAction):
    r"""The slow\_mode\_delay setting of a supergroup was changed

    Parameters:
        old_slow_mode_delay (:class:`int`):
            Previous value of slow\_mode\_delay, in seconds

        new_slow_mode_delay (:class:`int`):
            New value of slow\_mode\_delay, in seconds

    """

    def __init__(
        self, old_slow_mode_delay: int = 0, new_slow_mode_delay: int = 0
    ) -> None:
        self.old_slow_mode_delay: int = int(old_slow_mode_delay)
        r"""Previous value of slow\_mode\_delay, in seconds"""
        self.new_slow_mode_delay: int = int(new_slow_mode_delay)
        r"""New value of slow\_mode\_delay, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventSlowModeDelayChanged"]:
        return "chatEventSlowModeDelayChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_slow_mode_delay": self.old_slow_mode_delay,
            "new_slow_mode_delay": self.new_slow_mode_delay,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventSlowModeDelayChanged", None]:
        if data:
            data_class = cls()
            data_class.old_slow_mode_delay = int(data.get("old_slow_mode_delay", 0))
            data_class.new_slow_mode_delay = int(data.get("new_slow_mode_delay", 0))

        return data_class


class ChatEventStickerSetChanged(TlObject, ChatEventAction):
    r"""The supergroup sticker set was changed

    Parameters:
        old_sticker_set_id (:class:`int`):
            Previous identifier of the chat sticker set; 0 if none

        new_sticker_set_id (:class:`int`):
            New identifier of the chat sticker set; 0 if none

    """

    def __init__(
        self, old_sticker_set_id: int = 0, new_sticker_set_id: int = 0
    ) -> None:
        self.old_sticker_set_id: int = int(old_sticker_set_id)
        r"""Previous identifier of the chat sticker set; 0 if none"""
        self.new_sticker_set_id: int = int(new_sticker_set_id)
        r"""New identifier of the chat sticker set; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventStickerSetChanged"]:
        return "chatEventStickerSetChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_sticker_set_id": self.old_sticker_set_id,
            "new_sticker_set_id": self.new_sticker_set_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventStickerSetChanged", None]:
        if data:
            data_class = cls()
            data_class.old_sticker_set_id = int(data.get("old_sticker_set_id", 0))
            data_class.new_sticker_set_id = int(data.get("new_sticker_set_id", 0))

        return data_class


class ChatEventCustomEmojiStickerSetChanged(TlObject, ChatEventAction):
    r"""The supergroup sticker set with allowed custom emoji was changed

    Parameters:
        old_sticker_set_id (:class:`int`):
            Previous identifier of the chat sticker set; 0 if none

        new_sticker_set_id (:class:`int`):
            New identifier of the chat sticker set; 0 if none

    """

    def __init__(
        self, old_sticker_set_id: int = 0, new_sticker_set_id: int = 0
    ) -> None:
        self.old_sticker_set_id: int = int(old_sticker_set_id)
        r"""Previous identifier of the chat sticker set; 0 if none"""
        self.new_sticker_set_id: int = int(new_sticker_set_id)
        r"""New identifier of the chat sticker set; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventCustomEmojiStickerSetChanged"]:
        return "chatEventCustomEmojiStickerSetChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_sticker_set_id": self.old_sticker_set_id,
            "new_sticker_set_id": self.new_sticker_set_id,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventCustomEmojiStickerSetChanged", None]:
        if data:
            data_class = cls()
            data_class.old_sticker_set_id = int(data.get("old_sticker_set_id", 0))
            data_class.new_sticker_set_id = int(data.get("new_sticker_set_id", 0))

        return data_class


class ChatEventTitleChanged(TlObject, ChatEventAction):
    r"""The chat title was changed

    Parameters:
        old_title (:class:`str`):
            Previous chat title

        new_title (:class:`str`):
            New chat title

    """

    def __init__(self, old_title: str = "", new_title: str = "") -> None:
        self.old_title: Union[str, None] = old_title
        r"""Previous chat title"""
        self.new_title: Union[str, None] = new_title
        r"""New chat title"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventTitleChanged"]:
        return "chatEventTitleChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_title": self.old_title,
            "new_title": self.new_title,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventTitleChanged", None]:
        if data:
            data_class = cls()
            data_class.old_title = data.get("old_title", "")
            data_class.new_title = data.get("new_title", "")

        return data_class


class ChatEventUsernameChanged(TlObject, ChatEventAction):
    r"""The chat editable username was changed

    Parameters:
        old_username (:class:`str`):
            Previous chat username

        new_username (:class:`str`):
            New chat username

    """

    def __init__(self, old_username: str = "", new_username: str = "") -> None:
        self.old_username: Union[str, None] = old_username
        r"""Previous chat username"""
        self.new_username: Union[str, None] = new_username
        r"""New chat username"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventUsernameChanged"]:
        return "chatEventUsernameChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_username": self.old_username,
            "new_username": self.new_username,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventUsernameChanged", None]:
        if data:
            data_class = cls()
            data_class.old_username = data.get("old_username", "")
            data_class.new_username = data.get("new_username", "")

        return data_class


class ChatEventActiveUsernamesChanged(TlObject, ChatEventAction):
    r"""The chat active usernames were changed

    Parameters:
        old_usernames (:class:`List[str]`):
            Previous list of active usernames

        new_usernames (:class:`List[str]`):
            New list of active usernames

    """

    def __init__(
        self, old_usernames: List[str] = None, new_usernames: List[str] = None
    ) -> None:
        self.old_usernames: List[str] = old_usernames or []
        r"""Previous list of active usernames"""
        self.new_usernames: List[str] = new_usernames or []
        r"""New list of active usernames"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventActiveUsernamesChanged"]:
        return "chatEventActiveUsernamesChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_usernames": self.old_usernames,
            "new_usernames": self.new_usernames,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventActiveUsernamesChanged", None]:
        if data:
            data_class = cls()
            data_class.old_usernames = data.get("old_usernames", None)
            data_class.new_usernames = data.get("new_usernames", None)

        return data_class


class ChatEventAccentColorChanged(TlObject, ChatEventAction):
    r"""The chat accent color or background custom emoji were changed

    Parameters:
        old_accent_color_id (:class:`int`):
            Previous identifier of chat accent color

        old_background_custom_emoji_id (:class:`int`):
            Previous identifier of the custom emoji; 0 if none

        new_accent_color_id (:class:`int`):
            New identifier of chat accent color

        new_background_custom_emoji_id (:class:`int`):
            New identifier of the custom emoji; 0 if none

    """

    def __init__(
        self,
        old_accent_color_id: int = 0,
        old_background_custom_emoji_id: int = 0,
        new_accent_color_id: int = 0,
        new_background_custom_emoji_id: int = 0,
    ) -> None:
        self.old_accent_color_id: int = int(old_accent_color_id)
        r"""Previous identifier of chat accent color"""
        self.old_background_custom_emoji_id: int = int(old_background_custom_emoji_id)
        r"""Previous identifier of the custom emoji; 0 if none"""
        self.new_accent_color_id: int = int(new_accent_color_id)
        r"""New identifier of chat accent color"""
        self.new_background_custom_emoji_id: int = int(new_background_custom_emoji_id)
        r"""New identifier of the custom emoji; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventAccentColorChanged"]:
        return "chatEventAccentColorChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_accent_color_id": self.old_accent_color_id,
            "old_background_custom_emoji_id": self.old_background_custom_emoji_id,
            "new_accent_color_id": self.new_accent_color_id,
            "new_background_custom_emoji_id": self.new_background_custom_emoji_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventAccentColorChanged", None]:
        if data:
            data_class = cls()
            data_class.old_accent_color_id = int(data.get("old_accent_color_id", 0))
            data_class.old_background_custom_emoji_id = int(
                data.get("old_background_custom_emoji_id", 0)
            )
            data_class.new_accent_color_id = int(data.get("new_accent_color_id", 0))
            data_class.new_background_custom_emoji_id = int(
                data.get("new_background_custom_emoji_id", 0)
            )

        return data_class


class ChatEventProfileAccentColorChanged(TlObject, ChatEventAction):
    r"""The chat's profile accent color or profile background custom emoji were changed

    Parameters:
        old_profile_accent_color_id (:class:`int`):
            Previous identifier of chat's profile accent color; \-1 if none

        old_profile_background_custom_emoji_id (:class:`int`):
            Previous identifier of the custom emoji; 0 if none

        new_profile_accent_color_id (:class:`int`):
            New identifier of chat's profile accent color; \-1 if none

        new_profile_background_custom_emoji_id (:class:`int`):
            New identifier of the custom emoji; 0 if none

    """

    def __init__(
        self,
        old_profile_accent_color_id: int = 0,
        old_profile_background_custom_emoji_id: int = 0,
        new_profile_accent_color_id: int = 0,
        new_profile_background_custom_emoji_id: int = 0,
    ) -> None:
        self.old_profile_accent_color_id: int = int(old_profile_accent_color_id)
        r"""Previous identifier of chat's profile accent color; \-1 if none"""
        self.old_profile_background_custom_emoji_id: int = int(
            old_profile_background_custom_emoji_id
        )
        r"""Previous identifier of the custom emoji; 0 if none"""
        self.new_profile_accent_color_id: int = int(new_profile_accent_color_id)
        r"""New identifier of chat's profile accent color; \-1 if none"""
        self.new_profile_background_custom_emoji_id: int = int(
            new_profile_background_custom_emoji_id
        )
        r"""New identifier of the custom emoji; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventProfileAccentColorChanged"]:
        return "chatEventProfileAccentColorChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_profile_accent_color_id": self.old_profile_accent_color_id,
            "old_profile_background_custom_emoji_id": self.old_profile_background_custom_emoji_id,
            "new_profile_accent_color_id": self.new_profile_accent_color_id,
            "new_profile_background_custom_emoji_id": self.new_profile_background_custom_emoji_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventProfileAccentColorChanged", None]:
        if data:
            data_class = cls()
            data_class.old_profile_accent_color_id = int(
                data.get("old_profile_accent_color_id", 0)
            )
            data_class.old_profile_background_custom_emoji_id = int(
                data.get("old_profile_background_custom_emoji_id", 0)
            )
            data_class.new_profile_accent_color_id = int(
                data.get("new_profile_accent_color_id", 0)
            )
            data_class.new_profile_background_custom_emoji_id = int(
                data.get("new_profile_background_custom_emoji_id", 0)
            )

        return data_class


class ChatEventHasProtectedContentToggled(TlObject, ChatEventAction):
    r"""The has\_protected\_content setting of a channel was toggled

    Parameters:
        has_protected_content (:class:`bool`):
            New value of has\_protected\_content

    """

    def __init__(self, has_protected_content: bool = False) -> None:
        self.has_protected_content: bool = bool(has_protected_content)
        r"""New value of has\_protected\_content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventHasProtectedContentToggled"]:
        return "chatEventHasProtectedContentToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "has_protected_content": self.has_protected_content,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventHasProtectedContentToggled", None]:
        if data:
            data_class = cls()
            data_class.has_protected_content = data.get("has_protected_content", False)

        return data_class


class ChatEventInvitesToggled(TlObject, ChatEventAction):
    r"""The can\_invite\_users permission of a supergroup chat was toggled

    Parameters:
        can_invite_users (:class:`bool`):
            New value of can\_invite\_users permission

    """

    def __init__(self, can_invite_users: bool = False) -> None:
        self.can_invite_users: bool = bool(can_invite_users)
        r"""New value of can\_invite\_users permission"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventInvitesToggled"]:
        return "chatEventInvitesToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "can_invite_users": self.can_invite_users}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventInvitesToggled", None]:
        if data:
            data_class = cls()
            data_class.can_invite_users = data.get("can_invite_users", False)

        return data_class


class ChatEventIsAllHistoryAvailableToggled(TlObject, ChatEventAction):
    r"""The is\_all\_history\_available setting of a supergroup was toggled

    Parameters:
        is_all_history_available (:class:`bool`):
            New value of is\_all\_history\_available

    """

    def __init__(self, is_all_history_available: bool = False) -> None:
        self.is_all_history_available: bool = bool(is_all_history_available)
        r"""New value of is\_all\_history\_available"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventIsAllHistoryAvailableToggled"]:
        return "chatEventIsAllHistoryAvailableToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_all_history_available": self.is_all_history_available,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventIsAllHistoryAvailableToggled", None]:
        if data:
            data_class = cls()
            data_class.is_all_history_available = data.get(
                "is_all_history_available", False
            )

        return data_class


class ChatEventHasAggressiveAntiSpamEnabledToggled(TlObject, ChatEventAction):
    r"""The has\_aggressive\_anti\_spam\_enabled setting of a supergroup was toggled

    Parameters:
        has_aggressive_anti_spam_enabled (:class:`bool`):
            New value of has\_aggressive\_anti\_spam\_enabled

    """

    def __init__(self, has_aggressive_anti_spam_enabled: bool = False) -> None:
        self.has_aggressive_anti_spam_enabled: bool = bool(
            has_aggressive_anti_spam_enabled
        )
        r"""New value of has\_aggressive\_anti\_spam\_enabled"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventHasAggressiveAntiSpamEnabledToggled"]:
        return "chatEventHasAggressiveAntiSpamEnabledToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "has_aggressive_anti_spam_enabled": self.has_aggressive_anti_spam_enabled,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventHasAggressiveAntiSpamEnabledToggled", None]:
        if data:
            data_class = cls()
            data_class.has_aggressive_anti_spam_enabled = data.get(
                "has_aggressive_anti_spam_enabled", False
            )

        return data_class


class ChatEventSignMessagesToggled(TlObject, ChatEventAction):
    r"""The sign\_messages setting of a channel was toggled

    Parameters:
        sign_messages (:class:`bool`):
            New value of sign\_messages

    """

    def __init__(self, sign_messages: bool = False) -> None:
        self.sign_messages: bool = bool(sign_messages)
        r"""New value of sign\_messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventSignMessagesToggled"]:
        return "chatEventSignMessagesToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sign_messages": self.sign_messages}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventSignMessagesToggled", None]:
        if data:
            data_class = cls()
            data_class.sign_messages = data.get("sign_messages", False)

        return data_class


class ChatEventShowMessageSenderToggled(TlObject, ChatEventAction):
    r"""The show\_message\_sender setting of a channel was toggled

    Parameters:
        show_message_sender (:class:`bool`):
            New value of show\_message\_sender

    """

    def __init__(self, show_message_sender: bool = False) -> None:
        self.show_message_sender: bool = bool(show_message_sender)
        r"""New value of show\_message\_sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventShowMessageSenderToggled"]:
        return "chatEventShowMessageSenderToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "show_message_sender": self.show_message_sender,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventShowMessageSenderToggled", None]:
        if data:
            data_class = cls()
            data_class.show_message_sender = data.get("show_message_sender", False)

        return data_class


class ChatEventInviteLinkEdited(TlObject, ChatEventAction):
    r"""A chat invite link was edited

    Parameters:
        old_invite_link (:class:`"types.ChatInviteLink"`):
            Previous information about the invite link

        new_invite_link (:class:`"types.ChatInviteLink"`):
            New information about the invite link

    """

    def __init__(
        self,
        old_invite_link: ChatInviteLink = None,
        new_invite_link: ChatInviteLink = None,
    ) -> None:
        self.old_invite_link: Union[ChatInviteLink, None] = old_invite_link
        r"""Previous information about the invite link"""
        self.new_invite_link: Union[ChatInviteLink, None] = new_invite_link
        r"""New information about the invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventInviteLinkEdited"]:
        return "chatEventInviteLinkEdited"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_invite_link": self.old_invite_link,
            "new_invite_link": self.new_invite_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventInviteLinkEdited", None]:
        if data:
            data_class = cls()
            data_class.old_invite_link = data.get("old_invite_link", None)
            data_class.new_invite_link = data.get("new_invite_link", None)

        return data_class


class ChatEventInviteLinkRevoked(TlObject, ChatEventAction):
    r"""A chat invite link was revoked

    Parameters:
        invite_link (:class:`"types.ChatInviteLink"`):
            The invite link

    """

    def __init__(self, invite_link: ChatInviteLink = None) -> None:
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""The invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventInviteLinkRevoked"]:
        return "chatEventInviteLinkRevoked"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invite_link": self.invite_link}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventInviteLinkRevoked", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", None)

        return data_class


class ChatEventInviteLinkDeleted(TlObject, ChatEventAction):
    r"""A revoked chat invite link was deleted

    Parameters:
        invite_link (:class:`"types.ChatInviteLink"`):
            The invite link

    """

    def __init__(self, invite_link: ChatInviteLink = None) -> None:
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""The invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventInviteLinkDeleted"]:
        return "chatEventInviteLinkDeleted"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invite_link": self.invite_link}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventInviteLinkDeleted", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", None)

        return data_class


class ChatEventVideoChatCreated(TlObject, ChatEventAction):
    r"""A video chat was created

    Parameters:
        group_call_id (:class:`int`):
            Identifier of the video chat\. The video chat can be received through the method getGroupCall

    """

    def __init__(self, group_call_id: int = 0) -> None:
        self.group_call_id: int = int(group_call_id)
        r"""Identifier of the video chat\. The video chat can be received through the method getGroupCall"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventVideoChatCreated"]:
        return "chatEventVideoChatCreated"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "group_call_id": self.group_call_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventVideoChatCreated", None]:
        if data:
            data_class = cls()
            data_class.group_call_id = int(data.get("group_call_id", 0))

        return data_class


class ChatEventVideoChatEnded(TlObject, ChatEventAction):
    r"""A video chat was ended

    Parameters:
        group_call_id (:class:`int`):
            Identifier of the video chat\. The video chat can be received through the method getGroupCall

    """

    def __init__(self, group_call_id: int = 0) -> None:
        self.group_call_id: int = int(group_call_id)
        r"""Identifier of the video chat\. The video chat can be received through the method getGroupCall"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventVideoChatEnded"]:
        return "chatEventVideoChatEnded"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "group_call_id": self.group_call_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventVideoChatEnded", None]:
        if data:
            data_class = cls()
            data_class.group_call_id = int(data.get("group_call_id", 0))

        return data_class


class ChatEventVideoChatMuteNewParticipantsToggled(TlObject, ChatEventAction):
    r"""The mute\_new\_participants setting of a video chat was toggled

    Parameters:
        mute_new_participants (:class:`bool`):
            New value of the mute\_new\_participants setting

    """

    def __init__(self, mute_new_participants: bool = False) -> None:
        self.mute_new_participants: bool = bool(mute_new_participants)
        r"""New value of the mute\_new\_participants setting"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventVideoChatMuteNewParticipantsToggled"]:
        return "chatEventVideoChatMuteNewParticipantsToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "mute_new_participants": self.mute_new_participants,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventVideoChatMuteNewParticipantsToggled", None]:
        if data:
            data_class = cls()
            data_class.mute_new_participants = data.get("mute_new_participants", False)

        return data_class


class ChatEventVideoChatParticipantIsMutedToggled(TlObject, ChatEventAction):
    r"""A video chat participant was muted or unmuted

    Parameters:
        participant_id (:class:`"types.MessageSender"`):
            Identifier of the affected group call participant

        is_muted (:class:`bool`):
            New value of is\_muted

    """

    def __init__(
        self, participant_id: MessageSender = None, is_muted: bool = False
    ) -> None:
        self.participant_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            participant_id
        )
        r"""Identifier of the affected group call participant"""
        self.is_muted: bool = bool(is_muted)
        r"""New value of is\_muted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventVideoChatParticipantIsMutedToggled"]:
        return "chatEventVideoChatParticipantIsMutedToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "participant_id": self.participant_id,
            "is_muted": self.is_muted,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventVideoChatParticipantIsMutedToggled", None]:
        if data:
            data_class = cls()
            data_class.participant_id = data.get("participant_id", None)
            data_class.is_muted = data.get("is_muted", False)

        return data_class


class ChatEventVideoChatParticipantVolumeLevelChanged(TlObject, ChatEventAction):
    r"""A video chat participant volume level was changed

    Parameters:
        participant_id (:class:`"types.MessageSender"`):
            Identifier of the affected group call participant

        volume_level (:class:`int`):
            New value of volume\_level; 1\-20000 in hundreds of percents

    """

    def __init__(
        self, participant_id: MessageSender = None, volume_level: int = 0
    ) -> None:
        self.participant_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            participant_id
        )
        r"""Identifier of the affected group call participant"""
        self.volume_level: int = int(volume_level)
        r"""New value of volume\_level; 1\-20000 in hundreds of percents"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventVideoChatParticipantVolumeLevelChanged"]:
        return "chatEventVideoChatParticipantVolumeLevelChanged"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "participant_id": self.participant_id,
            "volume_level": self.volume_level,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatEventVideoChatParticipantVolumeLevelChanged", None]:
        if data:
            data_class = cls()
            data_class.participant_id = data.get("participant_id", None)
            data_class.volume_level = int(data.get("volume_level", 0))

        return data_class


class ChatEventIsForumToggled(TlObject, ChatEventAction):
    r"""The is\_forum setting of a channel was toggled

    Parameters:
        is_forum (:class:`bool`):
            New value of is\_forum

    """

    def __init__(self, is_forum: bool = False) -> None:
        self.is_forum: bool = bool(is_forum)
        r"""New value of is\_forum"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventIsForumToggled"]:
        return "chatEventIsForumToggled"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_forum": self.is_forum}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventIsForumToggled", None]:
        if data:
            data_class = cls()
            data_class.is_forum = data.get("is_forum", False)

        return data_class


class ChatEventForumTopicCreated(TlObject, ChatEventAction):
    r"""A new forum topic was created

    Parameters:
        topic_info (:class:`"types.ForumTopicInfo"`):
            Information about the topic

    """

    def __init__(self, topic_info: ForumTopicInfo = None) -> None:
        self.topic_info: Union[ForumTopicInfo, None] = topic_info
        r"""Information about the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventForumTopicCreated"]:
        return "chatEventForumTopicCreated"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "topic_info": self.topic_info}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventForumTopicCreated", None]:
        if data:
            data_class = cls()
            data_class.topic_info = data.get("topic_info", None)

        return data_class


class ChatEventForumTopicEdited(TlObject, ChatEventAction):
    r"""A forum topic was edited

    Parameters:
        old_topic_info (:class:`"types.ForumTopicInfo"`):
            Old information about the topic

        new_topic_info (:class:`"types.ForumTopicInfo"`):
            New information about the topic

    """

    def __init__(
        self,
        old_topic_info: ForumTopicInfo = None,
        new_topic_info: ForumTopicInfo = None,
    ) -> None:
        self.old_topic_info: Union[ForumTopicInfo, None] = old_topic_info
        r"""Old information about the topic"""
        self.new_topic_info: Union[ForumTopicInfo, None] = new_topic_info
        r"""New information about the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventForumTopicEdited"]:
        return "chatEventForumTopicEdited"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_topic_info": self.old_topic_info,
            "new_topic_info": self.new_topic_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventForumTopicEdited", None]:
        if data:
            data_class = cls()
            data_class.old_topic_info = data.get("old_topic_info", None)
            data_class.new_topic_info = data.get("new_topic_info", None)

        return data_class


class ChatEventForumTopicToggleIsClosed(TlObject, ChatEventAction):
    r"""A forum topic was closed or reopened

    Parameters:
        topic_info (:class:`"types.ForumTopicInfo"`):
            New information about the topic

    """

    def __init__(self, topic_info: ForumTopicInfo = None) -> None:
        self.topic_info: Union[ForumTopicInfo, None] = topic_info
        r"""New information about the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventForumTopicToggleIsClosed"]:
        return "chatEventForumTopicToggleIsClosed"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "topic_info": self.topic_info}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventForumTopicToggleIsClosed", None]:
        if data:
            data_class = cls()
            data_class.topic_info = data.get("topic_info", None)

        return data_class


class ChatEventForumTopicToggleIsHidden(TlObject, ChatEventAction):
    r"""The General forum topic was hidden or unhidden

    Parameters:
        topic_info (:class:`"types.ForumTopicInfo"`):
            New information about the topic

    """

    def __init__(self, topic_info: ForumTopicInfo = None) -> None:
        self.topic_info: Union[ForumTopicInfo, None] = topic_info
        r"""New information about the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventForumTopicToggleIsHidden"]:
        return "chatEventForumTopicToggleIsHidden"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "topic_info": self.topic_info}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventForumTopicToggleIsHidden", None]:
        if data:
            data_class = cls()
            data_class.topic_info = data.get("topic_info", None)

        return data_class


class ChatEventForumTopicDeleted(TlObject, ChatEventAction):
    r"""A forum topic was deleted

    Parameters:
        topic_info (:class:`"types.ForumTopicInfo"`):
            Information about the topic

    """

    def __init__(self, topic_info: ForumTopicInfo = None) -> None:
        self.topic_info: Union[ForumTopicInfo, None] = topic_info
        r"""Information about the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventForumTopicDeleted"]:
        return "chatEventForumTopicDeleted"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "topic_info": self.topic_info}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventForumTopicDeleted", None]:
        if data:
            data_class = cls()
            data_class.topic_info = data.get("topic_info", None)

        return data_class


class ChatEventForumTopicPinned(TlObject, ChatEventAction):
    r"""A pinned forum topic was changed

    Parameters:
        old_topic_info (:class:`"types.ForumTopicInfo"`):
            Information about the old pinned topic; may be null

        new_topic_info (:class:`"types.ForumTopicInfo"`):
            Information about the new pinned topic; may be null

    """

    def __init__(
        self,
        old_topic_info: ForumTopicInfo = None,
        new_topic_info: ForumTopicInfo = None,
    ) -> None:
        self.old_topic_info: Union[ForumTopicInfo, None] = old_topic_info
        r"""Information about the old pinned topic; may be null"""
        self.new_topic_info: Union[ForumTopicInfo, None] = new_topic_info
        r"""Information about the new pinned topic; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventForumTopicPinned"]:
        return "chatEventForumTopicPinned"

    def getClass(self) -> Literal["ChatEventAction"]:
        return "ChatEventAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "old_topic_info": self.old_topic_info,
            "new_topic_info": self.new_topic_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventForumTopicPinned", None]:
        if data:
            data_class = cls()
            data_class.old_topic_info = data.get("old_topic_info", None)
            data_class.new_topic_info = data.get("new_topic_info", None)

        return data_class


class ChatEvent(TlObject):
    r"""Represents a chat event

    Parameters:
        id (:class:`int`):
            Chat event identifier

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the event happened

        member_id (:class:`"types.MessageSender"`):
            Identifier of the user or chat who performed the action

        action (:class:`"types.ChatEventAction"`):
            The action

    """

    def __init__(
        self,
        id: int = 0,
        date: int = 0,
        member_id: MessageSender = None,
        action: ChatEventAction = None,
    ) -> None:
        self.id: int = int(id)
        r"""Chat event identifier"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the event happened"""
        self.member_id: Union[MessageSenderUser, MessageSenderChat, None] = member_id
        r"""Identifier of the user or chat who performed the action"""
        self.action: Union[
            ChatEventMessageEdited,
            ChatEventMessageDeleted,
            ChatEventMessagePinned,
            ChatEventMessageUnpinned,
            ChatEventPollStopped,
            ChatEventMemberJoined,
            ChatEventMemberJoinedByInviteLink,
            ChatEventMemberJoinedByRequest,
            ChatEventMemberInvited,
            ChatEventMemberLeft,
            ChatEventMemberPromoted,
            ChatEventMemberRestricted,
            ChatEventMemberSubscriptionExtended,
            ChatEventAvailableReactionsChanged,
            ChatEventBackgroundChanged,
            ChatEventDescriptionChanged,
            ChatEventEmojiStatusChanged,
            ChatEventLinkedChatChanged,
            ChatEventLocationChanged,
            ChatEventMessageAutoDeleteTimeChanged,
            ChatEventPermissionsChanged,
            ChatEventPhotoChanged,
            ChatEventSlowModeDelayChanged,
            ChatEventStickerSetChanged,
            ChatEventCustomEmojiStickerSetChanged,
            ChatEventTitleChanged,
            ChatEventUsernameChanged,
            ChatEventActiveUsernamesChanged,
            ChatEventAccentColorChanged,
            ChatEventProfileAccentColorChanged,
            ChatEventHasProtectedContentToggled,
            ChatEventInvitesToggled,
            ChatEventIsAllHistoryAvailableToggled,
            ChatEventHasAggressiveAntiSpamEnabledToggled,
            ChatEventSignMessagesToggled,
            ChatEventShowMessageSenderToggled,
            ChatEventInviteLinkEdited,
            ChatEventInviteLinkRevoked,
            ChatEventInviteLinkDeleted,
            ChatEventVideoChatCreated,
            ChatEventVideoChatEnded,
            ChatEventVideoChatMuteNewParticipantsToggled,
            ChatEventVideoChatParticipantIsMutedToggled,
            ChatEventVideoChatParticipantVolumeLevelChanged,
            ChatEventIsForumToggled,
            ChatEventForumTopicCreated,
            ChatEventForumTopicEdited,
            ChatEventForumTopicToggleIsClosed,
            ChatEventForumTopicToggleIsHidden,
            ChatEventForumTopicDeleted,
            ChatEventForumTopicPinned,
            None,
        ] = action
        r"""The action"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEvent"]:
        return "chatEvent"

    def getClass(self) -> Literal["ChatEvent"]:
        return "ChatEvent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "date": self.date,
            "member_id": self.member_id,
            "action": self.action,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEvent", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.member_id = data.get("member_id", None)
            data_class.action = data.get("action", None)

        return data_class


class ChatEvents(TlObject):
    r"""Contains a list of chat events

    Parameters:
        events (:class:`List["types.ChatEvent"]`):
            List of events

    """

    def __init__(self, events: List[ChatEvent] = None) -> None:
        self.events: List[ChatEvent] = events or []
        r"""List of events"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEvents"]:
        return "chatEvents"

    def getClass(self) -> Literal["ChatEvents"]:
        return "ChatEvents"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "events": self.events}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEvents", None]:
        if data:
            data_class = cls()
            data_class.events = data.get("events", None)

        return data_class


class ChatEventLogFilters(TlObject):
    r"""Represents a set of filters used to obtain a chat event log

    Parameters:
        message_edits (:class:`bool`):
            True, if message edits need to be returned

        message_deletions (:class:`bool`):
            True, if message deletions need to be returned

        message_pins (:class:`bool`):
            True, if pin/unpin events need to be returned

        member_joins (:class:`bool`):
            True, if members joining events need to be returned

        member_leaves (:class:`bool`):
            True, if members leaving events need to be returned

        member_invites (:class:`bool`):
            True, if invited member events need to be returned

        member_promotions (:class:`bool`):
            True, if member promotion/demotion events need to be returned

        member_restrictions (:class:`bool`):
            True, if member restricted/unrestricted/banned/unbanned events need to be returned

        info_changes (:class:`bool`):
            True, if changes in chat information need to be returned

        setting_changes (:class:`bool`):
            True, if changes in chat settings need to be returned

        invite_link_changes (:class:`bool`):
            True, if changes to invite links need to be returned

        video_chat_changes (:class:`bool`):
            True, if video chat actions need to be returned

        forum_changes (:class:`bool`):
            True, if forum\-related actions need to be returned

        subscription_extensions (:class:`bool`):
            True, if subscription extensions need to be returned

    """

    def __init__(
        self,
        message_edits: bool = False,
        message_deletions: bool = False,
        message_pins: bool = False,
        member_joins: bool = False,
        member_leaves: bool = False,
        member_invites: bool = False,
        member_promotions: bool = False,
        member_restrictions: bool = False,
        info_changes: bool = False,
        setting_changes: bool = False,
        invite_link_changes: bool = False,
        video_chat_changes: bool = False,
        forum_changes: bool = False,
        subscription_extensions: bool = False,
    ) -> None:
        self.message_edits: bool = bool(message_edits)
        r"""True, if message edits need to be returned"""
        self.message_deletions: bool = bool(message_deletions)
        r"""True, if message deletions need to be returned"""
        self.message_pins: bool = bool(message_pins)
        r"""True, if pin/unpin events need to be returned"""
        self.member_joins: bool = bool(member_joins)
        r"""True, if members joining events need to be returned"""
        self.member_leaves: bool = bool(member_leaves)
        r"""True, if members leaving events need to be returned"""
        self.member_invites: bool = bool(member_invites)
        r"""True, if invited member events need to be returned"""
        self.member_promotions: bool = bool(member_promotions)
        r"""True, if member promotion/demotion events need to be returned"""
        self.member_restrictions: bool = bool(member_restrictions)
        r"""True, if member restricted/unrestricted/banned/unbanned events need to be returned"""
        self.info_changes: bool = bool(info_changes)
        r"""True, if changes in chat information need to be returned"""
        self.setting_changes: bool = bool(setting_changes)
        r"""True, if changes in chat settings need to be returned"""
        self.invite_link_changes: bool = bool(invite_link_changes)
        r"""True, if changes to invite links need to be returned"""
        self.video_chat_changes: bool = bool(video_chat_changes)
        r"""True, if video chat actions need to be returned"""
        self.forum_changes: bool = bool(forum_changes)
        r"""True, if forum\-related actions need to be returned"""
        self.subscription_extensions: bool = bool(subscription_extensions)
        r"""True, if subscription extensions need to be returned"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatEventLogFilters"]:
        return "chatEventLogFilters"

    def getClass(self) -> Literal["ChatEventLogFilters"]:
        return "ChatEventLogFilters"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_edits": self.message_edits,
            "message_deletions": self.message_deletions,
            "message_pins": self.message_pins,
            "member_joins": self.member_joins,
            "member_leaves": self.member_leaves,
            "member_invites": self.member_invites,
            "member_promotions": self.member_promotions,
            "member_restrictions": self.member_restrictions,
            "info_changes": self.info_changes,
            "setting_changes": self.setting_changes,
            "invite_link_changes": self.invite_link_changes,
            "video_chat_changes": self.video_chat_changes,
            "forum_changes": self.forum_changes,
            "subscription_extensions": self.subscription_extensions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatEventLogFilters", None]:
        if data:
            data_class = cls()
            data_class.message_edits = data.get("message_edits", False)
            data_class.message_deletions = data.get("message_deletions", False)
            data_class.message_pins = data.get("message_pins", False)
            data_class.member_joins = data.get("member_joins", False)
            data_class.member_leaves = data.get("member_leaves", False)
            data_class.member_invites = data.get("member_invites", False)
            data_class.member_promotions = data.get("member_promotions", False)
            data_class.member_restrictions = data.get("member_restrictions", False)
            data_class.info_changes = data.get("info_changes", False)
            data_class.setting_changes = data.get("setting_changes", False)
            data_class.invite_link_changes = data.get("invite_link_changes", False)
            data_class.video_chat_changes = data.get("video_chat_changes", False)
            data_class.forum_changes = data.get("forum_changes", False)
            data_class.subscription_extensions = data.get(
                "subscription_extensions", False
            )

        return data_class


class LanguagePackStringValueOrdinary(TlObject, LanguagePackStringValue):
    r"""An ordinary language pack string

    Parameters:
        value (:class:`str`):
            String value

    """

    def __init__(self, value: str = "") -> None:
        self.value: Union[str, None] = value
        r"""String value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["languagePackStringValueOrdinary"]:
        return "languagePackStringValueOrdinary"

    def getClass(self) -> Literal["LanguagePackStringValue"]:
        return "LanguagePackStringValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LanguagePackStringValueOrdinary", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", "")

        return data_class


class LanguagePackStringValuePluralized(TlObject, LanguagePackStringValue):
    r"""A language pack string which has different forms based on the number of some object it mentions\. See https://www\.unicode\.org/cldr/charts/latest/supplemental/language\_plural\_rules\.html for more information

    Parameters:
        zero_value (:class:`str`):
            Value for zero objects

        one_value (:class:`str`):
            Value for one object

        two_value (:class:`str`):
            Value for two objects

        few_value (:class:`str`):
            Value for few objects

        many_value (:class:`str`):
            Value for many objects

        other_value (:class:`str`):
            Default value

    """

    def __init__(
        self,
        zero_value: str = "",
        one_value: str = "",
        two_value: str = "",
        few_value: str = "",
        many_value: str = "",
        other_value: str = "",
    ) -> None:
        self.zero_value: Union[str, None] = zero_value
        r"""Value for zero objects"""
        self.one_value: Union[str, None] = one_value
        r"""Value for one object"""
        self.two_value: Union[str, None] = two_value
        r"""Value for two objects"""
        self.few_value: Union[str, None] = few_value
        r"""Value for few objects"""
        self.many_value: Union[str, None] = many_value
        r"""Value for many objects"""
        self.other_value: Union[str, None] = other_value
        r"""Default value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["languagePackStringValuePluralized"]:
        return "languagePackStringValuePluralized"

    def getClass(self) -> Literal["LanguagePackStringValue"]:
        return "LanguagePackStringValue"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "zero_value": self.zero_value,
            "one_value": self.one_value,
            "two_value": self.two_value,
            "few_value": self.few_value,
            "many_value": self.many_value,
            "other_value": self.other_value,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LanguagePackStringValuePluralized", None]:
        if data:
            data_class = cls()
            data_class.zero_value = data.get("zero_value", "")
            data_class.one_value = data.get("one_value", "")
            data_class.two_value = data.get("two_value", "")
            data_class.few_value = data.get("few_value", "")
            data_class.many_value = data.get("many_value", "")
            data_class.other_value = data.get("other_value", "")

        return data_class


class LanguagePackStringValueDeleted(TlObject, LanguagePackStringValue):
    r"""A deleted language pack string, the value must be taken from the built\-in English language pack"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["languagePackStringValueDeleted"]:
        return "languagePackStringValueDeleted"

    def getClass(self) -> Literal["LanguagePackStringValue"]:
        return "LanguagePackStringValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LanguagePackStringValueDeleted", None]:
        if data:
            data_class = cls()

        return data_class


class LanguagePackString(TlObject):
    r"""Represents one language pack string

    Parameters:
        key (:class:`str`):
            String key

        value (:class:`"types.LanguagePackStringValue"`):
            String value; pass null if the string needs to be taken from the built\-in English language pack

    """

    def __init__(self, key: str = "", value: LanguagePackStringValue = None) -> None:
        self.key: Union[str, None] = key
        r"""String key"""
        self.value: Union[
            LanguagePackStringValueOrdinary,
            LanguagePackStringValuePluralized,
            LanguagePackStringValueDeleted,
            None,
        ] = value
        r"""String value; pass null if the string needs to be taken from the built\-in English language pack"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["languagePackString"]:
        return "languagePackString"

    def getClass(self) -> Literal["LanguagePackString"]:
        return "LanguagePackString"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "key": self.key, "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LanguagePackString", None]:
        if data:
            data_class = cls()
            data_class.key = data.get("key", "")
            data_class.value = data.get("value", None)

        return data_class


class LanguagePackStrings(TlObject):
    r"""Contains a list of language pack strings

    Parameters:
        strings (:class:`List["types.LanguagePackString"]`):
            A list of language pack strings

    """

    def __init__(self, strings: List[LanguagePackString] = None) -> None:
        self.strings: List[LanguagePackString] = strings or []
        r"""A list of language pack strings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["languagePackStrings"]:
        return "languagePackStrings"

    def getClass(self) -> Literal["LanguagePackStrings"]:
        return "LanguagePackStrings"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "strings": self.strings}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LanguagePackStrings", None]:
        if data:
            data_class = cls()
            data_class.strings = data.get("strings", None)

        return data_class


class LanguagePackInfo(TlObject):
    r"""Contains information about a language pack

    Parameters:
        id (:class:`str`):
            Unique language pack identifier

        base_language_pack_id (:class:`str`):
            Identifier of a base language pack; may be empty\. If a string is missed in the language pack, then it must be fetched from base language pack\. Unsupported in custom language packs

        name (:class:`str`):
            Language name

        native_name (:class:`str`):
            Name of the language in that language

        plural_code (:class:`str`):
            A language code to be used to apply plural forms\. See https://www\.unicode\.org/cldr/charts/latest/supplemental/language\_plural\_rules\.html for more information

        is_official (:class:`bool`):
            True, if the language pack is official

        is_rtl (:class:`bool`):
            True, if the language pack strings are RTL

        is_beta (:class:`bool`):
            True, if the language pack is a beta language pack

        is_installed (:class:`bool`):
            True, if the language pack is installed by the current user

        total_string_count (:class:`int`):
            Total number of non\-deleted strings from the language pack

        translated_string_count (:class:`int`):
            Total number of translated strings from the language pack

        local_string_count (:class:`int`):
            Total number of non\-deleted strings from the language pack available locally

        translation_url (:class:`str`):
            Link to language translation interface; empty for custom local language packs

    """

    def __init__(
        self,
        id: str = "",
        base_language_pack_id: str = "",
        name: str = "",
        native_name: str = "",
        plural_code: str = "",
        is_official: bool = False,
        is_rtl: bool = False,
        is_beta: bool = False,
        is_installed: bool = False,
        total_string_count: int = 0,
        translated_string_count: int = 0,
        local_string_count: int = 0,
        translation_url: str = "",
    ) -> None:
        self.id: Union[str, None] = id
        r"""Unique language pack identifier"""
        self.base_language_pack_id: Union[str, None] = base_language_pack_id
        r"""Identifier of a base language pack; may be empty\. If a string is missed in the language pack, then it must be fetched from base language pack\. Unsupported in custom language packs"""
        self.name: Union[str, None] = name
        r"""Language name"""
        self.native_name: Union[str, None] = native_name
        r"""Name of the language in that language"""
        self.plural_code: Union[str, None] = plural_code
        r"""A language code to be used to apply plural forms\. See https://www\.unicode\.org/cldr/charts/latest/supplemental/language\_plural\_rules\.html for more information"""
        self.is_official: bool = bool(is_official)
        r"""True, if the language pack is official"""
        self.is_rtl: bool = bool(is_rtl)
        r"""True, if the language pack strings are RTL"""
        self.is_beta: bool = bool(is_beta)
        r"""True, if the language pack is a beta language pack"""
        self.is_installed: bool = bool(is_installed)
        r"""True, if the language pack is installed by the current user"""
        self.total_string_count: int = int(total_string_count)
        r"""Total number of non\-deleted strings from the language pack"""
        self.translated_string_count: int = int(translated_string_count)
        r"""Total number of translated strings from the language pack"""
        self.local_string_count: int = int(local_string_count)
        r"""Total number of non\-deleted strings from the language pack available locally"""
        self.translation_url: Union[str, None] = translation_url
        r"""Link to language translation interface; empty for custom local language packs"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["languagePackInfo"]:
        return "languagePackInfo"

    def getClass(self) -> Literal["LanguagePackInfo"]:
        return "LanguagePackInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "base_language_pack_id": self.base_language_pack_id,
            "name": self.name,
            "native_name": self.native_name,
            "plural_code": self.plural_code,
            "is_official": self.is_official,
            "is_rtl": self.is_rtl,
            "is_beta": self.is_beta,
            "is_installed": self.is_installed,
            "total_string_count": self.total_string_count,
            "translated_string_count": self.translated_string_count,
            "local_string_count": self.local_string_count,
            "translation_url": self.translation_url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LanguagePackInfo", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.base_language_pack_id = data.get("base_language_pack_id", "")
            data_class.name = data.get("name", "")
            data_class.native_name = data.get("native_name", "")
            data_class.plural_code = data.get("plural_code", "")
            data_class.is_official = data.get("is_official", False)
            data_class.is_rtl = data.get("is_rtl", False)
            data_class.is_beta = data.get("is_beta", False)
            data_class.is_installed = data.get("is_installed", False)
            data_class.total_string_count = int(data.get("total_string_count", 0))
            data_class.translated_string_count = int(
                data.get("translated_string_count", 0)
            )
            data_class.local_string_count = int(data.get("local_string_count", 0))
            data_class.translation_url = data.get("translation_url", "")

        return data_class


class LocalizationTargetInfo(TlObject):
    r"""Contains information about the current localization target

    Parameters:
        language_packs (:class:`List["types.LanguagePackInfo"]`):
            List of available language packs for this application

    """

    def __init__(self, language_packs: List[LanguagePackInfo] = None) -> None:
        self.language_packs: List[LanguagePackInfo] = language_packs or []
        r"""List of available language packs for this application"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["localizationTargetInfo"]:
        return "localizationTargetInfo"

    def getClass(self) -> Literal["LocalizationTargetInfo"]:
        return "LocalizationTargetInfo"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "language_packs": self.language_packs}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LocalizationTargetInfo", None]:
        if data:
            data_class = cls()
            data_class.language_packs = data.get("language_packs", None)

        return data_class


class PremiumLimitTypeSupergroupCount(TlObject, PremiumLimitType):
    r"""The maximum number of joined supergroups and channels"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeSupergroupCount"]:
        return "premiumLimitTypeSupergroupCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypeSupergroupCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypePinnedChatCount(TlObject, PremiumLimitType):
    r"""The maximum number of pinned chats in the main chat list"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypePinnedChatCount"]:
        return "premiumLimitTypePinnedChatCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypePinnedChatCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeCreatedPublicChatCount(TlObject, PremiumLimitType):
    r"""The maximum number of created public chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeCreatedPublicChatCount"]:
        return "premiumLimitTypeCreatedPublicChatCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeCreatedPublicChatCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeSavedAnimationCount(TlObject, PremiumLimitType):
    r"""The maximum number of saved animations"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeSavedAnimationCount"]:
        return "premiumLimitTypeSavedAnimationCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeSavedAnimationCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeFavoriteStickerCount(TlObject, PremiumLimitType):
    r"""The maximum number of favorite stickers"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeFavoriteStickerCount"]:
        return "premiumLimitTypeFavoriteStickerCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeFavoriteStickerCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeChatFolderCount(TlObject, PremiumLimitType):
    r"""The maximum number of chat folders"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeChatFolderCount"]:
        return "premiumLimitTypeChatFolderCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypeChatFolderCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeChatFolderChosenChatCount(TlObject, PremiumLimitType):
    r"""The maximum number of pinned and always included, or always excluded chats in a chat folder"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeChatFolderChosenChatCount"]:
        return "premiumLimitTypeChatFolderChosenChatCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeChatFolderChosenChatCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypePinnedArchivedChatCount(TlObject, PremiumLimitType):
    r"""The maximum number of pinned chats in the archive chat list"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypePinnedArchivedChatCount"]:
        return "premiumLimitTypePinnedArchivedChatCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypePinnedArchivedChatCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypePinnedSavedMessagesTopicCount(TlObject, PremiumLimitType):
    r"""The maximum number of pinned Saved Messages topics"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypePinnedSavedMessagesTopicCount"]:
        return "premiumLimitTypePinnedSavedMessagesTopicCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypePinnedSavedMessagesTopicCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeCaptionLength(TlObject, PremiumLimitType):
    r"""The maximum length of sent media caption"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeCaptionLength"]:
        return "premiumLimitTypeCaptionLength"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypeCaptionLength", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeBioLength(TlObject, PremiumLimitType):
    r"""The maximum length of the user's bio"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeBioLength"]:
        return "premiumLimitTypeBioLength"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypeBioLength", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeChatFolderInviteLinkCount(TlObject, PremiumLimitType):
    r"""The maximum number of invite links for a chat folder"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeChatFolderInviteLinkCount"]:
        return "premiumLimitTypeChatFolderInviteLinkCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeChatFolderInviteLinkCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeShareableChatFolderCount(TlObject, PremiumLimitType):
    r"""The maximum number of added shareable chat folders"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeShareableChatFolderCount"]:
        return "premiumLimitTypeShareableChatFolderCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeShareableChatFolderCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeActiveStoryCount(TlObject, PremiumLimitType):
    r"""The maximum number of active stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeActiveStoryCount"]:
        return "premiumLimitTypeActiveStoryCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypeActiveStoryCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeWeeklySentStoryCount(TlObject, PremiumLimitType):
    r"""The maximum number of stories sent per week"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeWeeklySentStoryCount"]:
        return "premiumLimitTypeWeeklySentStoryCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeWeeklySentStoryCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeMonthlySentStoryCount(TlObject, PremiumLimitType):
    r"""The maximum number of stories sent per month"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeMonthlySentStoryCount"]:
        return "premiumLimitTypeMonthlySentStoryCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeMonthlySentStoryCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeStoryCaptionLength(TlObject, PremiumLimitType):
    r"""The maximum length of captions of sent stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeStoryCaptionLength"]:
        return "premiumLimitTypeStoryCaptionLength"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypeStoryCaptionLength", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeStorySuggestedReactionAreaCount(TlObject, PremiumLimitType):
    r"""The maximum number of suggested reaction areas on a story"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeStorySuggestedReactionAreaCount"]:
        return "premiumLimitTypeStorySuggestedReactionAreaCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumLimitTypeStorySuggestedReactionAreaCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimitTypeSimilarChatCount(TlObject, PremiumLimitType):
    r"""The maximum number of received similar chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimitTypeSimilarChatCount"]:
        return "premiumLimitTypeSimilarChatCount"

    def getClass(self) -> Literal["PremiumLimitType"]:
        return "PremiumLimitType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimitTypeSimilarChatCount", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureIncreasedLimits(TlObject, PremiumFeature):
    r"""Increased limits"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureIncreasedLimits"]:
        return "premiumFeatureIncreasedLimits"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureIncreasedLimits", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureIncreasedUploadFileSize(TlObject, PremiumFeature):
    r"""Increased maximum upload file size"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureIncreasedUploadFileSize"]:
        return "premiumFeatureIncreasedUploadFileSize"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumFeatureIncreasedUploadFileSize", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureImprovedDownloadSpeed(TlObject, PremiumFeature):
    r"""Improved download speed"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureImprovedDownloadSpeed"]:
        return "premiumFeatureImprovedDownloadSpeed"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumFeatureImprovedDownloadSpeed", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureVoiceRecognition(TlObject, PremiumFeature):
    r"""The ability to convert voice notes to text"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureVoiceRecognition"]:
        return "premiumFeatureVoiceRecognition"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureVoiceRecognition", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureDisabledAds(TlObject, PremiumFeature):
    r"""Disabled ads"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureDisabledAds"]:
        return "premiumFeatureDisabledAds"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureDisabledAds", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureUniqueReactions(TlObject, PremiumFeature):
    r"""Allowed to use more reactions"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureUniqueReactions"]:
        return "premiumFeatureUniqueReactions"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureUniqueReactions", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureUniqueStickers(TlObject, PremiumFeature):
    r"""Allowed to use premium stickers with unique effects"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureUniqueStickers"]:
        return "premiumFeatureUniqueStickers"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureUniqueStickers", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureCustomEmoji(TlObject, PremiumFeature):
    r"""Allowed to use custom emoji stickers in message texts and captions"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureCustomEmoji"]:
        return "premiumFeatureCustomEmoji"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureCustomEmoji", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureAdvancedChatManagement(TlObject, PremiumFeature):
    r"""Ability to change position of the main chat list, archive and mute all new chats from non\-contacts, and completely disable notifications about the user's contacts joined Telegram"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureAdvancedChatManagement"]:
        return "premiumFeatureAdvancedChatManagement"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumFeatureAdvancedChatManagement", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureProfileBadge(TlObject, PremiumFeature):
    r"""A badge in the user's profile"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureProfileBadge"]:
        return "premiumFeatureProfileBadge"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureProfileBadge", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureEmojiStatus(TlObject, PremiumFeature):
    r"""The ability to show an emoji status along with the user's name"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureEmojiStatus"]:
        return "premiumFeatureEmojiStatus"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureEmojiStatus", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureAnimatedProfilePhoto(TlObject, PremiumFeature):
    r"""Profile photo animation on message and chat screens"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureAnimatedProfilePhoto"]:
        return "premiumFeatureAnimatedProfilePhoto"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureAnimatedProfilePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureForumTopicIcon(TlObject, PremiumFeature):
    r"""The ability to set a custom emoji as a forum topic icon"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureForumTopicIcon"]:
        return "premiumFeatureForumTopicIcon"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureForumTopicIcon", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureAppIcons(TlObject, PremiumFeature):
    r"""Allowed to set a premium application icons"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureAppIcons"]:
        return "premiumFeatureAppIcons"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureAppIcons", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureRealTimeChatTranslation(TlObject, PremiumFeature):
    r"""Allowed to translate chat messages real\-time"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureRealTimeChatTranslation"]:
        return "premiumFeatureRealTimeChatTranslation"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumFeatureRealTimeChatTranslation", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureUpgradedStories(TlObject, PremiumFeature):
    r"""Allowed to use many additional features for stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureUpgradedStories"]:
        return "premiumFeatureUpgradedStories"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureUpgradedStories", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureChatBoost(TlObject, PremiumFeature):
    r"""The ability to boost chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureChatBoost"]:
        return "premiumFeatureChatBoost"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureChatBoost", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureAccentColor(TlObject, PremiumFeature):
    r"""The ability to choose accent color for replies and user profile"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureAccentColor"]:
        return "premiumFeatureAccentColor"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureAccentColor", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureBackgroundForBoth(TlObject, PremiumFeature):
    r"""The ability to set private chat background for both users"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureBackgroundForBoth"]:
        return "premiumFeatureBackgroundForBoth"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureBackgroundForBoth", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureSavedMessagesTags(TlObject, PremiumFeature):
    r"""The ability to use tags in Saved Messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureSavedMessagesTags"]:
        return "premiumFeatureSavedMessagesTags"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureSavedMessagesTags", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureMessagePrivacy(TlObject, PremiumFeature):
    r"""The ability to disallow incoming voice and video note messages in private chats using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages and to restrict incoming messages from non\-contacts using setNewChatPrivacySettings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureMessagePrivacy"]:
        return "premiumFeatureMessagePrivacy"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureMessagePrivacy", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureLastSeenTimes(TlObject, PremiumFeature):
    r"""The ability to view last seen and read times of other users even they can't view last seen or read time for the current user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureLastSeenTimes"]:
        return "premiumFeatureLastSeenTimes"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureLastSeenTimes", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureBusiness(TlObject, PremiumFeature):
    r"""The ability to use Business features"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureBusiness"]:
        return "premiumFeatureBusiness"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureBusiness", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeatureMessageEffects(TlObject, PremiumFeature):
    r"""The ability to use all available message effects"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatureMessageEffects"]:
        return "premiumFeatureMessageEffects"

    def getClass(self) -> Literal["PremiumFeature"]:
        return "PremiumFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatureMessageEffects", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureLocation(TlObject, BusinessFeature):
    r"""The ability to set location"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureLocation"]:
        return "businessFeatureLocation"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureLocation", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureOpeningHours(TlObject, BusinessFeature):
    r"""The ability to set opening hours"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureOpeningHours"]:
        return "businessFeatureOpeningHours"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureOpeningHours", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureQuickReplies(TlObject, BusinessFeature):
    r"""The ability to use quick replies"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureQuickReplies"]:
        return "businessFeatureQuickReplies"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureQuickReplies", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureGreetingMessage(TlObject, BusinessFeature):
    r"""The ability to set up a greeting message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureGreetingMessage"]:
        return "businessFeatureGreetingMessage"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureGreetingMessage", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureAwayMessage(TlObject, BusinessFeature):
    r"""The ability to set up an away message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureAwayMessage"]:
        return "businessFeatureAwayMessage"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureAwayMessage", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureAccountLinks(TlObject, BusinessFeature):
    r"""The ability to create links to the business account with predefined message text"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureAccountLinks"]:
        return "businessFeatureAccountLinks"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureAccountLinks", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureStartPage(TlObject, BusinessFeature):
    r"""The ability to customize start page"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureStartPage"]:
        return "businessFeatureStartPage"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureStartPage", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureBots(TlObject, BusinessFeature):
    r"""The ability to connect a bot to the account"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureBots"]:
        return "businessFeatureBots"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureBots", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureEmojiStatus(TlObject, BusinessFeature):
    r"""The ability to show an emoji status along with the business name"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureEmojiStatus"]:
        return "businessFeatureEmojiStatus"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureEmojiStatus", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureChatFolderTags(TlObject, BusinessFeature):
    r"""The ability to display folder names for each chat in the chat list"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureChatFolderTags"]:
        return "businessFeatureChatFolderTags"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureChatFolderTags", None]:
        if data:
            data_class = cls()

        return data_class


class BusinessFeatureUpgradedStories(TlObject, BusinessFeature):
    r"""Allowed to use many additional features for stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatureUpgradedStories"]:
        return "businessFeatureUpgradedStories"

    def getClass(self) -> Literal["BusinessFeature"]:
        return "BusinessFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatureUpgradedStories", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumStoryFeaturePriorityOrder(TlObject, PremiumStoryFeature):
    r"""Stories of the current user are displayed before stories of non\-Premium contacts, supergroups, and channels"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStoryFeaturePriorityOrder"]:
        return "premiumStoryFeaturePriorityOrder"

    def getClass(self) -> Literal["PremiumStoryFeature"]:
        return "PremiumStoryFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumStoryFeaturePriorityOrder", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumStoryFeatureStealthMode(TlObject, PremiumStoryFeature):
    r"""The ability to hide the fact that the user viewed other's stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStoryFeatureStealthMode"]:
        return "premiumStoryFeatureStealthMode"

    def getClass(self) -> Literal["PremiumStoryFeature"]:
        return "PremiumStoryFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumStoryFeatureStealthMode", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumStoryFeaturePermanentViewsHistory(TlObject, PremiumStoryFeature):
    r"""The ability to check who opened the current user's stories after they expire"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStoryFeaturePermanentViewsHistory"]:
        return "premiumStoryFeaturePermanentViewsHistory"

    def getClass(self) -> Literal["PremiumStoryFeature"]:
        return "PremiumStoryFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumStoryFeaturePermanentViewsHistory", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumStoryFeatureCustomExpirationDuration(TlObject, PremiumStoryFeature):
    r"""The ability to set custom expiration duration for stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStoryFeatureCustomExpirationDuration"]:
        return "premiumStoryFeatureCustomExpirationDuration"

    def getClass(self) -> Literal["PremiumStoryFeature"]:
        return "PremiumStoryFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumStoryFeatureCustomExpirationDuration", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumStoryFeatureSaveStories(TlObject, PremiumStoryFeature):
    r"""The ability to save other's unprotected stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStoryFeatureSaveStories"]:
        return "premiumStoryFeatureSaveStories"

    def getClass(self) -> Literal["PremiumStoryFeature"]:
        return "PremiumStoryFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumStoryFeatureSaveStories", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumStoryFeatureLinksAndFormatting(TlObject, PremiumStoryFeature):
    r"""The ability to use links and formatting in story caption, and use inputStoryAreaTypeLink areas"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStoryFeatureLinksAndFormatting"]:
        return "premiumStoryFeatureLinksAndFormatting"

    def getClass(self) -> Literal["PremiumStoryFeature"]:
        return "PremiumStoryFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PremiumStoryFeatureLinksAndFormatting", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumStoryFeatureVideoQuality(TlObject, PremiumStoryFeature):
    r"""The ability to choose better quality for viewed stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumStoryFeatureVideoQuality"]:
        return "premiumStoryFeatureVideoQuality"

    def getClass(self) -> Literal["PremiumStoryFeature"]:
        return "PremiumStoryFeature"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumStoryFeatureVideoQuality", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumLimit(TlObject):
    r"""Contains information about a limit, increased for Premium users

    Parameters:
        type (:class:`"types.PremiumLimitType"`):
            The type of the limit

        default_value (:class:`int`):
            Default value of the limit

        premium_value (:class:`int`):
            Value of the limit for Premium users

    """

    def __init__(
        self,
        type: PremiumLimitType = None,
        default_value: int = 0,
        premium_value: int = 0,
    ) -> None:
        self.type: Union[
            PremiumLimitTypeSupergroupCount,
            PremiumLimitTypePinnedChatCount,
            PremiumLimitTypeCreatedPublicChatCount,
            PremiumLimitTypeSavedAnimationCount,
            PremiumLimitTypeFavoriteStickerCount,
            PremiumLimitTypeChatFolderCount,
            PremiumLimitTypeChatFolderChosenChatCount,
            PremiumLimitTypePinnedArchivedChatCount,
            PremiumLimitTypePinnedSavedMessagesTopicCount,
            PremiumLimitTypeCaptionLength,
            PremiumLimitTypeBioLength,
            PremiumLimitTypeChatFolderInviteLinkCount,
            PremiumLimitTypeShareableChatFolderCount,
            PremiumLimitTypeActiveStoryCount,
            PremiumLimitTypeWeeklySentStoryCount,
            PremiumLimitTypeMonthlySentStoryCount,
            PremiumLimitTypeStoryCaptionLength,
            PremiumLimitTypeStorySuggestedReactionAreaCount,
            PremiumLimitTypeSimilarChatCount,
            None,
        ] = type
        r"""The type of the limit"""
        self.default_value: int = int(default_value)
        r"""Default value of the limit"""
        self.premium_value: int = int(premium_value)
        r"""Value of the limit for Premium users"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumLimit"]:
        return "premiumLimit"

    def getClass(self) -> Literal["PremiumLimit"]:
        return "PremiumLimit"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "type": self.type,
            "default_value": self.default_value,
            "premium_value": self.premium_value,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumLimit", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)
            data_class.default_value = int(data.get("default_value", 0))
            data_class.premium_value = int(data.get("premium_value", 0))

        return data_class


class PremiumFeatures(TlObject):
    r"""Contains information about features, available to Premium users

    Parameters:
        features (:class:`List["types.PremiumFeature"]`):
            The list of available features

        limits (:class:`List["types.PremiumLimit"]`):
            The list of limits, increased for Premium users

        payment_link (:class:`"types.InternalLinkType"`):
            An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available

    """

    def __init__(
        self,
        features: List[PremiumFeature] = None,
        limits: List[PremiumLimit] = None,
        payment_link: InternalLinkType = None,
    ) -> None:
        self.features: List[PremiumFeature] = features or []
        r"""The list of available features"""
        self.limits: List[PremiumLimit] = limits or []
        r"""The list of limits, increased for Premium users"""
        self.payment_link: Union[
            InternalLinkTypeActiveSessions,
            InternalLinkTypeAttachmentMenuBot,
            InternalLinkTypeAuthenticationCode,
            InternalLinkTypeBackground,
            InternalLinkTypeBotAddToChannel,
            InternalLinkTypeBotStart,
            InternalLinkTypeBotStartInGroup,
            InternalLinkTypeBusinessChat,
            InternalLinkTypeBuyStars,
            InternalLinkTypeChangePhoneNumber,
            InternalLinkTypeChatAffiliateProgram,
            InternalLinkTypeChatBoost,
            InternalLinkTypeChatFolderInvite,
            InternalLinkTypeChatFolderSettings,
            InternalLinkTypeChatInvite,
            InternalLinkTypeDefaultMessageAutoDeleteTimerSettings,
            InternalLinkTypeEditProfileSettings,
            InternalLinkTypeGame,
            InternalLinkTypeInstantView,
            InternalLinkTypeInvoice,
            InternalLinkTypeLanguagePack,
            InternalLinkTypeLanguageSettings,
            InternalLinkTypeMainWebApp,
            InternalLinkTypeMessage,
            InternalLinkTypeMessageDraft,
            InternalLinkTypePassportDataRequest,
            InternalLinkTypePhoneNumberConfirmation,
            InternalLinkTypePremiumFeatures,
            InternalLinkTypePremiumGift,
            InternalLinkTypePremiumGiftCode,
            InternalLinkTypePrivacyAndSecuritySettings,
            InternalLinkTypeProxy,
            InternalLinkTypePublicChat,
            InternalLinkTypeQrCodeAuthentication,
            InternalLinkTypeRestorePurchases,
            InternalLinkTypeSettings,
            InternalLinkTypeStickerSet,
            InternalLinkTypeStory,
            InternalLinkTypeTheme,
            InternalLinkTypeThemeSettings,
            InternalLinkTypeUnknownDeepLink,
            InternalLinkTypeUnsupportedProxy,
            InternalLinkTypeUpgradedGift,
            InternalLinkTypeUserPhoneNumber,
            InternalLinkTypeUserToken,
            InternalLinkTypeVideoChat,
            InternalLinkTypeWebApp,
            None,
        ] = payment_link
        r"""An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeatures"]:
        return "premiumFeatures"

    def getClass(self) -> Literal["PremiumFeatures"]:
        return "PremiumFeatures"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "features": self.features,
            "limits": self.limits,
            "payment_link": self.payment_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeatures", None]:
        if data:
            data_class = cls()
            data_class.features = data.get("features", None)
            data_class.limits = data.get("limits", None)
            data_class.payment_link = data.get("payment_link", None)

        return data_class


class BusinessFeatures(TlObject):
    r"""Contains information about features, available to Business user accounts

    Parameters:
        features (:class:`List["types.BusinessFeature"]`):
            The list of available business features

    """

    def __init__(self, features: List[BusinessFeature] = None) -> None:
        self.features: List[BusinessFeature] = features or []
        r"""The list of available business features"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeatures"]:
        return "businessFeatures"

    def getClass(self) -> Literal["BusinessFeatures"]:
        return "BusinessFeatures"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "features": self.features}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeatures", None]:
        if data:
            data_class = cls()
            data_class.features = data.get("features", None)

        return data_class


class PremiumSourceLimitExceeded(TlObject, PremiumSource):
    r"""A limit was exceeded

    Parameters:
        limit_type (:class:`"types.PremiumLimitType"`):
            Type of the exceeded limit

    """

    def __init__(self, limit_type: PremiumLimitType = None) -> None:
        self.limit_type: Union[
            PremiumLimitTypeSupergroupCount,
            PremiumLimitTypePinnedChatCount,
            PremiumLimitTypeCreatedPublicChatCount,
            PremiumLimitTypeSavedAnimationCount,
            PremiumLimitTypeFavoriteStickerCount,
            PremiumLimitTypeChatFolderCount,
            PremiumLimitTypeChatFolderChosenChatCount,
            PremiumLimitTypePinnedArchivedChatCount,
            PremiumLimitTypePinnedSavedMessagesTopicCount,
            PremiumLimitTypeCaptionLength,
            PremiumLimitTypeBioLength,
            PremiumLimitTypeChatFolderInviteLinkCount,
            PremiumLimitTypeShareableChatFolderCount,
            PremiumLimitTypeActiveStoryCount,
            PremiumLimitTypeWeeklySentStoryCount,
            PremiumLimitTypeMonthlySentStoryCount,
            PremiumLimitTypeStoryCaptionLength,
            PremiumLimitTypeStorySuggestedReactionAreaCount,
            PremiumLimitTypeSimilarChatCount,
            None,
        ] = limit_type
        r"""Type of the exceeded limit"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumSourceLimitExceeded"]:
        return "premiumSourceLimitExceeded"

    def getClass(self) -> Literal["PremiumSource"]:
        return "PremiumSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "limit_type": self.limit_type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumSourceLimitExceeded", None]:
        if data:
            data_class = cls()
            data_class.limit_type = data.get("limit_type", None)

        return data_class


class PremiumSourceFeature(TlObject, PremiumSource):
    r"""A user tried to use a Premium feature

    Parameters:
        feature (:class:`"types.PremiumFeature"`):
            The used feature

    """

    def __init__(self, feature: PremiumFeature = None) -> None:
        self.feature: Union[
            PremiumFeatureIncreasedLimits,
            PremiumFeatureIncreasedUploadFileSize,
            PremiumFeatureImprovedDownloadSpeed,
            PremiumFeatureVoiceRecognition,
            PremiumFeatureDisabledAds,
            PremiumFeatureUniqueReactions,
            PremiumFeatureUniqueStickers,
            PremiumFeatureCustomEmoji,
            PremiumFeatureAdvancedChatManagement,
            PremiumFeatureProfileBadge,
            PremiumFeatureEmojiStatus,
            PremiumFeatureAnimatedProfilePhoto,
            PremiumFeatureForumTopicIcon,
            PremiumFeatureAppIcons,
            PremiumFeatureRealTimeChatTranslation,
            PremiumFeatureUpgradedStories,
            PremiumFeatureChatBoost,
            PremiumFeatureAccentColor,
            PremiumFeatureBackgroundForBoth,
            PremiumFeatureSavedMessagesTags,
            PremiumFeatureMessagePrivacy,
            PremiumFeatureLastSeenTimes,
            PremiumFeatureBusiness,
            PremiumFeatureMessageEffects,
            None,
        ] = feature
        r"""The used feature"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumSourceFeature"]:
        return "premiumSourceFeature"

    def getClass(self) -> Literal["PremiumSource"]:
        return "PremiumSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "feature": self.feature}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumSourceFeature", None]:
        if data:
            data_class = cls()
            data_class.feature = data.get("feature", None)

        return data_class


class PremiumSourceBusinessFeature(TlObject, PremiumSource):
    r"""A user tried to use a Business feature

    Parameters:
        feature (:class:`"types.BusinessFeature"`):
            The used feature; pass null if none specific feature was used

    """

    def __init__(self, feature: BusinessFeature = None) -> None:
        self.feature: Union[
            BusinessFeatureLocation,
            BusinessFeatureOpeningHours,
            BusinessFeatureQuickReplies,
            BusinessFeatureGreetingMessage,
            BusinessFeatureAwayMessage,
            BusinessFeatureAccountLinks,
            BusinessFeatureStartPage,
            BusinessFeatureBots,
            BusinessFeatureEmojiStatus,
            BusinessFeatureChatFolderTags,
            BusinessFeatureUpgradedStories,
            None,
        ] = feature
        r"""The used feature; pass null if none specific feature was used"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumSourceBusinessFeature"]:
        return "premiumSourceBusinessFeature"

    def getClass(self) -> Literal["PremiumSource"]:
        return "PremiumSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "feature": self.feature}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumSourceBusinessFeature", None]:
        if data:
            data_class = cls()
            data_class.feature = data.get("feature", None)

        return data_class


class PremiumSourceStoryFeature(TlObject, PremiumSource):
    r"""A user tried to use a Premium story feature

    Parameters:
        feature (:class:`"types.PremiumStoryFeature"`):
            The used feature

    """

    def __init__(self, feature: PremiumStoryFeature = None) -> None:
        self.feature: Union[
            PremiumStoryFeaturePriorityOrder,
            PremiumStoryFeatureStealthMode,
            PremiumStoryFeaturePermanentViewsHistory,
            PremiumStoryFeatureCustomExpirationDuration,
            PremiumStoryFeatureSaveStories,
            PremiumStoryFeatureLinksAndFormatting,
            PremiumStoryFeatureVideoQuality,
            None,
        ] = feature
        r"""The used feature"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumSourceStoryFeature"]:
        return "premiumSourceStoryFeature"

    def getClass(self) -> Literal["PremiumSource"]:
        return "PremiumSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "feature": self.feature}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumSourceStoryFeature", None]:
        if data:
            data_class = cls()
            data_class.feature = data.get("feature", None)

        return data_class


class PremiumSourceLink(TlObject, PremiumSource):
    r"""A user opened an internal link of the type internalLinkTypePremiumFeatures

    Parameters:
        referrer (:class:`str`):
            The referrer from the link

    """

    def __init__(self, referrer: str = "") -> None:
        self.referrer: Union[str, None] = referrer
        r"""The referrer from the link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumSourceLink"]:
        return "premiumSourceLink"

    def getClass(self) -> Literal["PremiumSource"]:
        return "PremiumSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "referrer": self.referrer}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumSourceLink", None]:
        if data:
            data_class = cls()
            data_class.referrer = data.get("referrer", "")

        return data_class


class PremiumSourceSettings(TlObject, PremiumSource):
    r"""A user opened the Premium features screen from settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumSourceSettings"]:
        return "premiumSourceSettings"

    def getClass(self) -> Literal["PremiumSource"]:
        return "PremiumSource"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumSourceSettings", None]:
        if data:
            data_class = cls()

        return data_class


class PremiumFeaturePromotionAnimation(TlObject):
    r"""Describes a promotion animation for a Premium feature

    Parameters:
        feature (:class:`"types.PremiumFeature"`):
            Premium feature

        animation (:class:`"types.Animation"`):
            Promotion animation for the feature

    """

    def __init__(
        self, feature: PremiumFeature = None, animation: Animation = None
    ) -> None:
        self.feature: Union[
            PremiumFeatureIncreasedLimits,
            PremiumFeatureIncreasedUploadFileSize,
            PremiumFeatureImprovedDownloadSpeed,
            PremiumFeatureVoiceRecognition,
            PremiumFeatureDisabledAds,
            PremiumFeatureUniqueReactions,
            PremiumFeatureUniqueStickers,
            PremiumFeatureCustomEmoji,
            PremiumFeatureAdvancedChatManagement,
            PremiumFeatureProfileBadge,
            PremiumFeatureEmojiStatus,
            PremiumFeatureAnimatedProfilePhoto,
            PremiumFeatureForumTopicIcon,
            PremiumFeatureAppIcons,
            PremiumFeatureRealTimeChatTranslation,
            PremiumFeatureUpgradedStories,
            PremiumFeatureChatBoost,
            PremiumFeatureAccentColor,
            PremiumFeatureBackgroundForBoth,
            PremiumFeatureSavedMessagesTags,
            PremiumFeatureMessagePrivacy,
            PremiumFeatureLastSeenTimes,
            PremiumFeatureBusiness,
            PremiumFeatureMessageEffects,
            None,
        ] = feature
        r"""Premium feature"""
        self.animation: Union[Animation, None] = animation
        r"""Promotion animation for the feature"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumFeaturePromotionAnimation"]:
        return "premiumFeaturePromotionAnimation"

    def getClass(self) -> Literal["PremiumFeaturePromotionAnimation"]:
        return "PremiumFeaturePromotionAnimation"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "feature": self.feature,
            "animation": self.animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumFeaturePromotionAnimation", None]:
        if data:
            data_class = cls()
            data_class.feature = data.get("feature", None)
            data_class.animation = data.get("animation", None)

        return data_class


class BusinessFeaturePromotionAnimation(TlObject):
    r"""Describes a promotion animation for a Business feature

    Parameters:
        feature (:class:`"types.BusinessFeature"`):
            Business feature

        animation (:class:`"types.Animation"`):
            Promotion animation for the feature

    """

    def __init__(
        self, feature: BusinessFeature = None, animation: Animation = None
    ) -> None:
        self.feature: Union[
            BusinessFeatureLocation,
            BusinessFeatureOpeningHours,
            BusinessFeatureQuickReplies,
            BusinessFeatureGreetingMessage,
            BusinessFeatureAwayMessage,
            BusinessFeatureAccountLinks,
            BusinessFeatureStartPage,
            BusinessFeatureBots,
            BusinessFeatureEmojiStatus,
            BusinessFeatureChatFolderTags,
            BusinessFeatureUpgradedStories,
            None,
        ] = feature
        r"""Business feature"""
        self.animation: Union[Animation, None] = animation
        r"""Promotion animation for the feature"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["businessFeaturePromotionAnimation"]:
        return "businessFeaturePromotionAnimation"

    def getClass(self) -> Literal["BusinessFeaturePromotionAnimation"]:
        return "BusinessFeaturePromotionAnimation"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "feature": self.feature,
            "animation": self.animation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BusinessFeaturePromotionAnimation", None]:
        if data:
            data_class = cls()
            data_class.feature = data.get("feature", None)
            data_class.animation = data.get("animation", None)

        return data_class


class PremiumState(TlObject):
    r"""Contains state of Telegram Premium subscription and promotion videos for Premium features

    Parameters:
        state (:class:`"types.FormattedText"`):
            Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription

        payment_options (:class:`List["types.PremiumStatePaymentOption"]`):
            The list of available options for buying Telegram Premium

        animations (:class:`List["types.PremiumFeaturePromotionAnimation"]`):
            The list of available promotion animations for Premium features

        business_animations (:class:`List["types.BusinessFeaturePromotionAnimation"]`):
            The list of available promotion animations for Business features

    """

    def __init__(
        self,
        state: FormattedText = None,
        payment_options: List[PremiumStatePaymentOption] = None,
        animations: List[PremiumFeaturePromotionAnimation] = None,
        business_animations: List[BusinessFeaturePromotionAnimation] = None,
    ) -> None:
        self.state: Union[FormattedText, None] = state
        r"""Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription"""
        self.payment_options: List[PremiumStatePaymentOption] = payment_options or []
        r"""The list of available options for buying Telegram Premium"""
        self.animations: List[PremiumFeaturePromotionAnimation] = animations or []
        r"""The list of available promotion animations for Premium features"""
        self.business_animations: List[BusinessFeaturePromotionAnimation] = (
            business_animations or []
        )
        r"""The list of available promotion animations for Business features"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["premiumState"]:
        return "premiumState"

    def getClass(self) -> Literal["PremiumState"]:
        return "PremiumState"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "state": self.state,
            "payment_options": self.payment_options,
            "animations": self.animations,
            "business_animations": self.business_animations,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PremiumState", None]:
        if data:
            data_class = cls()
            data_class.state = data.get("state", None)
            data_class.payment_options = data.get("payment_options", None)
            data_class.animations = data.get("animations", None)
            data_class.business_animations = data.get("business_animations", None)

        return data_class


class StorePaymentPurposePremiumSubscription(TlObject, StorePaymentPurpose):
    r"""The user subscribing to Telegram Premium

    Parameters:
        is_restore (:class:`bool`):
            Pass true if this is a restore of a Telegram Premium purchase; only for App Store

        is_upgrade (:class:`bool`):
            Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store

    """

    def __init__(self, is_restore: bool = False, is_upgrade: bool = False) -> None:
        self.is_restore: bool = bool(is_restore)
        r"""Pass true if this is a restore of a Telegram Premium purchase; only for App Store"""
        self.is_upgrade: bool = bool(is_upgrade)
        r"""Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storePaymentPurposePremiumSubscription"]:
        return "storePaymentPurposePremiumSubscription"

    def getClass(self) -> Literal["StorePaymentPurpose"]:
        return "StorePaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_restore": self.is_restore,
            "is_upgrade": self.is_upgrade,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StorePaymentPurposePremiumSubscription", None]:
        if data:
            data_class = cls()
            data_class.is_restore = data.get("is_restore", False)
            data_class.is_upgrade = data.get("is_upgrade", False)

        return data_class


class StorePaymentPurposePremiumGift(TlObject, StorePaymentPurpose):
    r"""The user gifting Telegram Premium to another user

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        user_id (:class:`int`):
            Identifiers of the user which will receive Telegram Premium

        text (:class:`"types.FormattedText"`):
            Text to show along with the gift codes; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed

    """

    def __init__(
        self,
        currency: str = "",
        amount: int = 0,
        user_id: int = 0,
        text: FormattedText = None,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.user_id: int = int(user_id)
        r"""Identifiers of the user which will receive Telegram Premium"""
        self.text: Union[FormattedText, None] = text
        r"""Text to show along with the gift codes; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storePaymentPurposePremiumGift"]:
        return "storePaymentPurposePremiumGift"

    def getClass(self) -> Literal["StorePaymentPurpose"]:
        return "StorePaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "user_id": self.user_id,
            "text": self.text,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorePaymentPurposePremiumGift", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.user_id = int(data.get("user_id", 0))
            data_class.text = data.get("text", None)

        return data_class


class StorePaymentPurposePremiumGiftCodes(TlObject, StorePaymentPurpose):
    r"""The user boosting a chat by creating Telegram Premium gift codes for other users

    Parameters:
        boosted_chat_id (:class:`int`):
            Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        user_ids (:class:`List[int]`):
            Identifiers of the users which can activate the gift codes

        text (:class:`"types.FormattedText"`):
            Text to show along with the gift codes; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed

    """

    def __init__(
        self,
        boosted_chat_id: int = 0,
        currency: str = "",
        amount: int = 0,
        user_ids: List[int] = None,
        text: FormattedText = None,
    ) -> None:
        self.boosted_chat_id: int = int(boosted_chat_id)
        r"""Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.user_ids: List[int] = user_ids or []
        r"""Identifiers of the users which can activate the gift codes"""
        self.text: Union[FormattedText, None] = text
        r"""Text to show along with the gift codes; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storePaymentPurposePremiumGiftCodes"]:
        return "storePaymentPurposePremiumGiftCodes"

    def getClass(self) -> Literal["StorePaymentPurpose"]:
        return "StorePaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "boosted_chat_id": self.boosted_chat_id,
            "currency": self.currency,
            "amount": self.amount,
            "user_ids": self.user_ids,
            "text": self.text,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["StorePaymentPurposePremiumGiftCodes", None]:
        if data:
            data_class = cls()
            data_class.boosted_chat_id = int(data.get("boosted_chat_id", 0))
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.user_ids = data.get("user_ids", None)
            data_class.text = data.get("text", None)

        return data_class


class StorePaymentPurposePremiumGiveaway(TlObject, StorePaymentPurpose):
    r"""The user creating a Telegram Premium giveaway

    Parameters:
        parameters (:class:`"types.GiveawayParameters"`):
            Giveaway parameters

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

    """

    def __init__(
        self, parameters: GiveawayParameters = None, currency: str = "", amount: int = 0
    ) -> None:
        self.parameters: Union[GiveawayParameters, None] = parameters
        r"""Giveaway parameters"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storePaymentPurposePremiumGiveaway"]:
        return "storePaymentPurposePremiumGiveaway"

    def getClass(self) -> Literal["StorePaymentPurpose"]:
        return "StorePaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "parameters": self.parameters,
            "currency": self.currency,
            "amount": self.amount,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorePaymentPurposePremiumGiveaway", None]:
        if data:
            data_class = cls()
            data_class.parameters = data.get("parameters", None)
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))

        return data_class


class StorePaymentPurposeStarGiveaway(TlObject, StorePaymentPurpose):
    r"""The user creating a Telegram Star giveaway

    Parameters:
        parameters (:class:`"types.GiveawayParameters"`):
            Giveaway parameters

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        winner_count (:class:`int`):
            The number of users to receive Telegram Stars

        star_count (:class:`int`):
            The number of Telegram Stars to be distributed through the giveaway

    """

    def __init__(
        self,
        parameters: GiveawayParameters = None,
        currency: str = "",
        amount: int = 0,
        winner_count: int = 0,
        star_count: int = 0,
    ) -> None:
        self.parameters: Union[GiveawayParameters, None] = parameters
        r"""Giveaway parameters"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.winner_count: int = int(winner_count)
        r"""The number of users to receive Telegram Stars"""
        self.star_count: int = int(star_count)
        r"""The number of Telegram Stars to be distributed through the giveaway"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storePaymentPurposeStarGiveaway"]:
        return "storePaymentPurposeStarGiveaway"

    def getClass(self) -> Literal["StorePaymentPurpose"]:
        return "StorePaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "parameters": self.parameters,
            "currency": self.currency,
            "amount": self.amount,
            "winner_count": self.winner_count,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorePaymentPurposeStarGiveaway", None]:
        if data:
            data_class = cls()
            data_class.parameters = data.get("parameters", None)
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class StorePaymentPurposeStars(TlObject, StorePaymentPurpose):
    r"""The user buying Telegram Stars

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        star_count (:class:`int`):
            Number of bought Telegram Stars

    """

    def __init__(
        self, currency: str = "", amount: int = 0, star_count: int = 0
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.star_count: int = int(star_count)
        r"""Number of bought Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storePaymentPurposeStars"]:
        return "storePaymentPurposeStars"

    def getClass(self) -> Literal["StorePaymentPurpose"]:
        return "StorePaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorePaymentPurposeStars", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class StorePaymentPurposeGiftedStars(TlObject, StorePaymentPurpose):
    r"""The user buying Telegram Stars for other users

    Parameters:
        user_id (:class:`int`):
            Identifier of the user to which Telegram Stars are gifted

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        star_count (:class:`int`):
            Number of bought Telegram Stars

    """

    def __init__(
        self, user_id: int = 0, currency: str = "", amount: int = 0, star_count: int = 0
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user to which Telegram Stars are gifted"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.star_count: int = int(star_count)
        r"""Number of bought Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storePaymentPurposeGiftedStars"]:
        return "storePaymentPurposeGiftedStars"

    def getClass(self) -> Literal["StorePaymentPurpose"]:
        return "StorePaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "currency": self.currency,
            "amount": self.amount,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorePaymentPurposeGiftedStars", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class StoreTransactionAppStore(TlObject, StoreTransaction):
    r"""A purchase through App Store

    Parameters:
        receipt (:class:`bytes`):
            App Store receipt

    """

    def __init__(self, receipt: bytes = b"") -> None:
        self.receipt: Union[bytes, None] = receipt
        r"""App Store receipt"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storeTransactionAppStore"]:
        return "storeTransactionAppStore"

    def getClass(self) -> Literal["StoreTransaction"]:
        return "StoreTransaction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "receipt": self.receipt}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoreTransactionAppStore", None]:
        if data:
            data_class = cls()
            data_class.receipt = b64decode(data.get("receipt", b""))

        return data_class


class StoreTransactionGooglePlay(TlObject, StoreTransaction):
    r"""A purchase through Google Play

    Parameters:
        package_name (:class:`str`):
            Application package name

        store_product_id (:class:`str`):
            Identifier of the purchased store product

        purchase_token (:class:`str`):
            Google Play purchase token

    """

    def __init__(
        self,
        package_name: str = "",
        store_product_id: str = "",
        purchase_token: str = "",
    ) -> None:
        self.package_name: Union[str, None] = package_name
        r"""Application package name"""
        self.store_product_id: Union[str, None] = store_product_id
        r"""Identifier of the purchased store product"""
        self.purchase_token: Union[str, None] = purchase_token
        r"""Google Play purchase token"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storeTransactionGooglePlay"]:
        return "storeTransactionGooglePlay"

    def getClass(self) -> Literal["StoreTransaction"]:
        return "StoreTransaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "package_name": self.package_name,
            "store_product_id": self.store_product_id,
            "purchase_token": self.purchase_token,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoreTransactionGooglePlay", None]:
        if data:
            data_class = cls()
            data_class.package_name = data.get("package_name", "")
            data_class.store_product_id = data.get("store_product_id", "")
            data_class.purchase_token = data.get("purchase_token", "")

        return data_class


class TelegramPaymentPurposePremiumGift(TlObject, TelegramPaymentPurpose):
    r"""The user gifting Telegram Premium to another user

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code of the payment currency, or \"XTR\" for payments in Telegram Stars

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        user_id (:class:`int`):
            Identifier of the user which will receive Telegram Premium

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active for the user

        text (:class:`"types.FormattedText"`):
            Text to show to the user receiving Telegram Premium; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed

    """

    def __init__(
        self,
        currency: str = "",
        amount: int = 0,
        user_id: int = 0,
        month_count: int = 0,
        text: FormattedText = None,
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency, or \"XTR\" for payments in Telegram Stars"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.user_id: int = int(user_id)
        r"""Identifier of the user which will receive Telegram Premium"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active for the user"""
        self.text: Union[FormattedText, None] = text
        r"""Text to show to the user receiving Telegram Premium; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["telegramPaymentPurposePremiumGift"]:
        return "telegramPaymentPurposePremiumGift"

    def getClass(self) -> Literal["TelegramPaymentPurpose"]:
        return "TelegramPaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "user_id": self.user_id,
            "month_count": self.month_count,
            "text": self.text,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TelegramPaymentPurposePremiumGift", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.user_id = int(data.get("user_id", 0))
            data_class.month_count = int(data.get("month_count", 0))
            data_class.text = data.get("text", None)

        return data_class


class TelegramPaymentPurposePremiumGiftCodes(TlObject, TelegramPaymentPurpose):
    r"""The user boosting a chat by creating Telegram Premium gift codes for other users

    Parameters:
        boosted_chat_id (:class:`int`):
            Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        user_ids (:class:`List[int]`):
            Identifiers of the users which can activate the gift codes

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active for the users

        text (:class:`"types.FormattedText"`):
            Text to show along with the gift codes; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed

    """

    def __init__(
        self,
        boosted_chat_id: int = 0,
        currency: str = "",
        amount: int = 0,
        user_ids: List[int] = None,
        month_count: int = 0,
        text: FormattedText = None,
    ) -> None:
        self.boosted_chat_id: int = int(boosted_chat_id)
        r"""Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.user_ids: List[int] = user_ids or []
        r"""Identifiers of the users which can activate the gift codes"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active for the users"""
        self.text: Union[FormattedText, None] = text
        r"""Text to show along with the gift codes; 0\-getOption\(\"gift\_text\_length\_max\"\) characters\. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["telegramPaymentPurposePremiumGiftCodes"]:
        return "telegramPaymentPurposePremiumGiftCodes"

    def getClass(self) -> Literal["TelegramPaymentPurpose"]:
        return "TelegramPaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "boosted_chat_id": self.boosted_chat_id,
            "currency": self.currency,
            "amount": self.amount,
            "user_ids": self.user_ids,
            "month_count": self.month_count,
            "text": self.text,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["TelegramPaymentPurposePremiumGiftCodes", None]:
        if data:
            data_class = cls()
            data_class.boosted_chat_id = int(data.get("boosted_chat_id", 0))
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.user_ids = data.get("user_ids", None)
            data_class.month_count = int(data.get("month_count", 0))
            data_class.text = data.get("text", None)

        return data_class


class TelegramPaymentPurposePremiumGiveaway(TlObject, TelegramPaymentPurpose):
    r"""The user creating a Telegram Premium giveaway

    Parameters:
        parameters (:class:`"types.GiveawayParameters"`):
            Giveaway parameters

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        winner_count (:class:`int`):
            Number of users which will be able to activate the gift codes

        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active for the users

    """

    def __init__(
        self,
        parameters: GiveawayParameters = None,
        currency: str = "",
        amount: int = 0,
        winner_count: int = 0,
        month_count: int = 0,
    ) -> None:
        self.parameters: Union[GiveawayParameters, None] = parameters
        r"""Giveaway parameters"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.winner_count: int = int(winner_count)
        r"""Number of users which will be able to activate the gift codes"""
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active for the users"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["telegramPaymentPurposePremiumGiveaway"]:
        return "telegramPaymentPurposePremiumGiveaway"

    def getClass(self) -> Literal["TelegramPaymentPurpose"]:
        return "TelegramPaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "parameters": self.parameters,
            "currency": self.currency,
            "amount": self.amount,
            "winner_count": self.winner_count,
            "month_count": self.month_count,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["TelegramPaymentPurposePremiumGiveaway", None]:
        if data:
            data_class = cls()
            data_class.parameters = data.get("parameters", None)
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.month_count = int(data.get("month_count", 0))

        return data_class


class TelegramPaymentPurposeStars(TlObject, TelegramPaymentPurpose):
    r"""The user buying Telegram Stars

    Parameters:
        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        star_count (:class:`int`):
            Number of bought Telegram Stars

    """

    def __init__(
        self, currency: str = "", amount: int = 0, star_count: int = 0
    ) -> None:
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.star_count: int = int(star_count)
        r"""Number of bought Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["telegramPaymentPurposeStars"]:
        return "telegramPaymentPurposeStars"

    def getClass(self) -> Literal["TelegramPaymentPurpose"]:
        return "TelegramPaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "currency": self.currency,
            "amount": self.amount,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TelegramPaymentPurposeStars", None]:
        if data:
            data_class = cls()
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class TelegramPaymentPurposeGiftedStars(TlObject, TelegramPaymentPurpose):
    r"""The user buying Telegram Stars for other users

    Parameters:
        user_id (:class:`int`):
            Identifier of the user to which Telegram Stars are gifted

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        star_count (:class:`int`):
            Number of bought Telegram Stars

    """

    def __init__(
        self, user_id: int = 0, currency: str = "", amount: int = 0, star_count: int = 0
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user to which Telegram Stars are gifted"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.star_count: int = int(star_count)
        r"""Number of bought Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["telegramPaymentPurposeGiftedStars"]:
        return "telegramPaymentPurposeGiftedStars"

    def getClass(self) -> Literal["TelegramPaymentPurpose"]:
        return "TelegramPaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "currency": self.currency,
            "amount": self.amount,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TelegramPaymentPurposeGiftedStars", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class TelegramPaymentPurposeStarGiveaway(TlObject, TelegramPaymentPurpose):
    r"""The user creating a Telegram Star giveaway

    Parameters:
        parameters (:class:`"types.GiveawayParameters"`):
            Giveaway parameters

        currency (:class:`str`):
            ISO 4217 currency code of the payment currency

        amount (:class:`int`):
            Paid amount, in the smallest units of the currency

        winner_count (:class:`int`):
            The number of users to receive Telegram Stars

        star_count (:class:`int`):
            The number of Telegram Stars to be distributed through the giveaway

    """

    def __init__(
        self,
        parameters: GiveawayParameters = None,
        currency: str = "",
        amount: int = 0,
        winner_count: int = 0,
        star_count: int = 0,
    ) -> None:
        self.parameters: Union[GiveawayParameters, None] = parameters
        r"""Giveaway parameters"""
        self.currency: Union[str, None] = currency
        r"""ISO 4217 currency code of the payment currency"""
        self.amount: int = int(amount)
        r"""Paid amount, in the smallest units of the currency"""
        self.winner_count: int = int(winner_count)
        r"""The number of users to receive Telegram Stars"""
        self.star_count: int = int(star_count)
        r"""The number of Telegram Stars to be distributed through the giveaway"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["telegramPaymentPurposeStarGiveaway"]:
        return "telegramPaymentPurposeStarGiveaway"

    def getClass(self) -> Literal["TelegramPaymentPurpose"]:
        return "TelegramPaymentPurpose"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "parameters": self.parameters,
            "currency": self.currency,
            "amount": self.amount,
            "winner_count": self.winner_count,
            "star_count": self.star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TelegramPaymentPurposeStarGiveaway", None]:
        if data:
            data_class = cls()
            data_class.parameters = data.get("parameters", None)
            data_class.currency = data.get("currency", "")
            data_class.amount = int(data.get("amount", 0))
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class TelegramPaymentPurposeJoinChat(TlObject, TelegramPaymentPurpose):
    r"""The user joins a chat and subscribes to regular payments in Telegram Stars

    Parameters:
        invite_link (:class:`str`):
            Invite link to use

    """

    def __init__(self, invite_link: str = "") -> None:
        self.invite_link: Union[str, None] = invite_link
        r"""Invite link to use"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["telegramPaymentPurposeJoinChat"]:
        return "telegramPaymentPurposeJoinChat"

    def getClass(self) -> Literal["TelegramPaymentPurpose"]:
        return "TelegramPaymentPurpose"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invite_link": self.invite_link}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TelegramPaymentPurposeJoinChat", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", "")

        return data_class


class DeviceTokenFirebaseCloudMessaging(TlObject, DeviceToken):
    r"""A token for Firebase Cloud Messaging

    Parameters:
        token (:class:`str`):
            Device registration token; may be empty to deregister a device

        encrypt (:class:`bool`):
            True, if push notifications must be additionally encrypted

    """

    def __init__(self, token: str = "", encrypt: bool = False) -> None:
        self.token: Union[str, None] = token
        r"""Device registration token; may be empty to deregister a device"""
        self.encrypt: bool = bool(encrypt)
        r"""True, if push notifications must be additionally encrypted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenFirebaseCloudMessaging"]:
        return "deviceTokenFirebaseCloudMessaging"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token, "encrypt": self.encrypt}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenFirebaseCloudMessaging", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")
            data_class.encrypt = data.get("encrypt", False)

        return data_class


class DeviceTokenApplePush(TlObject, DeviceToken):
    r"""A token for Apple Push Notification service

    Parameters:
        device_token (:class:`str`):
            Device token; may be empty to deregister a device

        is_app_sandbox (:class:`bool`):
            True, if App Sandbox is enabled

    """

    def __init__(self, device_token: str = "", is_app_sandbox: bool = False) -> None:
        self.device_token: Union[str, None] = device_token
        r"""Device token; may be empty to deregister a device"""
        self.is_app_sandbox: bool = bool(is_app_sandbox)
        r"""True, if App Sandbox is enabled"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenApplePush"]:
        return "deviceTokenApplePush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "device_token": self.device_token,
            "is_app_sandbox": self.is_app_sandbox,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenApplePush", None]:
        if data:
            data_class = cls()
            data_class.device_token = data.get("device_token", "")
            data_class.is_app_sandbox = data.get("is_app_sandbox", False)

        return data_class


class DeviceTokenApplePushVoIP(TlObject, DeviceToken):
    r"""A token for Apple Push Notification service VoIP notifications

    Parameters:
        device_token (:class:`str`):
            Device token; may be empty to deregister a device

        is_app_sandbox (:class:`bool`):
            True, if App Sandbox is enabled

        encrypt (:class:`bool`):
            True, if push notifications must be additionally encrypted

    """

    def __init__(
        self,
        device_token: str = "",
        is_app_sandbox: bool = False,
        encrypt: bool = False,
    ) -> None:
        self.device_token: Union[str, None] = device_token
        r"""Device token; may be empty to deregister a device"""
        self.is_app_sandbox: bool = bool(is_app_sandbox)
        r"""True, if App Sandbox is enabled"""
        self.encrypt: bool = bool(encrypt)
        r"""True, if push notifications must be additionally encrypted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenApplePushVoIP"]:
        return "deviceTokenApplePushVoIP"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "device_token": self.device_token,
            "is_app_sandbox": self.is_app_sandbox,
            "encrypt": self.encrypt,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenApplePushVoIP", None]:
        if data:
            data_class = cls()
            data_class.device_token = data.get("device_token", "")
            data_class.is_app_sandbox = data.get("is_app_sandbox", False)
            data_class.encrypt = data.get("encrypt", False)

        return data_class


class DeviceTokenWindowsPush(TlObject, DeviceToken):
    r"""A token for Windows Push Notification Services

    Parameters:
        access_token (:class:`str`):
            The access token that will be used to send notifications; may be empty to deregister a device

    """

    def __init__(self, access_token: str = "") -> None:
        self.access_token: Union[str, None] = access_token
        r"""The access token that will be used to send notifications; may be empty to deregister a device"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenWindowsPush"]:
        return "deviceTokenWindowsPush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "access_token": self.access_token}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenWindowsPush", None]:
        if data:
            data_class = cls()
            data_class.access_token = data.get("access_token", "")

        return data_class


class DeviceTokenMicrosoftPush(TlObject, DeviceToken):
    r"""A token for Microsoft Push Notification Service

    Parameters:
        channel_uri (:class:`str`):
            Push notification channel URI; may be empty to deregister a device

    """

    def __init__(self, channel_uri: str = "") -> None:
        self.channel_uri: Union[str, None] = channel_uri
        r"""Push notification channel URI; may be empty to deregister a device"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenMicrosoftPush"]:
        return "deviceTokenMicrosoftPush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "channel_uri": self.channel_uri}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenMicrosoftPush", None]:
        if data:
            data_class = cls()
            data_class.channel_uri = data.get("channel_uri", "")

        return data_class


class DeviceTokenMicrosoftPushVoIP(TlObject, DeviceToken):
    r"""A token for Microsoft Push Notification Service VoIP channel

    Parameters:
        channel_uri (:class:`str`):
            Push notification channel URI; may be empty to deregister a device

    """

    def __init__(self, channel_uri: str = "") -> None:
        self.channel_uri: Union[str, None] = channel_uri
        r"""Push notification channel URI; may be empty to deregister a device"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenMicrosoftPushVoIP"]:
        return "deviceTokenMicrosoftPushVoIP"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "channel_uri": self.channel_uri}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenMicrosoftPushVoIP", None]:
        if data:
            data_class = cls()
            data_class.channel_uri = data.get("channel_uri", "")

        return data_class


class DeviceTokenWebPush(TlObject, DeviceToken):
    r"""A token for web Push API

    Parameters:
        endpoint (:class:`str`):
            Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device

        p256dh_base64url (:class:`str`):
            Base64url\-encoded P\-256 elliptic curve Diffie\-Hellman public key

        auth_base64url (:class:`str`):
            Base64url\-encoded authentication secret

    """

    def __init__(
        self, endpoint: str = "", p256dh_base64url: str = "", auth_base64url: str = ""
    ) -> None:
        self.endpoint: Union[str, None] = endpoint
        r"""Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device"""
        self.p256dh_base64url: Union[str, None] = p256dh_base64url
        r"""Base64url\-encoded P\-256 elliptic curve Diffie\-Hellman public key"""
        self.auth_base64url: Union[str, None] = auth_base64url
        r"""Base64url\-encoded authentication secret"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenWebPush"]:
        return "deviceTokenWebPush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "endpoint": self.endpoint,
            "p256dh_base64url": self.p256dh_base64url,
            "auth_base64url": self.auth_base64url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenWebPush", None]:
        if data:
            data_class = cls()
            data_class.endpoint = data.get("endpoint", "")
            data_class.p256dh_base64url = data.get("p256dh_base64url", "")
            data_class.auth_base64url = data.get("auth_base64url", "")

        return data_class


class DeviceTokenSimplePush(TlObject, DeviceToken):
    r"""A token for Simple Push API for Firefox OS

    Parameters:
        endpoint (:class:`str`):
            Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device

    """

    def __init__(self, endpoint: str = "") -> None:
        self.endpoint: Union[str, None] = endpoint
        r"""Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenSimplePush"]:
        return "deviceTokenSimplePush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "endpoint": self.endpoint}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenSimplePush", None]:
        if data:
            data_class = cls()
            data_class.endpoint = data.get("endpoint", "")

        return data_class


class DeviceTokenUbuntuPush(TlObject, DeviceToken):
    r"""A token for Ubuntu Push Client service

    Parameters:
        token (:class:`str`):
            Token; may be empty to deregister a device

    """

    def __init__(self, token: str = "") -> None:
        self.token: Union[str, None] = token
        r"""Token; may be empty to deregister a device"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenUbuntuPush"]:
        return "deviceTokenUbuntuPush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenUbuntuPush", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")

        return data_class


class DeviceTokenBlackBerryPush(TlObject, DeviceToken):
    r"""A token for BlackBerry Push Service

    Parameters:
        token (:class:`str`):
            Token; may be empty to deregister a device

    """

    def __init__(self, token: str = "") -> None:
        self.token: Union[str, None] = token
        r"""Token; may be empty to deregister a device"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenBlackBerryPush"]:
        return "deviceTokenBlackBerryPush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenBlackBerryPush", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")

        return data_class


class DeviceTokenTizenPush(TlObject, DeviceToken):
    r"""A token for Tizen Push Service

    Parameters:
        reg_id (:class:`str`):
            Push service registration identifier; may be empty to deregister a device

    """

    def __init__(self, reg_id: str = "") -> None:
        self.reg_id: Union[str, None] = reg_id
        r"""Push service registration identifier; may be empty to deregister a device"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenTizenPush"]:
        return "deviceTokenTizenPush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "reg_id": self.reg_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenTizenPush", None]:
        if data:
            data_class = cls()
            data_class.reg_id = data.get("reg_id", "")

        return data_class


class DeviceTokenHuaweiPush(TlObject, DeviceToken):
    r"""A token for HUAWEI Push Service

    Parameters:
        token (:class:`str`):
            Device registration token; may be empty to deregister a device

        encrypt (:class:`bool`):
            True, if push notifications must be additionally encrypted

    """

    def __init__(self, token: str = "", encrypt: bool = False) -> None:
        self.token: Union[str, None] = token
        r"""Device registration token; may be empty to deregister a device"""
        self.encrypt: bool = bool(encrypt)
        r"""True, if push notifications must be additionally encrypted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deviceTokenHuaweiPush"]:
        return "deviceTokenHuaweiPush"

    def getClass(self) -> Literal["DeviceToken"]:
        return "DeviceToken"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token, "encrypt": self.encrypt}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeviceTokenHuaweiPush", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")
            data_class.encrypt = data.get("encrypt", False)

        return data_class


class PushReceiverId(TlObject):
    r"""Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification

    Parameters:
        id (:class:`int`):
            The globally unique identifier of push notification subscription

    """

    def __init__(self, id: int = 0) -> None:
        self.id: int = int(id)
        r"""The globally unique identifier of push notification subscription"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushReceiverId"]:
        return "pushReceiverId"

    def getClass(self) -> Literal["PushReceiverId"]:
        return "PushReceiverId"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "id": self.id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushReceiverId", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))

        return data_class


class BackgroundFillSolid(TlObject, BackgroundFill):
    r"""Describes a solid fill of a background

    Parameters:
        color (:class:`int`):
            A color of the background in the RGB format

    """

    def __init__(self, color: int = 0) -> None:
        self.color: int = int(color)
        r"""A color of the background in the RGB format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgroundFillSolid"]:
        return "backgroundFillSolid"

    def getClass(self) -> Literal["BackgroundFill"]:
        return "BackgroundFill"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "color": self.color}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BackgroundFillSolid", None]:
        if data:
            data_class = cls()
            data_class.color = int(data.get("color", 0))

        return data_class


class BackgroundFillGradient(TlObject, BackgroundFill):
    r"""Describes a gradient fill of a background

    Parameters:
        top_color (:class:`int`):
            A top color of the background in the RGB format

        bottom_color (:class:`int`):
            A bottom color of the background in the RGB format

        rotation_angle (:class:`int`):
            Clockwise rotation angle of the gradient, in degrees; 0\-359\. Must always be divisible by 45

    """

    def __init__(
        self, top_color: int = 0, bottom_color: int = 0, rotation_angle: int = 0
    ) -> None:
        self.top_color: int = int(top_color)
        r"""A top color of the background in the RGB format"""
        self.bottom_color: int = int(bottom_color)
        r"""A bottom color of the background in the RGB format"""
        self.rotation_angle: int = int(rotation_angle)
        r"""Clockwise rotation angle of the gradient, in degrees; 0\-359\. Must always be divisible by 45"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgroundFillGradient"]:
        return "backgroundFillGradient"

    def getClass(self) -> Literal["BackgroundFill"]:
        return "BackgroundFill"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "top_color": self.top_color,
            "bottom_color": self.bottom_color,
            "rotation_angle": self.rotation_angle,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BackgroundFillGradient", None]:
        if data:
            data_class = cls()
            data_class.top_color = int(data.get("top_color", 0))
            data_class.bottom_color = int(data.get("bottom_color", 0))
            data_class.rotation_angle = int(data.get("rotation_angle", 0))

        return data_class


class BackgroundFillFreeformGradient(TlObject, BackgroundFill):
    r"""Describes a freeform gradient fill of a background

    Parameters:
        colors (:class:`List[int]`):
            A list of 3 or 4 colors of the freeform gradient in the RGB format

    """

    def __init__(self, colors: List[int] = None) -> None:
        self.colors: List[int] = colors or []
        r"""A list of 3 or 4 colors of the freeform gradient in the RGB format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgroundFillFreeformGradient"]:
        return "backgroundFillFreeformGradient"

    def getClass(self) -> Literal["BackgroundFill"]:
        return "BackgroundFill"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "colors": self.colors}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BackgroundFillFreeformGradient", None]:
        if data:
            data_class = cls()
            data_class.colors = data.get("colors", None)

        return data_class


class BackgroundTypeWallpaper(TlObject, BackgroundType):
    r"""A wallpaper in JPEG format

    Parameters:
        is_blurred (:class:`bool`):
            True, if the wallpaper must be downscaled to fit in 450x450 square and then box\-blurred with radius 12

        is_moving (:class:`bool`):
            True, if the background needs to be slightly moved when device is tilted

    """

    def __init__(self, is_blurred: bool = False, is_moving: bool = False) -> None:
        self.is_blurred: bool = bool(is_blurred)
        r"""True, if the wallpaper must be downscaled to fit in 450x450 square and then box\-blurred with radius 12"""
        self.is_moving: bool = bool(is_moving)
        r"""True, if the background needs to be slightly moved when device is tilted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgroundTypeWallpaper"]:
        return "backgroundTypeWallpaper"

    def getClass(self) -> Literal["BackgroundType"]:
        return "BackgroundType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_blurred": self.is_blurred,
            "is_moving": self.is_moving,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BackgroundTypeWallpaper", None]:
        if data:
            data_class = cls()
            data_class.is_blurred = data.get("is_blurred", False)
            data_class.is_moving = data.get("is_moving", False)

        return data_class


class BackgroundTypePattern(TlObject, BackgroundType):
    r"""A PNG or TGV \(gzipped subset of SVG with MIME type \"application/x\-tgwallpattern\"\) pattern to be combined with the background fill chosen by the user

    Parameters:
        fill (:class:`"types.BackgroundFill"`):
            Fill of the background

        intensity (:class:`int`):
            Intensity of the pattern when it is shown above the filled background; 0\-100

        is_inverted (:class:`bool`):
            True, if the background fill must be applied only to the pattern itself\. All other pixels are black in this case\. For dark themes only

        is_moving (:class:`bool`):
            True, if the background needs to be slightly moved when device is tilted

    """

    def __init__(
        self,
        fill: BackgroundFill = None,
        intensity: int = 0,
        is_inverted: bool = False,
        is_moving: bool = False,
    ) -> None:
        self.fill: Union[
            BackgroundFillSolid,
            BackgroundFillGradient,
            BackgroundFillFreeformGradient,
            None,
        ] = fill
        r"""Fill of the background"""
        self.intensity: int = int(intensity)
        r"""Intensity of the pattern when it is shown above the filled background; 0\-100"""
        self.is_inverted: bool = bool(is_inverted)
        r"""True, if the background fill must be applied only to the pattern itself\. All other pixels are black in this case\. For dark themes only"""
        self.is_moving: bool = bool(is_moving)
        r"""True, if the background needs to be slightly moved when device is tilted"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgroundTypePattern"]:
        return "backgroundTypePattern"

    def getClass(self) -> Literal["BackgroundType"]:
        return "BackgroundType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "fill": self.fill,
            "intensity": self.intensity,
            "is_inverted": self.is_inverted,
            "is_moving": self.is_moving,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BackgroundTypePattern", None]:
        if data:
            data_class = cls()
            data_class.fill = data.get("fill", None)
            data_class.intensity = int(data.get("intensity", 0))
            data_class.is_inverted = data.get("is_inverted", False)
            data_class.is_moving = data.get("is_moving", False)

        return data_class


class BackgroundTypeFill(TlObject, BackgroundType):
    r"""A filled background

    Parameters:
        fill (:class:`"types.BackgroundFill"`):
            The background fill

    """

    def __init__(self, fill: BackgroundFill = None) -> None:
        self.fill: Union[
            BackgroundFillSolid,
            BackgroundFillGradient,
            BackgroundFillFreeformGradient,
            None,
        ] = fill
        r"""The background fill"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgroundTypeFill"]:
        return "backgroundTypeFill"

    def getClass(self) -> Literal["BackgroundType"]:
        return "BackgroundType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "fill": self.fill}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BackgroundTypeFill", None]:
        if data:
            data_class = cls()
            data_class.fill = data.get("fill", None)

        return data_class


class BackgroundTypeChatTheme(TlObject, BackgroundType):
    r"""A background from a chat theme; can be used only as a chat background in channels

    Parameters:
        theme_name (:class:`str`):
            Name of the chat theme

    """

    def __init__(self, theme_name: str = "") -> None:
        self.theme_name: Union[str, None] = theme_name
        r"""Name of the chat theme"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["backgroundTypeChatTheme"]:
        return "backgroundTypeChatTheme"

    def getClass(self) -> Literal["BackgroundType"]:
        return "BackgroundType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "theme_name": self.theme_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BackgroundTypeChatTheme", None]:
        if data:
            data_class = cls()
            data_class.theme_name = data.get("theme_name", "")

        return data_class


class InputBackgroundLocal(TlObject, InputBackground):
    r"""A background from a local file

    Parameters:
        background (:class:`"types.InputFile"`):
            Background file to use\. Only inputFileLocal and inputFileGenerated are supported\. The file must be in JPEG format for wallpapers and in PNG format for patterns

    """

    def __init__(self, background: InputFile = None) -> None:
        self.background: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = background
        r"""Background file to use\. Only inputFileLocal and inputFileGenerated are supported\. The file must be in JPEG format for wallpapers and in PNG format for patterns"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputBackgroundLocal"]:
        return "inputBackgroundLocal"

    def getClass(self) -> Literal["InputBackground"]:
        return "InputBackground"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "background": self.background}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputBackgroundLocal", None]:
        if data:
            data_class = cls()
            data_class.background = data.get("background", None)

        return data_class


class InputBackgroundRemote(TlObject, InputBackground):
    r"""A background from the server

    Parameters:
        background_id (:class:`int`):
            The background identifier

    """

    def __init__(self, background_id: int = 0) -> None:
        self.background_id: int = int(background_id)
        r"""The background identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputBackgroundRemote"]:
        return "inputBackgroundRemote"

    def getClass(self) -> Literal["InputBackground"]:
        return "InputBackground"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "background_id": self.background_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputBackgroundRemote", None]:
        if data:
            data_class = cls()
            data_class.background_id = int(data.get("background_id", 0))

        return data_class


class InputBackgroundPrevious(TlObject, InputBackground):
    r"""A background previously set in the chat; for chat backgrounds only

    Parameters:
        message_id (:class:`int`):
            Identifier of the message with the background

    """

    def __init__(self, message_id: int = 0) -> None:
        self.message_id: int = int(message_id)
        r"""Identifier of the message with the background"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputBackgroundPrevious"]:
        return "inputBackgroundPrevious"

    def getClass(self) -> Literal["InputBackground"]:
        return "InputBackground"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message_id": self.message_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputBackgroundPrevious", None]:
        if data:
            data_class = cls()
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class ChatTheme(TlObject):
    r"""Describes a chat theme

    Parameters:
        name (:class:`str`):
            Theme name

        light_settings (:class:`"types.ThemeSettings"`):
            Theme settings for a light chat theme

        dark_settings (:class:`"types.ThemeSettings"`):
            Theme settings for a dark chat theme

    """

    def __init__(
        self,
        name: str = "",
        light_settings: ThemeSettings = None,
        dark_settings: ThemeSettings = None,
    ) -> None:
        self.name: Union[str, None] = name
        r"""Theme name"""
        self.light_settings: Union[ThemeSettings, None] = light_settings
        r"""Theme settings for a light chat theme"""
        self.dark_settings: Union[ThemeSettings, None] = dark_settings
        r"""Theme settings for a dark chat theme"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatTheme"]:
        return "chatTheme"

    def getClass(self) -> Literal["ChatTheme"]:
        return "ChatTheme"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "name": self.name,
            "light_settings": self.light_settings,
            "dark_settings": self.dark_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatTheme", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.light_settings = data.get("light_settings", None)
            data_class.dark_settings = data.get("dark_settings", None)

        return data_class


class TimeZone(TlObject):
    r"""Describes a time zone

    Parameters:
        id (:class:`str`):
            Unique time zone identifier

        name (:class:`str`):
            Time zone name

        utc_time_offset (:class:`int`):
            Current UTC time offset for the time zone

    """

    def __init__(self, id: str = "", name: str = "", utc_time_offset: int = 0) -> None:
        self.id: Union[str, None] = id
        r"""Unique time zone identifier"""
        self.name: Union[str, None] = name
        r"""Time zone name"""
        self.utc_time_offset: int = int(utc_time_offset)
        r"""Current UTC time offset for the time zone"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["timeZone"]:
        return "timeZone"

    def getClass(self) -> Literal["TimeZone"]:
        return "TimeZone"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "name": self.name,
            "utc_time_offset": self.utc_time_offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["TimeZone", None]:
        if data:
            data_class = cls()
            data_class.id = data.get("id", "")
            data_class.name = data.get("name", "")
            data_class.utc_time_offset = int(data.get("utc_time_offset", 0))

        return data_class


class TimeZones(TlObject):
    r"""Contains a list of time zones

    Parameters:
        time_zones (:class:`List["types.TimeZone"]`):
            A list of time zones

    """

    def __init__(self, time_zones: List[TimeZone] = None) -> None:
        self.time_zones: List[TimeZone] = time_zones or []
        r"""A list of time zones"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["timeZones"]:
        return "timeZones"

    def getClass(self) -> Literal["TimeZones"]:
        return "TimeZones"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "time_zones": self.time_zones}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TimeZones", None]:
        if data:
            data_class = cls()
            data_class.time_zones = data.get("time_zones", None)

        return data_class


class Hashtags(TlObject):
    r"""Contains a list of hashtags

    Parameters:
        hashtags (:class:`List[str]`):
            A list of hashtags

    """

    def __init__(self, hashtags: List[str] = None) -> None:
        self.hashtags: List[str] = hashtags or []
        r"""A list of hashtags"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["hashtags"]:
        return "hashtags"

    def getClass(self) -> Literal["Hashtags"]:
        return "Hashtags"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "hashtags": self.hashtags}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Hashtags", None]:
        if data:
            data_class = cls()
            data_class.hashtags = data.get("hashtags", None)

        return data_class


class CanSendStoryResultOk(TlObject, CanSendStoryResult):
    r"""A story can be sent"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendStoryResultOk"]:
        return "canSendStoryResultOk"

    def getClass(self) -> Literal["CanSendStoryResult"]:
        return "CanSendStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CanSendStoryResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class CanSendStoryResultPremiumNeeded(TlObject, CanSendStoryResult):
    r"""The user must subscribe to Telegram Premium to be able to post stories"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendStoryResultPremiumNeeded"]:
        return "canSendStoryResultPremiumNeeded"

    def getClass(self) -> Literal["CanSendStoryResult"]:
        return "CanSendStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CanSendStoryResultPremiumNeeded", None]:
        if data:
            data_class = cls()

        return data_class


class CanSendStoryResultBoostNeeded(TlObject, CanSendStoryResult):
    r"""The chat must be boosted first by Telegram Premium subscribers to post more stories\. Call getChatBoostStatus to get current boost status of the chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendStoryResultBoostNeeded"]:
        return "canSendStoryResultBoostNeeded"

    def getClass(self) -> Literal["CanSendStoryResult"]:
        return "CanSendStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CanSendStoryResultBoostNeeded", None]:
        if data:
            data_class = cls()

        return data_class


class CanSendStoryResultActiveStoryLimitExceeded(TlObject, CanSendStoryResult):
    r"""The limit for the number of active stories exceeded\. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendStoryResultActiveStoryLimitExceeded"]:
        return "canSendStoryResultActiveStoryLimitExceeded"

    def getClass(self) -> Literal["CanSendStoryResult"]:
        return "CanSendStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanSendStoryResultActiveStoryLimitExceeded", None]:
        if data:
            data_class = cls()

        return data_class


class CanSendStoryResultWeeklyLimitExceeded(TlObject, CanSendStoryResult):
    r"""The weekly limit for the number of posted stories exceeded\. The user needs to buy Telegram Premium or wait specified time

    Parameters:
        retry_after (:class:`int`):
            Time left before the user can send the next story

    """

    def __init__(self, retry_after: int = 0) -> None:
        self.retry_after: int = int(retry_after)
        r"""Time left before the user can send the next story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendStoryResultWeeklyLimitExceeded"]:
        return "canSendStoryResultWeeklyLimitExceeded"

    def getClass(self) -> Literal["CanSendStoryResult"]:
        return "CanSendStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "retry_after": self.retry_after}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanSendStoryResultWeeklyLimitExceeded", None]:
        if data:
            data_class = cls()
            data_class.retry_after = int(data.get("retry_after", 0))

        return data_class


class CanSendStoryResultMonthlyLimitExceeded(TlObject, CanSendStoryResult):
    r"""The monthly limit for the number of posted stories exceeded\. The user needs to buy Telegram Premium or wait specified time

    Parameters:
        retry_after (:class:`int`):
            Time left before the user can send the next story

    """

    def __init__(self, retry_after: int = 0) -> None:
        self.retry_after: int = int(retry_after)
        r"""Time left before the user can send the next story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendStoryResultMonthlyLimitExceeded"]:
        return "canSendStoryResultMonthlyLimitExceeded"

    def getClass(self) -> Literal["CanSendStoryResult"]:
        return "CanSendStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "retry_after": self.retry_after}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanSendStoryResultMonthlyLimitExceeded", None]:
        if data:
            data_class = cls()
            data_class.retry_after = int(data.get("retry_after", 0))

        return data_class


class CanTransferOwnershipResultOk(TlObject, CanTransferOwnershipResult):
    r"""The session can be used"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canTransferOwnershipResultOk"]:
        return "canTransferOwnershipResultOk"

    def getClass(self) -> Literal["CanTransferOwnershipResult"]:
        return "CanTransferOwnershipResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CanTransferOwnershipResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class CanTransferOwnershipResultPasswordNeeded(TlObject, CanTransferOwnershipResult):
    r"""The 2\-step verification needs to be enabled first"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canTransferOwnershipResultPasswordNeeded"]:
        return "canTransferOwnershipResultPasswordNeeded"

    def getClass(self) -> Literal["CanTransferOwnershipResult"]:
        return "CanTransferOwnershipResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanTransferOwnershipResultPasswordNeeded", None]:
        if data:
            data_class = cls()

        return data_class


class CanTransferOwnershipResultPasswordTooFresh(TlObject, CanTransferOwnershipResult):
    r"""The 2\-step verification was enabled recently, user needs to wait

    Parameters:
        retry_after (:class:`int`):
            Time left before the session can be used to transfer ownership of a chat, in seconds

    """

    def __init__(self, retry_after: int = 0) -> None:
        self.retry_after: int = int(retry_after)
        r"""Time left before the session can be used to transfer ownership of a chat, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canTransferOwnershipResultPasswordTooFresh"]:
        return "canTransferOwnershipResultPasswordTooFresh"

    def getClass(self) -> Literal["CanTransferOwnershipResult"]:
        return "CanTransferOwnershipResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "retry_after": self.retry_after}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanTransferOwnershipResultPasswordTooFresh", None]:
        if data:
            data_class = cls()
            data_class.retry_after = int(data.get("retry_after", 0))

        return data_class


class CanTransferOwnershipResultSessionTooFresh(TlObject, CanTransferOwnershipResult):
    r"""The session was created recently, user needs to wait

    Parameters:
        retry_after (:class:`int`):
            Time left before the session can be used to transfer ownership of a chat, in seconds

    """

    def __init__(self, retry_after: int = 0) -> None:
        self.retry_after: int = int(retry_after)
        r"""Time left before the session can be used to transfer ownership of a chat, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canTransferOwnershipResultSessionTooFresh"]:
        return "canTransferOwnershipResultSessionTooFresh"

    def getClass(self) -> Literal["CanTransferOwnershipResult"]:
        return "CanTransferOwnershipResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "retry_after": self.retry_after}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanTransferOwnershipResultSessionTooFresh", None]:
        if data:
            data_class = cls()
            data_class.retry_after = int(data.get("retry_after", 0))

        return data_class


class CheckChatUsernameResultOk(TlObject, CheckChatUsernameResult):
    r"""The username can be set"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkChatUsernameResultOk"]:
        return "checkChatUsernameResultOk"

    def getClass(self) -> Literal["CheckChatUsernameResult"]:
        return "CheckChatUsernameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CheckChatUsernameResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class CheckChatUsernameResultUsernameInvalid(TlObject, CheckChatUsernameResult):
    r"""The username is invalid"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkChatUsernameResultUsernameInvalid"]:
        return "checkChatUsernameResultUsernameInvalid"

    def getClass(self) -> Literal["CheckChatUsernameResult"]:
        return "CheckChatUsernameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CheckChatUsernameResultUsernameInvalid", None]:
        if data:
            data_class = cls()

        return data_class


class CheckChatUsernameResultUsernameOccupied(TlObject, CheckChatUsernameResult):
    r"""The username is occupied"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkChatUsernameResultUsernameOccupied"]:
        return "checkChatUsernameResultUsernameOccupied"

    def getClass(self) -> Literal["CheckChatUsernameResult"]:
        return "CheckChatUsernameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CheckChatUsernameResultUsernameOccupied", None]:
        if data:
            data_class = cls()

        return data_class


class CheckChatUsernameResultUsernamePurchasable(TlObject, CheckChatUsernameResult):
    r"""The username can be purchased at https://fragment\.com\. Information about the username can be received using getCollectibleItemInfo"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkChatUsernameResultUsernamePurchasable"]:
        return "checkChatUsernameResultUsernamePurchasable"

    def getClass(self) -> Literal["CheckChatUsernameResult"]:
        return "CheckChatUsernameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CheckChatUsernameResultUsernamePurchasable", None]:
        if data:
            data_class = cls()

        return data_class


class CheckChatUsernameResultPublicChatsTooMany(TlObject, CheckChatUsernameResult):
    r"""The user has too many chats with username, one of them must be made private first"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkChatUsernameResultPublicChatsTooMany"]:
        return "checkChatUsernameResultPublicChatsTooMany"

    def getClass(self) -> Literal["CheckChatUsernameResult"]:
        return "CheckChatUsernameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CheckChatUsernameResultPublicChatsTooMany", None]:
        if data:
            data_class = cls()

        return data_class


class CheckChatUsernameResultPublicGroupsUnavailable(TlObject, CheckChatUsernameResult):
    r"""The user can't be a member of a public supergroup"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkChatUsernameResultPublicGroupsUnavailable"]:
        return "checkChatUsernameResultPublicGroupsUnavailable"

    def getClass(self) -> Literal["CheckChatUsernameResult"]:
        return "CheckChatUsernameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CheckChatUsernameResultPublicGroupsUnavailable", None]:
        if data:
            data_class = cls()

        return data_class


class CheckStickerSetNameResultOk(TlObject, CheckStickerSetNameResult):
    r"""The name can be set"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkStickerSetNameResultOk"]:
        return "checkStickerSetNameResultOk"

    def getClass(self) -> Literal["CheckStickerSetNameResult"]:
        return "CheckStickerSetNameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CheckStickerSetNameResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class CheckStickerSetNameResultNameInvalid(TlObject, CheckStickerSetNameResult):
    r"""The name is invalid"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkStickerSetNameResultNameInvalid"]:
        return "checkStickerSetNameResultNameInvalid"

    def getClass(self) -> Literal["CheckStickerSetNameResult"]:
        return "CheckStickerSetNameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CheckStickerSetNameResultNameInvalid", None]:
        if data:
            data_class = cls()

        return data_class


class CheckStickerSetNameResultNameOccupied(TlObject, CheckStickerSetNameResult):
    r"""The name is occupied"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["checkStickerSetNameResultNameOccupied"]:
        return "checkStickerSetNameResultNameOccupied"

    def getClass(self) -> Literal["CheckStickerSetNameResult"]:
        return "CheckStickerSetNameResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CheckStickerSetNameResultNameOccupied", None]:
        if data:
            data_class = cls()

        return data_class


class ResetPasswordResultOk(TlObject, ResetPasswordResult):
    r"""The password was reset"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["resetPasswordResultOk"]:
        return "resetPasswordResultOk"

    def getClass(self) -> Literal["ResetPasswordResult"]:
        return "ResetPasswordResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ResetPasswordResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class ResetPasswordResultPending(TlObject, ResetPasswordResult):
    r"""The password reset request is pending

    Parameters:
        pending_reset_date (:class:`int`):
            Point in time \(Unix timestamp\) after which the password can be reset immediately using resetPassword

    """

    def __init__(self, pending_reset_date: int = 0) -> None:
        self.pending_reset_date: int = int(pending_reset_date)
        r"""Point in time \(Unix timestamp\) after which the password can be reset immediately using resetPassword"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["resetPasswordResultPending"]:
        return "resetPasswordResultPending"

    def getClass(self) -> Literal["ResetPasswordResult"]:
        return "ResetPasswordResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "pending_reset_date": self.pending_reset_date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ResetPasswordResultPending", None]:
        if data:
            data_class = cls()
            data_class.pending_reset_date = int(data.get("pending_reset_date", 0))

        return data_class


class ResetPasswordResultDeclined(TlObject, ResetPasswordResult):
    r"""The password reset request was declined

    Parameters:
        retry_date (:class:`int`):
            Point in time \(Unix timestamp\) when the password reset can be retried

    """

    def __init__(self, retry_date: int = 0) -> None:
        self.retry_date: int = int(retry_date)
        r"""Point in time \(Unix timestamp\) when the password reset can be retried"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["resetPasswordResultDeclined"]:
        return "resetPasswordResultDeclined"

    def getClass(self) -> Literal["ResetPasswordResult"]:
        return "ResetPasswordResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "retry_date": self.retry_date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ResetPasswordResultDeclined", None]:
        if data:
            data_class = cls()
            data_class.retry_date = int(data.get("retry_date", 0))

        return data_class


class MessageFileTypePrivate(TlObject, MessageFileType):
    r"""The messages were exported from a private chat

    Parameters:
        name (:class:`str`):
            Name of the other party; may be empty if unrecognized

    """

    def __init__(self, name: str = "") -> None:
        self.name: Union[str, None] = name
        r"""Name of the other party; may be empty if unrecognized"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageFileTypePrivate"]:
        return "messageFileTypePrivate"

    def getClass(self) -> Literal["MessageFileType"]:
        return "MessageFileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageFileTypePrivate", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")

        return data_class


class MessageFileTypeGroup(TlObject, MessageFileType):
    r"""The messages were exported from a group chat

    Parameters:
        title (:class:`str`):
            Title of the group chat; may be empty if unrecognized

    """

    def __init__(self, title: str = "") -> None:
        self.title: Union[str, None] = title
        r"""Title of the group chat; may be empty if unrecognized"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageFileTypeGroup"]:
        return "messageFileTypeGroup"

    def getClass(self) -> Literal["MessageFileType"]:
        return "MessageFileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageFileTypeGroup", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")

        return data_class


class MessageFileTypeUnknown(TlObject, MessageFileType):
    r"""The messages were exported from a chat of unknown type"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageFileTypeUnknown"]:
        return "messageFileTypeUnknown"

    def getClass(self) -> Literal["MessageFileType"]:
        return "MessageFileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageFileTypeUnknown", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentHidden(TlObject, PushMessageContent):
    r"""A general message with hidden content

    Parameters:
        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, is_pinned: bool = False) -> None:
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentHidden"]:
        return "pushMessageContentHidden"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_pinned": self.is_pinned}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentHidden", None]:
        if data:
            data_class = cls()
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentAnimation(TlObject, PushMessageContent):
    r"""An animation message \(GIF\-style\)\.

    Parameters:
        animation (:class:`"types.Animation"`):
            Message content; may be null

        caption (:class:`str`):
            Animation caption

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(
        self, animation: Animation = None, caption: str = "", is_pinned: bool = False
    ) -> None:
        self.animation: Union[Animation, None] = animation
        r"""Message content; may be null"""
        self.caption: Union[str, None] = caption
        r"""Animation caption"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentAnimation"]:
        return "pushMessageContentAnimation"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "animation": self.animation,
            "caption": self.caption,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentAnimation", None]:
        if data:
            data_class = cls()
            data_class.animation = data.get("animation", None)
            data_class.caption = data.get("caption", "")
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentAudio(TlObject, PushMessageContent):
    r"""An audio message

    Parameters:
        audio (:class:`"types.Audio"`):
            Message content; may be null

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, audio: Audio = None, is_pinned: bool = False) -> None:
        self.audio: Union[Audio, None] = audio
        r"""Message content; may be null"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentAudio"]:
        return "pushMessageContentAudio"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "audio": self.audio,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentAudio", None]:
        if data:
            data_class = cls()
            data_class.audio = data.get("audio", None)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentContact(TlObject, PushMessageContent):
    r"""A message with a user contact

    Parameters:
        name (:class:`str`):
            Contact's name

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, name: str = "", is_pinned: bool = False) -> None:
        self.name: Union[str, None] = name
        r"""Contact's name"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentContact"]:
        return "pushMessageContentContact"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name, "is_pinned": self.is_pinned}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentContact", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentContactRegistered(TlObject, PushMessageContent):
    r"""A contact has registered with Telegram"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentContactRegistered"]:
        return "pushMessageContentContactRegistered"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PushMessageContentContactRegistered", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentDocument(TlObject, PushMessageContent):
    r"""A document message \(a general file\)

    Parameters:
        document (:class:`"types.Document"`):
            Message content; may be null

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, document: Document = None, is_pinned: bool = False) -> None:
        self.document: Union[Document, None] = document
        r"""Message content; may be null"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentDocument"]:
        return "pushMessageContentDocument"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "document": self.document,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentDocument", None]:
        if data:
            data_class = cls()
            data_class.document = data.get("document", None)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentGame(TlObject, PushMessageContent):
    r"""A message with a game

    Parameters:
        title (:class:`str`):
            Game title, empty for pinned game message

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, title: str = "", is_pinned: bool = False) -> None:
        self.title: Union[str, None] = title
        r"""Game title, empty for pinned game message"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentGame"]:
        return "pushMessageContentGame"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentGame", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentGameScore(TlObject, PushMessageContent):
    r"""A new high score was achieved in a game

    Parameters:
        title (:class:`str`):
            Game title, empty for pinned message

        score (:class:`int`):
            New score, 0 for pinned message

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(
        self, title: str = "", score: int = 0, is_pinned: bool = False
    ) -> None:
        self.title: Union[str, None] = title
        r"""Game title, empty for pinned message"""
        self.score: int = int(score)
        r"""New score, 0 for pinned message"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentGameScore"]:
        return "pushMessageContentGameScore"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "title": self.title,
            "score": self.score,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentGameScore", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.score = int(data.get("score", 0))
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentInvoice(TlObject, PushMessageContent):
    r"""A message with an invoice from a bot

    Parameters:
        price (:class:`str`):
            Product price

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, price: str = "", is_pinned: bool = False) -> None:
        self.price: Union[str, None] = price
        r"""Product price"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentInvoice"]:
        return "pushMessageContentInvoice"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "price": self.price,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentInvoice", None]:
        if data:
            data_class = cls()
            data_class.price = data.get("price", "")
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentLocation(TlObject, PushMessageContent):
    r"""A message with a location

    Parameters:
        is_live (:class:`bool`):
            True, if the location is live

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, is_live: bool = False, is_pinned: bool = False) -> None:
        self.is_live: bool = bool(is_live)
        r"""True, if the location is live"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentLocation"]:
        return "pushMessageContentLocation"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_live": self.is_live,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentLocation", None]:
        if data:
            data_class = cls()
            data_class.is_live = data.get("is_live", False)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentPaidMedia(TlObject, PushMessageContent):
    r"""A message with paid media

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars needed to buy access to the media in the message; 0 for pinned message

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, star_count: int = 0, is_pinned: bool = False) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars needed to buy access to the media in the message; 0 for pinned message"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentPaidMedia"]:
        return "pushMessageContentPaidMedia"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_count": self.star_count,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentPaidMedia", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentPhoto(TlObject, PushMessageContent):
    r"""A photo message

    Parameters:
        photo (:class:`"types.Photo"`):
            Message content; may be null

        caption (:class:`str`):
            Photo caption

        is_secret (:class:`bool`):
            True, if the photo is secret

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(
        self,
        photo: Photo = None,
        caption: str = "",
        is_secret: bool = False,
        is_pinned: bool = False,
    ) -> None:
        self.photo: Union[Photo, None] = photo
        r"""Message content; may be null"""
        self.caption: Union[str, None] = caption
        r"""Photo caption"""
        self.is_secret: bool = bool(is_secret)
        r"""True, if the photo is secret"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentPhoto"]:
        return "pushMessageContentPhoto"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "photo": self.photo,
            "caption": self.caption,
            "is_secret": self.is_secret,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentPhoto", None]:
        if data:
            data_class = cls()
            data_class.photo = data.get("photo", None)
            data_class.caption = data.get("caption", "")
            data_class.is_secret = data.get("is_secret", False)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentPoll(TlObject, PushMessageContent):
    r"""A message with a poll

    Parameters:
        question (:class:`str`):
            Poll question

        is_regular (:class:`bool`):
            True, if the poll is regular and not in quiz mode

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(
        self, question: str = "", is_regular: bool = False, is_pinned: bool = False
    ) -> None:
        self.question: Union[str, None] = question
        r"""Poll question"""
        self.is_regular: bool = bool(is_regular)
        r"""True, if the poll is regular and not in quiz mode"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentPoll"]:
        return "pushMessageContentPoll"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "question": self.question,
            "is_regular": self.is_regular,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentPoll", None]:
        if data:
            data_class = cls()
            data_class.question = data.get("question", "")
            data_class.is_regular = data.get("is_regular", False)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentPremiumGiftCode(TlObject, PushMessageContent):
    r"""A message with a Telegram Premium gift code created for the user

    Parameters:
        month_count (:class:`int`):
            Number of months the Telegram Premium subscription will be active after code activation

    """

    def __init__(self, month_count: int = 0) -> None:
        self.month_count: int = int(month_count)
        r"""Number of months the Telegram Premium subscription will be active after code activation"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentPremiumGiftCode"]:
        return "pushMessageContentPremiumGiftCode"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "month_count": self.month_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentPremiumGiftCode", None]:
        if data:
            data_class = cls()
            data_class.month_count = int(data.get("month_count", 0))

        return data_class


class PushMessageContentGiveaway(TlObject, PushMessageContent):
    r"""A message with a giveaway

    Parameters:
        winner_count (:class:`int`):
            Number of users which will receive giveaway prizes; 0 for pinned message

        prize (:class:`"types.GiveawayPrize"`):
            Prize of the giveaway; may be null for pinned message

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(
        self,
        winner_count: int = 0,
        prize: GiveawayPrize = None,
        is_pinned: bool = False,
    ) -> None:
        self.winner_count: int = int(winner_count)
        r"""Number of users which will receive giveaway prizes; 0 for pinned message"""
        self.prize: Union[GiveawayPrizePremium, GiveawayPrizeStars, None] = prize
        r"""Prize of the giveaway; may be null for pinned message"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentGiveaway"]:
        return "pushMessageContentGiveaway"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "winner_count": self.winner_count,
            "prize": self.prize,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentGiveaway", None]:
        if data:
            data_class = cls()
            data_class.winner_count = int(data.get("winner_count", 0))
            data_class.prize = data.get("prize", None)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentGift(TlObject, PushMessageContent):
    r"""A message with a gift

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars that sender paid for the gift

    """

    def __init__(self, star_count: int = 0) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars that sender paid for the gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentGift"]:
        return "pushMessageContentGift"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "star_count": self.star_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentGift", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class PushMessageContentUpgradedGift(TlObject, PushMessageContent):
    r"""A message with an upgraded gift

    Parameters:
        is_upgrade (:class:`bool`):
            True, if the gift was obtained by upgrading of a previously received gift; otherwise, this is a transferred gift

    """

    def __init__(self, is_upgrade: bool = False) -> None:
        self.is_upgrade: bool = bool(is_upgrade)
        r"""True, if the gift was obtained by upgrading of a previously received gift; otherwise, this is a transferred gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentUpgradedGift"]:
        return "pushMessageContentUpgradedGift"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_upgrade": self.is_upgrade}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.is_upgrade = data.get("is_upgrade", False)

        return data_class


class PushMessageContentScreenshotTaken(TlObject, PushMessageContent):
    r"""A screenshot of a message in the chat has been taken"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentScreenshotTaken"]:
        return "pushMessageContentScreenshotTaken"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentScreenshotTaken", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentSticker(TlObject, PushMessageContent):
    r"""A message with a sticker

    Parameters:
        sticker (:class:`"types.Sticker"`):
            Message content; may be null

        emoji (:class:`str`):
            Emoji corresponding to the sticker; may be empty

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(
        self, sticker: Sticker = None, emoji: str = "", is_pinned: bool = False
    ) -> None:
        self.sticker: Union[Sticker, None] = sticker
        r"""Message content; may be null"""
        self.emoji: Union[str, None] = emoji
        r"""Emoji corresponding to the sticker; may be empty"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentSticker"]:
        return "pushMessageContentSticker"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker": self.sticker,
            "emoji": self.emoji,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentSticker", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)
            data_class.emoji = data.get("emoji", "")
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentStory(TlObject, PushMessageContent):
    r"""A message with a story

    Parameters:
        is_mention (:class:`bool`):
            True, if the user was mentioned in the story

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, is_mention: bool = False, is_pinned: bool = False) -> None:
        self.is_mention: bool = bool(is_mention)
        r"""True, if the user was mentioned in the story"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentStory"]:
        return "pushMessageContentStory"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_mention": self.is_mention,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentStory", None]:
        if data:
            data_class = cls()
            data_class.is_mention = data.get("is_mention", False)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentText(TlObject, PushMessageContent):
    r"""A text message

    Parameters:
        text (:class:`str`):
            Message text

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, text: str = "", is_pinned: bool = False) -> None:
        self.text: Union[str, None] = text
        r"""Message text"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentText"]:
        return "pushMessageContentText"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text, "is_pinned": self.is_pinned}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentText", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentVideo(TlObject, PushMessageContent):
    r"""A video message

    Parameters:
        video (:class:`"types.Video"`):
            Message content; may be null

        caption (:class:`str`):
            Video caption

        is_secret (:class:`bool`):
            True, if the video is secret

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(
        self,
        video: Video = None,
        caption: str = "",
        is_secret: bool = False,
        is_pinned: bool = False,
    ) -> None:
        self.video: Union[Video, None] = video
        r"""Message content; may be null"""
        self.caption: Union[str, None] = caption
        r"""Video caption"""
        self.is_secret: bool = bool(is_secret)
        r"""True, if the video is secret"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentVideo"]:
        return "pushMessageContentVideo"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video": self.video,
            "caption": self.caption,
            "is_secret": self.is_secret,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentVideo", None]:
        if data:
            data_class = cls()
            data_class.video = data.get("video", None)
            data_class.caption = data.get("caption", "")
            data_class.is_secret = data.get("is_secret", False)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentVideoNote(TlObject, PushMessageContent):
    r"""A video note message

    Parameters:
        video_note (:class:`"types.VideoNote"`):
            Message content; may be null

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, video_note: VideoNote = None, is_pinned: bool = False) -> None:
        self.video_note: Union[VideoNote, None] = video_note
        r"""Message content; may be null"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentVideoNote"]:
        return "pushMessageContentVideoNote"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "video_note": self.video_note,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentVideoNote", None]:
        if data:
            data_class = cls()
            data_class.video_note = data.get("video_note", None)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentVoiceNote(TlObject, PushMessageContent):
    r"""A voice note message

    Parameters:
        voice_note (:class:`"types.VoiceNote"`):
            Message content; may be null

        is_pinned (:class:`bool`):
            True, if the message is a pinned message with the specified content

    """

    def __init__(self, voice_note: VoiceNote = None, is_pinned: bool = False) -> None:
        self.voice_note: Union[VoiceNote, None] = voice_note
        r"""Message content; may be null"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is a pinned message with the specified content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentVoiceNote"]:
        return "pushMessageContentVoiceNote"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "voice_note": self.voice_note,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentVoiceNote", None]:
        if data:
            data_class = cls()
            data_class.voice_note = data.get("voice_note", None)
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class PushMessageContentBasicGroupChatCreate(TlObject, PushMessageContent):
    r"""A newly created basic group"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentBasicGroupChatCreate"]:
        return "pushMessageContentBasicGroupChatCreate"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PushMessageContentBasicGroupChatCreate", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentVideoChatStarted(TlObject, PushMessageContent):
    r"""A video chat or live stream was started"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentVideoChatStarted"]:
        return "pushMessageContentVideoChatStarted"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentVideoChatStarted", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentVideoChatEnded(TlObject, PushMessageContent):
    r"""A video chat or live stream has ended"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentVideoChatEnded"]:
        return "pushMessageContentVideoChatEnded"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentVideoChatEnded", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentInviteVideoChatParticipants(TlObject, PushMessageContent):
    r"""An invitation of participants to a video chat or live stream

    Parameters:
        is_current_user (:class:`bool`):
            True, if the current user was invited to the video chat or the live stream

    """

    def __init__(self, is_current_user: bool = False) -> None:
        self.is_current_user: bool = bool(is_current_user)
        r"""True, if the current user was invited to the video chat or the live stream"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentInviteVideoChatParticipants"]:
        return "pushMessageContentInviteVideoChatParticipants"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_current_user": self.is_current_user}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PushMessageContentInviteVideoChatParticipants", None]:
        if data:
            data_class = cls()
            data_class.is_current_user = data.get("is_current_user", False)

        return data_class


class PushMessageContentChatAddMembers(TlObject, PushMessageContent):
    r"""New chat members were invited to a group

    Parameters:
        member_name (:class:`str`):
            Name of the added member

        is_current_user (:class:`bool`):
            True, if the current user was added to the group

        is_returned (:class:`bool`):
            True, if the user has returned to the group themselves

    """

    def __init__(
        self,
        member_name: str = "",
        is_current_user: bool = False,
        is_returned: bool = False,
    ) -> None:
        self.member_name: Union[str, None] = member_name
        r"""Name of the added member"""
        self.is_current_user: bool = bool(is_current_user)
        r"""True, if the current user was added to the group"""
        self.is_returned: bool = bool(is_returned)
        r"""True, if the user has returned to the group themselves"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatAddMembers"]:
        return "pushMessageContentChatAddMembers"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "member_name": self.member_name,
            "is_current_user": self.is_current_user,
            "is_returned": self.is_returned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentChatAddMembers", None]:
        if data:
            data_class = cls()
            data_class.member_name = data.get("member_name", "")
            data_class.is_current_user = data.get("is_current_user", False)
            data_class.is_returned = data.get("is_returned", False)

        return data_class


class PushMessageContentChatChangePhoto(TlObject, PushMessageContent):
    r"""A chat photo was edited"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatChangePhoto"]:
        return "pushMessageContentChatChangePhoto"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentChatChangePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentChatChangeTitle(TlObject, PushMessageContent):
    r"""A chat title was edited

    Parameters:
        title (:class:`str`):
            New chat title

    """

    def __init__(self, title: str = "") -> None:
        self.title: Union[str, None] = title
        r"""New chat title"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatChangeTitle"]:
        return "pushMessageContentChatChangeTitle"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentChatChangeTitle", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")

        return data_class


class PushMessageContentChatSetBackground(TlObject, PushMessageContent):
    r"""A chat background was edited

    Parameters:
        is_same (:class:`bool`):
            True, if the set background is the same as the background of the current user

    """

    def __init__(self, is_same: bool = False) -> None:
        self.is_same: bool = bool(is_same)
        r"""True, if the set background is the same as the background of the current user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatSetBackground"]:
        return "pushMessageContentChatSetBackground"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_same": self.is_same}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PushMessageContentChatSetBackground", None]:
        if data:
            data_class = cls()
            data_class.is_same = data.get("is_same", False)

        return data_class


class PushMessageContentChatSetTheme(TlObject, PushMessageContent):
    r"""A chat theme was edited

    Parameters:
        theme_name (:class:`str`):
            If non\-empty, name of a new theme, set for the chat\. Otherwise, the chat theme was reset to the default one

    """

    def __init__(self, theme_name: str = "") -> None:
        self.theme_name: Union[str, None] = theme_name
        r"""If non\-empty, name of a new theme, set for the chat\. Otherwise, the chat theme was reset to the default one"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatSetTheme"]:
        return "pushMessageContentChatSetTheme"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "theme_name": self.theme_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentChatSetTheme", None]:
        if data:
            data_class = cls()
            data_class.theme_name = data.get("theme_name", "")

        return data_class


class PushMessageContentChatDeleteMember(TlObject, PushMessageContent):
    r"""A chat member was deleted

    Parameters:
        member_name (:class:`str`):
            Name of the deleted member

        is_current_user (:class:`bool`):
            True, if the current user was deleted from the group

        is_left (:class:`bool`):
            True, if the user has left the group themselves

    """

    def __init__(
        self,
        member_name: str = "",
        is_current_user: bool = False,
        is_left: bool = False,
    ) -> None:
        self.member_name: Union[str, None] = member_name
        r"""Name of the deleted member"""
        self.is_current_user: bool = bool(is_current_user)
        r"""True, if the current user was deleted from the group"""
        self.is_left: bool = bool(is_left)
        r"""True, if the user has left the group themselves"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatDeleteMember"]:
        return "pushMessageContentChatDeleteMember"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "member_name": self.member_name,
            "is_current_user": self.is_current_user,
            "is_left": self.is_left,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentChatDeleteMember", None]:
        if data:
            data_class = cls()
            data_class.member_name = data.get("member_name", "")
            data_class.is_current_user = data.get("is_current_user", False)
            data_class.is_left = data.get("is_left", False)

        return data_class


class PushMessageContentChatJoinByLink(TlObject, PushMessageContent):
    r"""A new member joined the chat via an invite link"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatJoinByLink"]:
        return "pushMessageContentChatJoinByLink"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentChatJoinByLink", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentChatJoinByRequest(TlObject, PushMessageContent):
    r"""A new member was accepted to the chat by an administrator"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentChatJoinByRequest"]:
        return "pushMessageContentChatJoinByRequest"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PushMessageContentChatJoinByRequest", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentRecurringPayment(TlObject, PushMessageContent):
    r"""A new recurring payment was made by the current user

    Parameters:
        amount (:class:`str`):
            The paid amount

    """

    def __init__(self, amount: str = "") -> None:
        self.amount: Union[str, None] = amount
        r"""The paid amount"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentRecurringPayment"]:
        return "pushMessageContentRecurringPayment"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "amount": self.amount}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentRecurringPayment", None]:
        if data:
            data_class = cls()
            data_class.amount = data.get("amount", "")

        return data_class


class PushMessageContentSuggestProfilePhoto(TlObject, PushMessageContent):
    r"""A profile photo was suggested to the user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentSuggestProfilePhoto"]:
        return "pushMessageContentSuggestProfilePhoto"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PushMessageContentSuggestProfilePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class PushMessageContentProximityAlertTriggered(TlObject, PushMessageContent):
    r"""A user in the chat came within proximity alert range from the current user

    Parameters:
        distance (:class:`int`):
            The distance to the user

    """

    def __init__(self, distance: int = 0) -> None:
        self.distance: int = int(distance)
        r"""The distance to the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentProximityAlertTriggered"]:
        return "pushMessageContentProximityAlertTriggered"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "distance": self.distance}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PushMessageContentProximityAlertTriggered", None]:
        if data:
            data_class = cls()
            data_class.distance = int(data.get("distance", 0))

        return data_class


class PushMessageContentMessageForwards(TlObject, PushMessageContent):
    r"""A forwarded messages

    Parameters:
        total_count (:class:`int`):
            Number of forwarded messages

    """

    def __init__(self, total_count: int = 0) -> None:
        self.total_count: int = int(total_count)
        r"""Number of forwarded messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentMessageForwards"]:
        return "pushMessageContentMessageForwards"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "total_count": self.total_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentMessageForwards", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))

        return data_class


class PushMessageContentMediaAlbum(TlObject, PushMessageContent):
    r"""A media album

    Parameters:
        total_count (:class:`int`):
            Number of messages in the album

        has_photos (:class:`bool`):
            True, if the album has at least one photo

        has_videos (:class:`bool`):
            True, if the album has at least one video file

        has_audios (:class:`bool`):
            True, if the album has at least one audio file

        has_documents (:class:`bool`):
            True, if the album has at least one document

    """

    def __init__(
        self,
        total_count: int = 0,
        has_photos: bool = False,
        has_videos: bool = False,
        has_audios: bool = False,
        has_documents: bool = False,
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Number of messages in the album"""
        self.has_photos: bool = bool(has_photos)
        r"""True, if the album has at least one photo"""
        self.has_videos: bool = bool(has_videos)
        r"""True, if the album has at least one video file"""
        self.has_audios: bool = bool(has_audios)
        r"""True, if the album has at least one audio file"""
        self.has_documents: bool = bool(has_documents)
        r"""True, if the album has at least one document"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["pushMessageContentMediaAlbum"]:
        return "pushMessageContentMediaAlbum"

    def getClass(self) -> Literal["PushMessageContent"]:
        return "PushMessageContent"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "has_photos": self.has_photos,
            "has_videos": self.has_videos,
            "has_audios": self.has_audios,
            "has_documents": self.has_documents,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["PushMessageContentMediaAlbum", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.has_photos = data.get("has_photos", False)
            data_class.has_videos = data.get("has_videos", False)
            data_class.has_audios = data.get("has_audios", False)
            data_class.has_documents = data.get("has_documents", False)

        return data_class


class NotificationTypeNewMessage(TlObject, NotificationType):
    r"""New message was received

    Parameters:
        message (:class:`"types.Message"`):
            The message

        show_preview (:class:`bool`):
            True, if message content must be displayed in notifications

    """

    def __init__(self, message: Message = None, show_preview: bool = False) -> None:
        self.message: Union[Message, None] = message
        r"""The message"""
        self.show_preview: bool = bool(show_preview)
        r"""True, if message content must be displayed in notifications"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationTypeNewMessage"]:
        return "notificationTypeNewMessage"

    def getClass(self) -> Literal["NotificationType"]:
        return "NotificationType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message": self.message,
            "show_preview": self.show_preview,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationTypeNewMessage", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)
            data_class.show_preview = data.get("show_preview", False)

        return data_class


class NotificationTypeNewSecretChat(TlObject, NotificationType):
    r"""New secret chat was created"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationTypeNewSecretChat"]:
        return "notificationTypeNewSecretChat"

    def getClass(self) -> Literal["NotificationType"]:
        return "NotificationType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationTypeNewSecretChat", None]:
        if data:
            data_class = cls()

        return data_class


class NotificationTypeNewCall(TlObject, NotificationType):
    r"""New call was received

    Parameters:
        call_id (:class:`int`):
            Call identifier

    """

    def __init__(self, call_id: int = 0) -> None:
        self.call_id: int = int(call_id)
        r"""Call identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationTypeNewCall"]:
        return "notificationTypeNewCall"

    def getClass(self) -> Literal["NotificationType"]:
        return "NotificationType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "call_id": self.call_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationTypeNewCall", None]:
        if data:
            data_class = cls()
            data_class.call_id = int(data.get("call_id", 0))

        return data_class


class NotificationTypeNewPushMessage(TlObject, NotificationType):
    r"""New message was received through a push notification

    Parameters:
        message_id (:class:`int`):
            The message identifier\. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat

        sender_id (:class:`"types.MessageSender"`):
            Identifier of the sender of the message\. Corresponding user or chat may be inaccessible

        sender_name (:class:`str`):
            Name of the sender

        is_outgoing (:class:`bool`):
            True, if the message is outgoing

        content (:class:`"types.PushMessageContent"`):
            Push message content

    """

    def __init__(
        self,
        message_id: int = 0,
        sender_id: MessageSender = None,
        sender_name: str = "",
        is_outgoing: bool = False,
        content: PushMessageContent = None,
    ) -> None:
        self.message_id: int = int(message_id)
        r"""The message identifier\. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of the sender of the message\. Corresponding user or chat may be inaccessible"""
        self.sender_name: Union[str, None] = sender_name
        r"""Name of the sender"""
        self.is_outgoing: bool = bool(is_outgoing)
        r"""True, if the message is outgoing"""
        self.content: Union[
            PushMessageContentHidden,
            PushMessageContentAnimation,
            PushMessageContentAudio,
            PushMessageContentContact,
            PushMessageContentContactRegistered,
            PushMessageContentDocument,
            PushMessageContentGame,
            PushMessageContentGameScore,
            PushMessageContentInvoice,
            PushMessageContentLocation,
            PushMessageContentPaidMedia,
            PushMessageContentPhoto,
            PushMessageContentPoll,
            PushMessageContentPremiumGiftCode,
            PushMessageContentGiveaway,
            PushMessageContentGift,
            PushMessageContentUpgradedGift,
            PushMessageContentScreenshotTaken,
            PushMessageContentSticker,
            PushMessageContentStory,
            PushMessageContentText,
            PushMessageContentVideo,
            PushMessageContentVideoNote,
            PushMessageContentVoiceNote,
            PushMessageContentBasicGroupChatCreate,
            PushMessageContentVideoChatStarted,
            PushMessageContentVideoChatEnded,
            PushMessageContentInviteVideoChatParticipants,
            PushMessageContentChatAddMembers,
            PushMessageContentChatChangePhoto,
            PushMessageContentChatChangeTitle,
            PushMessageContentChatSetBackground,
            PushMessageContentChatSetTheme,
            PushMessageContentChatDeleteMember,
            PushMessageContentChatJoinByLink,
            PushMessageContentChatJoinByRequest,
            PushMessageContentRecurringPayment,
            PushMessageContentSuggestProfilePhoto,
            PushMessageContentProximityAlertTriggered,
            PushMessageContentMessageForwards,
            PushMessageContentMediaAlbum,
            None,
        ] = content
        r"""Push message content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationTypeNewPushMessage"]:
        return "notificationTypeNewPushMessage"

    def getClass(self) -> Literal["NotificationType"]:
        return "NotificationType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_id": self.message_id,
            "sender_id": self.sender_id,
            "sender_name": self.sender_name,
            "is_outgoing": self.is_outgoing,
            "content": self.content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationTypeNewPushMessage", None]:
        if data:
            data_class = cls()
            data_class.message_id = int(data.get("message_id", 0))
            data_class.sender_id = data.get("sender_id", None)
            data_class.sender_name = data.get("sender_name", "")
            data_class.is_outgoing = data.get("is_outgoing", False)
            data_class.content = data.get("content", None)

        return data_class


class NotificationGroupTypeMessages(TlObject, NotificationGroupType):
    r"""A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationGroupTypeMessages"]:
        return "notificationGroupTypeMessages"

    def getClass(self) -> Literal["NotificationGroupType"]:
        return "NotificationGroupType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationGroupTypeMessages", None]:
        if data:
            data_class = cls()

        return data_class


class NotificationGroupTypeMentions(TlObject, NotificationGroupType):
    r"""A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationGroupTypeMentions"]:
        return "notificationGroupTypeMentions"

    def getClass(self) -> Literal["NotificationGroupType"]:
        return "NotificationGroupType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationGroupTypeMentions", None]:
        if data:
            data_class = cls()

        return data_class


class NotificationGroupTypeSecretChat(TlObject, NotificationGroupType):
    r"""A group containing a notification of type notificationTypeNewSecretChat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationGroupTypeSecretChat"]:
        return "notificationGroupTypeSecretChat"

    def getClass(self) -> Literal["NotificationGroupType"]:
        return "NotificationGroupType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationGroupTypeSecretChat", None]:
        if data:
            data_class = cls()

        return data_class


class NotificationGroupTypeCalls(TlObject, NotificationGroupType):
    r"""A group containing notifications of type notificationTypeNewCall"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationGroupTypeCalls"]:
        return "notificationGroupTypeCalls"

    def getClass(self) -> Literal["NotificationGroupType"]:
        return "NotificationGroupType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationGroupTypeCalls", None]:
        if data:
            data_class = cls()

        return data_class


class NotificationSound(TlObject):
    r"""Describes a notification sound in MP3 format

    Parameters:
        id (:class:`int`):
            Unique identifier of the notification sound

        duration (:class:`int`):
            Duration of the sound, in seconds

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the sound was created

        title (:class:`str`):
            Title of the notification sound

        data (:class:`str`):
            Arbitrary data, defined while the sound was uploaded

        sound (:class:`"types.File"`):
            File containing the sound

    """

    def __init__(
        self,
        id: int = 0,
        duration: int = 0,
        date: int = 0,
        title: str = "",
        data: str = "",
        sound: File = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the notification sound"""
        self.duration: int = int(duration)
        r"""Duration of the sound, in seconds"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the sound was created"""
        self.title: Union[str, None] = title
        r"""Title of the notification sound"""
        self.data: Union[str, None] = data
        r"""Arbitrary data, defined while the sound was uploaded"""
        self.sound: Union[File, None] = sound
        r"""File containing the sound"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationSound"]:
        return "notificationSound"

    def getClass(self) -> Literal["NotificationSound"]:
        return "NotificationSound"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "duration": self.duration,
            "date": self.date,
            "title": self.title,
            "data": self.data,
            "sound": self.sound,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationSound", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.duration = int(data.get("duration", 0))
            data_class.date = int(data.get("date", 0))
            data_class.title = data.get("title", "")
            data_class.data = data.get("data", "")
            data_class.sound = data.get("sound", None)

        return data_class


class NotificationSounds(TlObject):
    r"""Contains a list of notification sounds

    Parameters:
        notification_sounds (:class:`List["types.NotificationSound"]`):
            A list of notification sounds

    """

    def __init__(self, notification_sounds: List[NotificationSound] = None) -> None:
        self.notification_sounds: List[NotificationSound] = notification_sounds or []
        r"""A list of notification sounds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationSounds"]:
        return "notificationSounds"

    def getClass(self) -> Literal["NotificationSounds"]:
        return "NotificationSounds"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "notification_sounds": self.notification_sounds,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationSounds", None]:
        if data:
            data_class = cls()
            data_class.notification_sounds = data.get("notification_sounds", None)

        return data_class


class Notification(TlObject):
    r"""Contains information about a notification

    Parameters:
        id (:class:`int`):
            Unique persistent identifier of this notification

        date (:class:`int`):
            Notification date

        is_silent (:class:`bool`):
            True, if the notification was explicitly sent without sound

        type (:class:`"types.NotificationType"`):
            Notification type

    """

    def __init__(
        self,
        id: int = 0,
        date: int = 0,
        is_silent: bool = False,
        type: NotificationType = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique persistent identifier of this notification"""
        self.date: int = int(date)
        r"""Notification date"""
        self.is_silent: bool = bool(is_silent)
        r"""True, if the notification was explicitly sent without sound"""
        self.type: Union[
            NotificationTypeNewMessage,
            NotificationTypeNewSecretChat,
            NotificationTypeNewCall,
            NotificationTypeNewPushMessage,
            None,
        ] = type
        r"""Notification type"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notification"]:
        return "notification"

    def getClass(self) -> Literal["Notification"]:
        return "Notification"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "date": self.date,
            "is_silent": self.is_silent,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Notification", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.is_silent = data.get("is_silent", False)
            data_class.type = data.get("type", None)

        return data_class


class NotificationGroup(TlObject):
    r"""Describes a group of notifications

    Parameters:
        id (:class:`int`):
            Unique persistent auto\-incremented from 1 identifier of the notification group

        type (:class:`"types.NotificationGroupType"`):
            Type of the group

        chat_id (:class:`int`):
            Identifier of a chat to which all notifications in the group belong

        total_count (:class:`int`):
            Total number of active notifications in the group

        notifications (:class:`List["types.Notification"]`):
            The list of active notifications

    """

    def __init__(
        self,
        id: int = 0,
        type: NotificationGroupType = None,
        chat_id: int = 0,
        total_count: int = 0,
        notifications: List[Notification] = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique persistent auto\-incremented from 1 identifier of the notification group"""
        self.type: Union[
            NotificationGroupTypeMessages,
            NotificationGroupTypeMentions,
            NotificationGroupTypeSecretChat,
            NotificationGroupTypeCalls,
            None,
        ] = type
        r"""Type of the group"""
        self.chat_id: int = int(chat_id)
        r"""Identifier of a chat to which all notifications in the group belong"""
        self.total_count: int = int(total_count)
        r"""Total number of active notifications in the group"""
        self.notifications: List[Notification] = notifications or []
        r"""The list of active notifications"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["notificationGroup"]:
        return "notificationGroup"

    def getClass(self) -> Literal["NotificationGroup"]:
        return "NotificationGroup"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "type": self.type,
            "chat_id": self.chat_id,
            "total_count": self.total_count,
            "notifications": self.notifications,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NotificationGroup", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.type = data.get("type", None)
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.total_count = int(data.get("total_count", 0))
            data_class.notifications = data.get("notifications", None)

        return data_class


class OptionValueBoolean(TlObject, OptionValue):
    r"""Represents a boolean option

    Parameters:
        value (:class:`bool`):
            The value of the option

    """

    def __init__(self, value: bool = False) -> None:
        self.value: bool = bool(value)
        r"""The value of the option"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["optionValueBoolean"]:
        return "optionValueBoolean"

    def getClass(self) -> Literal["OptionValue"]:
        return "OptionValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["OptionValueBoolean", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", False)

        return data_class


class OptionValueEmpty(TlObject, OptionValue):
    r"""Represents an unknown option or an option which has a default value"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["optionValueEmpty"]:
        return "optionValueEmpty"

    def getClass(self) -> Literal["OptionValue"]:
        return "OptionValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["OptionValueEmpty", None]:
        if data:
            data_class = cls()

        return data_class


class OptionValueInteger(TlObject, OptionValue):
    r"""Represents an integer option

    Parameters:
        value (:class:`int`):
            The value of the option

    """

    def __init__(self, value: int = 0) -> None:
        self.value: int = int(value)
        r"""The value of the option"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["optionValueInteger"]:
        return "optionValueInteger"

    def getClass(self) -> Literal["OptionValue"]:
        return "OptionValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["OptionValueInteger", None]:
        if data:
            data_class = cls()
            data_class.value = int(data.get("value", 0))

        return data_class


class OptionValueString(TlObject, OptionValue):
    r"""Represents a string option

    Parameters:
        value (:class:`str`):
            The value of the option

    """

    def __init__(self, value: str = "") -> None:
        self.value: Union[str, None] = value
        r"""The value of the option"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["optionValueString"]:
        return "optionValueString"

    def getClass(self) -> Literal["OptionValue"]:
        return "OptionValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["OptionValueString", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", "")

        return data_class


class JsonObjectMember(TlObject):
    r"""Represents one member of a JSON object

    Parameters:
        key (:class:`str`):
            Member's key

        value (:class:`"types.JsonValue"`):
            Member's value

    """

    def __init__(self, key: str = "", value: JsonValue = None) -> None:
        self.key: Union[str, None] = key
        r"""Member's key"""
        self.value: Union[
            JsonValueNull,
            JsonValueBoolean,
            JsonValueNumber,
            JsonValueString,
            JsonValueArray,
            JsonValueObject,
            None,
        ] = value
        r"""Member's value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["jsonObjectMember"]:
        return "jsonObjectMember"

    def getClass(self) -> Literal["JsonObjectMember"]:
        return "JsonObjectMember"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "key": self.key, "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["JsonObjectMember", None]:
        if data:
            data_class = cls()
            data_class.key = data.get("key", "")
            data_class.value = data.get("value", None)

        return data_class


class JsonValueNull(TlObject, JsonValue):
    r"""Represents a null JSON value"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["jsonValueNull"]:
        return "jsonValueNull"

    def getClass(self) -> Literal["JsonValue"]:
        return "JsonValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["JsonValueNull", None]:
        if data:
            data_class = cls()

        return data_class


class JsonValueBoolean(TlObject, JsonValue):
    r"""Represents a boolean JSON value

    Parameters:
        value (:class:`bool`):
            The value

    """

    def __init__(self, value: bool = False) -> None:
        self.value: bool = bool(value)
        r"""The value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["jsonValueBoolean"]:
        return "jsonValueBoolean"

    def getClass(self) -> Literal["JsonValue"]:
        return "JsonValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["JsonValueBoolean", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", False)

        return data_class


class JsonValueNumber(TlObject, JsonValue):
    r"""Represents a numeric JSON value

    Parameters:
        value (:class:`float`):
            The value

    """

    def __init__(self, value: float = 0.0) -> None:
        self.value: float = float(value)
        r"""The value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["jsonValueNumber"]:
        return "jsonValueNumber"

    def getClass(self) -> Literal["JsonValue"]:
        return "JsonValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["JsonValueNumber", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", 0.0)

        return data_class


class JsonValueString(TlObject, JsonValue):
    r"""Represents a string JSON value

    Parameters:
        value (:class:`str`):
            The value

    """

    def __init__(self, value: str = "") -> None:
        self.value: Union[str, None] = value
        r"""The value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["jsonValueString"]:
        return "jsonValueString"

    def getClass(self) -> Literal["JsonValue"]:
        return "JsonValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["JsonValueString", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", "")

        return data_class


class JsonValueArray(TlObject, JsonValue):
    r"""Represents a JSON array

    Parameters:
        values (:class:`List["types.JsonValue"]`):
            The list of array elements

    """

    def __init__(self, values: List[JsonValue] = None) -> None:
        self.values: List[JsonValue] = values or []
        r"""The list of array elements"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["jsonValueArray"]:
        return "jsonValueArray"

    def getClass(self) -> Literal["JsonValue"]:
        return "JsonValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "values": self.values}

    @classmethod
    def from_dict(cls, data: dict) -> Union["JsonValueArray", None]:
        if data:
            data_class = cls()
            data_class.values = data.get("values", None)

        return data_class


class JsonValueObject(TlObject, JsonValue):
    r"""Represents a JSON object

    Parameters:
        members (:class:`List["types.JsonObjectMember"]`):
            The list of object members

    """

    def __init__(self, members: List[JsonObjectMember] = None) -> None:
        self.members: List[JsonObjectMember] = members or []
        r"""The list of object members"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["jsonValueObject"]:
        return "jsonValueObject"

    def getClass(self) -> Literal["JsonValue"]:
        return "JsonValue"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "members": self.members}

    @classmethod
    def from_dict(cls, data: dict) -> Union["JsonValueObject", None]:
        if data:
            data_class = cls()
            data_class.members = data.get("members", None)

        return data_class


class StoryPrivacySettingsEveryone(TlObject, StoryPrivacySettings):
    r"""The story can be viewed by everyone

    Parameters:
        except_user_ids (:class:`List[int]`):
            Identifiers of the users that can't see the story; always unknown and empty for non\-owned stories

    """

    def __init__(self, except_user_ids: List[int] = None) -> None:
        self.except_user_ids: List[int] = except_user_ids or []
        r"""Identifiers of the users that can't see the story; always unknown and empty for non\-owned stories"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyPrivacySettingsEveryone"]:
        return "storyPrivacySettingsEveryone"

    def getClass(self) -> Literal["StoryPrivacySettings"]:
        return "StoryPrivacySettings"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "except_user_ids": self.except_user_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryPrivacySettingsEveryone", None]:
        if data:
            data_class = cls()
            data_class.except_user_ids = data.get("except_user_ids", None)

        return data_class


class StoryPrivacySettingsContacts(TlObject, StoryPrivacySettings):
    r"""The story can be viewed by all contacts except chosen users

    Parameters:
        except_user_ids (:class:`List[int]`):
            User identifiers of the contacts that can't see the story; always unknown and empty for non\-owned stories

    """

    def __init__(self, except_user_ids: List[int] = None) -> None:
        self.except_user_ids: List[int] = except_user_ids or []
        r"""User identifiers of the contacts that can't see the story; always unknown and empty for non\-owned stories"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyPrivacySettingsContacts"]:
        return "storyPrivacySettingsContacts"

    def getClass(self) -> Literal["StoryPrivacySettings"]:
        return "StoryPrivacySettings"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "except_user_ids": self.except_user_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryPrivacySettingsContacts", None]:
        if data:
            data_class = cls()
            data_class.except_user_ids = data.get("except_user_ids", None)

        return data_class


class StoryPrivacySettingsCloseFriends(TlObject, StoryPrivacySettings):
    r"""The story can be viewed by all close friends"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyPrivacySettingsCloseFriends"]:
        return "storyPrivacySettingsCloseFriends"

    def getClass(self) -> Literal["StoryPrivacySettings"]:
        return "StoryPrivacySettings"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryPrivacySettingsCloseFriends", None]:
        if data:
            data_class = cls()

        return data_class


class StoryPrivacySettingsSelectedUsers(TlObject, StoryPrivacySettings):
    r"""The story can be viewed by certain specified users

    Parameters:
        user_ids (:class:`List[int]`):
            Identifiers of the users; always unknown and empty for non\-owned stories

    """

    def __init__(self, user_ids: List[int] = None) -> None:
        self.user_ids: List[int] = user_ids or []
        r"""Identifiers of the users; always unknown and empty for non\-owned stories"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyPrivacySettingsSelectedUsers"]:
        return "storyPrivacySettingsSelectedUsers"

    def getClass(self) -> Literal["StoryPrivacySettings"]:
        return "StoryPrivacySettings"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_ids": self.user_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryPrivacySettingsSelectedUsers", None]:
        if data:
            data_class = cls()
            data_class.user_ids = data.get("user_ids", None)

        return data_class


class UserPrivacySettingRuleAllowAll(TlObject, UserPrivacySettingRule):
    r"""A rule to allow all users to do something"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleAllowAll"]:
        return "userPrivacySettingRuleAllowAll"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingRuleAllowAll", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingRuleAllowContacts(TlObject, UserPrivacySettingRule):
    r"""A rule to allow all contacts of the user to do something"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleAllowContacts"]:
        return "userPrivacySettingRuleAllowContacts"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingRuleAllowContacts", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingRuleAllowBots(TlObject, UserPrivacySettingRule):
    r"""A rule to allow all bots to do something"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleAllowBots"]:
        return "userPrivacySettingRuleAllowBots"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingRuleAllowBots", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingRuleAllowPremiumUsers(TlObject, UserPrivacySettingRule):
    r"""A rule to allow all Premium Users to do something; currently, allowed only for userPrivacySettingAllowChatInvites"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleAllowPremiumUsers"]:
        return "userPrivacySettingRuleAllowPremiumUsers"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingRuleAllowPremiumUsers", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingRuleAllowUsers(TlObject, UserPrivacySettingRule):
    r"""A rule to allow certain specified users to do something

    Parameters:
        user_ids (:class:`List[int]`):
            The user identifiers, total number of users in all rules must not exceed 1000

    """

    def __init__(self, user_ids: List[int] = None) -> None:
        self.user_ids: List[int] = user_ids or []
        r"""The user identifiers, total number of users in all rules must not exceed 1000"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleAllowUsers"]:
        return "userPrivacySettingRuleAllowUsers"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_ids": self.user_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingRuleAllowUsers", None]:
        if data:
            data_class = cls()
            data_class.user_ids = data.get("user_ids", None)

        return data_class


class UserPrivacySettingRuleAllowChatMembers(TlObject, UserPrivacySettingRule):
    r"""A rule to allow all members of certain specified basic groups and supergroups to doing something

    Parameters:
        chat_ids (:class:`List[int]`):
            The chat identifiers, total number of chats in all rules must not exceed 20

    """

    def __init__(self, chat_ids: List[int] = None) -> None:
        self.chat_ids: List[int] = chat_ids or []
        r"""The chat identifiers, total number of chats in all rules must not exceed 20"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleAllowChatMembers"]:
        return "userPrivacySettingRuleAllowChatMembers"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_ids": self.chat_ids}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingRuleAllowChatMembers", None]:
        if data:
            data_class = cls()
            data_class.chat_ids = data.get("chat_ids", None)

        return data_class


class UserPrivacySettingRuleRestrictAll(TlObject, UserPrivacySettingRule):
    r"""A rule to restrict all users from doing something"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleRestrictAll"]:
        return "userPrivacySettingRuleRestrictAll"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingRuleRestrictAll", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingRuleRestrictContacts(TlObject, UserPrivacySettingRule):
    r"""A rule to restrict all contacts of the user from doing something"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleRestrictContacts"]:
        return "userPrivacySettingRuleRestrictContacts"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingRuleRestrictContacts", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingRuleRestrictBots(TlObject, UserPrivacySettingRule):
    r"""A rule to restrict all bots from doing something"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleRestrictBots"]:
        return "userPrivacySettingRuleRestrictBots"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingRuleRestrictBots", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingRuleRestrictUsers(TlObject, UserPrivacySettingRule):
    r"""A rule to restrict all specified users from doing something

    Parameters:
        user_ids (:class:`List[int]`):
            The user identifiers, total number of users in all rules must not exceed 1000

    """

    def __init__(self, user_ids: List[int] = None) -> None:
        self.user_ids: List[int] = user_ids or []
        r"""The user identifiers, total number of users in all rules must not exceed 1000"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleRestrictUsers"]:
        return "userPrivacySettingRuleRestrictUsers"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_ids": self.user_ids}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingRuleRestrictUsers", None]:
        if data:
            data_class = cls()
            data_class.user_ids = data.get("user_ids", None)

        return data_class


class UserPrivacySettingRuleRestrictChatMembers(TlObject, UserPrivacySettingRule):
    r"""A rule to restrict all members of specified basic groups and supergroups from doing something

    Parameters:
        chat_ids (:class:`List[int]`):
            The chat identifiers, total number of chats in all rules must not exceed 20

    """

    def __init__(self, chat_ids: List[int] = None) -> None:
        self.chat_ids: List[int] = chat_ids or []
        r"""The chat identifiers, total number of chats in all rules must not exceed 20"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRuleRestrictChatMembers"]:
        return "userPrivacySettingRuleRestrictChatMembers"

    def getClass(self) -> Literal["UserPrivacySettingRule"]:
        return "UserPrivacySettingRule"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_ids": self.chat_ids}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingRuleRestrictChatMembers", None]:
        if data:
            data_class = cls()
            data_class.chat_ids = data.get("chat_ids", None)

        return data_class


class UserPrivacySettingRules(TlObject):
    r"""A list of privacy rules\. Rules are matched in the specified order\. The first matched rule defines the privacy setting for a given user\. If no rule matches, the action is not allowed

    Parameters:
        rules (:class:`List["types.UserPrivacySettingRule"]`):
            A list of rules

    """

    def __init__(self, rules: List[UserPrivacySettingRule] = None) -> None:
        self.rules: List[UserPrivacySettingRule] = rules or []
        r"""A list of rules"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingRules"]:
        return "userPrivacySettingRules"

    def getClass(self) -> Literal["UserPrivacySettingRules"]:
        return "UserPrivacySettingRules"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "rules": self.rules}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingRules", None]:
        if data:
            data_class = cls()
            data_class.rules = data.get("rules", None)

        return data_class


class UserPrivacySettingShowStatus(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user's online status is visible"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingShowStatus"]:
        return "userPrivacySettingShowStatus"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingShowStatus", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingShowProfilePhoto(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user's profile photo is visible"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingShowProfilePhoto"]:
        return "userPrivacySettingShowProfilePhoto"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingShowProfilePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingShowLinkInForwardedMessages(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether a link to the user's account is included in forwarded messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingShowLinkInForwardedMessages"]:
        return "userPrivacySettingShowLinkInForwardedMessages"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingShowLinkInForwardedMessages", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingShowPhoneNumber(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user's phone number is visible"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingShowPhoneNumber"]:
        return "userPrivacySettingShowPhoneNumber"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingShowPhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingShowBio(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user's bio is visible"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingShowBio"]:
        return "userPrivacySettingShowBio"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingShowBio", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingShowBirthdate(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user's birthdate is visible"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingShowBirthdate"]:
        return "userPrivacySettingShowBirthdate"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingShowBirthdate", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingAllowChatInvites(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user can be invited to chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingAllowChatInvites"]:
        return "userPrivacySettingAllowChatInvites"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingAllowChatInvites", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingAllowCalls(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user can be called"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingAllowCalls"]:
        return "userPrivacySettingAllowCalls"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingAllowCalls", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingAllowPeerToPeerCalls(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether peer\-to\-peer connections can be used for calls"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingAllowPeerToPeerCalls"]:
        return "userPrivacySettingAllowPeerToPeerCalls"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingAllowPeerToPeerCalls", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingAllowFindingByPhoneNumber(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user can be found by their phone number\. Checked only if the phone number is not known to the other user\. Can be set only to \"Allow contacts\" or \"Allow all\" """

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingAllowFindingByPhoneNumber"]:
        return "userPrivacySettingAllowFindingByPhoneNumber"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingAllowFindingByPhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages(
    TlObject, UserPrivacySetting
):
    r"""A privacy setting for managing whether the user can receive voice and video messages in private chats; for Telegram Premium users only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(
        self,
    ) -> Literal["userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"]:
        return "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingAutosaveGifts(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether received gifts are automatically shown on the user's profile page"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingAutosaveGifts"]:
        return "userPrivacySettingAutosaveGifts"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserPrivacySettingAutosaveGifts", None]:
        if data:
            data_class = cls()

        return data_class


class UserPrivacySettingAllowUnpaidMessages(TlObject, UserPrivacySetting):
    r"""A privacy setting for managing whether the user can receive messages without additional payment"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userPrivacySettingAllowUnpaidMessages"]:
        return "userPrivacySettingAllowUnpaidMessages"

    def getClass(self) -> Literal["UserPrivacySetting"]:
        return "UserPrivacySetting"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UserPrivacySettingAllowUnpaidMessages", None]:
        if data:
            data_class = cls()

        return data_class


class ReadDatePrivacySettings(TlObject):
    r"""Contains privacy settings for message read date in private chats\. Read dates are always shown to the users that can see online status of the current user regardless of this setting

    Parameters:
        show_read_date (:class:`bool`):
            True, if message read date is shown to other users in private chats\. If false and the current user isn't a Telegram Premium user, then they will not be able to see other's message read date

    """

    def __init__(self, show_read_date: bool = False) -> None:
        self.show_read_date: bool = bool(show_read_date)
        r"""True, if message read date is shown to other users in private chats\. If false and the current user isn't a Telegram Premium user, then they will not be able to see other's message read date"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["readDatePrivacySettings"]:
        return "readDatePrivacySettings"

    def getClass(self) -> Literal["ReadDatePrivacySettings"]:
        return "ReadDatePrivacySettings"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "show_read_date": self.show_read_date}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReadDatePrivacySettings", None]:
        if data:
            data_class = cls()
            data_class.show_read_date = data.get("show_read_date", False)

        return data_class


class NewChatPrivacySettings(TlObject):
    r"""Contains privacy settings for chats with non\-contacts

    Parameters:
        allow_new_chats_from_unknown_users (:class:`bool`):
            True, if non\-contacts users are able to write first to the current user\. Telegram Premium subscribers are able to write first regardless of this setting

        incoming_paid_message_star_count (:class:`int`):
            Number of Telegram Stars that must be paid for every incoming private message by non\-contacts; 0\-getOption\(\"paid\_message\_star\_count\_max\"\)\. If positive, then allow\_new\_chats\_from\_unknown\_users must be true\. The current user will receive getOption\(\"paid\_message\_earnings\_per\_mille\"\) Telegram Stars for each 1000 Telegram Stars paid for message sending\. Can be positive, only if getOption\(\"can\_enable\_paid\_messages\"\) is true

    """

    def __init__(
        self,
        allow_new_chats_from_unknown_users: bool = False,
        incoming_paid_message_star_count: int = 0,
    ) -> None:
        self.allow_new_chats_from_unknown_users: bool = bool(
            allow_new_chats_from_unknown_users
        )
        r"""True, if non\-contacts users are able to write first to the current user\. Telegram Premium subscribers are able to write first regardless of this setting"""
        self.incoming_paid_message_star_count: int = int(
            incoming_paid_message_star_count
        )
        r"""Number of Telegram Stars that must be paid for every incoming private message by non\-contacts; 0\-getOption\(\"paid\_message\_star\_count\_max\"\)\. If positive, then allow\_new\_chats\_from\_unknown\_users must be true\. The current user will receive getOption\(\"paid\_message\_earnings\_per\_mille\"\) Telegram Stars for each 1000 Telegram Stars paid for message sending\. Can be positive, only if getOption\(\"can\_enable\_paid\_messages\"\) is true"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["newChatPrivacySettings"]:
        return "newChatPrivacySettings"

    def getClass(self) -> Literal["NewChatPrivacySettings"]:
        return "NewChatPrivacySettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "allow_new_chats_from_unknown_users": self.allow_new_chats_from_unknown_users,
            "incoming_paid_message_star_count": self.incoming_paid_message_star_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NewChatPrivacySettings", None]:
        if data:
            data_class = cls()
            data_class.allow_new_chats_from_unknown_users = data.get(
                "allow_new_chats_from_unknown_users", False
            )
            data_class.incoming_paid_message_star_count = int(
                data.get("incoming_paid_message_star_count", 0)
            )

        return data_class


class CanSendMessageToUserResultOk(TlObject, CanSendMessageToUserResult):
    r"""The user can be messaged"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendMessageToUserResultOk"]:
        return "canSendMessageToUserResultOk"

    def getClass(self) -> Literal["CanSendMessageToUserResult"]:
        return "CanSendMessageToUserResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["CanSendMessageToUserResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class CanSendMessageToUserResultUserHasPaidMessages(
    TlObject, CanSendMessageToUserResult
):
    r"""The user can be messaged, but the messages are paid

    Parameters:
        outgoing_paid_message_star_count (:class:`int`):
            Number of Telegram Stars that must be paid by the current user for each sent message to the user

    """

    def __init__(self, outgoing_paid_message_star_count: int = 0) -> None:
        self.outgoing_paid_message_star_count: int = int(
            outgoing_paid_message_star_count
        )
        r"""Number of Telegram Stars that must be paid by the current user for each sent message to the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendMessageToUserResultUserHasPaidMessages"]:
        return "canSendMessageToUserResultUserHasPaidMessages"

    def getClass(self) -> Literal["CanSendMessageToUserResult"]:
        return "CanSendMessageToUserResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "outgoing_paid_message_star_count": self.outgoing_paid_message_star_count,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanSendMessageToUserResultUserHasPaidMessages", None]:
        if data:
            data_class = cls()
            data_class.outgoing_paid_message_star_count = int(
                data.get("outgoing_paid_message_star_count", 0)
            )

        return data_class


class CanSendMessageToUserResultUserIsDeleted(TlObject, CanSendMessageToUserResult):
    r"""The user can't be messaged, because they are deleted or unknown"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendMessageToUserResultUserIsDeleted"]:
        return "canSendMessageToUserResultUserIsDeleted"

    def getClass(self) -> Literal["CanSendMessageToUserResult"]:
        return "CanSendMessageToUserResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanSendMessageToUserResultUserIsDeleted", None]:
        if data:
            data_class = cls()

        return data_class


class CanSendMessageToUserResultUserRestrictsNewChats(
    TlObject, CanSendMessageToUserResult
):
    r"""The user can't be messaged, because they restrict new chats with non\-contacts"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["canSendMessageToUserResultUserRestrictsNewChats"]:
        return "canSendMessageToUserResultUserRestrictsNewChats"

    def getClass(self) -> Literal["CanSendMessageToUserResult"]:
        return "CanSendMessageToUserResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["CanSendMessageToUserResultUserRestrictsNewChats", None]:
        if data:
            data_class = cls()

        return data_class


class AccountTtl(TlObject):
    r"""Contains information about the period of inactivity after which the current user's account will automatically be deleted

    Parameters:
        days (:class:`int`):
            Number of days of inactivity before the account will be flagged for deletion; 30\-730 days

    """

    def __init__(self, days: int = 0) -> None:
        self.days: int = int(days)
        r"""Number of days of inactivity before the account will be flagged for deletion; 30\-730 days"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["accountTtl"]:
        return "accountTtl"

    def getClass(self) -> Literal["AccountTtl"]:
        return "AccountTtl"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "days": self.days}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AccountTtl", None]:
        if data:
            data_class = cls()
            data_class.days = int(data.get("days", 0))

        return data_class


class MessageAutoDeleteTime(TlObject):
    r"""Contains default auto\-delete timer setting for new chats

    Parameters:
        time (:class:`int`):
            Message auto\-delete time, in seconds\. If 0, then messages aren't deleted automatically

    """

    def __init__(self, time: int = 0) -> None:
        self.time: int = int(time)
        r"""Message auto\-delete time, in seconds\. If 0, then messages aren't deleted automatically"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageAutoDeleteTime"]:
        return "messageAutoDeleteTime"

    def getClass(self) -> Literal["MessageAutoDeleteTime"]:
        return "MessageAutoDeleteTime"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "time": self.time}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageAutoDeleteTime", None]:
        if data:
            data_class = cls()
            data_class.time = int(data.get("time", 0))

        return data_class


class SessionTypeAndroid(TlObject, SessionType):
    r"""The session is running on an Android device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeAndroid"]:
        return "sessionTypeAndroid"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeAndroid", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeApple(TlObject, SessionType):
    r"""The session is running on a generic Apple device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeApple"]:
        return "sessionTypeApple"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeApple", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeBrave(TlObject, SessionType):
    r"""The session is running on the Brave browser"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeBrave"]:
        return "sessionTypeBrave"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeBrave", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeChrome(TlObject, SessionType):
    r"""The session is running on the Chrome browser"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeChrome"]:
        return "sessionTypeChrome"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeChrome", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeEdge(TlObject, SessionType):
    r"""The session is running on the Edge browser"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeEdge"]:
        return "sessionTypeEdge"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeEdge", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeFirefox(TlObject, SessionType):
    r"""The session is running on the Firefox browser"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeFirefox"]:
        return "sessionTypeFirefox"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeFirefox", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeIpad(TlObject, SessionType):
    r"""The session is running on an iPad device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeIpad"]:
        return "sessionTypeIpad"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeIpad", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeIphone(TlObject, SessionType):
    r"""The session is running on an iPhone device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeIphone"]:
        return "sessionTypeIphone"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeIphone", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeLinux(TlObject, SessionType):
    r"""The session is running on a Linux device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeLinux"]:
        return "sessionTypeLinux"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeLinux", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeMac(TlObject, SessionType):
    r"""The session is running on a Mac device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeMac"]:
        return "sessionTypeMac"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeMac", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeOpera(TlObject, SessionType):
    r"""The session is running on the Opera browser"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeOpera"]:
        return "sessionTypeOpera"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeOpera", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeSafari(TlObject, SessionType):
    r"""The session is running on the Safari browser"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeSafari"]:
        return "sessionTypeSafari"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeSafari", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeUbuntu(TlObject, SessionType):
    r"""The session is running on an Ubuntu device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeUbuntu"]:
        return "sessionTypeUbuntu"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeUbuntu", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeUnknown(TlObject, SessionType):
    r"""The session is running on an unknown type of device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeUnknown"]:
        return "sessionTypeUnknown"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeUnknown", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeVivaldi(TlObject, SessionType):
    r"""The session is running on the Vivaldi browser"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeVivaldi"]:
        return "sessionTypeVivaldi"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeVivaldi", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeWindows(TlObject, SessionType):
    r"""The session is running on a Windows device"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeWindows"]:
        return "sessionTypeWindows"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeWindows", None]:
        if data:
            data_class = cls()

        return data_class


class SessionTypeXbox(TlObject, SessionType):
    r"""The session is running on an Xbox console"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessionTypeXbox"]:
        return "sessionTypeXbox"

    def getClass(self) -> Literal["SessionType"]:
        return "SessionType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SessionTypeXbox", None]:
        if data:
            data_class = cls()

        return data_class


class Session(TlObject):
    r"""Contains information about one session in a Telegram application used by the current user\. Sessions must be shown to the user in the returned order

    Parameters:
        id (:class:`int`):
            Session identifier

        is_current (:class:`bool`):
            True, if this session is the current session

        is_password_pending (:class:`bool`):
            True, if a 2\-step verification password is needed to complete authorization of the session

        is_unconfirmed (:class:`bool`):
            True, if the session wasn't confirmed from another session

        can_accept_secret_chats (:class:`bool`):
            True, if incoming secret chats can be accepted by the session

        can_accept_calls (:class:`bool`):
            True, if incoming calls can be accepted by the session

        type (:class:`"types.SessionType"`):
            Session type based on the system and application version, which can be used to display a corresponding icon

        api_id (:class:`int`):
            Telegram API identifier, as provided by the application

        application_name (:class:`str`):
            Name of the application, as provided by the application

        application_version (:class:`str`):
            The version of the application, as provided by the application

        is_official_application (:class:`bool`):
            True, if the application is an official application or uses the api\_id of an official application

        device_model (:class:`str`):
            Model of the device the application has been run or is running on, as provided by the application

        platform (:class:`str`):
            Operating system the application has been run or is running on, as provided by the application

        system_version (:class:`str`):
            Version of the operating system the application has been run or is running on, as provided by the application

        log_in_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user has logged in

        last_active_date (:class:`int`):
            Point in time \(Unix timestamp\) when the session was last used

        ip_address (:class:`str`):
            IP address from which the session was created, in human\-readable format

        location (:class:`str`):
            A human\-readable description of the location from which the session was created, based on the IP address

    """

    def __init__(
        self,
        id: int = 0,
        is_current: bool = False,
        is_password_pending: bool = False,
        is_unconfirmed: bool = False,
        can_accept_secret_chats: bool = False,
        can_accept_calls: bool = False,
        type: SessionType = None,
        api_id: int = 0,
        application_name: str = "",
        application_version: str = "",
        is_official_application: bool = False,
        device_model: str = "",
        platform: str = "",
        system_version: str = "",
        log_in_date: int = 0,
        last_active_date: int = 0,
        ip_address: str = "",
        location: str = "",
    ) -> None:
        self.id: int = int(id)
        r"""Session identifier"""
        self.is_current: bool = bool(is_current)
        r"""True, if this session is the current session"""
        self.is_password_pending: bool = bool(is_password_pending)
        r"""True, if a 2\-step verification password is needed to complete authorization of the session"""
        self.is_unconfirmed: bool = bool(is_unconfirmed)
        r"""True, if the session wasn't confirmed from another session"""
        self.can_accept_secret_chats: bool = bool(can_accept_secret_chats)
        r"""True, if incoming secret chats can be accepted by the session"""
        self.can_accept_calls: bool = bool(can_accept_calls)
        r"""True, if incoming calls can be accepted by the session"""
        self.type: Union[
            SessionTypeAndroid,
            SessionTypeApple,
            SessionTypeBrave,
            SessionTypeChrome,
            SessionTypeEdge,
            SessionTypeFirefox,
            SessionTypeIpad,
            SessionTypeIphone,
            SessionTypeLinux,
            SessionTypeMac,
            SessionTypeOpera,
            SessionTypeSafari,
            SessionTypeUbuntu,
            SessionTypeUnknown,
            SessionTypeVivaldi,
            SessionTypeWindows,
            SessionTypeXbox,
            None,
        ] = type
        r"""Session type based on the system and application version, which can be used to display a corresponding icon"""
        self.api_id: int = int(api_id)
        r"""Telegram API identifier, as provided by the application"""
        self.application_name: Union[str, None] = application_name
        r"""Name of the application, as provided by the application"""
        self.application_version: Union[str, None] = application_version
        r"""The version of the application, as provided by the application"""
        self.is_official_application: bool = bool(is_official_application)
        r"""True, if the application is an official application or uses the api\_id of an official application"""
        self.device_model: Union[str, None] = device_model
        r"""Model of the device the application has been run or is running on, as provided by the application"""
        self.platform: Union[str, None] = platform
        r"""Operating system the application has been run or is running on, as provided by the application"""
        self.system_version: Union[str, None] = system_version
        r"""Version of the operating system the application has been run or is running on, as provided by the application"""
        self.log_in_date: int = int(log_in_date)
        r"""Point in time \(Unix timestamp\) when the user has logged in"""
        self.last_active_date: int = int(last_active_date)
        r"""Point in time \(Unix timestamp\) when the session was last used"""
        self.ip_address: Union[str, None] = ip_address
        r"""IP address from which the session was created, in human\-readable format"""
        self.location: Union[str, None] = location
        r"""A human\-readable description of the location from which the session was created, based on the IP address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["session"]:
        return "session"

    def getClass(self) -> Literal["Session"]:
        return "Session"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "is_current": self.is_current,
            "is_password_pending": self.is_password_pending,
            "is_unconfirmed": self.is_unconfirmed,
            "can_accept_secret_chats": self.can_accept_secret_chats,
            "can_accept_calls": self.can_accept_calls,
            "type": self.type,
            "api_id": self.api_id,
            "application_name": self.application_name,
            "application_version": self.application_version,
            "is_official_application": self.is_official_application,
            "device_model": self.device_model,
            "platform": self.platform,
            "system_version": self.system_version,
            "log_in_date": self.log_in_date,
            "last_active_date": self.last_active_date,
            "ip_address": self.ip_address,
            "location": self.location,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Session", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.is_current = data.get("is_current", False)
            data_class.is_password_pending = data.get("is_password_pending", False)
            data_class.is_unconfirmed = data.get("is_unconfirmed", False)
            data_class.can_accept_secret_chats = data.get(
                "can_accept_secret_chats", False
            )
            data_class.can_accept_calls = data.get("can_accept_calls", False)
            data_class.type = data.get("type", None)
            data_class.api_id = int(data.get("api_id", 0))
            data_class.application_name = data.get("application_name", "")
            data_class.application_version = data.get("application_version", "")
            data_class.is_official_application = data.get(
                "is_official_application", False
            )
            data_class.device_model = data.get("device_model", "")
            data_class.platform = data.get("platform", "")
            data_class.system_version = data.get("system_version", "")
            data_class.log_in_date = int(data.get("log_in_date", 0))
            data_class.last_active_date = int(data.get("last_active_date", 0))
            data_class.ip_address = data.get("ip_address", "")
            data_class.location = data.get("location", "")

        return data_class


class Sessions(TlObject):
    r"""Contains a list of sessions

    Parameters:
        sessions (:class:`List["types.Session"]`):
            List of sessions

        inactive_session_ttl_days (:class:`int`):
            Number of days of inactivity before sessions will automatically be terminated; 1\-366 days

    """

    def __init__(
        self, sessions: List[Session] = None, inactive_session_ttl_days: int = 0
    ) -> None:
        self.sessions: List[Session] = sessions or []
        r"""List of sessions"""
        self.inactive_session_ttl_days: int = int(inactive_session_ttl_days)
        r"""Number of days of inactivity before sessions will automatically be terminated; 1\-366 days"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["sessions"]:
        return "sessions"

    def getClass(self) -> Literal["Sessions"]:
        return "Sessions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sessions": self.sessions,
            "inactive_session_ttl_days": self.inactive_session_ttl_days,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Sessions", None]:
        if data:
            data_class = cls()
            data_class.sessions = data.get("sessions", None)
            data_class.inactive_session_ttl_days = int(
                data.get("inactive_session_ttl_days", 0)
            )

        return data_class


class UnconfirmedSession(TlObject):
    r"""Contains information about an unconfirmed session

    Parameters:
        id (:class:`int`):
            Session identifier

        log_in_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user has logged in

        device_model (:class:`str`):
            Model of the device that was used for the session creation, as provided by the application

        location (:class:`str`):
            A human\-readable description of the location from which the session was created, based on the IP address

    """

    def __init__(
        self,
        id: int = 0,
        log_in_date: int = 0,
        device_model: str = "",
        location: str = "",
    ) -> None:
        self.id: int = int(id)
        r"""Session identifier"""
        self.log_in_date: int = int(log_in_date)
        r"""Point in time \(Unix timestamp\) when the user has logged in"""
        self.device_model: Union[str, None] = device_model
        r"""Model of the device that was used for the session creation, as provided by the application"""
        self.location: Union[str, None] = location
        r"""A human\-readable description of the location from which the session was created, based on the IP address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["unconfirmedSession"]:
        return "unconfirmedSession"

    def getClass(self) -> Literal["UnconfirmedSession"]:
        return "UnconfirmedSession"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "log_in_date": self.log_in_date,
            "device_model": self.device_model,
            "location": self.location,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UnconfirmedSession", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.log_in_date = int(data.get("log_in_date", 0))
            data_class.device_model = data.get("device_model", "")
            data_class.location = data.get("location", "")

        return data_class


class ConnectedWebsite(TlObject):
    r"""Contains information about one website the current user is logged in with Telegram

    Parameters:
        id (:class:`int`):
            Website identifier

        domain_name (:class:`str`):
            The domain name of the website

        bot_user_id (:class:`int`):
            User identifier of a bot linked with the website

        browser (:class:`str`):
            The version of a browser used to log in

        platform (:class:`str`):
            Operating system the browser is running on

        log_in_date (:class:`int`):
            Point in time \(Unix timestamp\) when the user was logged in

        last_active_date (:class:`int`):
            Point in time \(Unix timestamp\) when obtained authorization was last used

        ip_address (:class:`str`):
            IP address from which the user was logged in, in human\-readable format

        location (:class:`str`):
            Human\-readable description of a country and a region from which the user was logged in, based on the IP address

    """

    def __init__(
        self,
        id: int = 0,
        domain_name: str = "",
        bot_user_id: int = 0,
        browser: str = "",
        platform: str = "",
        log_in_date: int = 0,
        last_active_date: int = 0,
        ip_address: str = "",
        location: str = "",
    ) -> None:
        self.id: int = int(id)
        r"""Website identifier"""
        self.domain_name: Union[str, None] = domain_name
        r"""The domain name of the website"""
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of a bot linked with the website"""
        self.browser: Union[str, None] = browser
        r"""The version of a browser used to log in"""
        self.platform: Union[str, None] = platform
        r"""Operating system the browser is running on"""
        self.log_in_date: int = int(log_in_date)
        r"""Point in time \(Unix timestamp\) when the user was logged in"""
        self.last_active_date: int = int(last_active_date)
        r"""Point in time \(Unix timestamp\) when obtained authorization was last used"""
        self.ip_address: Union[str, None] = ip_address
        r"""IP address from which the user was logged in, in human\-readable format"""
        self.location: Union[str, None] = location
        r"""Human\-readable description of a country and a region from which the user was logged in, based on the IP address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectedWebsite"]:
        return "connectedWebsite"

    def getClass(self) -> Literal["ConnectedWebsite"]:
        return "ConnectedWebsite"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "domain_name": self.domain_name,
            "bot_user_id": self.bot_user_id,
            "browser": self.browser,
            "platform": self.platform,
            "log_in_date": self.log_in_date,
            "last_active_date": self.last_active_date,
            "ip_address": self.ip_address,
            "location": self.location,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectedWebsite", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.domain_name = data.get("domain_name", "")
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.browser = data.get("browser", "")
            data_class.platform = data.get("platform", "")
            data_class.log_in_date = int(data.get("log_in_date", 0))
            data_class.last_active_date = int(data.get("last_active_date", 0))
            data_class.ip_address = data.get("ip_address", "")
            data_class.location = data.get("location", "")

        return data_class


class ConnectedWebsites(TlObject):
    r"""Contains a list of websites the current user is logged in with Telegram

    Parameters:
        websites (:class:`List["types.ConnectedWebsite"]`):
            List of connected websites

    """

    def __init__(self, websites: List[ConnectedWebsite] = None) -> None:
        self.websites: List[ConnectedWebsite] = websites or []
        r"""List of connected websites"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectedWebsites"]:
        return "connectedWebsites"

    def getClass(self) -> Literal["ConnectedWebsites"]:
        return "ConnectedWebsites"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "websites": self.websites}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectedWebsites", None]:
        if data:
            data_class = cls()
            data_class.websites = data.get("websites", None)

        return data_class


class ReportReasonSpam(TlObject, ReportReason):
    r"""The chat contains spam messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonSpam"]:
        return "reportReasonSpam"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonSpam", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonViolence(TlObject, ReportReason):
    r"""The chat promotes violence"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonViolence"]:
        return "reportReasonViolence"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonViolence", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonPornography(TlObject, ReportReason):
    r"""The chat contains pornographic messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonPornography"]:
        return "reportReasonPornography"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonPornography", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonChildAbuse(TlObject, ReportReason):
    r"""The chat has child abuse related content"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonChildAbuse"]:
        return "reportReasonChildAbuse"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonChildAbuse", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonCopyright(TlObject, ReportReason):
    r"""The chat contains copyrighted content"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonCopyright"]:
        return "reportReasonCopyright"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonCopyright", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonUnrelatedLocation(TlObject, ReportReason):
    r"""The location\-based chat is unrelated to its stated location"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonUnrelatedLocation"]:
        return "reportReasonUnrelatedLocation"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonUnrelatedLocation", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonFake(TlObject, ReportReason):
    r"""The chat represents a fake account"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonFake"]:
        return "reportReasonFake"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonFake", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonIllegalDrugs(TlObject, ReportReason):
    r"""The chat has illegal drugs related content"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonIllegalDrugs"]:
        return "reportReasonIllegalDrugs"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonIllegalDrugs", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonPersonalDetails(TlObject, ReportReason):
    r"""The chat contains messages with personal details"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonPersonalDetails"]:
        return "reportReasonPersonalDetails"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonPersonalDetails", None]:
        if data:
            data_class = cls()

        return data_class


class ReportReasonCustom(TlObject, ReportReason):
    r"""A custom reason provided by the user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportReasonCustom"]:
        return "reportReasonCustom"

    def getClass(self) -> Literal["ReportReason"]:
        return "ReportReason"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportReasonCustom", None]:
        if data:
            data_class = cls()

        return data_class


class ReportChatResultOk(TlObject, ReportChatResult):
    r"""The chat was reported successfully"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportChatResultOk"]:
        return "reportChatResultOk"

    def getClass(self) -> Literal["ReportChatResult"]:
        return "ReportChatResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportChatResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class ReportChatResultOptionRequired(TlObject, ReportChatResult):
    r"""The user must choose an option to report the chat and repeat request with the chosen option

    Parameters:
        title (:class:`str`):
            Title for the option choice

        options (:class:`List["types.ReportOption"]`):
            List of available options

    """

    def __init__(self, title: str = "", options: List[ReportOption] = None) -> None:
        self.title: Union[str, None] = title
        r"""Title for the option choice"""
        self.options: List[ReportOption] = options or []
        r"""List of available options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportChatResultOptionRequired"]:
        return "reportChatResultOptionRequired"

    def getClass(self) -> Literal["ReportChatResult"]:
        return "ReportChatResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title, "options": self.options}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportChatResultOptionRequired", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.options = data.get("options", None)

        return data_class


class ReportChatResultTextRequired(TlObject, ReportChatResult):
    r"""The user must add additional text details to the report

    Parameters:
        option_id (:class:`bytes`):
            Option identifier for the next reportChat request

        is_optional (:class:`bool`):
            True, if the user can skip text adding

    """

    def __init__(self, option_id: bytes = b"", is_optional: bool = False) -> None:
        self.option_id: Union[bytes, None] = option_id
        r"""Option identifier for the next reportChat request"""
        self.is_optional: bool = bool(is_optional)
        r"""True, if the user can skip text adding"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportChatResultTextRequired"]:
        return "reportChatResultTextRequired"

    def getClass(self) -> Literal["ReportChatResult"]:
        return "ReportChatResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "option_id": self.option_id,
            "is_optional": self.is_optional,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportChatResultTextRequired", None]:
        if data:
            data_class = cls()
            data_class.option_id = b64decode(data.get("option_id", b""))
            data_class.is_optional = data.get("is_optional", False)

        return data_class


class ReportChatResultMessagesRequired(TlObject, ReportChatResult):
    r"""The user must choose messages to report and repeat the reportChat request with the chosen messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportChatResultMessagesRequired"]:
        return "reportChatResultMessagesRequired"

    def getClass(self) -> Literal["ReportChatResult"]:
        return "ReportChatResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportChatResultMessagesRequired", None]:
        if data:
            data_class = cls()

        return data_class


class ReportStoryResultOk(TlObject, ReportStoryResult):
    r"""The story was reported successfully"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportStoryResultOk"]:
        return "reportStoryResultOk"

    def getClass(self) -> Literal["ReportStoryResult"]:
        return "ReportStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportStoryResultOk", None]:
        if data:
            data_class = cls()

        return data_class


class ReportStoryResultOptionRequired(TlObject, ReportStoryResult):
    r"""The user must choose an option to report the story and repeat request with the chosen option

    Parameters:
        title (:class:`str`):
            Title for the option choice

        options (:class:`List["types.ReportOption"]`):
            List of available options

    """

    def __init__(self, title: str = "", options: List[ReportOption] = None) -> None:
        self.title: Union[str, None] = title
        r"""Title for the option choice"""
        self.options: List[ReportOption] = options or []
        r"""List of available options"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportStoryResultOptionRequired"]:
        return "reportStoryResultOptionRequired"

    def getClass(self) -> Literal["ReportStoryResult"]:
        return "ReportStoryResult"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "title": self.title, "options": self.options}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportStoryResultOptionRequired", None]:
        if data:
            data_class = cls()
            data_class.title = data.get("title", "")
            data_class.options = data.get("options", None)

        return data_class


class ReportStoryResultTextRequired(TlObject, ReportStoryResult):
    r"""The user must add additional text details to the report

    Parameters:
        option_id (:class:`bytes`):
            Option identifier for the next reportStory request

        is_optional (:class:`bool`):
            True, if the user can skip text adding

    """

    def __init__(self, option_id: bytes = b"", is_optional: bool = False) -> None:
        self.option_id: Union[bytes, None] = option_id
        r"""Option identifier for the next reportStory request"""
        self.is_optional: bool = bool(is_optional)
        r"""True, if the user can skip text adding"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["reportStoryResultTextRequired"]:
        return "reportStoryResultTextRequired"

    def getClass(self) -> Literal["ReportStoryResult"]:
        return "ReportStoryResult"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "option_id": self.option_id,
            "is_optional": self.is_optional,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ReportStoryResultTextRequired", None]:
        if data:
            data_class = cls()
            data_class.option_id = b64decode(data.get("option_id", b""))
            data_class.is_optional = data.get("is_optional", False)

        return data_class


class InternalLinkTypeActiveSessions(TlObject, InternalLinkType):
    r"""The link is a link to the Devices section of the application\. Use getActiveSessions to get the list of active sessions and show them to the user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeActiveSessions"]:
        return "internalLinkTypeActiveSessions"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeActiveSessions", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeAttachmentMenuBot(TlObject, InternalLinkType):
    r"""The link is a link to an attachment menu bot to be opened in the specified or a chosen chat\. Process given target\_chat to open the chat\. Then, call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu\. Then, use getAttachmentMenuBot to receive information about the bot\. If the bot isn't added to attachment menu, then show a disclaimer about Mini Apps being third\-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu\. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot\. If the attachment menu bot can't be used in the opened chat, show an error to the user\. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL

    Parameters:
        target_chat (:class:`"types.TargetChat"`):
            Target chat to be opened

        bot_username (:class:`str`):
            Username of the bot

        url (:class:`str`):
            URL to be passed to openWebApp

    """

    def __init__(
        self, target_chat: TargetChat = None, bot_username: str = "", url: str = ""
    ) -> None:
        self.target_chat: Union[
            TargetChatCurrent, TargetChatChosen, TargetChatInternalLink, None
        ] = target_chat
        r"""Target chat to be opened"""
        self.bot_username: Union[str, None] = bot_username
        r"""Username of the bot"""
        self.url: Union[str, None] = url
        r"""URL to be passed to openWebApp"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeAttachmentMenuBot"]:
        return "internalLinkTypeAttachmentMenuBot"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "target_chat": self.target_chat,
            "bot_username": self.bot_username,
            "url": self.url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeAttachmentMenuBot", None]:
        if data:
            data_class = cls()
            data_class.target_chat = data.get("target_chat", None)
            data_class.bot_username = data.get("bot_username", "")
            data_class.url = data.get("url", "")

        return data_class


class InternalLinkTypeAuthenticationCode(TlObject, InternalLinkType):
    r"""The link contains an authentication code\. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode

    Parameters:
        code (:class:`str`):
            The authentication code

    """

    def __init__(self, code: str = "") -> None:
        self.code: Union[str, None] = code
        r"""The authentication code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeAuthenticationCode"]:
        return "internalLinkTypeAuthenticationCode"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "code": self.code}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeAuthenticationCode", None]:
        if data:
            data_class = cls()
            data_class.code = data.get("code", "")

        return data_class


class InternalLinkTypeBackground(TlObject, InternalLinkType):
    r"""The link is a link to a background\. Call searchBackground with the given background name to process the link\. If background is found and the user wants to apply it, then call setDefaultBackground

    Parameters:
        background_name (:class:`str`):
            Name of the background

    """

    def __init__(self, background_name: str = "") -> None:
        self.background_name: Union[str, None] = background_name
        r"""Name of the background"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeBackground"]:
        return "internalLinkTypeBackground"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "background_name": self.background_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeBackground", None]:
        if data:
            data_class = cls()
            data_class.background_name = data.get("background_name", "")

        return data_class


class InternalLinkTypeBotAddToChannel(TlObject, InternalLinkType):
    r"""The link is a link to a Telegram bot, which is expected to be added to a channel chat as an administrator\. Call searchPublicChat with the given bot username and check that the user is a bot, ask the current user to select a channel chat to add the bot to as an administrator\. Then, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights and combine received rights with the requested administrator rights\. Then, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights

    Parameters:
        bot_username (:class:`str`):
            Username of the bot

        administrator_rights (:class:`"types.ChatAdministratorRights"`):
            Expected administrator rights for the bot

    """

    def __init__(
        self,
        bot_username: str = "",
        administrator_rights: ChatAdministratorRights = None,
    ) -> None:
        self.bot_username: Union[str, None] = bot_username
        r"""Username of the bot"""
        self.administrator_rights: Union[ChatAdministratorRights, None] = (
            administrator_rights
        )
        r"""Expected administrator rights for the bot"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeBotAddToChannel"]:
        return "internalLinkTypeBotAddToChannel"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_username": self.bot_username,
            "administrator_rights": self.administrator_rights,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeBotAddToChannel", None]:
        if data:
            data_class = cls()
            data_class.bot_username = data.get("bot_username", "")
            data_class.administrator_rights = data.get("administrator_rights", None)

        return data_class


class InternalLinkTypeBotStart(TlObject, InternalLinkType):
    r"""The link is a link to a chat with a Telegram bot\. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot, and then call sendBotStartMessage with the given start parameter after the button is pressed

    Parameters:
        bot_username (:class:`str`):
            Username of the bot

        start_parameter (:class:`str`):
            The parameter to be passed to sendBotStartMessage

        autostart (:class:`bool`):
            True, if sendBotStartMessage must be called automatically without showing the START button

    """

    def __init__(
        self, bot_username: str = "", start_parameter: str = "", autostart: bool = False
    ) -> None:
        self.bot_username: Union[str, None] = bot_username
        r"""Username of the bot"""
        self.start_parameter: Union[str, None] = start_parameter
        r"""The parameter to be passed to sendBotStartMessage"""
        self.autostart: bool = bool(autostart)
        r"""True, if sendBotStartMessage must be called automatically without showing the START button"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeBotStart"]:
        return "internalLinkTypeBotStart"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_username": self.bot_username,
            "start_parameter": self.start_parameter,
            "autostart": self.autostart,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeBotStart", None]:
        if data:
            data_class = cls()
            data_class.bot_username = data.get("bot_username", "")
            data_class.start_parameter = data.get("start_parameter", "")
            data_class.autostart = data.get("autostart", False)

        return data_class


class InternalLinkTypeBotStartInGroup(TlObject, InternalLinkType):
    r"""The link is a link to a Telegram bot, which is expected to be added to a group chat\. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups, ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup\. If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed administrator rights\. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat\. Then, if start\_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat; otherwise, just send /start message with bot's username added to the chat

    Parameters:
        bot_username (:class:`str`):
            Username of the bot

        start_parameter (:class:`str`):
            The parameter to be passed to sendBotStartMessage

        administrator_rights (:class:`"types.ChatAdministratorRights"`):
            Expected administrator rights for the bot; may be null

    """

    def __init__(
        self,
        bot_username: str = "",
        start_parameter: str = "",
        administrator_rights: ChatAdministratorRights = None,
    ) -> None:
        self.bot_username: Union[str, None] = bot_username
        r"""Username of the bot"""
        self.start_parameter: Union[str, None] = start_parameter
        r"""The parameter to be passed to sendBotStartMessage"""
        self.administrator_rights: Union[ChatAdministratorRights, None] = (
            administrator_rights
        )
        r"""Expected administrator rights for the bot; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeBotStartInGroup"]:
        return "internalLinkTypeBotStartInGroup"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_username": self.bot_username,
            "start_parameter": self.start_parameter,
            "administrator_rights": self.administrator_rights,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeBotStartInGroup", None]:
        if data:
            data_class = cls()
            data_class.bot_username = data.get("bot_username", "")
            data_class.start_parameter = data.get("start_parameter", "")
            data_class.administrator_rights = data.get("administrator_rights", None)

        return data_class


class InternalLinkTypeBusinessChat(TlObject, InternalLinkType):
    r"""The link is a link to a business chat\. Use getBusinessChatLinkInfo with the provided link name to get information about the link, then open received private chat and replace chat draft with the provided text

    Parameters:
        link_name (:class:`str`):
            Name of the link

    """

    def __init__(self, link_name: str = "") -> None:
        self.link_name: Union[str, None] = link_name
        r"""Name of the link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeBusinessChat"]:
        return "internalLinkTypeBusinessChat"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "link_name": self.link_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeBusinessChat", None]:
        if data:
            data_class = cls()
            data_class.link_name = data.get("link_name", "")

        return data_class


class InternalLinkTypeBuyStars(TlObject, InternalLinkType):
    r"""The link is a link to the Telegram Star purchase section of the application

    Parameters:
        star_count (:class:`int`):
            The number of Telegram Stars that must be owned by the user

        purpose (:class:`str`):
            Purpose of Telegram Star purchase\. Arbitrary string specified by the server, for example, \"subs\" if the Telegram Stars are required to extend channel subscriptions

    """

    def __init__(self, star_count: int = 0, purpose: str = "") -> None:
        self.star_count: int = int(star_count)
        r"""The number of Telegram Stars that must be owned by the user"""
        self.purpose: Union[str, None] = purpose
        r"""Purpose of Telegram Star purchase\. Arbitrary string specified by the server, for example, \"subs\" if the Telegram Stars are required to extend channel subscriptions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeBuyStars"]:
        return "internalLinkTypeBuyStars"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "star_count": self.star_count,
            "purpose": self.purpose,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeBuyStars", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))
            data_class.purpose = data.get("purpose", "")

        return data_class


class InternalLinkTypeChangePhoneNumber(TlObject, InternalLinkType):
    r"""The link is a link to the change phone number section of the application"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeChangePhoneNumber"]:
        return "internalLinkTypeChangePhoneNumber"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeChangePhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeChatAffiliateProgram(TlObject, InternalLinkType):
    r"""The link is an affiliate program link\. Call searchChatAffiliateProgram with the given username and referrer to process the link

    Parameters:
        username (:class:`str`):
            Username to be passed to searchChatAffiliateProgram

        referrer (:class:`str`):
            Referrer to be passed to searchChatAffiliateProgram

    """

    def __init__(self, username: str = "", referrer: str = "") -> None:
        self.username: Union[str, None] = username
        r"""Username to be passed to searchChatAffiliateProgram"""
        self.referrer: Union[str, None] = referrer
        r"""Referrer to be passed to searchChatAffiliateProgram"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeChatAffiliateProgram"]:
        return "internalLinkTypeChatAffiliateProgram"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "username": self.username,
            "referrer": self.referrer,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InternalLinkTypeChatAffiliateProgram", None]:
        if data:
            data_class = cls()
            data_class.username = data.get("username", "")
            data_class.referrer = data.get("referrer", "")

        return data_class


class InternalLinkTypeChatBoost(TlObject, InternalLinkType):
    r"""The link is a link to boost a Telegram chat\. Call getChatBoostLinkInfo with the given URL to process the link\. If the chat is found, then call getChatBoostStatus and getAvailableChatBoostSlots to get the current boost status and check whether the chat can be boosted\. If the user wants to boost the chat and the chat can be boosted, then call boostChat

    Parameters:
        url (:class:`str`):
            URL to be passed to getChatBoostLinkInfo

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""URL to be passed to getChatBoostLinkInfo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeChatBoost"]:
        return "internalLinkTypeChatBoost"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeChatBoost", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class InternalLinkTypeChatFolderInvite(TlObject, InternalLinkType):
    r"""The link is an invite link to a chat folder\. Call checkChatFolderInviteLink with the given invite link to process the link\. If the link is valid and the user wants to join the chat folder, then call addChatFolderByInviteLink

    Parameters:
        invite_link (:class:`str`):
            Internal representation of the invite link

    """

    def __init__(self, invite_link: str = "") -> None:
        self.invite_link: Union[str, None] = invite_link
        r"""Internal representation of the invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeChatFolderInvite"]:
        return "internalLinkTypeChatFolderInvite"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invite_link": self.invite_link}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeChatFolderInvite", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", "")

        return data_class


class InternalLinkTypeChatFolderSettings(TlObject, InternalLinkType):
    r"""The link is a link to the folder section of the application settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeChatFolderSettings"]:
        return "internalLinkTypeChatFolderSettings"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeChatFolderSettings", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeChatInvite(TlObject, InternalLinkType):
    r"""The link is a chat invite link\. Call checkChatInviteLink with the given invite link to process the link\. If the link is valid and the user wants to join the chat, then call joinChatByInviteLink

    Parameters:
        invite_link (:class:`str`):
            Internal representation of the invite link

    """

    def __init__(self, invite_link: str = "") -> None:
        self.invite_link: Union[str, None] = invite_link
        r"""Internal representation of the invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeChatInvite"]:
        return "internalLinkTypeChatInvite"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invite_link": self.invite_link}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeChatInvite", None]:
        if data:
            data_class = cls()
            data_class.invite_link = data.get("invite_link", "")

        return data_class


class InternalLinkTypeDefaultMessageAutoDeleteTimerSettings(TlObject, InternalLinkType):
    r"""The link is a link to the default message auto\-delete timer settings section of the application settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(
        self,
    ) -> Literal["internalLinkTypeDefaultMessageAutoDeleteTimerSettings"]:
        return "internalLinkTypeDefaultMessageAutoDeleteTimerSettings"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InternalLinkTypeDefaultMessageAutoDeleteTimerSettings", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeEditProfileSettings(TlObject, InternalLinkType):
    r"""The link is a link to the edit profile section of the application settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeEditProfileSettings"]:
        return "internalLinkTypeEditProfileSettings"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InternalLinkTypeEditProfileSettings", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeGame(TlObject, InternalLinkType):
    r"""The link is a link to a game\. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame

    Parameters:
        bot_username (:class:`str`):
            Username of the bot that owns the game

        game_short_name (:class:`str`):
            Short name of the game

    """

    def __init__(self, bot_username: str = "", game_short_name: str = "") -> None:
        self.bot_username: Union[str, None] = bot_username
        r"""Username of the bot that owns the game"""
        self.game_short_name: Union[str, None] = game_short_name
        r"""Short name of the game"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeGame"]:
        return "internalLinkTypeGame"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_username": self.bot_username,
            "game_short_name": self.game_short_name,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeGame", None]:
        if data:
            data_class = cls()
            data_class.bot_username = data.get("bot_username", "")
            data_class.game_short_name = data.get("game_short_name", "")

        return data_class


class InternalLinkTypeInstantView(TlObject, InternalLinkType):
    r"""The link must be opened in an Instant View\. Call getWebPageInstantView with the given URL to process the link\. If Instant View is found, then show it, otherwise, open the fallback URL in an external browser

    Parameters:
        url (:class:`str`):
            URL to be passed to getWebPageInstantView

        fallback_url (:class:`str`):
            An URL to open if getWebPageInstantView fails

    """

    def __init__(self, url: str = "", fallback_url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""URL to be passed to getWebPageInstantView"""
        self.fallback_url: Union[str, None] = fallback_url
        r"""An URL to open if getWebPageInstantView fails"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeInstantView"]:
        return "internalLinkTypeInstantView"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "url": self.url,
            "fallback_url": self.fallback_url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeInstantView", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.fallback_url = data.get("fallback_url", "")

        return data_class


class InternalLinkTypeInvoice(TlObject, InternalLinkType):
    r"""The link is a link to an invoice\. Call getPaymentForm with the given invoice name to process the link

    Parameters:
        invoice_name (:class:`str`):
            Name of the invoice

    """

    def __init__(self, invoice_name: str = "") -> None:
        self.invoice_name: Union[str, None] = invoice_name
        r"""Name of the invoice"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeInvoice"]:
        return "internalLinkTypeInvoice"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "invoice_name": self.invoice_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeInvoice", None]:
        if data:
            data_class = cls()
            data_class.invoice_name = data.get("invoice_name", "")

        return data_class


class InternalLinkTypeLanguagePack(TlObject, InternalLinkType):
    r"""The link is a link to a language pack\. Call getLanguagePackInfo with the given language pack identifier to process the link\. If the language pack is found and the user wants to apply it, then call setOption for the option \"language\_pack\_id\"

    Parameters:
        language_pack_id (:class:`str`):
            Language pack identifier

    """

    def __init__(self, language_pack_id: str = "") -> None:
        self.language_pack_id: Union[str, None] = language_pack_id
        r"""Language pack identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeLanguagePack"]:
        return "internalLinkTypeLanguagePack"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "language_pack_id": self.language_pack_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeLanguagePack", None]:
        if data:
            data_class = cls()
            data_class.language_pack_id = data.get("language_pack_id", "")

        return data_class


class InternalLinkTypeLanguageSettings(TlObject, InternalLinkType):
    r"""The link is a link to the language section of the application settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeLanguageSettings"]:
        return "internalLinkTypeLanguageSettings"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeLanguageSettings", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeMainWebApp(TlObject, InternalLinkType):
    r"""The link is a link to the main Web App of a bot\. Call searchPublicChat with the given bot username, check that the user is a bot and has the main Web App\. If the bot can be added to attachment menu, then use getAttachmentMenuBot to receive information about the bot, then if the bot isn't added to side menu, show a disclaimer about Mini Apps being third\-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu to add the bot\. Then, use getMainWebApp with the given start parameter and mode and open the returned URL as a Web App

    Parameters:
        bot_username (:class:`str`):
            Username of the bot

        start_parameter (:class:`str`):
            Start parameter to be passed to getMainWebApp

        mode (:class:`"types.WebAppOpenMode"`):
            The mode to be passed to getMainWebApp

    """

    def __init__(
        self,
        bot_username: str = "",
        start_parameter: str = "",
        mode: WebAppOpenMode = None,
    ) -> None:
        self.bot_username: Union[str, None] = bot_username
        r"""Username of the bot"""
        self.start_parameter: Union[str, None] = start_parameter
        r"""Start parameter to be passed to getMainWebApp"""
        self.mode: Union[
            WebAppOpenModeCompact,
            WebAppOpenModeFullSize,
            WebAppOpenModeFullScreen,
            None,
        ] = mode
        r"""The mode to be passed to getMainWebApp"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeMainWebApp"]:
        return "internalLinkTypeMainWebApp"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_username": self.bot_username,
            "start_parameter": self.start_parameter,
            "mode": self.mode,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeMainWebApp", None]:
        if data:
            data_class = cls()
            data_class.bot_username = data.get("bot_username", "")
            data_class.start_parameter = data.get("start_parameter", "")
            data_class.mode = data.get("mode", None)

        return data_class


class InternalLinkTypeMessage(TlObject, InternalLinkType):
    r"""The link is a link to a Telegram message or a forum topic\. Call getMessageLinkInfo with the given URL to process the link, and then open received forum topic or chat and show the message there

    Parameters:
        url (:class:`str`):
            URL to be passed to getMessageLinkInfo

    """

    def __init__(self, url: str = "") -> None:
        self.url: Union[str, None] = url
        r"""URL to be passed to getMessageLinkInfo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeMessage"]:
        return "internalLinkTypeMessage"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeMessage", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")

        return data_class


class InternalLinkTypeMessageDraft(TlObject, InternalLinkType):
    r"""The link contains a message draft text\. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field

    Parameters:
        text (:class:`"types.FormattedText"`):
            Message draft text

        contains_link (:class:`bool`):
            True, if the first line of the text contains a link\. If true, the input field needs to be focused and the text after the link must be selected

    """

    def __init__(self, text: FormattedText = None, contains_link: bool = False) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Message draft text"""
        self.contains_link: bool = bool(contains_link)
        r"""True, if the first line of the text contains a link\. If true, the input field needs to be focused and the text after the link must be selected"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeMessageDraft"]:
        return "internalLinkTypeMessageDraft"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "contains_link": self.contains_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeMessageDraft", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.contains_link = data.get("contains_link", False)

        return data_class


class InternalLinkTypePassportDataRequest(TlObject, InternalLinkType):
    r"""The link contains a request of Telegram passport data\. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it

    Parameters:
        bot_user_id (:class:`int`):
            User identifier of the service's bot; the corresponding user may be unknown yet

        scope (:class:`str`):
            Telegram Passport element types requested by the service

        public_key (:class:`str`):
            Service's public key

        nonce (:class:`str`):
            Unique request identifier provided by the service

        callback_url (:class:`str`):
            An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg\_passport\=success, tg\_passport\=cancel, or tg\_passport\=error&error\=\.\.\. respectively\. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot\{bot\_user\_id\}://passport/success or tgbot\{bot\_user\_id\}://passport/cancel must be opened otherwise

    """

    def __init__(
        self,
        bot_user_id: int = 0,
        scope: str = "",
        public_key: str = "",
        nonce: str = "",
        callback_url: str = "",
    ) -> None:
        self.bot_user_id: int = int(bot_user_id)
        r"""User identifier of the service's bot; the corresponding user may be unknown yet"""
        self.scope: Union[str, None] = scope
        r"""Telegram Passport element types requested by the service"""
        self.public_key: Union[str, None] = public_key
        r"""Service's public key"""
        self.nonce: Union[str, None] = nonce
        r"""Unique request identifier provided by the service"""
        self.callback_url: Union[str, None] = callback_url
        r"""An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg\_passport\=success, tg\_passport\=cancel, or tg\_passport\=error&error\=\.\.\. respectively\. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot\{bot\_user\_id\}://passport/success or tgbot\{bot\_user\_id\}://passport/cancel must be opened otherwise"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypePassportDataRequest"]:
        return "internalLinkTypePassportDataRequest"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_user_id": self.bot_user_id,
            "scope": self.scope,
            "public_key": self.public_key,
            "nonce": self.nonce,
            "callback_url": self.callback_url,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InternalLinkTypePassportDataRequest", None]:
        if data:
            data_class = cls()
            data_class.bot_user_id = int(data.get("bot_user_id", 0))
            data_class.scope = data.get("scope", "")
            data_class.public_key = data.get("public_key", "")
            data_class.nonce = data.get("nonce", "")
            data_class.callback_url = data.get("callback_url", "")

        return data_class


class InternalLinkTypePhoneNumberConfirmation(TlObject, InternalLinkType):
    r"""The link can be used to confirm ownership of a phone number to prevent account deletion\. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership with the given hash to process the link\. If succeeded, call checkPhoneNumberCode to check entered by the user code, or resendPhoneNumberCode to resend it

    Parameters:
        hash (:class:`str`):
            Hash value from the link

        phone_number (:class:`str`):
            Phone number value from the link

    """

    def __init__(self, hash: str = "", phone_number: str = "") -> None:
        self.hash: Union[str, None] = hash
        r"""Hash value from the link"""
        self.phone_number: Union[str, None] = phone_number
        r"""Phone number value from the link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypePhoneNumberConfirmation"]:
        return "internalLinkTypePhoneNumberConfirmation"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "hash": self.hash,
            "phone_number": self.phone_number,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InternalLinkTypePhoneNumberConfirmation", None]:
        if data:
            data_class = cls()
            data_class.hash = data.get("hash", "")
            data_class.phone_number = data.get("phone_number", "")

        return data_class


class InternalLinkTypePremiumFeatures(TlObject, InternalLinkType):
    r"""The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium\. Call getPremiumFeatures with the given referrer to process the link

    Parameters:
        referrer (:class:`str`):
            Referrer specified in the link

    """

    def __init__(self, referrer: str = "") -> None:
        self.referrer: Union[str, None] = referrer
        r"""Referrer specified in the link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypePremiumFeatures"]:
        return "internalLinkTypePremiumFeatures"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "referrer": self.referrer}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypePremiumFeatures", None]:
        if data:
            data_class = cls()
            data_class.referrer = data.get("referrer", "")

        return data_class


class InternalLinkTypePremiumGift(TlObject, InternalLinkType):
    r"""The link is a link to the screen for gifting Telegram Premium subscriptions to friends via inputInvoiceTelegram with telegramPaymentPurposePremiumGift payments or in\-store purchases

    Parameters:
        referrer (:class:`str`):
            Referrer specified in the link

    """

    def __init__(self, referrer: str = "") -> None:
        self.referrer: Union[str, None] = referrer
        r"""Referrer specified in the link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypePremiumGift"]:
        return "internalLinkTypePremiumGift"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "referrer": self.referrer}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypePremiumGift", None]:
        if data:
            data_class = cls()
            data_class.referrer = data.get("referrer", "")

        return data_class


class InternalLinkTypePremiumGiftCode(TlObject, InternalLinkType):
    r"""The link is a link with a Telegram Premium gift code\. Call checkPremiumGiftCode with the given code to process the link\. If the code is valid and the user wants to apply it, then call applyPremiumGiftCode

    Parameters:
        code (:class:`str`):
            The Telegram Premium gift code

    """

    def __init__(self, code: str = "") -> None:
        self.code: Union[str, None] = code
        r"""The Telegram Premium gift code"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypePremiumGiftCode"]:
        return "internalLinkTypePremiumGiftCode"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "code": self.code}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypePremiumGiftCode", None]:
        if data:
            data_class = cls()
            data_class.code = data.get("code", "")

        return data_class


class InternalLinkTypePrivacyAndSecuritySettings(TlObject, InternalLinkType):
    r"""The link is a link to the privacy and security section of the application settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypePrivacyAndSecuritySettings"]:
        return "internalLinkTypePrivacyAndSecuritySettings"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InternalLinkTypePrivacyAndSecuritySettings", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeProxy(TlObject, InternalLinkType):
    r"""The link is a link to a proxy\. Call addProxy with the given parameters to process the link and add the proxy

    Parameters:
        server (:class:`str`):
            Proxy server domain or IP address

        port (:class:`int`):
            Proxy server port

        type (:class:`"types.ProxyType"`):
            Type of the proxy

    """

    def __init__(self, server: str = "", port: int = 0, type: ProxyType = None) -> None:
        self.server: Union[str, None] = server
        r"""Proxy server domain or IP address"""
        self.port: int = int(port)
        r"""Proxy server port"""
        self.type: Union[ProxyTypeSocks5, ProxyTypeHttp, ProxyTypeMtproto, None] = type
        r"""Type of the proxy"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeProxy"]:
        return "internalLinkTypeProxy"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "server": self.server,
            "port": self.port,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeProxy", None]:
        if data:
            data_class = cls()
            data_class.server = data.get("server", "")
            data_class.port = int(data.get("port", 0))
            data_class.type = data.get("type", None)

        return data_class


class InternalLinkTypePublicChat(TlObject, InternalLinkType):
    r"""The link is a link to a chat by its username\. Call searchPublicChat with the given chat username to process the link\. If the chat is found, open its profile information screen or the chat itself\. If draft text isn't empty and the chat is a private chat with a regular user, then put the draft text in the input field

    Parameters:
        chat_username (:class:`str`):
            Username of the chat

        draft_text (:class:`str`):
            Draft text for message to send in the chat

        open_profile (:class:`bool`):
            True, if chat profile information screen must be opened; otherwise, the chat itself must be opened

    """

    def __init__(
        self, chat_username: str = "", draft_text: str = "", open_profile: bool = False
    ) -> None:
        self.chat_username: Union[str, None] = chat_username
        r"""Username of the chat"""
        self.draft_text: Union[str, None] = draft_text
        r"""Draft text for message to send in the chat"""
        self.open_profile: bool = bool(open_profile)
        r"""True, if chat profile information screen must be opened; otherwise, the chat itself must be opened"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypePublicChat"]:
        return "internalLinkTypePublicChat"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_username": self.chat_username,
            "draft_text": self.draft_text,
            "open_profile": self.open_profile,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypePublicChat", None]:
        if data:
            data_class = cls()
            data_class.chat_username = data.get("chat_username", "")
            data_class.draft_text = data.get("draft_text", "")
            data_class.open_profile = data.get("open_profile", False)

        return data_class


class InternalLinkTypeQrCodeAuthentication(TlObject, InternalLinkType):
    r"""The link can be used to login the current user on another device, but it must be scanned from QR\-code using in\-app camera\. An alert similar to \"This code can be used to allow someone to log in to your Telegram account\. To confirm Telegram login, please go to Settings \> Devices \> Scan QR and scan the code\" needs to be shown"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeQrCodeAuthentication"]:
        return "internalLinkTypeQrCodeAuthentication"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["InternalLinkTypeQrCodeAuthentication", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeRestorePurchases(TlObject, InternalLinkType):
    r"""The link forces restore of App Store purchases when opened\. For official iOS application only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeRestorePurchases"]:
        return "internalLinkTypeRestorePurchases"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeRestorePurchases", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeSettings(TlObject, InternalLinkType):
    r"""The link is a link to application settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeSettings"]:
        return "internalLinkTypeSettings"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeSettings", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeStickerSet(TlObject, InternalLinkType):
    r"""The link is a link to a sticker set\. Call searchStickerSet with the given sticker set name to process the link and show the sticker set\. If the sticker set is found and the user wants to add it, then call changeStickerSet

    Parameters:
        sticker_set_name (:class:`str`):
            Name of the sticker set

        expect_custom_emoji (:class:`bool`):
            True, if the sticker set is expected to contain custom emoji

    """

    def __init__(
        self, sticker_set_name: str = "", expect_custom_emoji: bool = False
    ) -> None:
        self.sticker_set_name: Union[str, None] = sticker_set_name
        r"""Name of the sticker set"""
        self.expect_custom_emoji: bool = bool(expect_custom_emoji)
        r"""True, if the sticker set is expected to contain custom emoji"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeStickerSet"]:
        return "internalLinkTypeStickerSet"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker_set_name": self.sticker_set_name,
            "expect_custom_emoji": self.expect_custom_emoji,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeStickerSet", None]:
        if data:
            data_class = cls()
            data_class.sticker_set_name = data.get("sticker_set_name", "")
            data_class.expect_custom_emoji = data.get("expect_custom_emoji", False)

        return data_class


class InternalLinkTypeStory(TlObject, InternalLinkType):
    r"""The link is a link to a story\. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier, then show the story if received

    Parameters:
        story_sender_username (:class:`str`):
            Username of the sender of the story

        story_id (:class:`int`):
            Story identifier

    """

    def __init__(self, story_sender_username: str = "", story_id: int = 0) -> None:
        self.story_sender_username: Union[str, None] = story_sender_username
        r"""Username of the sender of the story"""
        self.story_id: int = int(story_id)
        r"""Story identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeStory"]:
        return "internalLinkTypeStory"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_sender_username": self.story_sender_username,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeStory", None]:
        if data:
            data_class = cls()
            data_class.story_sender_username = data.get("story_sender_username", "")
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class InternalLinkTypeTheme(TlObject, InternalLinkType):
    r"""The link is a link to a cloud theme\. TDLib has no theme support yet

    Parameters:
        theme_name (:class:`str`):
            Name of the theme

    """

    def __init__(self, theme_name: str = "") -> None:
        self.theme_name: Union[str, None] = theme_name
        r"""Name of the theme"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeTheme"]:
        return "internalLinkTypeTheme"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "theme_name": self.theme_name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeTheme", None]:
        if data:
            data_class = cls()
            data_class.theme_name = data.get("theme_name", "")

        return data_class


class InternalLinkTypeThemeSettings(TlObject, InternalLinkType):
    r"""The link is a link to the theme section of the application settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeThemeSettings"]:
        return "internalLinkTypeThemeSettings"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeThemeSettings", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeUnknownDeepLink(TlObject, InternalLinkType):
    r"""The link is an unknown tg: link\. Call getDeepLinkInfo to process the link

    Parameters:
        link (:class:`str`):
            Link to be passed to getDeepLinkInfo

    """

    def __init__(self, link: str = "") -> None:
        self.link: Union[str, None] = link
        r"""Link to be passed to getDeepLinkInfo"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeUnknownDeepLink"]:
        return "internalLinkTypeUnknownDeepLink"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "link": self.link}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeUnknownDeepLink", None]:
        if data:
            data_class = cls()
            data_class.link = data.get("link", "")

        return data_class


class InternalLinkTypeUnsupportedProxy(TlObject, InternalLinkType):
    r"""The link is a link to an unsupported proxy\. An alert can be shown to the user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeUnsupportedProxy"]:
        return "internalLinkTypeUnsupportedProxy"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeUnsupportedProxy", None]:
        if data:
            data_class = cls()

        return data_class


class InternalLinkTypeUpgradedGift(TlObject, InternalLinkType):
    r"""The link is a link to an upgraded gift\. Call getUpgradedGift with the given name to process the link

    Parameters:
        name (:class:`str`):
            Name of the unique gift

    """

    def __init__(self, name: str = "") -> None:
        self.name: Union[str, None] = name
        r"""Name of the unique gift"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeUpgradedGift"]:
        return "internalLinkTypeUpgradedGift"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeUpgradedGift", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")

        return data_class


class InternalLinkTypeUserPhoneNumber(TlObject, InternalLinkType):
    r"""The link is a link to a user by its phone number\. Call searchUserByPhoneNumber with the given phone number to process the link\. If the user is found, then call createPrivateChat and open user's profile information screen or the chat itself\. If draft text isn't empty, then put the draft text in the input field

    Parameters:
        phone_number (:class:`str`):
            Phone number of the user

        draft_text (:class:`str`):
            Draft text for message to send in the chat

        open_profile (:class:`bool`):
            True, if user's profile information screen must be opened; otherwise, the chat itself must be opened

    """

    def __init__(
        self, phone_number: str = "", draft_text: str = "", open_profile: bool = False
    ) -> None:
        self.phone_number: Union[str, None] = phone_number
        r"""Phone number of the user"""
        self.draft_text: Union[str, None] = draft_text
        r"""Draft text for message to send in the chat"""
        self.open_profile: bool = bool(open_profile)
        r"""True, if user's profile information screen must be opened; otherwise, the chat itself must be opened"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeUserPhoneNumber"]:
        return "internalLinkTypeUserPhoneNumber"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "phone_number": self.phone_number,
            "draft_text": self.draft_text,
            "open_profile": self.open_profile,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeUserPhoneNumber", None]:
        if data:
            data_class = cls()
            data_class.phone_number = data.get("phone_number", "")
            data_class.draft_text = data.get("draft_text", "")
            data_class.open_profile = data.get("open_profile", False)

        return data_class


class InternalLinkTypeUserToken(TlObject, InternalLinkType):
    r"""The link is a link to a user by a temporary token\. Call searchUserByToken with the given token to process the link\. If the user is found, then call createPrivateChat and open the chat

    Parameters:
        token (:class:`str`):
            The token

    """

    def __init__(self, token: str = "") -> None:
        self.token: Union[str, None] = token
        r"""The token"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeUserToken"]:
        return "internalLinkTypeUserToken"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token}

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeUserToken", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")

        return data_class


class InternalLinkTypeVideoChat(TlObject, InternalLinkType):
    r"""The link is a link to a video chat\. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link

    Parameters:
        chat_username (:class:`str`):
            Username of the chat with the video chat

        invite_hash (:class:`str`):
            If non\-empty, invite hash to be used to join the video chat without being muted by administrators

        is_live_stream (:class:`bool`):
            True, if the video chat is expected to be a live stream in a channel or a broadcast group

    """

    def __init__(
        self,
        chat_username: str = "",
        invite_hash: str = "",
        is_live_stream: bool = False,
    ) -> None:
        self.chat_username: Union[str, None] = chat_username
        r"""Username of the chat with the video chat"""
        self.invite_hash: Union[str, None] = invite_hash
        r"""If non\-empty, invite hash to be used to join the video chat without being muted by administrators"""
        self.is_live_stream: bool = bool(is_live_stream)
        r"""True, if the video chat is expected to be a live stream in a channel or a broadcast group"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeVideoChat"]:
        return "internalLinkTypeVideoChat"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_username": self.chat_username,
            "invite_hash": self.invite_hash,
            "is_live_stream": self.is_live_stream,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeVideoChat", None]:
        if data:
            data_class = cls()
            data_class.chat_username = data.get("chat_username", "")
            data_class.invite_hash = data.get("invite_hash", "")
            data_class.is_live_stream = data.get("is_live_stream", False)

        return data_class


class InternalLinkTypeWebApp(TlObject, InternalLinkType):
    r"""The link is a link to a Web App\. Call searchPublicChat with the given bot username, check that the user is a bot\. If the bot is restricted for the current user, then show an error message\. Otherwise, call searchWebApp with the received bot and the given web\_app\_short\_name\. Process received foundWebApp by showing a confirmation dialog if needed\. If the bot can be added to attachment or side menu, but isn't added yet, then show a disclaimer about Mini Apps being third\-party applications instead of the dialog and ask the user to accept their Terms of service\. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot\. Then, call getWebAppLinkUrl and open the returned URL as a Web App

    Parameters:
        bot_username (:class:`str`):
            Username of the bot that owns the Web App

        web_app_short_name (:class:`str`):
            Short name of the Web App

        start_parameter (:class:`str`):
            Start parameter to be passed to getWebAppLinkUrl

        mode (:class:`"types.WebAppOpenMode"`):
            The mode in which the Web App must be opened

    """

    def __init__(
        self,
        bot_username: str = "",
        web_app_short_name: str = "",
        start_parameter: str = "",
        mode: WebAppOpenMode = None,
    ) -> None:
        self.bot_username: Union[str, None] = bot_username
        r"""Username of the bot that owns the Web App"""
        self.web_app_short_name: Union[str, None] = web_app_short_name
        r"""Short name of the Web App"""
        self.start_parameter: Union[str, None] = start_parameter
        r"""Start parameter to be passed to getWebAppLinkUrl"""
        self.mode: Union[
            WebAppOpenModeCompact,
            WebAppOpenModeFullSize,
            WebAppOpenModeFullScreen,
            None,
        ] = mode
        r"""The mode in which the Web App must be opened"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["internalLinkTypeWebApp"]:
        return "internalLinkTypeWebApp"

    def getClass(self) -> Literal["InternalLinkType"]:
        return "InternalLinkType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "bot_username": self.bot_username,
            "web_app_short_name": self.web_app_short_name,
            "start_parameter": self.start_parameter,
            "mode": self.mode,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InternalLinkTypeWebApp", None]:
        if data:
            data_class = cls()
            data_class.bot_username = data.get("bot_username", "")
            data_class.web_app_short_name = data.get("web_app_short_name", "")
            data_class.start_parameter = data.get("start_parameter", "")
            data_class.mode = data.get("mode", None)

        return data_class


class MessageLink(TlObject):
    r"""Contains an HTTPS link to a message in a supergroup or channel, or a forum topic

    Parameters:
        link (:class:`str`):
            The link

        is_public (:class:`bool`):
            True, if the link will work for non\-members of the chat

    """

    def __init__(self, link: str = "", is_public: bool = False) -> None:
        self.link: Union[str, None] = link
        r"""The link"""
        self.is_public: bool = bool(is_public)
        r"""True, if the link will work for non\-members of the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageLink"]:
        return "messageLink"

    def getClass(self) -> Literal["MessageLink"]:
        return "MessageLink"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "link": self.link, "is_public": self.is_public}

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageLink", None]:
        if data:
            data_class = cls()
            data_class.link = data.get("link", "")
            data_class.is_public = data.get("is_public", False)

        return data_class


class MessageLinkInfo(TlObject):
    r"""Contains information about a link to a message or a forum topic in a chat

    Parameters:
        is_public (:class:`bool`):
            True, if the link is a public link for a message or a forum topic in a chat

        chat_id (:class:`int`):
            If found, identifier of the chat to which the link points, 0 otherwise

        message_thread_id (:class:`int`):
            If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing

        message (:class:`"types.Message"`):
            If found, the linked message; may be null

        media_timestamp (:class:`int`):
            Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified\. The media can be in the message content or in its link preview

        for_album (:class:`bool`):
            True, if the whole media album to which the message belongs is linked

    """

    def __init__(
        self,
        is_public: bool = False,
        chat_id: int = 0,
        message_thread_id: int = 0,
        message: Message = None,
        media_timestamp: int = 0,
        for_album: bool = False,
    ) -> None:
        self.is_public: bool = bool(is_public)
        r"""True, if the link is a public link for a message or a forum topic in a chat"""
        self.chat_id: int = int(chat_id)
        r"""If found, identifier of the chat to which the link points, 0 otherwise"""
        self.message_thread_id: int = int(message_thread_id)
        r"""If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing"""
        self.message: Union[Message, None] = message
        r"""If found, the linked message; may be null"""
        self.media_timestamp: int = int(media_timestamp)
        r"""Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified\. The media can be in the message content or in its link preview"""
        self.for_album: bool = bool(for_album)
        r"""True, if the whole media album to which the message belongs is linked"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageLinkInfo"]:
        return "messageLinkInfo"

    def getClass(self) -> Literal["MessageLinkInfo"]:
        return "MessageLinkInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_public": self.is_public,
            "chat_id": self.chat_id,
            "message_thread_id": self.message_thread_id,
            "message": self.message,
            "media_timestamp": self.media_timestamp,
            "for_album": self.for_album,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageLinkInfo", None]:
        if data:
            data_class = cls()
            data_class.is_public = data.get("is_public", False)
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_thread_id = int(data.get("message_thread_id", 0))
            data_class.message = data.get("message", None)
            data_class.media_timestamp = int(data.get("media_timestamp", 0))
            data_class.for_album = data.get("for_album", False)

        return data_class


class ChatBoostLink(TlObject):
    r"""Contains an HTTPS link to boost a chat

    Parameters:
        link (:class:`str`):
            The link

        is_public (:class:`bool`):
            True, if the link will work for non\-members of the chat

    """

    def __init__(self, link: str = "", is_public: bool = False) -> None:
        self.link: Union[str, None] = link
        r"""The link"""
        self.is_public: bool = bool(is_public)
        r"""True, if the link will work for non\-members of the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostLink"]:
        return "chatBoostLink"

    def getClass(self) -> Literal["ChatBoostLink"]:
        return "ChatBoostLink"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "link": self.link, "is_public": self.is_public}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostLink", None]:
        if data:
            data_class = cls()
            data_class.link = data.get("link", "")
            data_class.is_public = data.get("is_public", False)

        return data_class


class ChatBoostLinkInfo(TlObject):
    r"""Contains information about a link to boost a chat

    Parameters:
        is_public (:class:`bool`):
            True, if the link will work for non\-members of the chat

        chat_id (:class:`int`):
            Identifier of the chat to which the link points; 0 if the chat isn't found

    """

    def __init__(self, is_public: bool = False, chat_id: int = 0) -> None:
        self.is_public: bool = bool(is_public)
        r"""True, if the link will work for non\-members of the chat"""
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat to which the link points; 0 if the chat isn't found"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatBoostLinkInfo"]:
        return "chatBoostLinkInfo"

    def getClass(self) -> Literal["ChatBoostLinkInfo"]:
        return "ChatBoostLinkInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_public": self.is_public,
            "chat_id": self.chat_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatBoostLinkInfo", None]:
        if data:
            data_class = cls()
            data_class.is_public = data.get("is_public", False)
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class BlockListMain(TlObject, BlockList):
    r"""The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["blockListMain"]:
        return "blockListMain"

    def getClass(self) -> Literal["BlockList"]:
        return "BlockList"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BlockListMain", None]:
        if data:
            data_class = cls()

        return data_class


class BlockListStories(TlObject, BlockList):
    r"""The block list that disallows viewing of stories of the current user"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["blockListStories"]:
        return "blockListStories"

    def getClass(self) -> Literal["BlockList"]:
        return "BlockList"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BlockListStories", None]:
        if data:
            data_class = cls()

        return data_class


class FilePart(TlObject):
    r"""Contains a part of a file

    Parameters:
        data (:class:`bytes`):
            File bytes

    """

    def __init__(self, data: bytes = b"") -> None:
        self.data: Union[bytes, None] = data
        r"""File bytes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["filePart"]:
        return "filePart"

    def getClass(self) -> Literal["FilePart"]:
        return "FilePart"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "data": self.data}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FilePart", None]:
        if data:
            data_class = cls()
            data_class.data = b64decode(data.get("data", b""))

        return data_class


class FileTypeNone(TlObject, FileType):
    r"""The data is not a file"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeNone"]:
        return "fileTypeNone"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeNone", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeAnimation(TlObject, FileType):
    r"""The file is an animation"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeAnimation"]:
        return "fileTypeAnimation"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeAnimation", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeAudio(TlObject, FileType):
    r"""The file is an audio file"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeAudio"]:
        return "fileTypeAudio"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeAudio", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeDocument(TlObject, FileType):
    r"""The file is a document"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeDocument"]:
        return "fileTypeDocument"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeDocument", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeNotificationSound(TlObject, FileType):
    r"""The file is a notification sound"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeNotificationSound"]:
        return "fileTypeNotificationSound"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeNotificationSound", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypePhoto(TlObject, FileType):
    r"""The file is a photo"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypePhoto"]:
        return "fileTypePhoto"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypePhotoStory(TlObject, FileType):
    r"""The file is a photo published as a story"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypePhotoStory"]:
        return "fileTypePhotoStory"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypePhotoStory", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeProfilePhoto(TlObject, FileType):
    r"""The file is a profile photo"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeProfilePhoto"]:
        return "fileTypeProfilePhoto"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeProfilePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSecret(TlObject, FileType):
    r"""The file was sent to a secret chat \(the file type is not known to the server\)"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSecret"]:
        return "fileTypeSecret"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSecret", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSecretThumbnail(TlObject, FileType):
    r"""The file is a thumbnail of a file from a secret chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSecretThumbnail"]:
        return "fileTypeSecretThumbnail"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSecretThumbnail", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSecure(TlObject, FileType):
    r"""The file is a file from Secure storage used for storing Telegram Passport files"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSecure"]:
        return "fileTypeSecure"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSecure", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSelfDestructingPhoto(TlObject, FileType):
    r"""The file is a self\-destructing photo in a private chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSelfDestructingPhoto"]:
        return "fileTypeSelfDestructingPhoto"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSelfDestructingPhoto", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSelfDestructingVideo(TlObject, FileType):
    r"""The file is a self\-destructing video in a private chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSelfDestructingVideo"]:
        return "fileTypeSelfDestructingVideo"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSelfDestructingVideo", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSelfDestructingVideoNote(TlObject, FileType):
    r"""The file is a self\-destructing video note in a private chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSelfDestructingVideoNote"]:
        return "fileTypeSelfDestructingVideoNote"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSelfDestructingVideoNote", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSelfDestructingVoiceNote(TlObject, FileType):
    r"""The file is a self\-destructing voice note in a private chat"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSelfDestructingVoiceNote"]:
        return "fileTypeSelfDestructingVoiceNote"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSelfDestructingVoiceNote", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeSticker(TlObject, FileType):
    r"""The file is a sticker"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeSticker"]:
        return "fileTypeSticker"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeSticker", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeThumbnail(TlObject, FileType):
    r"""The file is a thumbnail of another file"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeThumbnail"]:
        return "fileTypeThumbnail"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeThumbnail", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeUnknown(TlObject, FileType):
    r"""The file type is not yet known"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeUnknown"]:
        return "fileTypeUnknown"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeUnknown", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeVideo(TlObject, FileType):
    r"""The file is a video"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeVideo"]:
        return "fileTypeVideo"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeVideo", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeVideoNote(TlObject, FileType):
    r"""The file is a video note"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeVideoNote"]:
        return "fileTypeVideoNote"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeVideoNote", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeVideoStory(TlObject, FileType):
    r"""The file is a video published as a story"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeVideoStory"]:
        return "fileTypeVideoStory"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeVideoStory", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeVoiceNote(TlObject, FileType):
    r"""The file is a voice note"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeVoiceNote"]:
        return "fileTypeVoiceNote"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeVoiceNote", None]:
        if data:
            data_class = cls()

        return data_class


class FileTypeWallpaper(TlObject, FileType):
    r"""The file is a wallpaper or a background pattern"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileTypeWallpaper"]:
        return "fileTypeWallpaper"

    def getClass(self) -> Literal["FileType"]:
        return "FileType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileTypeWallpaper", None]:
        if data:
            data_class = cls()

        return data_class


class StorageStatisticsByFileType(TlObject):
    r"""Contains the storage usage statistics for a specific file type

    Parameters:
        file_type (:class:`"types.FileType"`):
            File type

        size (:class:`int`):
            Total size of the files, in bytes

        count (:class:`int`):
            Total number of files

    """

    def __init__(
        self, file_type: FileType = None, size: int = 0, count: int = 0
    ) -> None:
        self.file_type: Union[
            FileTypeNone,
            FileTypeAnimation,
            FileTypeAudio,
            FileTypeDocument,
            FileTypeNotificationSound,
            FileTypePhoto,
            FileTypePhotoStory,
            FileTypeProfilePhoto,
            FileTypeSecret,
            FileTypeSecretThumbnail,
            FileTypeSecure,
            FileTypeSelfDestructingPhoto,
            FileTypeSelfDestructingVideo,
            FileTypeSelfDestructingVideoNote,
            FileTypeSelfDestructingVoiceNote,
            FileTypeSticker,
            FileTypeThumbnail,
            FileTypeUnknown,
            FileTypeVideo,
            FileTypeVideoNote,
            FileTypeVideoStory,
            FileTypeVoiceNote,
            FileTypeWallpaper,
            None,
        ] = file_type
        r"""File type"""
        self.size: int = int(size)
        r"""Total size of the files, in bytes"""
        self.count: int = int(count)
        r"""Total number of files"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storageStatisticsByFileType"]:
        return "storageStatisticsByFileType"

    def getClass(self) -> Literal["StorageStatisticsByFileType"]:
        return "StorageStatisticsByFileType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "file_type": self.file_type,
            "size": self.size,
            "count": self.count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorageStatisticsByFileType", None]:
        if data:
            data_class = cls()
            data_class.file_type = data.get("file_type", None)
            data_class.size = int(data.get("size", 0))
            data_class.count = int(data.get("count", 0))

        return data_class


class StorageStatisticsByChat(TlObject):
    r"""Contains the storage usage statistics for a specific chat

    Parameters:
        chat_id (:class:`int`):
            Chat identifier; 0 if none

        size (:class:`int`):
            Total size of the files in the chat, in bytes

        count (:class:`int`):
            Total number of files in the chat

        by_file_type (:class:`List["types.StorageStatisticsByFileType"]`):
            Statistics split by file types

    """

    def __init__(
        self,
        chat_id: int = 0,
        size: int = 0,
        count: int = 0,
        by_file_type: List[StorageStatisticsByFileType] = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier; 0 if none"""
        self.size: int = int(size)
        r"""Total size of the files in the chat, in bytes"""
        self.count: int = int(count)
        r"""Total number of files in the chat"""
        self.by_file_type: List[StorageStatisticsByFileType] = by_file_type or []
        r"""Statistics split by file types"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storageStatisticsByChat"]:
        return "storageStatisticsByChat"

    def getClass(self) -> Literal["StorageStatisticsByChat"]:
        return "StorageStatisticsByChat"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "size": self.size,
            "count": self.count,
            "by_file_type": self.by_file_type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorageStatisticsByChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.size = int(data.get("size", 0))
            data_class.count = int(data.get("count", 0))
            data_class.by_file_type = data.get("by_file_type", None)

        return data_class


class StorageStatistics(TlObject):
    r"""Contains the exact storage usage statistics split by chats and file type

    Parameters:
        size (:class:`int`):
            Total size of files, in bytes

        count (:class:`int`):
            Total number of files

        by_chat (:class:`List["types.StorageStatisticsByChat"]`):
            Statistics split by chats

    """

    def __init__(
        self,
        size: int = 0,
        count: int = 0,
        by_chat: List[StorageStatisticsByChat] = None,
    ) -> None:
        self.size: int = int(size)
        r"""Total size of files, in bytes"""
        self.count: int = int(count)
        r"""Total number of files"""
        self.by_chat: List[StorageStatisticsByChat] = by_chat or []
        r"""Statistics split by chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storageStatistics"]:
        return "storageStatistics"

    def getClass(self) -> Literal["StorageStatistics"]:
        return "StorageStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "size": self.size,
            "count": self.count,
            "by_chat": self.by_chat,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorageStatistics", None]:
        if data:
            data_class = cls()
            data_class.size = int(data.get("size", 0))
            data_class.count = int(data.get("count", 0))
            data_class.by_chat = data.get("by_chat", None)

        return data_class


class StorageStatisticsFast(TlObject):
    r"""Contains approximate storage usage statistics, excluding files of unknown file type

    Parameters:
        files_size (:class:`int`):
            Approximate total size of files, in bytes

        file_count (:class:`int`):
            Approximate number of files

        database_size (:class:`int`):
            Size of the database

        language_pack_database_size (:class:`int`):
            Size of the language pack database

        log_size (:class:`int`):
            Size of the TDLib internal log

    """

    def __init__(
        self,
        files_size: int = 0,
        file_count: int = 0,
        database_size: int = 0,
        language_pack_database_size: int = 0,
        log_size: int = 0,
    ) -> None:
        self.files_size: int = int(files_size)
        r"""Approximate total size of files, in bytes"""
        self.file_count: int = int(file_count)
        r"""Approximate number of files"""
        self.database_size: int = int(database_size)
        r"""Size of the database"""
        self.language_pack_database_size: int = int(language_pack_database_size)
        r"""Size of the language pack database"""
        self.log_size: int = int(log_size)
        r"""Size of the TDLib internal log"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storageStatisticsFast"]:
        return "storageStatisticsFast"

    def getClass(self) -> Literal["StorageStatisticsFast"]:
        return "StorageStatisticsFast"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "files_size": self.files_size,
            "file_count": self.file_count,
            "database_size": self.database_size,
            "language_pack_database_size": self.language_pack_database_size,
            "log_size": self.log_size,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StorageStatisticsFast", None]:
        if data:
            data_class = cls()
            data_class.files_size = int(data.get("files_size", 0))
            data_class.file_count = int(data.get("file_count", 0))
            data_class.database_size = int(data.get("database_size", 0))
            data_class.language_pack_database_size = int(
                data.get("language_pack_database_size", 0)
            )
            data_class.log_size = int(data.get("log_size", 0))

        return data_class


class DatabaseStatistics(TlObject):
    r"""Contains database statistics

    Parameters:
        statistics (:class:`str`):
            Database statistics in an unspecified human\-readable format

    """

    def __init__(self, statistics: str = "") -> None:
        self.statistics: Union[str, None] = statistics
        r"""Database statistics in an unspecified human\-readable format"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["databaseStatistics"]:
        return "databaseStatistics"

    def getClass(self) -> Literal["DatabaseStatistics"]:
        return "DatabaseStatistics"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "statistics": self.statistics}

    @classmethod
    def from_dict(cls, data: dict) -> Union["DatabaseStatistics", None]:
        if data:
            data_class = cls()
            data_class.statistics = data.get("statistics", "")

        return data_class


class NetworkTypeNone(TlObject, NetworkType):
    r"""The network is not available"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkTypeNone"]:
        return "networkTypeNone"

    def getClass(self) -> Literal["NetworkType"]:
        return "NetworkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkTypeNone", None]:
        if data:
            data_class = cls()

        return data_class


class NetworkTypeMobile(TlObject, NetworkType):
    r"""A mobile network"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkTypeMobile"]:
        return "networkTypeMobile"

    def getClass(self) -> Literal["NetworkType"]:
        return "NetworkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkTypeMobile", None]:
        if data:
            data_class = cls()

        return data_class


class NetworkTypeMobileRoaming(TlObject, NetworkType):
    r"""A mobile roaming network"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkTypeMobileRoaming"]:
        return "networkTypeMobileRoaming"

    def getClass(self) -> Literal["NetworkType"]:
        return "NetworkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkTypeMobileRoaming", None]:
        if data:
            data_class = cls()

        return data_class


class NetworkTypeWiFi(TlObject, NetworkType):
    r"""A Wi\-Fi network"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkTypeWiFi"]:
        return "networkTypeWiFi"

    def getClass(self) -> Literal["NetworkType"]:
        return "NetworkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkTypeWiFi", None]:
        if data:
            data_class = cls()

        return data_class


class NetworkTypeOther(TlObject, NetworkType):
    r"""A different network type \(e\.g\., Ethernet network\)"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkTypeOther"]:
        return "networkTypeOther"

    def getClass(self) -> Literal["NetworkType"]:
        return "NetworkType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkTypeOther", None]:
        if data:
            data_class = cls()

        return data_class


class NetworkStatisticsEntryFile(TlObject, NetworkStatisticsEntry):
    r"""Contains information about the total amount of data that was used to send and receive files

    Parameters:
        file_type (:class:`"types.FileType"`):
            Type of the file the data is part of; pass null if the data isn't related to files

        network_type (:class:`"types.NetworkType"`):
            Type of the network the data was sent through\. Call setNetworkType to maintain the actual network type

        sent_bytes (:class:`int`):
            Total number of bytes sent

        received_bytes (:class:`int`):
            Total number of bytes received

    """

    def __init__(
        self,
        file_type: FileType = None,
        network_type: NetworkType = None,
        sent_bytes: int = 0,
        received_bytes: int = 0,
    ) -> None:
        self.file_type: Union[
            FileTypeNone,
            FileTypeAnimation,
            FileTypeAudio,
            FileTypeDocument,
            FileTypeNotificationSound,
            FileTypePhoto,
            FileTypePhotoStory,
            FileTypeProfilePhoto,
            FileTypeSecret,
            FileTypeSecretThumbnail,
            FileTypeSecure,
            FileTypeSelfDestructingPhoto,
            FileTypeSelfDestructingVideo,
            FileTypeSelfDestructingVideoNote,
            FileTypeSelfDestructingVoiceNote,
            FileTypeSticker,
            FileTypeThumbnail,
            FileTypeUnknown,
            FileTypeVideo,
            FileTypeVideoNote,
            FileTypeVideoStory,
            FileTypeVoiceNote,
            FileTypeWallpaper,
            None,
        ] = file_type
        r"""Type of the file the data is part of; pass null if the data isn't related to files"""
        self.network_type: Union[
            NetworkTypeNone,
            NetworkTypeMobile,
            NetworkTypeMobileRoaming,
            NetworkTypeWiFi,
            NetworkTypeOther,
            None,
        ] = network_type
        r"""Type of the network the data was sent through\. Call setNetworkType to maintain the actual network type"""
        self.sent_bytes: int = int(sent_bytes)
        r"""Total number of bytes sent"""
        self.received_bytes: int = int(received_bytes)
        r"""Total number of bytes received"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkStatisticsEntryFile"]:
        return "networkStatisticsEntryFile"

    def getClass(self) -> Literal["NetworkStatisticsEntry"]:
        return "NetworkStatisticsEntry"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "file_type": self.file_type,
            "network_type": self.network_type,
            "sent_bytes": self.sent_bytes,
            "received_bytes": self.received_bytes,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkStatisticsEntryFile", None]:
        if data:
            data_class = cls()
            data_class.file_type = data.get("file_type", None)
            data_class.network_type = data.get("network_type", None)
            data_class.sent_bytes = int(data.get("sent_bytes", 0))
            data_class.received_bytes = int(data.get("received_bytes", 0))

        return data_class


class NetworkStatisticsEntryCall(TlObject, NetworkStatisticsEntry):
    r"""Contains information about the total amount of data that was used for calls

    Parameters:
        network_type (:class:`"types.NetworkType"`):
            Type of the network the data was sent through\. Call setNetworkType to maintain the actual network type

        sent_bytes (:class:`int`):
            Total number of bytes sent

        received_bytes (:class:`int`):
            Total number of bytes received

        duration (:class:`float`):
            Total call duration, in seconds

    """

    def __init__(
        self,
        network_type: NetworkType = None,
        sent_bytes: int = 0,
        received_bytes: int = 0,
        duration: float = 0.0,
    ) -> None:
        self.network_type: Union[
            NetworkTypeNone,
            NetworkTypeMobile,
            NetworkTypeMobileRoaming,
            NetworkTypeWiFi,
            NetworkTypeOther,
            None,
        ] = network_type
        r"""Type of the network the data was sent through\. Call setNetworkType to maintain the actual network type"""
        self.sent_bytes: int = int(sent_bytes)
        r"""Total number of bytes sent"""
        self.received_bytes: int = int(received_bytes)
        r"""Total number of bytes received"""
        self.duration: float = float(duration)
        r"""Total call duration, in seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkStatisticsEntryCall"]:
        return "networkStatisticsEntryCall"

    def getClass(self) -> Literal["NetworkStatisticsEntry"]:
        return "NetworkStatisticsEntry"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "network_type": self.network_type,
            "sent_bytes": self.sent_bytes,
            "received_bytes": self.received_bytes,
            "duration": self.duration,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkStatisticsEntryCall", None]:
        if data:
            data_class = cls()
            data_class.network_type = data.get("network_type", None)
            data_class.sent_bytes = int(data.get("sent_bytes", 0))
            data_class.received_bytes = int(data.get("received_bytes", 0))
            data_class.duration = data.get("duration", 0.0)

        return data_class


class NetworkStatistics(TlObject):
    r"""A full list of available network statistic entries

    Parameters:
        since_date (:class:`int`):
            Point in time \(Unix timestamp\) from which the statistics are collected

        entries (:class:`List["types.NetworkStatisticsEntry"]`):
            Network statistics entries

    """

    def __init__(
        self, since_date: int = 0, entries: List[NetworkStatisticsEntry] = None
    ) -> None:
        self.since_date: int = int(since_date)
        r"""Point in time \(Unix timestamp\) from which the statistics are collected"""
        self.entries: List[NetworkStatisticsEntry] = entries or []
        r"""Network statistics entries"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["networkStatistics"]:
        return "networkStatistics"

    def getClass(self) -> Literal["NetworkStatistics"]:
        return "NetworkStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "since_date": self.since_date,
            "entries": self.entries,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["NetworkStatistics", None]:
        if data:
            data_class = cls()
            data_class.since_date = int(data.get("since_date", 0))
            data_class.entries = data.get("entries", None)

        return data_class


class AutoDownloadSettings(TlObject):
    r"""Contains auto\-download settings

    Parameters:
        is_auto_download_enabled (:class:`bool`):
            True, if the auto\-download is enabled

        max_photo_file_size (:class:`int`):
            The maximum size of a photo file to be auto\-downloaded, in bytes

        max_video_file_size (:class:`int`):
            The maximum size of a video file to be auto\-downloaded, in bytes

        max_other_file_size (:class:`int`):
            The maximum size of other file types to be auto\-downloaded, in bytes

        video_upload_bitrate (:class:`int`):
            The maximum suggested bitrate for uploaded videos, in kbit/s

        preload_large_videos (:class:`bool`):
            True, if the beginning of video files needs to be preloaded for instant playback

        preload_next_audio (:class:`bool`):
            True, if the next audio track needs to be preloaded while the user is listening to an audio file

        preload_stories (:class:`bool`):
            True, if stories needs to be preloaded

        use_less_data_for_calls (:class:`bool`):
            True, if \"use less data for calls\" option needs to be enabled

    """

    def __init__(
        self,
        is_auto_download_enabled: bool = False,
        max_photo_file_size: int = 0,
        max_video_file_size: int = 0,
        max_other_file_size: int = 0,
        video_upload_bitrate: int = 0,
        preload_large_videos: bool = False,
        preload_next_audio: bool = False,
        preload_stories: bool = False,
        use_less_data_for_calls: bool = False,
    ) -> None:
        self.is_auto_download_enabled: bool = bool(is_auto_download_enabled)
        r"""True, if the auto\-download is enabled"""
        self.max_photo_file_size: int = int(max_photo_file_size)
        r"""The maximum size of a photo file to be auto\-downloaded, in bytes"""
        self.max_video_file_size: int = int(max_video_file_size)
        r"""The maximum size of a video file to be auto\-downloaded, in bytes"""
        self.max_other_file_size: int = int(max_other_file_size)
        r"""The maximum size of other file types to be auto\-downloaded, in bytes"""
        self.video_upload_bitrate: int = int(video_upload_bitrate)
        r"""The maximum suggested bitrate for uploaded videos, in kbit/s"""
        self.preload_large_videos: bool = bool(preload_large_videos)
        r"""True, if the beginning of video files needs to be preloaded for instant playback"""
        self.preload_next_audio: bool = bool(preload_next_audio)
        r"""True, if the next audio track needs to be preloaded while the user is listening to an audio file"""
        self.preload_stories: bool = bool(preload_stories)
        r"""True, if stories needs to be preloaded"""
        self.use_less_data_for_calls: bool = bool(use_less_data_for_calls)
        r"""True, if \"use less data for calls\" option needs to be enabled"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autoDownloadSettings"]:
        return "autoDownloadSettings"

    def getClass(self) -> Literal["AutoDownloadSettings"]:
        return "AutoDownloadSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_auto_download_enabled": self.is_auto_download_enabled,
            "max_photo_file_size": self.max_photo_file_size,
            "max_video_file_size": self.max_video_file_size,
            "max_other_file_size": self.max_other_file_size,
            "video_upload_bitrate": self.video_upload_bitrate,
            "preload_large_videos": self.preload_large_videos,
            "preload_next_audio": self.preload_next_audio,
            "preload_stories": self.preload_stories,
            "use_less_data_for_calls": self.use_less_data_for_calls,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutoDownloadSettings", None]:
        if data:
            data_class = cls()
            data_class.is_auto_download_enabled = data.get(
                "is_auto_download_enabled", False
            )
            data_class.max_photo_file_size = int(data.get("max_photo_file_size", 0))
            data_class.max_video_file_size = int(data.get("max_video_file_size", 0))
            data_class.max_other_file_size = int(data.get("max_other_file_size", 0))
            data_class.video_upload_bitrate = int(data.get("video_upload_bitrate", 0))
            data_class.preload_large_videos = data.get("preload_large_videos", False)
            data_class.preload_next_audio = data.get("preload_next_audio", False)
            data_class.preload_stories = data.get("preload_stories", False)
            data_class.use_less_data_for_calls = data.get(
                "use_less_data_for_calls", False
            )

        return data_class


class AutoDownloadSettingsPresets(TlObject):
    r"""Contains auto\-download settings presets for the current user

    Parameters:
        low (:class:`"types.AutoDownloadSettings"`):
            Preset with lowest settings; expected to be used by default when roaming

        medium (:class:`"types.AutoDownloadSettings"`):
            Preset with medium settings; expected to be used by default when using mobile data

        high (:class:`"types.AutoDownloadSettings"`):
            Preset with highest settings; expected to be used by default when connected on Wi\-Fi

    """

    def __init__(
        self,
        low: AutoDownloadSettings = None,
        medium: AutoDownloadSettings = None,
        high: AutoDownloadSettings = None,
    ) -> None:
        self.low: Union[AutoDownloadSettings, None] = low
        r"""Preset with lowest settings; expected to be used by default when roaming"""
        self.medium: Union[AutoDownloadSettings, None] = medium
        r"""Preset with medium settings; expected to be used by default when using mobile data"""
        self.high: Union[AutoDownloadSettings, None] = high
        r"""Preset with highest settings; expected to be used by default when connected on Wi\-Fi"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autoDownloadSettingsPresets"]:
        return "autoDownloadSettingsPresets"

    def getClass(self) -> Literal["AutoDownloadSettingsPresets"]:
        return "AutoDownloadSettingsPresets"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "low": self.low,
            "medium": self.medium,
            "high": self.high,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutoDownloadSettingsPresets", None]:
        if data:
            data_class = cls()
            data_class.low = data.get("low", None)
            data_class.medium = data.get("medium", None)
            data_class.high = data.get("high", None)

        return data_class


class AutosaveSettingsScopePrivateChats(TlObject, AutosaveSettingsScope):
    r"""Autosave settings applied to all private chats without chat\-specific settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autosaveSettingsScopePrivateChats"]:
        return "autosaveSettingsScopePrivateChats"

    def getClass(self) -> Literal["AutosaveSettingsScope"]:
        return "AutosaveSettingsScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutosaveSettingsScopePrivateChats", None]:
        if data:
            data_class = cls()

        return data_class


class AutosaveSettingsScopeGroupChats(TlObject, AutosaveSettingsScope):
    r"""Autosave settings applied to all basic group and supergroup chats without chat\-specific settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autosaveSettingsScopeGroupChats"]:
        return "autosaveSettingsScopeGroupChats"

    def getClass(self) -> Literal["AutosaveSettingsScope"]:
        return "AutosaveSettingsScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutosaveSettingsScopeGroupChats", None]:
        if data:
            data_class = cls()

        return data_class


class AutosaveSettingsScopeChannelChats(TlObject, AutosaveSettingsScope):
    r"""Autosave settings applied to all channel chats without chat\-specific settings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autosaveSettingsScopeChannelChats"]:
        return "autosaveSettingsScopeChannelChats"

    def getClass(self) -> Literal["AutosaveSettingsScope"]:
        return "AutosaveSettingsScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutosaveSettingsScopeChannelChats", None]:
        if data:
            data_class = cls()

        return data_class


class AutosaveSettingsScopeChat(TlObject, AutosaveSettingsScope):
    r"""Autosave settings applied to a chat

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autosaveSettingsScopeChat"]:
        return "autosaveSettingsScopeChat"

    def getClass(self) -> Literal["AutosaveSettingsScope"]:
        return "AutosaveSettingsScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutosaveSettingsScopeChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class ScopeAutosaveSettings(TlObject):
    r"""Contains autosave settings for an autosave settings scope

    Parameters:
        autosave_photos (:class:`bool`):
            True, if photo autosave is enabled

        autosave_videos (:class:`bool`):
            True, if video autosave is enabled

        max_video_file_size (:class:`int`):
            The maximum size of a video file to be autosaved, in bytes; 512 KB \- 4000 MB

    """

    def __init__(
        self,
        autosave_photos: bool = False,
        autosave_videos: bool = False,
        max_video_file_size: int = 0,
    ) -> None:
        self.autosave_photos: bool = bool(autosave_photos)
        r"""True, if photo autosave is enabled"""
        self.autosave_videos: bool = bool(autosave_videos)
        r"""True, if video autosave is enabled"""
        self.max_video_file_size: int = int(max_video_file_size)
        r"""The maximum size of a video file to be autosaved, in bytes; 512 KB \- 4000 MB"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["scopeAutosaveSettings"]:
        return "scopeAutosaveSettings"

    def getClass(self) -> Literal["ScopeAutosaveSettings"]:
        return "ScopeAutosaveSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "autosave_photos": self.autosave_photos,
            "autosave_videos": self.autosave_videos,
            "max_video_file_size": self.max_video_file_size,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ScopeAutosaveSettings", None]:
        if data:
            data_class = cls()
            data_class.autosave_photos = data.get("autosave_photos", False)
            data_class.autosave_videos = data.get("autosave_videos", False)
            data_class.max_video_file_size = int(data.get("max_video_file_size", 0))

        return data_class


class AutosaveSettingsException(TlObject):
    r"""Contains autosave settings for a chat, which overrides default settings for the corresponding scope

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        settings (:class:`"types.ScopeAutosaveSettings"`):
            Autosave settings for the chat

    """

    def __init__(
        self, chat_id: int = 0, settings: ScopeAutosaveSettings = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.settings: Union[ScopeAutosaveSettings, None] = settings
        r"""Autosave settings for the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autosaveSettingsException"]:
        return "autosaveSettingsException"

    def getClass(self) -> Literal["AutosaveSettingsException"]:
        return "AutosaveSettingsException"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "settings": self.settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutosaveSettingsException", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.settings = data.get("settings", None)

        return data_class


class AutosaveSettings(TlObject):
    r"""Describes autosave settings

    Parameters:
        private_chat_settings (:class:`"types.ScopeAutosaveSettings"`):
            Default autosave settings for private chats

        group_settings (:class:`"types.ScopeAutosaveSettings"`):
            Default autosave settings for basic group and supergroup chats

        channel_settings (:class:`"types.ScopeAutosaveSettings"`):
            Default autosave settings for channel chats

        exceptions (:class:`List["types.AutosaveSettingsException"]`):
            Autosave settings for specific chats

    """

    def __init__(
        self,
        private_chat_settings: ScopeAutosaveSettings = None,
        group_settings: ScopeAutosaveSettings = None,
        channel_settings: ScopeAutosaveSettings = None,
        exceptions: List[AutosaveSettingsException] = None,
    ) -> None:
        self.private_chat_settings: Union[ScopeAutosaveSettings, None] = (
            private_chat_settings
        )
        r"""Default autosave settings for private chats"""
        self.group_settings: Union[ScopeAutosaveSettings, None] = group_settings
        r"""Default autosave settings for basic group and supergroup chats"""
        self.channel_settings: Union[ScopeAutosaveSettings, None] = channel_settings
        r"""Default autosave settings for channel chats"""
        self.exceptions: List[AutosaveSettingsException] = exceptions or []
        r"""Autosave settings for specific chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["autosaveSettings"]:
        return "autosaveSettings"

    def getClass(self) -> Literal["AutosaveSettings"]:
        return "AutosaveSettings"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "private_chat_settings": self.private_chat_settings,
            "group_settings": self.group_settings,
            "channel_settings": self.channel_settings,
            "exceptions": self.exceptions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["AutosaveSettings", None]:
        if data:
            data_class = cls()
            data_class.private_chat_settings = data.get("private_chat_settings", None)
            data_class.group_settings = data.get("group_settings", None)
            data_class.channel_settings = data.get("channel_settings", None)
            data_class.exceptions = data.get("exceptions", None)

        return data_class


class ConnectionStateWaitingForNetwork(TlObject, ConnectionState):
    r"""Waiting for the network to become available\. Use setNetworkType to change the available network type"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectionStateWaitingForNetwork"]:
        return "connectionStateWaitingForNetwork"

    def getClass(self) -> Literal["ConnectionState"]:
        return "ConnectionState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectionStateWaitingForNetwork", None]:
        if data:
            data_class = cls()

        return data_class


class ConnectionStateConnectingToProxy(TlObject, ConnectionState):
    r"""Establishing a connection with a proxy server"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectionStateConnectingToProxy"]:
        return "connectionStateConnectingToProxy"

    def getClass(self) -> Literal["ConnectionState"]:
        return "ConnectionState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectionStateConnectingToProxy", None]:
        if data:
            data_class = cls()

        return data_class


class ConnectionStateConnecting(TlObject, ConnectionState):
    r"""Establishing a connection to the Telegram servers"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectionStateConnecting"]:
        return "connectionStateConnecting"

    def getClass(self) -> Literal["ConnectionState"]:
        return "ConnectionState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectionStateConnecting", None]:
        if data:
            data_class = cls()

        return data_class


class ConnectionStateUpdating(TlObject, ConnectionState):
    r"""Downloading data expected to be received while the application was offline"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectionStateUpdating"]:
        return "connectionStateUpdating"

    def getClass(self) -> Literal["ConnectionState"]:
        return "ConnectionState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectionStateUpdating", None]:
        if data:
            data_class = cls()

        return data_class


class ConnectionStateReady(TlObject, ConnectionState):
    r"""There is a working connection to the Telegram servers"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["connectionStateReady"]:
        return "connectionStateReady"

    def getClass(self) -> Literal["ConnectionState"]:
        return "ConnectionState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ConnectionStateReady", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryUsers(TlObject, TopChatCategory):
    r"""A category containing frequently used private chats with non\-bot users"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryUsers"]:
        return "topChatCategoryUsers"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryUsers", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryBots(TlObject, TopChatCategory):
    r"""A category containing frequently used private chats with bot users"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryBots"]:
        return "topChatCategoryBots"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryBots", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryGroups(TlObject, TopChatCategory):
    r"""A category containing frequently used basic groups and supergroups"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryGroups"]:
        return "topChatCategoryGroups"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryGroups", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryChannels(TlObject, TopChatCategory):
    r"""A category containing frequently used channels"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryChannels"]:
        return "topChatCategoryChannels"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryChannels", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryInlineBots(TlObject, TopChatCategory):
    r"""A category containing frequently used chats with inline bots sorted by their usage in inline mode"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryInlineBots"]:
        return "topChatCategoryInlineBots"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryInlineBots", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryWebAppBots(TlObject, TopChatCategory):
    r"""A category containing frequently used chats with bots, which Web Apps were opened"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryWebAppBots"]:
        return "topChatCategoryWebAppBots"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryWebAppBots", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryCalls(TlObject, TopChatCategory):
    r"""A category containing frequently used chats used for calls"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryCalls"]:
        return "topChatCategoryCalls"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryCalls", None]:
        if data:
            data_class = cls()

        return data_class


class TopChatCategoryForwardChats(TlObject, TopChatCategory):
    r"""A category containing frequently used chats used to forward messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["topChatCategoryForwardChats"]:
        return "topChatCategoryForwardChats"

    def getClass(self) -> Literal["TopChatCategory"]:
        return "TopChatCategory"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TopChatCategoryForwardChats", None]:
        if data:
            data_class = cls()

        return data_class


class FoundPosition(TlObject):
    r"""Contains 0\-based match position

    Parameters:
        position (:class:`int`):
            The position of the match

    """

    def __init__(self, position: int = 0) -> None:
        self.position: int = int(position)
        r"""The position of the match"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundPosition"]:
        return "foundPosition"

    def getClass(self) -> Literal["FoundPosition"]:
        return "FoundPosition"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "position": self.position}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundPosition", None]:
        if data:
            data_class = cls()
            data_class.position = int(data.get("position", 0))

        return data_class


class FoundPositions(TlObject):
    r"""Contains 0\-based positions of matched objects

    Parameters:
        total_count (:class:`int`):
            Total number of matched objects

        positions (:class:`List[int]`):
            The positions of the matched objects

    """

    def __init__(self, total_count: int = 0, positions: List[int] = None) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of matched objects"""
        self.positions: List[int] = positions or []
        r"""The positions of the matched objects"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["foundPositions"]:
        return "foundPositions"

    def getClass(self) -> Literal["FoundPositions"]:
        return "FoundPositions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "positions": self.positions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["FoundPositions", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.positions = data.get("positions", None)

        return data_class


class TMeUrlTypeUser(TlObject, TMeUrlType):
    r"""A URL linking to a user

    Parameters:
        user_id (:class:`int`):
            Identifier of the user

    """

    def __init__(self, user_id: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""Identifier of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["tMeUrlTypeUser"]:
        return "tMeUrlTypeUser"

    def getClass(self) -> Literal["TMeUrlType"]:
        return "TMeUrlType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TMeUrlTypeUser", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class TMeUrlTypeSupergroup(TlObject, TMeUrlType):
    r"""A URL linking to a public supergroup or channel

    Parameters:
        supergroup_id (:class:`int`):
            Identifier of the supergroup or channel

    """

    def __init__(self, supergroup_id: int = 0) -> None:
        self.supergroup_id: int = int(supergroup_id)
        r"""Identifier of the supergroup or channel"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["tMeUrlTypeSupergroup"]:
        return "tMeUrlTypeSupergroup"

    def getClass(self) -> Literal["TMeUrlType"]:
        return "TMeUrlType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "supergroup_id": self.supergroup_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TMeUrlTypeSupergroup", None]:
        if data:
            data_class = cls()
            data_class.supergroup_id = int(data.get("supergroup_id", 0))

        return data_class


class TMeUrlTypeChatInvite(TlObject, TMeUrlType):
    r"""A chat invite link

    Parameters:
        info (:class:`"types.ChatInviteLinkInfo"`):
            Information about the chat invite link

    """

    def __init__(self, info: ChatInviteLinkInfo = None) -> None:
        self.info: Union[ChatInviteLinkInfo, None] = info
        r"""Information about the chat invite link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["tMeUrlTypeChatInvite"]:
        return "tMeUrlTypeChatInvite"

    def getClass(self) -> Literal["TMeUrlType"]:
        return "TMeUrlType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "info": self.info}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TMeUrlTypeChatInvite", None]:
        if data:
            data_class = cls()
            data_class.info = data.get("info", None)

        return data_class


class TMeUrlTypeStickerSet(TlObject, TMeUrlType):
    r"""A URL linking to a sticker set

    Parameters:
        sticker_set_id (:class:`int`):
            Identifier of the sticker set

    """

    def __init__(self, sticker_set_id: int = 0) -> None:
        self.sticker_set_id: int = int(sticker_set_id)
        r"""Identifier of the sticker set"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["tMeUrlTypeStickerSet"]:
        return "tMeUrlTypeStickerSet"

    def getClass(self) -> Literal["TMeUrlType"]:
        return "TMeUrlType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sticker_set_id": self.sticker_set_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TMeUrlTypeStickerSet", None]:
        if data:
            data_class = cls()
            data_class.sticker_set_id = int(data.get("sticker_set_id", 0))

        return data_class


class TMeUrl(TlObject):
    r"""Represents a URL linking to an internal Telegram entity

    Parameters:
        url (:class:`str`):
            URL

        type (:class:`"types.TMeUrlType"`):
            Type of the URL

    """

    def __init__(self, url: str = "", type: TMeUrlType = None) -> None:
        self.url: Union[str, None] = url
        r"""URL"""
        self.type: Union[
            TMeUrlTypeUser,
            TMeUrlTypeSupergroup,
            TMeUrlTypeChatInvite,
            TMeUrlTypeStickerSet,
            None,
        ] = type
        r"""Type of the URL"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["tMeUrl"]:
        return "tMeUrl"

    def getClass(self) -> Literal["TMeUrl"]:
        return "TMeUrl"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "url": self.url, "type": self.type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TMeUrl", None]:
        if data:
            data_class = cls()
            data_class.url = data.get("url", "")
            data_class.type = data.get("type", None)

        return data_class


class TMeUrls(TlObject):
    r"""Contains a list of t\.me URLs

    Parameters:
        urls (:class:`List["types.TMeUrl"]`):
            List of URLs

    """

    def __init__(self, urls: List[TMeUrl] = None) -> None:
        self.urls: List[TMeUrl] = urls or []
        r"""List of URLs"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["tMeUrls"]:
        return "tMeUrls"

    def getClass(self) -> Literal["TMeUrls"]:
        return "TMeUrls"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "urls": self.urls}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TMeUrls", None]:
        if data:
            data_class = cls()
            data_class.urls = data.get("urls", None)

        return data_class


class SuggestedActionEnableArchiveAndMuteNewChats(TlObject, SuggestedAction):
    r"""Suggests the user to enable archive\_and\_mute\_new\_chats\_from\_unknown\_users setting in archiveChatListSettings"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionEnableArchiveAndMuteNewChats"]:
        return "suggestedActionEnableArchiveAndMuteNewChats"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SuggestedActionEnableArchiveAndMuteNewChats", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionCheckPassword(TlObject, SuggestedAction):
    r"""Suggests the user to check whether they still remember their 2\-step verification password"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionCheckPassword"]:
        return "suggestedActionCheckPassword"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionCheckPassword", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionCheckPhoneNumber(TlObject, SuggestedAction):
    r"""Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionCheckPhoneNumber"]:
        return "suggestedActionCheckPhoneNumber"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionCheckPhoneNumber", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionViewChecksHint(TlObject, SuggestedAction):
    r"""Suggests the user to view a hint about the meaning of one and two check marks on sent messages"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionViewChecksHint"]:
        return "suggestedActionViewChecksHint"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionViewChecksHint", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionConvertToBroadcastGroup(TlObject, SuggestedAction):
    r"""Suggests the user to convert specified supergroup to a broadcast group

    Parameters:
        supergroup_id (:class:`int`):
            Supergroup identifier

    """

    def __init__(self, supergroup_id: int = 0) -> None:
        self.supergroup_id: int = int(supergroup_id)
        r"""Supergroup identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionConvertToBroadcastGroup"]:
        return "suggestedActionConvertToBroadcastGroup"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "supergroup_id": self.supergroup_id}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SuggestedActionConvertToBroadcastGroup", None]:
        if data:
            data_class = cls()
            data_class.supergroup_id = int(data.get("supergroup_id", 0))

        return data_class


class SuggestedActionSetPassword(TlObject, SuggestedAction):
    r"""Suggests the user to set a 2\-step verification password to be able to log in again

    Parameters:
        authorization_delay (:class:`int`):
            The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons

    """

    def __init__(self, authorization_delay: int = 0) -> None:
        self.authorization_delay: int = int(authorization_delay)
        r"""The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionSetPassword"]:
        return "suggestedActionSetPassword"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "authorization_delay": self.authorization_delay,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionSetPassword", None]:
        if data:
            data_class = cls()
            data_class.authorization_delay = int(data.get("authorization_delay", 0))

        return data_class


class SuggestedActionUpgradePremium(TlObject, SuggestedAction):
    r"""Suggests the user to upgrade the Premium subscription from monthly payments to annual payments"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionUpgradePremium"]:
        return "suggestedActionUpgradePremium"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionUpgradePremium", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionRestorePremium(TlObject, SuggestedAction):
    r"""Suggests the user to restore a recently expired Premium subscription"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionRestorePremium"]:
        return "suggestedActionRestorePremium"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionRestorePremium", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionSubscribeToAnnualPremium(TlObject, SuggestedAction):
    r"""Suggests the user to subscribe to the Premium subscription with annual payments"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionSubscribeToAnnualPremium"]:
        return "suggestedActionSubscribeToAnnualPremium"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SuggestedActionSubscribeToAnnualPremium", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionGiftPremiumForChristmas(TlObject, SuggestedAction):
    r"""Suggests the user to gift Telegram Premium to friends for Christmas"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionGiftPremiumForChristmas"]:
        return "suggestedActionGiftPremiumForChristmas"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SuggestedActionGiftPremiumForChristmas", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionSetBirthdate(TlObject, SuggestedAction):
    r"""Suggests the user to set birthdate"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionSetBirthdate"]:
        return "suggestedActionSetBirthdate"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionSetBirthdate", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionSetProfilePhoto(TlObject, SuggestedAction):
    r"""Suggests the user to set profile photo"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionSetProfilePhoto"]:
        return "suggestedActionSetProfilePhoto"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionSetProfilePhoto", None]:
        if data:
            data_class = cls()

        return data_class


class SuggestedActionExtendPremium(TlObject, SuggestedAction):
    r"""Suggests the user to extend their expiring Telegram Premium subscription

    Parameters:
        manage_premium_subscription_url (:class:`str`):
            A URL for managing Telegram Premium subscription

    """

    def __init__(self, manage_premium_subscription_url: str = "") -> None:
        self.manage_premium_subscription_url: Union[str, None] = (
            manage_premium_subscription_url
        )
        r"""A URL for managing Telegram Premium subscription"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionExtendPremium"]:
        return "suggestedActionExtendPremium"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "manage_premium_subscription_url": self.manage_premium_subscription_url,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["SuggestedActionExtendPremium", None]:
        if data:
            data_class = cls()
            data_class.manage_premium_subscription_url = data.get(
                "manage_premium_subscription_url", ""
            )

        return data_class


class SuggestedActionExtendStarSubscriptions(TlObject, SuggestedAction):
    r"""Suggests the user to extend their expiring Telegram Star subscriptions\. Call getStarSubscriptions with only\_expiring \=\= true to get the number of expiring subscriptions and the number of required to buy Telegram Stars"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["suggestedActionExtendStarSubscriptions"]:
        return "suggestedActionExtendStarSubscriptions"

    def getClass(self) -> Literal["SuggestedAction"]:
        return "SuggestedAction"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["SuggestedActionExtendStarSubscriptions", None]:
        if data:
            data_class = cls()

        return data_class


class Count(TlObject):
    r"""Contains a counter

    Parameters:
        count (:class:`int`):
            Count

    """

    def __init__(self, count: int = 0) -> None:
        self.count: int = int(count)
        r"""Count"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["count"]:
        return "count"

    def getClass(self) -> Literal["Count"]:
        return "Count"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "count": self.count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Count", None]:
        if data:
            data_class = cls()
            data_class.count = int(data.get("count", 0))

        return data_class


class Text(TlObject):
    r"""Contains some text

    Parameters:
        text (:class:`str`):
            Text

    """

    def __init__(self, text: str = "") -> None:
        self.text: Union[str, None] = text
        r"""Text"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["text"]:
        return "text"

    def getClass(self) -> Literal["Text"]:
        return "Text"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "text": self.text}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Text", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", "")

        return data_class


class Seconds(TlObject):
    r"""Contains a value representing a number of seconds

    Parameters:
        seconds (:class:`float`):
            Number of seconds

    """

    def __init__(self, seconds: float = 0.0) -> None:
        self.seconds: float = float(seconds)
        r"""Number of seconds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["seconds"]:
        return "seconds"

    def getClass(self) -> Literal["Seconds"]:
        return "Seconds"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "seconds": self.seconds}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Seconds", None]:
        if data:
            data_class = cls()
            data_class.seconds = data.get("seconds", 0.0)

        return data_class


class FileDownloadedPrefixSize(TlObject):
    r"""Contains size of downloaded prefix of a file

    Parameters:
        size (:class:`int`):
            The prefix size, in bytes

    """

    def __init__(self, size: int = 0) -> None:
        self.size: int = int(size)
        r"""The prefix size, in bytes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["fileDownloadedPrefixSize"]:
        return "fileDownloadedPrefixSize"

    def getClass(self) -> Literal["FileDownloadedPrefixSize"]:
        return "FileDownloadedPrefixSize"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "size": self.size}

    @classmethod
    def from_dict(cls, data: dict) -> Union["FileDownloadedPrefixSize", None]:
        if data:
            data_class = cls()
            data_class.size = int(data.get("size", 0))

        return data_class


class StarCount(TlObject):
    r"""Contains a number of Telegram Stars

    Parameters:
        star_count (:class:`int`):
            Number of Telegram Stars

    """

    def __init__(self, star_count: int = 0) -> None:
        self.star_count: int = int(star_count)
        r"""Number of Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starCount"]:
        return "starCount"

    def getClass(self) -> Literal["StarCount"]:
        return "StarCount"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "star_count": self.star_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarCount", None]:
        if data:
            data_class = cls()
            data_class.star_count = int(data.get("star_count", 0))

        return data_class


class DeepLinkInfo(TlObject):
    r"""Contains information about a tg: deep link

    Parameters:
        text (:class:`"types.FormattedText"`):
            Text to be shown to the user

        need_update_application (:class:`bool`):
            True, if the user must be asked to update the application

    """

    def __init__(
        self, text: FormattedText = None, need_update_application: bool = False
    ) -> None:
        self.text: Union[FormattedText, None] = text
        r"""Text to be shown to the user"""
        self.need_update_application: bool = bool(need_update_application)
        r"""True, if the user must be asked to update the application"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["deepLinkInfo"]:
        return "deepLinkInfo"

    def getClass(self) -> Literal["DeepLinkInfo"]:
        return "DeepLinkInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "text": self.text,
            "need_update_application": self.need_update_application,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DeepLinkInfo", None]:
        if data:
            data_class = cls()
            data_class.text = data.get("text", None)
            data_class.need_update_application = data.get(
                "need_update_application", False
            )

        return data_class


class TextParseModeMarkdown(TlObject, TextParseMode):
    r"""The text uses Markdown\-style formatting

    Parameters:
        version (:class:`int`):
            Version of the parser: 0 or 1 \- Telegram Bot API \"Markdown\" parse mode, 2 \- Telegram Bot API \"MarkdownV2\" parse mode

    """

    def __init__(self, version: int = 0) -> None:
        self.version: int = int(version)
        r"""Version of the parser: 0 or 1 \- Telegram Bot API \"Markdown\" parse mode, 2 \- Telegram Bot API \"MarkdownV2\" parse mode"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textParseModeMarkdown"]:
        return "textParseModeMarkdown"

    def getClass(self) -> Literal["TextParseMode"]:
        return "TextParseMode"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "version": self.version}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextParseModeMarkdown", None]:
        if data:
            data_class = cls()
            data_class.version = int(data.get("version", 0))

        return data_class


class TextParseModeHTML(TlObject, TextParseMode):
    r"""The text uses HTML\-style formatting\. The same as Telegram Bot API \"HTML\" parse mode"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["textParseModeHTML"]:
        return "textParseModeHTML"

    def getClass(self) -> Literal["TextParseMode"]:
        return "TextParseMode"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TextParseModeHTML", None]:
        if data:
            data_class = cls()

        return data_class


class ProxyTypeSocks5(TlObject, ProxyType):
    r"""A SOCKS5 proxy server

    Parameters:
        username (:class:`str`):
            Username for logging in; may be empty

        password (:class:`str`):
            Password for logging in; may be empty

    """

    def __init__(self, username: str = "", password: str = "") -> None:
        self.username: Union[str, None] = username
        r"""Username for logging in; may be empty"""
        self.password: Union[str, None] = password
        r"""Password for logging in; may be empty"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["proxyTypeSocks5"]:
        return "proxyTypeSocks5"

    def getClass(self) -> Literal["ProxyType"]:
        return "ProxyType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "username": self.username,
            "password": self.password,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ProxyTypeSocks5", None]:
        if data:
            data_class = cls()
            data_class.username = data.get("username", "")
            data_class.password = data.get("password", "")

        return data_class


class ProxyTypeHttp(TlObject, ProxyType):
    r"""A HTTP transparent proxy server

    Parameters:
        username (:class:`str`):
            Username for logging in; may be empty

        password (:class:`str`):
            Password for logging in; may be empty

        http_only (:class:`bool`):
            Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method

    """

    def __init__(
        self, username: str = "", password: str = "", http_only: bool = False
    ) -> None:
        self.username: Union[str, None] = username
        r"""Username for logging in; may be empty"""
        self.password: Union[str, None] = password
        r"""Password for logging in; may be empty"""
        self.http_only: bool = bool(http_only)
        r"""Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["proxyTypeHttp"]:
        return "proxyTypeHttp"

    def getClass(self) -> Literal["ProxyType"]:
        return "ProxyType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "username": self.username,
            "password": self.password,
            "http_only": self.http_only,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ProxyTypeHttp", None]:
        if data:
            data_class = cls()
            data_class.username = data.get("username", "")
            data_class.password = data.get("password", "")
            data_class.http_only = data.get("http_only", False)

        return data_class


class ProxyTypeMtproto(TlObject, ProxyType):
    r"""An MTProto proxy server

    Parameters:
        secret (:class:`str`):
            The proxy's secret in hexadecimal encoding

    """

    def __init__(self, secret: str = "") -> None:
        self.secret: Union[str, None] = secret
        r"""The proxy's secret in hexadecimal encoding"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["proxyTypeMtproto"]:
        return "proxyTypeMtproto"

    def getClass(self) -> Literal["ProxyType"]:
        return "ProxyType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "secret": self.secret}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ProxyTypeMtproto", None]:
        if data:
            data_class = cls()
            data_class.secret = data.get("secret", "")

        return data_class


class Proxy(TlObject):
    r"""Contains information about a proxy server

    Parameters:
        id (:class:`int`):
            Unique identifier of the proxy

        server (:class:`str`):
            Proxy server domain or IP address

        port (:class:`int`):
            Proxy server port

        last_used_date (:class:`int`):
            Point in time \(Unix timestamp\) when the proxy was last used; 0 if never

        is_enabled (:class:`bool`):
            True, if the proxy is enabled now

        type (:class:`"types.ProxyType"`):
            Type of the proxy

    """

    def __init__(
        self,
        id: int = 0,
        server: str = "",
        port: int = 0,
        last_used_date: int = 0,
        is_enabled: bool = False,
        type: ProxyType = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique identifier of the proxy"""
        self.server: Union[str, None] = server
        r"""Proxy server domain or IP address"""
        self.port: int = int(port)
        r"""Proxy server port"""
        self.last_used_date: int = int(last_used_date)
        r"""Point in time \(Unix timestamp\) when the proxy was last used; 0 if never"""
        self.is_enabled: bool = bool(is_enabled)
        r"""True, if the proxy is enabled now"""
        self.type: Union[ProxyTypeSocks5, ProxyTypeHttp, ProxyTypeMtproto, None] = type
        r"""Type of the proxy"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["proxy"]:
        return "proxy"

    def getClass(self) -> Literal["Proxy"]:
        return "Proxy"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "server": self.server,
            "port": self.port,
            "last_used_date": self.last_used_date,
            "is_enabled": self.is_enabled,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["Proxy", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.server = data.get("server", "")
            data_class.port = int(data.get("port", 0))
            data_class.last_used_date = int(data.get("last_used_date", 0))
            data_class.is_enabled = data.get("is_enabled", False)
            data_class.type = data.get("type", None)

        return data_class


class Proxies(TlObject):
    r"""Represents a list of proxy servers

    Parameters:
        proxies (:class:`List["types.Proxy"]`):
            List of proxy servers

    """

    def __init__(self, proxies: List[Proxy] = None) -> None:
        self.proxies: List[Proxy] = proxies or []
        r"""List of proxy servers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["proxies"]:
        return "proxies"

    def getClass(self) -> Literal["Proxies"]:
        return "Proxies"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "proxies": self.proxies}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Proxies", None]:
        if data:
            data_class = cls()
            data_class.proxies = data.get("proxies", None)

        return data_class


class InputSticker(TlObject):
    r"""A sticker to be added to a sticker set

    Parameters:
        sticker (:class:`"types.InputFile"`):
            File with the sticker; must fit in a 512x512 square\. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server\-side\. See https://core\.telegram\.org/animated\_stickers\#technical\-requirements for technical requirements

        format (:class:`"types.StickerFormat"`):
            Format of the sticker

        emojis (:class:`str`):
            String with 1\-20 emoji corresponding to the sticker

        mask_position (:class:`"types.MaskPosition"`):
            Position where the mask is placed; pass null if not specified

        keywords (:class:`List[str]`):
            List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker

    """

    def __init__(
        self,
        sticker: InputFile = None,
        format: StickerFormat = None,
        emojis: str = "",
        mask_position: MaskPosition = None,
        keywords: List[str] = None,
    ) -> None:
        self.sticker: Union[
            InputFileId, InputFileRemote, InputFileLocal, InputFileGenerated, None
        ] = sticker
        r"""File with the sticker; must fit in a 512x512 square\. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server\-side\. See https://core\.telegram\.org/animated\_stickers\#technical\-requirements for technical requirements"""
        self.format: Union[
            StickerFormatWebp, StickerFormatTgs, StickerFormatWebm, None
        ] = format
        r"""Format of the sticker"""
        self.emojis: Union[str, None] = emojis
        r"""String with 1\-20 emoji corresponding to the sticker"""
        self.mask_position: Union[MaskPosition, None] = mask_position
        r"""Position where the mask is placed; pass null if not specified"""
        self.keywords: List[str] = keywords or []
        r"""List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["inputSticker"]:
        return "inputSticker"

    def getClass(self) -> Literal["InputSticker"]:
        return "InputSticker"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker": self.sticker,
            "format": self.format,
            "emojis": self.emojis,
            "mask_position": self.mask_position,
            "keywords": self.keywords,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["InputSticker", None]:
        if data:
            data_class = cls()
            data_class.sticker = data.get("sticker", None)
            data_class.format = data.get("format", None)
            data_class.emojis = data.get("emojis", "")
            data_class.mask_position = data.get("mask_position", None)
            data_class.keywords = data.get("keywords", None)

        return data_class


class DateRange(TlObject):
    r"""Represents a date range

    Parameters:
        start_date (:class:`int`):
            Point in time \(Unix timestamp\) at which the date range begins

        end_date (:class:`int`):
            Point in time \(Unix timestamp\) at which the date range ends

    """

    def __init__(self, start_date: int = 0, end_date: int = 0) -> None:
        self.start_date: int = int(start_date)
        r"""Point in time \(Unix timestamp\) at which the date range begins"""
        self.end_date: int = int(end_date)
        r"""Point in time \(Unix timestamp\) at which the date range ends"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["dateRange"]:
        return "dateRange"

    def getClass(self) -> Literal["DateRange"]:
        return "DateRange"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "start_date": self.start_date,
            "end_date": self.end_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["DateRange", None]:
        if data:
            data_class = cls()
            data_class.start_date = int(data.get("start_date", 0))
            data_class.end_date = int(data.get("end_date", 0))

        return data_class


class StatisticalValue(TlObject):
    r"""A value with information about its recent changes

    Parameters:
        value (:class:`float`):
            The current value

        previous_value (:class:`float`):
            The value for the previous day

        growth_rate_percentage (:class:`float`):
            The growth rate of the value, as a percentage

    """

    def __init__(
        self,
        value: float = 0.0,
        previous_value: float = 0.0,
        growth_rate_percentage: float = 0.0,
    ) -> None:
        self.value: float = float(value)
        r"""The current value"""
        self.previous_value: float = float(previous_value)
        r"""The value for the previous day"""
        self.growth_rate_percentage: float = float(growth_rate_percentage)
        r"""The growth rate of the value, as a percentage"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["statisticalValue"]:
        return "statisticalValue"

    def getClass(self) -> Literal["StatisticalValue"]:
        return "StatisticalValue"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "value": self.value,
            "previous_value": self.previous_value,
            "growth_rate_percentage": self.growth_rate_percentage,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StatisticalValue", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", 0.0)
            data_class.previous_value = data.get("previous_value", 0.0)
            data_class.growth_rate_percentage = data.get("growth_rate_percentage", 0.0)

        return data_class


class StatisticalGraphData(TlObject, StatisticalGraph):
    r"""A graph data

    Parameters:
        json_data (:class:`str`):
            Graph data in JSON format

        zoom_token (:class:`str`):
            If non\-empty, a token which can be used to receive a zoomed in graph

    """

    def __init__(self, json_data: str = "", zoom_token: str = "") -> None:
        self.json_data: Union[str, None] = json_data
        r"""Graph data in JSON format"""
        self.zoom_token: Union[str, None] = zoom_token
        r"""If non\-empty, a token which can be used to receive a zoomed in graph"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["statisticalGraphData"]:
        return "statisticalGraphData"

    def getClass(self) -> Literal["StatisticalGraph"]:
        return "StatisticalGraph"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "json_data": self.json_data,
            "zoom_token": self.zoom_token,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StatisticalGraphData", None]:
        if data:
            data_class = cls()
            data_class.json_data = data.get("json_data", "")
            data_class.zoom_token = data.get("zoom_token", "")

        return data_class


class StatisticalGraphAsync(TlObject, StatisticalGraph):
    r"""The graph data to be asynchronously loaded through getStatisticalGraph

    Parameters:
        token (:class:`str`):
            The token to use for data loading

    """

    def __init__(self, token: str = "") -> None:
        self.token: Union[str, None] = token
        r"""The token to use for data loading"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["statisticalGraphAsync"]:
        return "statisticalGraphAsync"

    def getClass(self) -> Literal["StatisticalGraph"]:
        return "StatisticalGraph"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "token": self.token}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StatisticalGraphAsync", None]:
        if data:
            data_class = cls()
            data_class.token = data.get("token", "")

        return data_class


class StatisticalGraphError(TlObject, StatisticalGraph):
    r"""An error message to be shown to the user instead of the graph

    Parameters:
        error_message (:class:`str`):
            The error message

    """

    def __init__(self, error_message: str = "") -> None:
        self.error_message: Union[str, None] = error_message
        r"""The error message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["statisticalGraphError"]:
        return "statisticalGraphError"

    def getClass(self) -> Literal["StatisticalGraph"]:
        return "StatisticalGraph"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "error_message": self.error_message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["StatisticalGraphError", None]:
        if data:
            data_class = cls()
            data_class.error_message = data.get("error_message", "")

        return data_class


class ChatStatisticsObjectTypeMessage(TlObject, ChatStatisticsObjectType):
    r"""Describes a message sent in the chat

    Parameters:
        message_id (:class:`int`):
            Message identifier

    """

    def __init__(self, message_id: int = 0) -> None:
        self.message_id: int = int(message_id)
        r"""Message identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsObjectTypeMessage"]:
        return "chatStatisticsObjectTypeMessage"

    def getClass(self) -> Literal["ChatStatisticsObjectType"]:
        return "ChatStatisticsObjectType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message_id": self.message_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatStatisticsObjectTypeMessage", None]:
        if data:
            data_class = cls()
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class ChatStatisticsObjectTypeStory(TlObject, ChatStatisticsObjectType):
    r"""Describes a story sent by the chat

    Parameters:
        story_id (:class:`int`):
            Story identifier

    """

    def __init__(self, story_id: int = 0) -> None:
        self.story_id: int = int(story_id)
        r"""Story identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsObjectTypeStory"]:
        return "chatStatisticsObjectTypeStory"

    def getClass(self) -> Literal["ChatStatisticsObjectType"]:
        return "ChatStatisticsObjectType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "story_id": self.story_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatStatisticsObjectTypeStory", None]:
        if data:
            data_class = cls()
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class ChatStatisticsInteractionInfo(TlObject):
    r"""Contains statistics about interactions with a message sent in the chat or a story sent by the chat

    Parameters:
        object_type (:class:`"types.ChatStatisticsObjectType"`):
            Type of the object

        view_count (:class:`int`):
            Number of times the object was viewed

        forward_count (:class:`int`):
            Number of times the object was forwarded

        reaction_count (:class:`int`):
            Number of times reactions were added to the object

    """

    def __init__(
        self,
        object_type: ChatStatisticsObjectType = None,
        view_count: int = 0,
        forward_count: int = 0,
        reaction_count: int = 0,
    ) -> None:
        self.object_type: Union[
            ChatStatisticsObjectTypeMessage, ChatStatisticsObjectTypeStory, None
        ] = object_type
        r"""Type of the object"""
        self.view_count: int = int(view_count)
        r"""Number of times the object was viewed"""
        self.forward_count: int = int(forward_count)
        r"""Number of times the object was forwarded"""
        self.reaction_count: int = int(reaction_count)
        r"""Number of times reactions were added to the object"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsInteractionInfo"]:
        return "chatStatisticsInteractionInfo"

    def getClass(self) -> Literal["ChatStatisticsInteractionInfo"]:
        return "ChatStatisticsInteractionInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "object_type": self.object_type,
            "view_count": self.view_count,
            "forward_count": self.forward_count,
            "reaction_count": self.reaction_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatStatisticsInteractionInfo", None]:
        if data:
            data_class = cls()
            data_class.object_type = data.get("object_type", None)
            data_class.view_count = int(data.get("view_count", 0))
            data_class.forward_count = int(data.get("forward_count", 0))
            data_class.reaction_count = int(data.get("reaction_count", 0))

        return data_class


class ChatStatisticsMessageSenderInfo(TlObject):
    r"""Contains statistics about messages sent by a user

    Parameters:
        user_id (:class:`int`):
            User identifier

        sent_message_count (:class:`int`):
            Number of sent messages

        average_character_count (:class:`int`):
            Average number of characters in sent messages; 0 if unknown

    """

    def __init__(
        self,
        user_id: int = 0,
        sent_message_count: int = 0,
        average_character_count: int = 0,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.sent_message_count: int = int(sent_message_count)
        r"""Number of sent messages"""
        self.average_character_count: int = int(average_character_count)
        r"""Average number of characters in sent messages; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsMessageSenderInfo"]:
        return "chatStatisticsMessageSenderInfo"

    def getClass(self) -> Literal["ChatStatisticsMessageSenderInfo"]:
        return "ChatStatisticsMessageSenderInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "sent_message_count": self.sent_message_count,
            "average_character_count": self.average_character_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatStatisticsMessageSenderInfo", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.sent_message_count = int(data.get("sent_message_count", 0))
            data_class.average_character_count = int(
                data.get("average_character_count", 0)
            )

        return data_class


class ChatStatisticsAdministratorActionsInfo(TlObject):
    r"""Contains statistics about administrator actions done by a user

    Parameters:
        user_id (:class:`int`):
            Administrator user identifier

        deleted_message_count (:class:`int`):
            Number of messages deleted by the administrator

        banned_user_count (:class:`int`):
            Number of users banned by the administrator

        restricted_user_count (:class:`int`):
            Number of users restricted by the administrator

    """

    def __init__(
        self,
        user_id: int = 0,
        deleted_message_count: int = 0,
        banned_user_count: int = 0,
        restricted_user_count: int = 0,
    ) -> None:
        self.user_id: int = int(user_id)
        r"""Administrator user identifier"""
        self.deleted_message_count: int = int(deleted_message_count)
        r"""Number of messages deleted by the administrator"""
        self.banned_user_count: int = int(banned_user_count)
        r"""Number of users banned by the administrator"""
        self.restricted_user_count: int = int(restricted_user_count)
        r"""Number of users restricted by the administrator"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsAdministratorActionsInfo"]:
        return "chatStatisticsAdministratorActionsInfo"

    def getClass(self) -> Literal["ChatStatisticsAdministratorActionsInfo"]:
        return "ChatStatisticsAdministratorActionsInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "deleted_message_count": self.deleted_message_count,
            "banned_user_count": self.banned_user_count,
            "restricted_user_count": self.restricted_user_count,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatStatisticsAdministratorActionsInfo", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.deleted_message_count = int(data.get("deleted_message_count", 0))
            data_class.banned_user_count = int(data.get("banned_user_count", 0))
            data_class.restricted_user_count = int(data.get("restricted_user_count", 0))

        return data_class


class ChatStatisticsInviterInfo(TlObject):
    r"""Contains statistics about number of new members invited by a user

    Parameters:
        user_id (:class:`int`):
            User identifier

        added_member_count (:class:`int`):
            Number of new members invited by the user

    """

    def __init__(self, user_id: int = 0, added_member_count: int = 0) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.added_member_count: int = int(added_member_count)
        r"""Number of new members invited by the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsInviterInfo"]:
        return "chatStatisticsInviterInfo"

    def getClass(self) -> Literal["ChatStatisticsInviterInfo"]:
        return "ChatStatisticsInviterInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "added_member_count": self.added_member_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatStatisticsInviterInfo", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.added_member_count = int(data.get("added_member_count", 0))

        return data_class


class ChatStatisticsSupergroup(TlObject, ChatStatistics):
    r"""A detailed statistics about a supergroup chat

    Parameters:
        period (:class:`"types.DateRange"`):
            A period to which the statistics applies

        member_count (:class:`"types.StatisticalValue"`):
            Number of members in the chat

        message_count (:class:`"types.StatisticalValue"`):
            Number of messages sent to the chat

        viewer_count (:class:`"types.StatisticalValue"`):
            Number of users who viewed messages in the chat

        sender_count (:class:`"types.StatisticalValue"`):
            Number of users who sent messages to the chat

        member_count_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of members in the chat

        join_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of members joined and left the chat

        join_by_source_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of new member joins per source

        language_graph (:class:`"types.StatisticalGraph"`):
            A graph containing distribution of active users per language

        message_content_graph (:class:`"types.StatisticalGraph"`):
            A graph containing distribution of sent messages by content type

        action_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of different actions in the chat

        day_graph (:class:`"types.StatisticalGraph"`):
            A graph containing distribution of message views per hour

        week_graph (:class:`"types.StatisticalGraph"`):
            A graph containing distribution of message views per day of week

        top_senders (:class:`List["types.ChatStatisticsMessageSenderInfo"]`):
            List of users sent most messages in the last week

        top_administrators (:class:`List["types.ChatStatisticsAdministratorActionsInfo"]`):
            List of most active administrators in the last week

        top_inviters (:class:`List["types.ChatStatisticsInviterInfo"]`):
            List of most active inviters of new members in the last week

    """

    def __init__(
        self,
        period: DateRange = None,
        member_count: StatisticalValue = None,
        message_count: StatisticalValue = None,
        viewer_count: StatisticalValue = None,
        sender_count: StatisticalValue = None,
        member_count_graph: StatisticalGraph = None,
        join_graph: StatisticalGraph = None,
        join_by_source_graph: StatisticalGraph = None,
        language_graph: StatisticalGraph = None,
        message_content_graph: StatisticalGraph = None,
        action_graph: StatisticalGraph = None,
        day_graph: StatisticalGraph = None,
        week_graph: StatisticalGraph = None,
        top_senders: List[ChatStatisticsMessageSenderInfo] = None,
        top_administrators: List[ChatStatisticsAdministratorActionsInfo] = None,
        top_inviters: List[ChatStatisticsInviterInfo] = None,
    ) -> None:
        self.period: Union[DateRange, None] = period
        r"""A period to which the statistics applies"""
        self.member_count: Union[StatisticalValue, None] = member_count
        r"""Number of members in the chat"""
        self.message_count: Union[StatisticalValue, None] = message_count
        r"""Number of messages sent to the chat"""
        self.viewer_count: Union[StatisticalValue, None] = viewer_count
        r"""Number of users who viewed messages in the chat"""
        self.sender_count: Union[StatisticalValue, None] = sender_count
        r"""Number of users who sent messages to the chat"""
        self.member_count_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = member_count_graph
        r"""A graph containing number of members in the chat"""
        self.join_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = join_graph
        r"""A graph containing number of members joined and left the chat"""
        self.join_by_source_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = join_by_source_graph
        r"""A graph containing number of new member joins per source"""
        self.language_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = language_graph
        r"""A graph containing distribution of active users per language"""
        self.message_content_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = message_content_graph
        r"""A graph containing distribution of sent messages by content type"""
        self.action_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = action_graph
        r"""A graph containing number of different actions in the chat"""
        self.day_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = day_graph
        r"""A graph containing distribution of message views per hour"""
        self.week_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = week_graph
        r"""A graph containing distribution of message views per day of week"""
        self.top_senders: List[ChatStatisticsMessageSenderInfo] = top_senders or []
        r"""List of users sent most messages in the last week"""
        self.top_administrators: List[ChatStatisticsAdministratorActionsInfo] = (
            top_administrators or []
        )
        r"""List of most active administrators in the last week"""
        self.top_inviters: List[ChatStatisticsInviterInfo] = top_inviters or []
        r"""List of most active inviters of new members in the last week"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsSupergroup"]:
        return "chatStatisticsSupergroup"

    def getClass(self) -> Literal["ChatStatistics"]:
        return "ChatStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "period": self.period,
            "member_count": self.member_count,
            "message_count": self.message_count,
            "viewer_count": self.viewer_count,
            "sender_count": self.sender_count,
            "member_count_graph": self.member_count_graph,
            "join_graph": self.join_graph,
            "join_by_source_graph": self.join_by_source_graph,
            "language_graph": self.language_graph,
            "message_content_graph": self.message_content_graph,
            "action_graph": self.action_graph,
            "day_graph": self.day_graph,
            "week_graph": self.week_graph,
            "top_senders": self.top_senders,
            "top_administrators": self.top_administrators,
            "top_inviters": self.top_inviters,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatStatisticsSupergroup", None]:
        if data:
            data_class = cls()
            data_class.period = data.get("period", None)
            data_class.member_count = data.get("member_count", None)
            data_class.message_count = data.get("message_count", None)
            data_class.viewer_count = data.get("viewer_count", None)
            data_class.sender_count = data.get("sender_count", None)
            data_class.member_count_graph = data.get("member_count_graph", None)
            data_class.join_graph = data.get("join_graph", None)
            data_class.join_by_source_graph = data.get("join_by_source_graph", None)
            data_class.language_graph = data.get("language_graph", None)
            data_class.message_content_graph = data.get("message_content_graph", None)
            data_class.action_graph = data.get("action_graph", None)
            data_class.day_graph = data.get("day_graph", None)
            data_class.week_graph = data.get("week_graph", None)
            data_class.top_senders = data.get("top_senders", None)
            data_class.top_administrators = data.get("top_administrators", None)
            data_class.top_inviters = data.get("top_inviters", None)

        return data_class


class ChatStatisticsChannel(TlObject, ChatStatistics):
    r"""A detailed statistics about a channel chat

    Parameters:
        period (:class:`"types.DateRange"`):
            A period to which the statistics applies

        member_count (:class:`"types.StatisticalValue"`):
            Number of members in the chat

        mean_message_view_count (:class:`"types.StatisticalValue"`):
            Mean number of times the recently sent messages were viewed

        mean_message_share_count (:class:`"types.StatisticalValue"`):
            Mean number of times the recently sent messages were shared

        mean_message_reaction_count (:class:`"types.StatisticalValue"`):
            Mean number of times reactions were added to the recently sent messages

        mean_story_view_count (:class:`"types.StatisticalValue"`):
            Mean number of times the recently sent stories were viewed

        mean_story_share_count (:class:`"types.StatisticalValue"`):
            Mean number of times the recently sent stories were shared

        mean_story_reaction_count (:class:`"types.StatisticalValue"`):
            Mean number of times reactions were added to the recently sent stories

        enabled_notifications_percentage (:class:`float`):
            A percentage of users with enabled notifications for the chat; 0\-100

        member_count_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of members in the chat

        join_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of members joined and left the chat

        mute_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of members muted and unmuted the chat

        view_count_by_hour_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of message views in a given hour in the last two weeks

        view_count_by_source_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of message views per source

        join_by_source_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of new member joins per source

        language_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of users viewed chat messages per language

        message_interaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of chat message views and shares

        message_reaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of reactions on messages

        story_interaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of story views and shares

        story_reaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of reactions on stories

        instant_view_interaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of views of associated with the chat instant views

        recent_interactions (:class:`List["types.ChatStatisticsInteractionInfo"]`):
            Detailed statistics about number of views and shares of recently sent messages and stories

    """

    def __init__(
        self,
        period: DateRange = None,
        member_count: StatisticalValue = None,
        mean_message_view_count: StatisticalValue = None,
        mean_message_share_count: StatisticalValue = None,
        mean_message_reaction_count: StatisticalValue = None,
        mean_story_view_count: StatisticalValue = None,
        mean_story_share_count: StatisticalValue = None,
        mean_story_reaction_count: StatisticalValue = None,
        enabled_notifications_percentage: float = 0.0,
        member_count_graph: StatisticalGraph = None,
        join_graph: StatisticalGraph = None,
        mute_graph: StatisticalGraph = None,
        view_count_by_hour_graph: StatisticalGraph = None,
        view_count_by_source_graph: StatisticalGraph = None,
        join_by_source_graph: StatisticalGraph = None,
        language_graph: StatisticalGraph = None,
        message_interaction_graph: StatisticalGraph = None,
        message_reaction_graph: StatisticalGraph = None,
        story_interaction_graph: StatisticalGraph = None,
        story_reaction_graph: StatisticalGraph = None,
        instant_view_interaction_graph: StatisticalGraph = None,
        recent_interactions: List[ChatStatisticsInteractionInfo] = None,
    ) -> None:
        self.period: Union[DateRange, None] = period
        r"""A period to which the statistics applies"""
        self.member_count: Union[StatisticalValue, None] = member_count
        r"""Number of members in the chat"""
        self.mean_message_view_count: Union[StatisticalValue, None] = (
            mean_message_view_count
        )
        r"""Mean number of times the recently sent messages were viewed"""
        self.mean_message_share_count: Union[StatisticalValue, None] = (
            mean_message_share_count
        )
        r"""Mean number of times the recently sent messages were shared"""
        self.mean_message_reaction_count: Union[StatisticalValue, None] = (
            mean_message_reaction_count
        )
        r"""Mean number of times reactions were added to the recently sent messages"""
        self.mean_story_view_count: Union[StatisticalValue, None] = (
            mean_story_view_count
        )
        r"""Mean number of times the recently sent stories were viewed"""
        self.mean_story_share_count: Union[StatisticalValue, None] = (
            mean_story_share_count
        )
        r"""Mean number of times the recently sent stories were shared"""
        self.mean_story_reaction_count: Union[StatisticalValue, None] = (
            mean_story_reaction_count
        )
        r"""Mean number of times reactions were added to the recently sent stories"""
        self.enabled_notifications_percentage: float = float(
            enabled_notifications_percentage
        )
        r"""A percentage of users with enabled notifications for the chat; 0\-100"""
        self.member_count_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = member_count_graph
        r"""A graph containing number of members in the chat"""
        self.join_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = join_graph
        r"""A graph containing number of members joined and left the chat"""
        self.mute_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = mute_graph
        r"""A graph containing number of members muted and unmuted the chat"""
        self.view_count_by_hour_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = view_count_by_hour_graph
        r"""A graph containing number of message views in a given hour in the last two weeks"""
        self.view_count_by_source_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = view_count_by_source_graph
        r"""A graph containing number of message views per source"""
        self.join_by_source_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = join_by_source_graph
        r"""A graph containing number of new member joins per source"""
        self.language_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = language_graph
        r"""A graph containing number of users viewed chat messages per language"""
        self.message_interaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = message_interaction_graph
        r"""A graph containing number of chat message views and shares"""
        self.message_reaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = message_reaction_graph
        r"""A graph containing number of reactions on messages"""
        self.story_interaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = story_interaction_graph
        r"""A graph containing number of story views and shares"""
        self.story_reaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = story_reaction_graph
        r"""A graph containing number of reactions on stories"""
        self.instant_view_interaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = instant_view_interaction_graph
        r"""A graph containing number of views of associated with the chat instant views"""
        self.recent_interactions: List[ChatStatisticsInteractionInfo] = (
            recent_interactions or []
        )
        r"""Detailed statistics about number of views and shares of recently sent messages and stories"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatStatisticsChannel"]:
        return "chatStatisticsChannel"

    def getClass(self) -> Literal["ChatStatistics"]:
        return "ChatStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "period": self.period,
            "member_count": self.member_count,
            "mean_message_view_count": self.mean_message_view_count,
            "mean_message_share_count": self.mean_message_share_count,
            "mean_message_reaction_count": self.mean_message_reaction_count,
            "mean_story_view_count": self.mean_story_view_count,
            "mean_story_share_count": self.mean_story_share_count,
            "mean_story_reaction_count": self.mean_story_reaction_count,
            "enabled_notifications_percentage": self.enabled_notifications_percentage,
            "member_count_graph": self.member_count_graph,
            "join_graph": self.join_graph,
            "mute_graph": self.mute_graph,
            "view_count_by_hour_graph": self.view_count_by_hour_graph,
            "view_count_by_source_graph": self.view_count_by_source_graph,
            "join_by_source_graph": self.join_by_source_graph,
            "language_graph": self.language_graph,
            "message_interaction_graph": self.message_interaction_graph,
            "message_reaction_graph": self.message_reaction_graph,
            "story_interaction_graph": self.story_interaction_graph,
            "story_reaction_graph": self.story_reaction_graph,
            "instant_view_interaction_graph": self.instant_view_interaction_graph,
            "recent_interactions": self.recent_interactions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatStatisticsChannel", None]:
        if data:
            data_class = cls()
            data_class.period = data.get("period", None)
            data_class.member_count = data.get("member_count", None)
            data_class.mean_message_view_count = data.get(
                "mean_message_view_count", None
            )
            data_class.mean_message_share_count = data.get(
                "mean_message_share_count", None
            )
            data_class.mean_message_reaction_count = data.get(
                "mean_message_reaction_count", None
            )
            data_class.mean_story_view_count = data.get("mean_story_view_count", None)
            data_class.mean_story_share_count = data.get("mean_story_share_count", None)
            data_class.mean_story_reaction_count = data.get(
                "mean_story_reaction_count", None
            )
            data_class.enabled_notifications_percentage = data.get(
                "enabled_notifications_percentage", 0.0
            )
            data_class.member_count_graph = data.get("member_count_graph", None)
            data_class.join_graph = data.get("join_graph", None)
            data_class.mute_graph = data.get("mute_graph", None)
            data_class.view_count_by_hour_graph = data.get(
                "view_count_by_hour_graph", None
            )
            data_class.view_count_by_source_graph = data.get(
                "view_count_by_source_graph", None
            )
            data_class.join_by_source_graph = data.get("join_by_source_graph", None)
            data_class.language_graph = data.get("language_graph", None)
            data_class.message_interaction_graph = data.get(
                "message_interaction_graph", None
            )
            data_class.message_reaction_graph = data.get("message_reaction_graph", None)
            data_class.story_interaction_graph = data.get(
                "story_interaction_graph", None
            )
            data_class.story_reaction_graph = data.get("story_reaction_graph", None)
            data_class.instant_view_interaction_graph = data.get(
                "instant_view_interaction_graph", None
            )
            data_class.recent_interactions = data.get("recent_interactions", None)

        return data_class


class ChatRevenueAmount(TlObject):
    r"""Contains information about revenue earned from sponsored messages in a chat

    Parameters:
        cryptocurrency (:class:`str`):
            Cryptocurrency in which revenue is calculated

        total_amount (:class:`int`):
            Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency

        balance_amount (:class:`int`):
            Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units of the cryptocurrency

        available_amount (:class:`int`):
            Amount of the cryptocurrency available for withdrawal, in the smallest units of the cryptocurrency

        withdrawal_enabled (:class:`bool`):
            True, if Telegram Stars can be withdrawn now or later

    """

    def __init__(
        self,
        cryptocurrency: str = "",
        total_amount: int = 0,
        balance_amount: int = 0,
        available_amount: int = 0,
        withdrawal_enabled: bool = False,
    ) -> None:
        self.cryptocurrency: Union[str, None] = cryptocurrency
        r"""Cryptocurrency in which revenue is calculated"""
        self.total_amount: int = int(total_amount)
        r"""Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency"""
        self.balance_amount: int = int(balance_amount)
        r"""Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units of the cryptocurrency"""
        self.available_amount: int = int(available_amount)
        r"""Amount of the cryptocurrency available for withdrawal, in the smallest units of the cryptocurrency"""
        self.withdrawal_enabled: bool = bool(withdrawal_enabled)
        r"""True, if Telegram Stars can be withdrawn now or later"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatRevenueAmount"]:
        return "chatRevenueAmount"

    def getClass(self) -> Literal["ChatRevenueAmount"]:
        return "ChatRevenueAmount"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "cryptocurrency": self.cryptocurrency,
            "total_amount": self.total_amount,
            "balance_amount": self.balance_amount,
            "available_amount": self.available_amount,
            "withdrawal_enabled": self.withdrawal_enabled,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatRevenueAmount", None]:
        if data:
            data_class = cls()
            data_class.cryptocurrency = data.get("cryptocurrency", "")
            data_class.total_amount = int(data.get("total_amount", 0))
            data_class.balance_amount = int(data.get("balance_amount", 0))
            data_class.available_amount = int(data.get("available_amount", 0))
            data_class.withdrawal_enabled = data.get("withdrawal_enabled", False)

        return data_class


class ChatRevenueStatistics(TlObject):
    r"""A detailed statistics about revenue earned from sponsored messages in a chat

    Parameters:
        revenue_by_hour_graph (:class:`"types.StatisticalGraph"`):
            A graph containing amount of revenue in a given hour

        revenue_graph (:class:`"types.StatisticalGraph"`):
            A graph containing amount of revenue

        revenue_amount (:class:`"types.ChatRevenueAmount"`):
            Amount of earned revenue

        usd_rate (:class:`float`):
            Current conversion rate of the cryptocurrency in which revenue is calculated to USD

    """

    def __init__(
        self,
        revenue_by_hour_graph: StatisticalGraph = None,
        revenue_graph: StatisticalGraph = None,
        revenue_amount: ChatRevenueAmount = None,
        usd_rate: float = 0.0,
    ) -> None:
        self.revenue_by_hour_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = revenue_by_hour_graph
        r"""A graph containing amount of revenue in a given hour"""
        self.revenue_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = revenue_graph
        r"""A graph containing amount of revenue"""
        self.revenue_amount: Union[ChatRevenueAmount, None] = revenue_amount
        r"""Amount of earned revenue"""
        self.usd_rate: float = float(usd_rate)
        r"""Current conversion rate of the cryptocurrency in which revenue is calculated to USD"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatRevenueStatistics"]:
        return "chatRevenueStatistics"

    def getClass(self) -> Literal["ChatRevenueStatistics"]:
        return "ChatRevenueStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "revenue_by_hour_graph": self.revenue_by_hour_graph,
            "revenue_graph": self.revenue_graph,
            "revenue_amount": self.revenue_amount,
            "usd_rate": self.usd_rate,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatRevenueStatistics", None]:
        if data:
            data_class = cls()
            data_class.revenue_by_hour_graph = data.get("revenue_by_hour_graph", None)
            data_class.revenue_graph = data.get("revenue_graph", None)
            data_class.revenue_amount = data.get("revenue_amount", None)
            data_class.usd_rate = data.get("usd_rate", 0.0)

        return data_class


class MessageStatistics(TlObject):
    r"""A detailed statistics about a message

    Parameters:
        message_interaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of message views and shares

        message_reaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of message reactions

    """

    def __init__(
        self,
        message_interaction_graph: StatisticalGraph = None,
        message_reaction_graph: StatisticalGraph = None,
    ) -> None:
        self.message_interaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = message_interaction_graph
        r"""A graph containing number of message views and shares"""
        self.message_reaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = message_reaction_graph
        r"""A graph containing number of message reactions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["messageStatistics"]:
        return "messageStatistics"

    def getClass(self) -> Literal["MessageStatistics"]:
        return "MessageStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message_interaction_graph": self.message_interaction_graph,
            "message_reaction_graph": self.message_reaction_graph,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["MessageStatistics", None]:
        if data:
            data_class = cls()
            data_class.message_interaction_graph = data.get(
                "message_interaction_graph", None
            )
            data_class.message_reaction_graph = data.get("message_reaction_graph", None)

        return data_class


class StoryStatistics(TlObject):
    r"""A detailed statistics about a story

    Parameters:
        story_interaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of story views and shares

        story_reaction_graph (:class:`"types.StatisticalGraph"`):
            A graph containing number of story reactions

    """

    def __init__(
        self,
        story_interaction_graph: StatisticalGraph = None,
        story_reaction_graph: StatisticalGraph = None,
    ) -> None:
        self.story_interaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = story_interaction_graph
        r"""A graph containing number of story views and shares"""
        self.story_reaction_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = story_reaction_graph
        r"""A graph containing number of story reactions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["storyStatistics"]:
        return "storyStatistics"

    def getClass(self) -> Literal["StoryStatistics"]:
        return "StoryStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_interaction_graph": self.story_interaction_graph,
            "story_reaction_graph": self.story_reaction_graph,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StoryStatistics", None]:
        if data:
            data_class = cls()
            data_class.story_interaction_graph = data.get(
                "story_interaction_graph", None
            )
            data_class.story_reaction_graph = data.get("story_reaction_graph", None)

        return data_class


class RevenueWithdrawalStatePending(TlObject, RevenueWithdrawalState):
    r"""Withdrawal is pending"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["revenueWithdrawalStatePending"]:
        return "revenueWithdrawalStatePending"

    def getClass(self) -> Literal["RevenueWithdrawalState"]:
        return "RevenueWithdrawalState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RevenueWithdrawalStatePending", None]:
        if data:
            data_class = cls()

        return data_class


class RevenueWithdrawalStateSucceeded(TlObject, RevenueWithdrawalState):
    r"""Withdrawal succeeded

    Parameters:
        date (:class:`int`):
            Point in time \(Unix timestamp\) when the withdrawal was completed

        url (:class:`str`):
            The URL where the withdrawal transaction can be viewed

    """

    def __init__(self, date: int = 0, url: str = "") -> None:
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the withdrawal was completed"""
        self.url: Union[str, None] = url
        r"""The URL where the withdrawal transaction can be viewed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["revenueWithdrawalStateSucceeded"]:
        return "revenueWithdrawalStateSucceeded"

    def getClass(self) -> Literal["RevenueWithdrawalState"]:
        return "RevenueWithdrawalState"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "date": self.date, "url": self.url}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RevenueWithdrawalStateSucceeded", None]:
        if data:
            data_class = cls()
            data_class.date = int(data.get("date", 0))
            data_class.url = data.get("url", "")

        return data_class


class RevenueWithdrawalStateFailed(TlObject, RevenueWithdrawalState):
    r"""Withdrawal failed"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["revenueWithdrawalStateFailed"]:
        return "revenueWithdrawalStateFailed"

    def getClass(self) -> Literal["RevenueWithdrawalState"]:
        return "RevenueWithdrawalState"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["RevenueWithdrawalStateFailed", None]:
        if data:
            data_class = cls()

        return data_class


class ChatRevenueTransactionTypeEarnings(TlObject, ChatRevenueTransactionType):
    r"""Describes earnings from sponsored messages in a chat in some time frame

    Parameters:
        start_date (:class:`int`):
            Point in time \(Unix timestamp\) when the earnings started

        end_date (:class:`int`):
            Point in time \(Unix timestamp\) when the earnings ended

    """

    def __init__(self, start_date: int = 0, end_date: int = 0) -> None:
        self.start_date: int = int(start_date)
        r"""Point in time \(Unix timestamp\) when the earnings started"""
        self.end_date: int = int(end_date)
        r"""Point in time \(Unix timestamp\) when the earnings ended"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatRevenueTransactionTypeEarnings"]:
        return "chatRevenueTransactionTypeEarnings"

    def getClass(self) -> Literal["ChatRevenueTransactionType"]:
        return "ChatRevenueTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "start_date": self.start_date,
            "end_date": self.end_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatRevenueTransactionTypeEarnings", None]:
        if data:
            data_class = cls()
            data_class.start_date = int(data.get("start_date", 0))
            data_class.end_date = int(data.get("end_date", 0))

        return data_class


class ChatRevenueTransactionTypeWithdrawal(TlObject, ChatRevenueTransactionType):
    r"""Describes a withdrawal of earnings

    Parameters:
        withdrawal_date (:class:`int`):
            Point in time \(Unix timestamp\) when the earnings withdrawal started

        provider (:class:`str`):
            Name of the payment provider

        state (:class:`"types.RevenueWithdrawalState"`):
            State of the withdrawal

    """

    def __init__(
        self,
        withdrawal_date: int = 0,
        provider: str = "",
        state: RevenueWithdrawalState = None,
    ) -> None:
        self.withdrawal_date: int = int(withdrawal_date)
        r"""Point in time \(Unix timestamp\) when the earnings withdrawal started"""
        self.provider: Union[str, None] = provider
        r"""Name of the payment provider"""
        self.state: Union[
            RevenueWithdrawalStatePending,
            RevenueWithdrawalStateSucceeded,
            RevenueWithdrawalStateFailed,
            None,
        ] = state
        r"""State of the withdrawal"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatRevenueTransactionTypeWithdrawal"]:
        return "chatRevenueTransactionTypeWithdrawal"

    def getClass(self) -> Literal["ChatRevenueTransactionType"]:
        return "ChatRevenueTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "withdrawal_date": self.withdrawal_date,
            "provider": self.provider,
            "state": self.state,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["ChatRevenueTransactionTypeWithdrawal", None]:
        if data:
            data_class = cls()
            data_class.withdrawal_date = int(data.get("withdrawal_date", 0))
            data_class.provider = data.get("provider", "")
            data_class.state = data.get("state", None)

        return data_class


class ChatRevenueTransactionTypeRefund(TlObject, ChatRevenueTransactionType):
    r"""Describes a refund for failed withdrawal of earnings

    Parameters:
        refund_date (:class:`int`):
            Point in time \(Unix timestamp\) when the transaction was refunded

        provider (:class:`str`):
            Name of the payment provider

    """

    def __init__(self, refund_date: int = 0, provider: str = "") -> None:
        self.refund_date: int = int(refund_date)
        r"""Point in time \(Unix timestamp\) when the transaction was refunded"""
        self.provider: Union[str, None] = provider
        r"""Name of the payment provider"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatRevenueTransactionTypeRefund"]:
        return "chatRevenueTransactionTypeRefund"

    def getClass(self) -> Literal["ChatRevenueTransactionType"]:
        return "ChatRevenueTransactionType"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "refund_date": self.refund_date,
            "provider": self.provider,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatRevenueTransactionTypeRefund", None]:
        if data:
            data_class = cls()
            data_class.refund_date = int(data.get("refund_date", 0))
            data_class.provider = data.get("provider", "")

        return data_class


class ChatRevenueTransaction(TlObject):
    r"""Contains a chat revenue transactions

    Parameters:
        cryptocurrency (:class:`str`):
            Cryptocurrency in which revenue is calculated

        cryptocurrency_amount (:class:`int`):
            The withdrawn amount, in the smallest units of the cryptocurrency

        type (:class:`"types.ChatRevenueTransactionType"`):
            Type of the transaction

    """

    def __init__(
        self,
        cryptocurrency: str = "",
        cryptocurrency_amount: int = 0,
        type: ChatRevenueTransactionType = None,
    ) -> None:
        self.cryptocurrency: Union[str, None] = cryptocurrency
        r"""Cryptocurrency in which revenue is calculated"""
        self.cryptocurrency_amount: int = int(cryptocurrency_amount)
        r"""The withdrawn amount, in the smallest units of the cryptocurrency"""
        self.type: Union[
            ChatRevenueTransactionTypeEarnings,
            ChatRevenueTransactionTypeWithdrawal,
            ChatRevenueTransactionTypeRefund,
            None,
        ] = type
        r"""Type of the transaction"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatRevenueTransaction"]:
        return "chatRevenueTransaction"

    def getClass(self) -> Literal["ChatRevenueTransaction"]:
        return "ChatRevenueTransaction"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "cryptocurrency": self.cryptocurrency,
            "cryptocurrency_amount": self.cryptocurrency_amount,
            "type": self.type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatRevenueTransaction", None]:
        if data:
            data_class = cls()
            data_class.cryptocurrency = data.get("cryptocurrency", "")
            data_class.cryptocurrency_amount = int(data.get("cryptocurrency_amount", 0))
            data_class.type = data.get("type", None)

        return data_class


class ChatRevenueTransactions(TlObject):
    r"""Contains a list of chat revenue transactions

    Parameters:
        total_count (:class:`int`):
            Total number of transactions

        transactions (:class:`List["types.ChatRevenueTransaction"]`):
            List of transactions

    """

    def __init__(
        self, total_count: int = 0, transactions: List[ChatRevenueTransaction] = None
    ) -> None:
        self.total_count: int = int(total_count)
        r"""Total number of transactions"""
        self.transactions: List[ChatRevenueTransaction] = transactions or []
        r"""List of transactions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["chatRevenueTransactions"]:
        return "chatRevenueTransactions"

    def getClass(self) -> Literal["ChatRevenueTransactions"]:
        return "ChatRevenueTransactions"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_count": self.total_count,
            "transactions": self.transactions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["ChatRevenueTransactions", None]:
        if data:
            data_class = cls()
            data_class.total_count = int(data.get("total_count", 0))
            data_class.transactions = data.get("transactions", None)

        return data_class


class StarRevenueStatus(TlObject):
    r"""Contains information about Telegram Stars earned by a bot or a chat

    Parameters:
        total_amount (:class:`"types.StarAmount"`):
            Total amount of Telegram Stars earned

        current_amount (:class:`"types.StarAmount"`):
            The amount of Telegram Stars that aren't withdrawn yet

        available_amount (:class:`"types.StarAmount"`):
            The amount of Telegram Stars that are available for withdrawal

        withdrawal_enabled (:class:`bool`):
            True, if Telegram Stars can be withdrawn now or later

        next_withdrawal_in (:class:`int`):
            Time left before the next withdrawal can be started, in seconds; 0 if withdrawal can be started now

    """

    def __init__(
        self,
        total_amount: StarAmount = None,
        current_amount: StarAmount = None,
        available_amount: StarAmount = None,
        withdrawal_enabled: bool = False,
        next_withdrawal_in: int = 0,
    ) -> None:
        self.total_amount: Union[StarAmount, None] = total_amount
        r"""Total amount of Telegram Stars earned"""
        self.current_amount: Union[StarAmount, None] = current_amount
        r"""The amount of Telegram Stars that aren't withdrawn yet"""
        self.available_amount: Union[StarAmount, None] = available_amount
        r"""The amount of Telegram Stars that are available for withdrawal"""
        self.withdrawal_enabled: bool = bool(withdrawal_enabled)
        r"""True, if Telegram Stars can be withdrawn now or later"""
        self.next_withdrawal_in: int = int(next_withdrawal_in)
        r"""Time left before the next withdrawal can be started, in seconds; 0 if withdrawal can be started now"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starRevenueStatus"]:
        return "starRevenueStatus"

    def getClass(self) -> Literal["StarRevenueStatus"]:
        return "StarRevenueStatus"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_amount": self.total_amount,
            "current_amount": self.current_amount,
            "available_amount": self.available_amount,
            "withdrawal_enabled": self.withdrawal_enabled,
            "next_withdrawal_in": self.next_withdrawal_in,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarRevenueStatus", None]:
        if data:
            data_class = cls()
            data_class.total_amount = data.get("total_amount", None)
            data_class.current_amount = data.get("current_amount", None)
            data_class.available_amount = data.get("available_amount", None)
            data_class.withdrawal_enabled = data.get("withdrawal_enabled", False)
            data_class.next_withdrawal_in = int(data.get("next_withdrawal_in", 0))

        return data_class


class StarRevenueStatistics(TlObject):
    r"""A detailed statistics about Telegram Stars earned by a bot or a chat

    Parameters:
        revenue_by_day_graph (:class:`"types.StatisticalGraph"`):
            A graph containing amount of revenue in a given day

        status (:class:`"types.StarRevenueStatus"`):
            Telegram Star revenue status

        usd_rate (:class:`float`):
            Current conversion rate of a Telegram Star to USD

    """

    def __init__(
        self,
        revenue_by_day_graph: StatisticalGraph = None,
        status: StarRevenueStatus = None,
        usd_rate: float = 0.0,
    ) -> None:
        self.revenue_by_day_graph: Union[
            StatisticalGraphData, StatisticalGraphAsync, StatisticalGraphError, None
        ] = revenue_by_day_graph
        r"""A graph containing amount of revenue in a given day"""
        self.status: Union[StarRevenueStatus, None] = status
        r"""Telegram Star revenue status"""
        self.usd_rate: float = float(usd_rate)
        r"""Current conversion rate of a Telegram Star to USD"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["starRevenueStatistics"]:
        return "starRevenueStatistics"

    def getClass(self) -> Literal["StarRevenueStatistics"]:
        return "StarRevenueStatistics"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "revenue_by_day_graph": self.revenue_by_day_graph,
            "status": self.status,
            "usd_rate": self.usd_rate,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["StarRevenueStatistics", None]:
        if data:
            data_class = cls()
            data_class.revenue_by_day_graph = data.get("revenue_by_day_graph", None)
            data_class.status = data.get("status", None)
            data_class.usd_rate = data.get("usd_rate", 0.0)

        return data_class


class Point(TlObject):
    r"""A point on a Cartesian plane

    Parameters:
        x (:class:`float`):
            The point's first coordinate

        y (:class:`float`):
            The point's second coordinate

    """

    def __init__(self, x: float = 0.0, y: float = 0.0) -> None:
        self.x: float = float(x)
        r"""The point's first coordinate"""
        self.y: float = float(y)
        r"""The point's second coordinate"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["point"]:
        return "point"

    def getClass(self) -> Literal["Point"]:
        return "Point"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "x": self.x, "y": self.y}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Point", None]:
        if data:
            data_class = cls()
            data_class.x = data.get("x", 0.0)
            data_class.y = data.get("y", 0.0)

        return data_class


class VectorPathCommandLine(TlObject, VectorPathCommand):
    r"""A straight line to a given point

    Parameters:
        end_point (:class:`"types.Point"`):
            The end point of the straight line

    """

    def __init__(self, end_point: Point = None) -> None:
        self.end_point: Union[Point, None] = end_point
        r"""The end point of the straight line"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["vectorPathCommandLine"]:
        return "vectorPathCommandLine"

    def getClass(self) -> Literal["VectorPathCommand"]:
        return "VectorPathCommand"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "end_point": self.end_point}

    @classmethod
    def from_dict(cls, data: dict) -> Union["VectorPathCommandLine", None]:
        if data:
            data_class = cls()
            data_class.end_point = data.get("end_point", None)

        return data_class


class VectorPathCommandCubicBezierCurve(TlObject, VectorPathCommand):
    r"""A cubic Bzier curve to a given point

    Parameters:
        start_control_point (:class:`"types.Point"`):
            The start control point of the curve

        end_control_point (:class:`"types.Point"`):
            The end control point of the curve

        end_point (:class:`"types.Point"`):
            The end point of the curve

    """

    def __init__(
        self,
        start_control_point: Point = None,
        end_control_point: Point = None,
        end_point: Point = None,
    ) -> None:
        self.start_control_point: Union[Point, None] = start_control_point
        r"""The start control point of the curve"""
        self.end_control_point: Union[Point, None] = end_control_point
        r"""The end control point of the curve"""
        self.end_point: Union[Point, None] = end_point
        r"""The end point of the curve"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["vectorPathCommandCubicBezierCurve"]:
        return "vectorPathCommandCubicBezierCurve"

    def getClass(self) -> Literal["VectorPathCommand"]:
        return "VectorPathCommand"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "start_control_point": self.start_control_point,
            "end_control_point": self.end_control_point,
            "end_point": self.end_point,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["VectorPathCommandCubicBezierCurve", None]:
        if data:
            data_class = cls()
            data_class.start_control_point = data.get("start_control_point", None)
            data_class.end_control_point = data.get("end_control_point", None)
            data_class.end_point = data.get("end_point", None)

        return data_class


class BotCommandScopeDefault(TlObject, BotCommandScope):
    r"""A scope covering all users"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommandScopeDefault"]:
        return "botCommandScopeDefault"

    def getClass(self) -> Literal["BotCommandScope"]:
        return "BotCommandScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommandScopeDefault", None]:
        if data:
            data_class = cls()

        return data_class


class BotCommandScopeAllPrivateChats(TlObject, BotCommandScope):
    r"""A scope covering all private chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommandScopeAllPrivateChats"]:
        return "botCommandScopeAllPrivateChats"

    def getClass(self) -> Literal["BotCommandScope"]:
        return "BotCommandScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommandScopeAllPrivateChats", None]:
        if data:
            data_class = cls()

        return data_class


class BotCommandScopeAllGroupChats(TlObject, BotCommandScope):
    r"""A scope covering all group and supergroup chats"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommandScopeAllGroupChats"]:
        return "botCommandScopeAllGroupChats"

    def getClass(self) -> Literal["BotCommandScope"]:
        return "BotCommandScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommandScopeAllGroupChats", None]:
        if data:
            data_class = cls()

        return data_class


class BotCommandScopeAllChatAdministrators(TlObject, BotCommandScope):
    r"""A scope covering all group and supergroup chat administrators"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommandScopeAllChatAdministrators"]:
        return "botCommandScopeAllChatAdministrators"

    def getClass(self) -> Literal["BotCommandScope"]:
        return "BotCommandScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["BotCommandScopeAllChatAdministrators", None]:
        if data:
            data_class = cls()

        return data_class


class BotCommandScopeChat(TlObject, BotCommandScope):
    r"""A scope covering all members of a chat

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommandScopeChat"]:
        return "botCommandScopeChat"

    def getClass(self) -> Literal["BotCommandScope"]:
        return "BotCommandScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommandScopeChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class BotCommandScopeChatAdministrators(TlObject, BotCommandScope):
    r"""A scope covering all administrators of a chat

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

    """

    def __init__(self, chat_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommandScopeChatAdministrators"]:
        return "botCommandScopeChatAdministrators"

    def getClass(self) -> Literal["BotCommandScope"]:
        return "BotCommandScope"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommandScopeChatAdministrators", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))

        return data_class


class BotCommandScopeChatMember(TlObject, BotCommandScope):
    r"""A scope covering a member of a chat

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        user_id (:class:`int`):
            User identifier

    """

    def __init__(self, chat_id: int = 0, user_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.user_id: int = int(user_id)
        r"""User identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["botCommandScopeChatMember"]:
        return "botCommandScopeChatMember"

    def getClass(self) -> Literal["BotCommandScope"]:
        return "BotCommandScope"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "user_id": self.user_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["BotCommandScopeChatMember", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.user_id = int(data.get("user_id", 0))

        return data_class


class PhoneNumberCodeTypeChange(TlObject, PhoneNumberCodeType):
    r"""Checks ownership of a new phone number to change the user's authentication phone number; for official Android and iOS applications only"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["phoneNumberCodeTypeChange"]:
        return "phoneNumberCodeTypeChange"

    def getClass(self) -> Literal["PhoneNumberCodeType"]:
        return "PhoneNumberCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PhoneNumberCodeTypeChange", None]:
        if data:
            data_class = cls()

        return data_class


class PhoneNumberCodeTypeVerify(TlObject, PhoneNumberCodeType):
    r"""Verifies ownership of a phone number to be added to the user's Telegram Passport"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["phoneNumberCodeTypeVerify"]:
        return "phoneNumberCodeTypeVerify"

    def getClass(self) -> Literal["PhoneNumberCodeType"]:
        return "PhoneNumberCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["PhoneNumberCodeTypeVerify", None]:
        if data:
            data_class = cls()

        return data_class


class PhoneNumberCodeTypeConfirmOwnership(TlObject, PhoneNumberCodeType):
    r"""Confirms ownership of a phone number to prevent account deletion while handling links of the type internalLinkTypePhoneNumberConfirmation

    Parameters:
        hash (:class:`str`):
            Hash value from the link

    """

    def __init__(self, hash: str = "") -> None:
        self.hash: Union[str, None] = hash
        r"""Hash value from the link"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["phoneNumberCodeTypeConfirmOwnership"]:
        return "phoneNumberCodeTypeConfirmOwnership"

    def getClass(self) -> Literal["PhoneNumberCodeType"]:
        return "PhoneNumberCodeType"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "hash": self.hash}

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["PhoneNumberCodeTypeConfirmOwnership", None]:
        if data:
            data_class = cls()
            data_class.hash = data.get("hash", "")

        return data_class


class LogStreamDefault(TlObject, LogStream):
    r"""The log is written to stderr or an OS specific log"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["logStreamDefault"]:
        return "logStreamDefault"

    def getClass(self) -> Literal["LogStream"]:
        return "LogStream"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LogStreamDefault", None]:
        if data:
            data_class = cls()

        return data_class


class LogStreamFile(TlObject, LogStream):
    r"""The log is written to a file

    Parameters:
        path (:class:`str`):
            Path to the file to where the internal TDLib log will be written

        max_file_size (:class:`int`):
            The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes

        redirect_stderr (:class:`bool`):
            Pass true to additionally redirect stderr to the log file\. Ignored on Windows

    """

    def __init__(
        self, path: str = "", max_file_size: int = 0, redirect_stderr: bool = False
    ) -> None:
        self.path: Union[str, None] = path
        r"""Path to the file to where the internal TDLib log will be written"""
        self.max_file_size: int = int(max_file_size)
        r"""The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes"""
        self.redirect_stderr: bool = bool(redirect_stderr)
        r"""Pass true to additionally redirect stderr to the log file\. Ignored on Windows"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["logStreamFile"]:
        return "logStreamFile"

    def getClass(self) -> Literal["LogStream"]:
        return "LogStream"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "path": self.path,
            "max_file_size": self.max_file_size,
            "redirect_stderr": self.redirect_stderr,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["LogStreamFile", None]:
        if data:
            data_class = cls()
            data_class.path = data.get("path", "")
            data_class.max_file_size = int(data.get("max_file_size", 0))
            data_class.redirect_stderr = data.get("redirect_stderr", False)

        return data_class


class LogStreamEmpty(TlObject, LogStream):
    r"""The log is written nowhere"""

    def __init__(self) -> None:
        pass

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["logStreamEmpty"]:
        return "logStreamEmpty"

    def getClass(self) -> Literal["LogStream"]:
        return "LogStream"

    def to_dict(self) -> dict:
        return {"@type": self.getType()}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LogStreamEmpty", None]:
        if data:
            data_class = cls()

        return data_class


class LogVerbosityLevel(TlObject):
    r"""Contains a TDLib internal log verbosity level

    Parameters:
        verbosity_level (:class:`int`):
            Log verbosity level

    """

    def __init__(self, verbosity_level: int = 0) -> None:
        self.verbosity_level: int = int(verbosity_level)
        r"""Log verbosity level"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["logVerbosityLevel"]:
        return "logVerbosityLevel"

    def getClass(self) -> Literal["LogVerbosityLevel"]:
        return "LogVerbosityLevel"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "verbosity_level": self.verbosity_level}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LogVerbosityLevel", None]:
        if data:
            data_class = cls()
            data_class.verbosity_level = int(data.get("verbosity_level", 0))

        return data_class


class LogTags(TlObject):
    r"""Contains a list of available TDLib internal log tags

    Parameters:
        tags (:class:`List[str]`):
            List of log tags

    """

    def __init__(self, tags: List[str] = None) -> None:
        self.tags: List[str] = tags or []
        r"""List of log tags"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["logTags"]:
        return "logTags"

    def getClass(self) -> Literal["LogTags"]:
        return "LogTags"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "tags": self.tags}

    @classmethod
    def from_dict(cls, data: dict) -> Union["LogTags", None]:
        if data:
            data_class = cls()
            data_class.tags = data.get("tags", None)

        return data_class


class UserSupportInfo(TlObject):
    r"""Contains custom information about the user

    Parameters:
        message (:class:`"types.FormattedText"`):
            Information message

        author (:class:`str`):
            Information author

        date (:class:`int`):
            Information change date

    """

    def __init__(
        self, message: FormattedText = None, author: str = "", date: int = 0
    ) -> None:
        self.message: Union[FormattedText, None] = message
        r"""Information message"""
        self.author: Union[str, None] = author
        r"""Information author"""
        self.date: int = int(date)
        r"""Information change date"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["userSupportInfo"]:
        return "userSupportInfo"

    def getClass(self) -> Literal["UserSupportInfo"]:
        return "UserSupportInfo"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message": self.message,
            "author": self.author,
            "date": self.date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UserSupportInfo", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)
            data_class.author = data.get("author", "")
            data_class.date = int(data.get("date", 0))

        return data_class


class TestInt(TlObject):
    r"""A simple object containing a number; for testing only

    Parameters:
        value (:class:`int`):
            Number

    """

    def __init__(self, value: int = 0) -> None:
        self.value: int = int(value)
        r"""Number"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["testInt"]:
        return "testInt"

    def getClass(self) -> Literal["TestInt"]:
        return "TestInt"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TestInt", None]:
        if data:
            data_class = cls()
            data_class.value = int(data.get("value", 0))

        return data_class


class TestString(TlObject):
    r"""A simple object containing a string; for testing only

    Parameters:
        value (:class:`str`):
            String

    """

    def __init__(self, value: str = "") -> None:
        self.value: Union[str, None] = value
        r"""String"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["testString"]:
        return "testString"

    def getClass(self) -> Literal["TestString"]:
        return "TestString"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TestString", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", "")

        return data_class


class TestBytes(TlObject):
    r"""A simple object containing a sequence of bytes; for testing only

    Parameters:
        value (:class:`bytes`):
            Bytes

    """

    def __init__(self, value: bytes = b"") -> None:
        self.value: Union[bytes, None] = value
        r"""Bytes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["testBytes"]:
        return "testBytes"

    def getClass(self) -> Literal["TestBytes"]:
        return "TestBytes"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TestBytes", None]:
        if data:
            data_class = cls()
            data_class.value = b64decode(data.get("value", b""))

        return data_class


class TestVectorInt(TlObject):
    r"""A simple object containing a vector of numbers; for testing only

    Parameters:
        value (:class:`List[int]`):
            Vector of numbers

    """

    def __init__(self, value: List[int] = None) -> None:
        self.value: List[int] = value or []
        r"""Vector of numbers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["testVectorInt"]:
        return "testVectorInt"

    def getClass(self) -> Literal["TestVectorInt"]:
        return "TestVectorInt"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TestVectorInt", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", None)

        return data_class


class TestVectorIntObject(TlObject):
    r"""A simple object containing a vector of objects that hold a number; for testing only

    Parameters:
        value (:class:`List["types.TestInt"]`):
            Vector of objects

    """

    def __init__(self, value: List[TestInt] = None) -> None:
        self.value: List[TestInt] = value or []
        r"""Vector of objects"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["testVectorIntObject"]:
        return "testVectorIntObject"

    def getClass(self) -> Literal["TestVectorIntObject"]:
        return "TestVectorIntObject"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TestVectorIntObject", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", None)

        return data_class


class TestVectorString(TlObject):
    r"""A simple object containing a vector of strings; for testing only

    Parameters:
        value (:class:`List[str]`):
            Vector of strings

    """

    def __init__(self, value: List[str] = None) -> None:
        self.value: List[str] = value or []
        r"""Vector of strings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["testVectorString"]:
        return "testVectorString"

    def getClass(self) -> Literal["TestVectorString"]:
        return "TestVectorString"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TestVectorString", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", None)

        return data_class


class TestVectorStringObject(TlObject):
    r"""A simple object containing a vector of objects that hold a string; for testing only

    Parameters:
        value (:class:`List["types.TestString"]`):
            Vector of objects

    """

    def __init__(self, value: List[TestString] = None) -> None:
        self.value: List[TestString] = value or []
        r"""Vector of objects"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["testVectorStringObject"]:
        return "testVectorStringObject"

    def getClass(self) -> Literal["TestVectorStringObject"]:
        return "TestVectorStringObject"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["TestVectorStringObject", None]:
        if data:
            data_class = cls()
            data_class.value = data.get("value", None)

        return data_class


class UpdateAuthorizationState(TlObject, Update):
    r"""The user authorization state has changed

    Parameters:
        authorization_state (:class:`"types.AuthorizationState"`):
            New authorization state

    """

    def __init__(self, authorization_state: AuthorizationState = None) -> None:
        self.authorization_state: Union[
            AuthorizationStateWaitTdlibParameters,
            AuthorizationStateWaitPhoneNumber,
            AuthorizationStateWaitPremiumPurchase,
            AuthorizationStateWaitEmailAddress,
            AuthorizationStateWaitEmailCode,
            AuthorizationStateWaitCode,
            AuthorizationStateWaitOtherDeviceConfirmation,
            AuthorizationStateWaitRegistration,
            AuthorizationStateWaitPassword,
            AuthorizationStateReady,
            AuthorizationStateLoggingOut,
            AuthorizationStateClosing,
            AuthorizationStateClosed,
            None,
        ] = authorization_state
        r"""New authorization state"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateAuthorizationState"]:
        return "updateAuthorizationState"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "authorization_state": self.authorization_state,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateAuthorizationState", None]:
        if data:
            data_class = cls()
            data_class.authorization_state = data.get("authorization_state", None)

        return data_class


class UpdateNewMessage(TlObject, Update):
    r"""A new message was received; can also be an outgoing message

    Parameters:
        message (:class:`"types.Message"`):
            The new message

    """

    def __init__(self, message: Message = None) -> None:
        self.message: Union[Message, None] = message
        r"""The new message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewMessage"]:
        return "updateNewMessage"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "message": self.message}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewMessage", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)

        return data_class


class UpdateMessageSendAcknowledged(TlObject, Update):
    r"""A request to send a message has reached the Telegram server\. This doesn't mean that the message will be sent successfully\. This update is sent only if the option \"use\_quick\_ack\" is set to true\. This update may be sent multiple times for the same message

    Parameters:
        chat_id (:class:`int`):
            The chat identifier of the sent message

        message_id (:class:`int`):
            A temporary message identifier

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""The chat identifier of the sent message"""
        self.message_id: int = int(message_id)
        r"""A temporary message identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageSendAcknowledged"]:
        return "updateMessageSendAcknowledged"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageSendAcknowledged", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class UpdateMessageSendSucceeded(TlObject, Update):
    r"""A message has been successfully sent

    Parameters:
        message (:class:`"types.Message"`):
            The sent message\. Almost any field of the new message can be different from the corresponding field of the original message\. For example, the field scheduling\_state may change, making the message scheduled, or non\-scheduled

        old_message_id (:class:`int`):
            The previous temporary message identifier

    """

    def __init__(self, message: Message = None, old_message_id: int = 0) -> None:
        self.message: Union[Message, None] = message
        r"""The sent message\. Almost any field of the new message can be different from the corresponding field of the original message\. For example, the field scheduling\_state may change, making the message scheduled, or non\-scheduled"""
        self.old_message_id: int = int(old_message_id)
        r"""The previous temporary message identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageSendSucceeded"]:
        return "updateMessageSendSucceeded"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message": self.message,
            "old_message_id": self.old_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageSendSucceeded", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)
            data_class.old_message_id = int(data.get("old_message_id", 0))

        return data_class


class UpdateMessageSendFailed(TlObject, Update):
    r"""A message failed to send\. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update

    Parameters:
        message (:class:`"types.Message"`):
            The failed to send message

        old_message_id (:class:`int`):
            The previous temporary message identifier

        error (:class:`"types.Error"`):
            The cause of the message sending failure

    """

    def __init__(
        self, message: Message = None, old_message_id: int = 0, error: Error = None
    ) -> None:
        self.message: Union[Message, None] = message
        r"""The failed to send message"""
        self.old_message_id: int = int(old_message_id)
        r"""The previous temporary message identifier"""
        self.error: Union[Error, None] = error
        r"""The cause of the message sending failure"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageSendFailed"]:
        return "updateMessageSendFailed"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "message": self.message,
            "old_message_id": self.old_message_id,
            "error": self.error,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageSendFailed", None]:
        if data:
            data_class = cls()
            data_class.message = data.get("message", None)
            data_class.old_message_id = int(data.get("old_message_id", 0))
            data_class.error = data.get("error", None)

        return data_class


class UpdateMessageContent(TlObject, Update):
    r"""The message content has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        new_content (:class:`"types.MessageContent"`):
            New message content

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, new_content: MessageContent = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.new_content: Union[
            MessageText,
            MessageAnimation,
            MessageAudio,
            MessageDocument,
            MessagePaidMedia,
            MessagePhoto,
            MessageSticker,
            MessageVideo,
            MessageVideoNote,
            MessageVoiceNote,
            MessageExpiredPhoto,
            MessageExpiredVideo,
            MessageExpiredVideoNote,
            MessageExpiredVoiceNote,
            MessageLocation,
            MessageVenue,
            MessageContact,
            MessageAnimatedEmoji,
            MessageDice,
            MessageGame,
            MessagePoll,
            MessageStory,
            MessageInvoice,
            MessageCall,
            MessageVideoChatScheduled,
            MessageVideoChatStarted,
            MessageVideoChatEnded,
            MessageInviteVideoChatParticipants,
            MessageBasicGroupChatCreate,
            MessageSupergroupChatCreate,
            MessageChatChangeTitle,
            MessageChatChangePhoto,
            MessageChatDeletePhoto,
            MessageChatAddMembers,
            MessageChatJoinByLink,
            MessageChatJoinByRequest,
            MessageChatDeleteMember,
            MessageChatUpgradeTo,
            MessageChatUpgradeFrom,
            MessagePinMessage,
            MessageScreenshotTaken,
            MessageChatSetBackground,
            MessageChatSetTheme,
            MessageChatSetMessageAutoDeleteTime,
            MessageChatBoost,
            MessageForumTopicCreated,
            MessageForumTopicEdited,
            MessageForumTopicIsClosedToggled,
            MessageForumTopicIsHiddenToggled,
            MessageSuggestProfilePhoto,
            MessageCustomServiceAction,
            MessageGameScore,
            MessagePaymentSuccessful,
            MessagePaymentSuccessfulBot,
            MessagePaymentRefunded,
            MessageGiftedPremium,
            MessagePremiumGiftCode,
            MessageGiveawayCreated,
            MessageGiveaway,
            MessageGiveawayCompleted,
            MessageGiveawayWinners,
            MessageGiftedStars,
            MessageGiveawayPrizeStars,
            MessageGift,
            MessageUpgradedGift,
            MessageRefundedUpgradedGift,
            MessagePaidMessagesRefunded,
            MessagePaidMessagePriceChanged,
            MessageContactRegistered,
            MessageUsersShared,
            MessageChatShared,
            MessageBotWriteAccessAllowed,
            MessageWebAppDataSent,
            MessageWebAppDataReceived,
            MessagePassportDataSent,
            MessagePassportDataReceived,
            MessageProximityAlertTriggered,
            MessageUnsupported,
            None,
        ] = new_content
        r"""New message content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageContent"]:
        return "updateMessageContent"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "new_content": self.new_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageContent", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.new_content = data.get("new_content", None)

        return data_class


class UpdateMessageEdited(TlObject, Update):
    r"""A message was edited\. Changes in the message content will come in a separate updateMessageContent

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        edit_date (:class:`int`):
            Point in time \(Unix timestamp\) when the message was edited

        reply_markup (:class:`"types.ReplyMarkup"`):
            New message reply markup; may be null

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_id: int = 0,
        edit_date: int = 0,
        reply_markup: ReplyMarkup = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.edit_date: int = int(edit_date)
        r"""Point in time \(Unix timestamp\) when the message was edited"""
        self.reply_markup: Union[
            ReplyMarkupRemoveKeyboard,
            ReplyMarkupForceReply,
            ReplyMarkupShowKeyboard,
            ReplyMarkupInlineKeyboard,
            None,
        ] = reply_markup
        r"""New message reply markup; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageEdited"]:
        return "updateMessageEdited"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "edit_date": self.edit_date,
            "reply_markup": self.reply_markup,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageEdited", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.edit_date = int(data.get("edit_date", 0))
            data_class.reply_markup = data.get("reply_markup", None)

        return data_class


class UpdateMessageIsPinned(TlObject, Update):
    r"""The message pinned state was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            The message identifier

        is_pinned (:class:`bool`):
            True, if the message is pinned

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, is_pinned: bool = False
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""The message identifier"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the message is pinned"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageIsPinned"]:
        return "updateMessageIsPinned"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "is_pinned": self.is_pinned,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageIsPinned", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.is_pinned = data.get("is_pinned", False)

        return data_class


class UpdateMessageInteractionInfo(TlObject, Update):
    r"""The information about interactions with a message has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        interaction_info (:class:`"types.MessageInteractionInfo"`):
            New information about interactions with the message; may be null

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_id: int = 0,
        interaction_info: MessageInteractionInfo = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.interaction_info: Union[MessageInteractionInfo, None] = interaction_info
        r"""New information about interactions with the message; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageInteractionInfo"]:
        return "updateMessageInteractionInfo"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "interaction_info": self.interaction_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageInteractionInfo", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.interaction_info = data.get("interaction_info", None)

        return data_class


class UpdateMessageContentOpened(TlObject, Update):
    r"""The message content was opened\. Updates voice note messages to \"listened\", video note messages to \"viewed\" and starts the self\-destruct timer

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageContentOpened"]:
        return "updateMessageContentOpened"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageContentOpened", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class UpdateMessageMentionRead(TlObject, Update):
    r"""A message with an unread mention was read

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        unread_mention_count (:class:`int`):
            The new number of unread mention messages left in the chat

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, unread_mention_count: int = 0
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.unread_mention_count: int = int(unread_mention_count)
        r"""The new number of unread mention messages left in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageMentionRead"]:
        return "updateMessageMentionRead"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "unread_mention_count": self.unread_mention_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageMentionRead", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.unread_mention_count = int(data.get("unread_mention_count", 0))

        return data_class


class UpdateMessageUnreadReactions(TlObject, Update):
    r"""The list of unread reactions added to a message was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        unread_reactions (:class:`List["types.UnreadReaction"]`):
            The new list of unread reactions

        unread_reaction_count (:class:`int`):
            The new number of messages with unread reactions left in the chat

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_id: int = 0,
        unread_reactions: List[UnreadReaction] = None,
        unread_reaction_count: int = 0,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.unread_reactions: List[UnreadReaction] = unread_reactions or []
        r"""The new list of unread reactions"""
        self.unread_reaction_count: int = int(unread_reaction_count)
        r"""The new number of messages with unread reactions left in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageUnreadReactions"]:
        return "updateMessageUnreadReactions"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "unread_reactions": self.unread_reactions,
            "unread_reaction_count": self.unread_reaction_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageUnreadReactions", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.unread_reactions = data.get("unread_reactions", None)
            data_class.unread_reaction_count = int(data.get("unread_reaction_count", 0))

        return data_class


class UpdateMessageFactCheck(TlObject, Update):
    r"""A fact\-check added to a message was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        fact_check (:class:`"types.FactCheck"`):
            The new fact\-check

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, fact_check: FactCheck = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.fact_check: Union[FactCheck, None] = fact_check
        r"""The new fact\-check"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageFactCheck"]:
        return "updateMessageFactCheck"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "fact_check": self.fact_check,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageFactCheck", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.fact_check = data.get("fact_check", None)

        return data_class


class UpdateMessageLiveLocationViewed(TlObject, Update):
    r"""A message with a live location was viewed\. When the update is received, the application is expected to update the live location

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat with the live location message

        message_id (:class:`int`):
            Identifier of the message with live location

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat with the live location message"""
        self.message_id: int = int(message_id)
        r"""Identifier of the message with live location"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageLiveLocationViewed"]:
        return "updateMessageLiveLocationViewed"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageLiveLocationViewed", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class UpdateVideoPublished(TlObject, Update):
    r"""An automatically scheduled message with video has been successfully sent after conversion

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat with the message

        message_id (:class:`int`):
            Identifier of the sent message

    """

    def __init__(self, chat_id: int = 0, message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat with the message"""
        self.message_id: int = int(message_id)
        r"""Identifier of the sent message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateVideoPublished"]:
        return "updateVideoPublished"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateVideoPublished", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))

        return data_class


class UpdateNewChat(TlObject, Update):
    r"""A new chat has been loaded/created\. This update is guaranteed to come before the chat identifier is returned to the application\. The chat field changes will be reported through separate updates

    Parameters:
        chat (:class:`"types.Chat"`):
            The chat

    """

    def __init__(self, chat: Chat = None) -> None:
        self.chat: Union[Chat, None] = chat
        r"""The chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewChat"]:
        return "updateNewChat"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat": self.chat}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewChat", None]:
        if data:
            data_class = cls()
            data_class.chat = data.get("chat", None)

        return data_class


class UpdateChatTitle(TlObject, Update):
    r"""The title of a chat was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        title (:class:`str`):
            The new chat title

    """

    def __init__(self, chat_id: int = 0, title: str = "") -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.title: Union[str, None] = title
        r"""The new chat title"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatTitle"]:
        return "updateChatTitle"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id, "title": self.title}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatTitle", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.title = data.get("title", "")

        return data_class


class UpdateChatPhoto(TlObject, Update):
    r"""A chat photo was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        photo (:class:`"types.ChatPhotoInfo"`):
            The new chat photo; may be null

    """

    def __init__(self, chat_id: int = 0, photo: ChatPhotoInfo = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.photo: Union[ChatPhotoInfo, None] = photo
        r"""The new chat photo; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatPhoto"]:
        return "updateChatPhoto"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id, "photo": self.photo}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatPhoto", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.photo = data.get("photo", None)

        return data_class


class UpdateChatAccentColors(TlObject, Update):
    r"""Chat accent colors have changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        accent_color_id (:class:`int`):
            The new chat accent color identifier

        background_custom_emoji_id (:class:`int`):
            The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none

        profile_accent_color_id (:class:`int`):
            The new chat profile accent color identifier; \-1 if none

        profile_background_custom_emoji_id (:class:`int`):
            The new identifier of a custom emoji to be shown on the profile background; 0 if none

    """

    def __init__(
        self,
        chat_id: int = 0,
        accent_color_id: int = 0,
        background_custom_emoji_id: int = 0,
        profile_accent_color_id: int = 0,
        profile_background_custom_emoji_id: int = 0,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.accent_color_id: int = int(accent_color_id)
        r"""The new chat accent color identifier"""
        self.background_custom_emoji_id: int = int(background_custom_emoji_id)
        r"""The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none"""
        self.profile_accent_color_id: int = int(profile_accent_color_id)
        r"""The new chat profile accent color identifier; \-1 if none"""
        self.profile_background_custom_emoji_id: int = int(
            profile_background_custom_emoji_id
        )
        r"""The new identifier of a custom emoji to be shown on the profile background; 0 if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatAccentColors"]:
        return "updateChatAccentColors"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "accent_color_id": self.accent_color_id,
            "background_custom_emoji_id": self.background_custom_emoji_id,
            "profile_accent_color_id": self.profile_accent_color_id,
            "profile_background_custom_emoji_id": self.profile_background_custom_emoji_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatAccentColors", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.accent_color_id = int(data.get("accent_color_id", 0))
            data_class.background_custom_emoji_id = int(
                data.get("background_custom_emoji_id", 0)
            )
            data_class.profile_accent_color_id = int(
                data.get("profile_accent_color_id", 0)
            )
            data_class.profile_background_custom_emoji_id = int(
                data.get("profile_background_custom_emoji_id", 0)
            )

        return data_class


class UpdateChatPermissions(TlObject, Update):
    r"""Chat permissions were changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        permissions (:class:`"types.ChatPermissions"`):
            The new chat permissions

    """

    def __init__(self, chat_id: int = 0, permissions: ChatPermissions = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.permissions: Union[ChatPermissions, None] = permissions
        r"""The new chat permissions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatPermissions"]:
        return "updateChatPermissions"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "permissions": self.permissions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatPermissions", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.permissions = data.get("permissions", None)

        return data_class


class UpdateChatLastMessage(TlObject, Update):
    r"""The last message of a chat was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        last_message (:class:`"types.Message"`):
            The new last message in the chat; may be null if the last message became unknown\. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update

        positions (:class:`List["types.ChatPosition"]`):
            The new chat positions in the chat lists

    """

    def __init__(
        self,
        chat_id: int = 0,
        last_message: Message = None,
        positions: List[ChatPosition] = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.last_message: Union[Message, None] = last_message
        r"""The new last message in the chat; may be null if the last message became unknown\. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update"""
        self.positions: List[ChatPosition] = positions or []
        r"""The new chat positions in the chat lists"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatLastMessage"]:
        return "updateChatLastMessage"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "last_message": self.last_message,
            "positions": self.positions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatLastMessage", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.last_message = data.get("last_message", None)
            data_class.positions = data.get("positions", None)

        return data_class


class UpdateChatPosition(TlObject, Update):
    r"""The position of a chat in a chat list has changed\. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        position (:class:`"types.ChatPosition"`):
            New chat position\. If new order is 0, then the chat needs to be removed from the list

    """

    def __init__(self, chat_id: int = 0, position: ChatPosition = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.position: Union[ChatPosition, None] = position
        r"""New chat position\. If new order is 0, then the chat needs to be removed from the list"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatPosition"]:
        return "updateChatPosition"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "position": self.position,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatPosition", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.position = data.get("position", None)

        return data_class


class UpdateChatAddedToList(TlObject, Update):
    r"""A chat was added to a chat list

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        chat_list (:class:`"types.ChatList"`):
            The chat list to which the chat was added

    """

    def __init__(self, chat_id: int = 0, chat_list: ChatList = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.chat_list: Union[ChatListMain, ChatListArchive, ChatListFolder, None] = (
            chat_list
        )
        r"""The chat list to which the chat was added"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatAddedToList"]:
        return "updateChatAddedToList"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "chat_list": self.chat_list,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatAddedToList", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.chat_list = data.get("chat_list", None)

        return data_class


class UpdateChatRemovedFromList(TlObject, Update):
    r"""A chat was removed from a chat list

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        chat_list (:class:`"types.ChatList"`):
            The chat list from which the chat was removed

    """

    def __init__(self, chat_id: int = 0, chat_list: ChatList = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.chat_list: Union[ChatListMain, ChatListArchive, ChatListFolder, None] = (
            chat_list
        )
        r"""The chat list from which the chat was removed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatRemovedFromList"]:
        return "updateChatRemovedFromList"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "chat_list": self.chat_list,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatRemovedFromList", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.chat_list = data.get("chat_list", None)

        return data_class


class UpdateChatReadInbox(TlObject, Update):
    r"""Incoming messages were read or the number of unread messages has been changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        last_read_inbox_message_id (:class:`int`):
            Identifier of the last read incoming message

        unread_count (:class:`int`):
            The number of unread messages left in the chat

    """

    def __init__(
        self,
        chat_id: int = 0,
        last_read_inbox_message_id: int = 0,
        unread_count: int = 0,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.last_read_inbox_message_id: int = int(last_read_inbox_message_id)
        r"""Identifier of the last read incoming message"""
        self.unread_count: int = int(unread_count)
        r"""The number of unread messages left in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatReadInbox"]:
        return "updateChatReadInbox"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "last_read_inbox_message_id": self.last_read_inbox_message_id,
            "unread_count": self.unread_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatReadInbox", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.last_read_inbox_message_id = int(
                data.get("last_read_inbox_message_id", 0)
            )
            data_class.unread_count = int(data.get("unread_count", 0))

        return data_class


class UpdateChatReadOutbox(TlObject, Update):
    r"""Outgoing messages were read

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        last_read_outbox_message_id (:class:`int`):
            Identifier of last read outgoing message

    """

    def __init__(self, chat_id: int = 0, last_read_outbox_message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.last_read_outbox_message_id: int = int(last_read_outbox_message_id)
        r"""Identifier of last read outgoing message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatReadOutbox"]:
        return "updateChatReadOutbox"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "last_read_outbox_message_id": self.last_read_outbox_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatReadOutbox", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.last_read_outbox_message_id = int(
                data.get("last_read_outbox_message_id", 0)
            )

        return data_class


class UpdateChatActionBar(TlObject, Update):
    r"""The chat action bar was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        action_bar (:class:`"types.ChatActionBar"`):
            The new value of the action bar; may be null

    """

    def __init__(self, chat_id: int = 0, action_bar: ChatActionBar = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.action_bar: Union[
            ChatActionBarReportSpam,
            ChatActionBarInviteMembers,
            ChatActionBarReportAddBlock,
            ChatActionBarAddContact,
            ChatActionBarSharePhoneNumber,
            ChatActionBarJoinRequest,
            None,
        ] = action_bar
        r"""The new value of the action bar; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatActionBar"]:
        return "updateChatActionBar"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "action_bar": self.action_bar,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatActionBar", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.action_bar = data.get("action_bar", None)

        return data_class


class UpdateChatBusinessBotManageBar(TlObject, Update):
    r"""The bar for managing business bot was changed in a chat

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        business_bot_manage_bar (:class:`"types.BusinessBotManageBar"`):
            The new value of the business bot manage bar; may be null

    """

    def __init__(
        self, chat_id: int = 0, business_bot_manage_bar: BusinessBotManageBar = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.business_bot_manage_bar: Union[BusinessBotManageBar, None] = (
            business_bot_manage_bar
        )
        r"""The new value of the business bot manage bar; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatBusinessBotManageBar"]:
        return "updateChatBusinessBotManageBar"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "business_bot_manage_bar": self.business_bot_manage_bar,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatBusinessBotManageBar", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.business_bot_manage_bar = data.get(
                "business_bot_manage_bar", None
            )

        return data_class


class UpdateChatAvailableReactions(TlObject, Update):
    r"""The chat available reactions were changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        available_reactions (:class:`"types.ChatAvailableReactions"`):
            The new reactions, available in the chat

    """

    def __init__(
        self, chat_id: int = 0, available_reactions: ChatAvailableReactions = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.available_reactions: Union[
            ChatAvailableReactionsAll, ChatAvailableReactionsSome, None
        ] = available_reactions
        r"""The new reactions, available in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatAvailableReactions"]:
        return "updateChatAvailableReactions"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "available_reactions": self.available_reactions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatAvailableReactions", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.available_reactions = data.get("available_reactions", None)

        return data_class


class UpdateChatDraftMessage(TlObject, Update):
    r"""A chat draft has changed\. Be aware that the update may come in the currently opened chat but with old content of the draft\. If the user has changed the content of the draft, this update mustn't be applied

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        draft_message (:class:`"types.DraftMessage"`):
            The new draft message; may be null if none

        positions (:class:`List["types.ChatPosition"]`):
            The new chat positions in the chat lists

    """

    def __init__(
        self,
        chat_id: int = 0,
        draft_message: DraftMessage = None,
        positions: List[ChatPosition] = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.draft_message: Union[DraftMessage, None] = draft_message
        r"""The new draft message; may be null if none"""
        self.positions: List[ChatPosition] = positions or []
        r"""The new chat positions in the chat lists"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatDraftMessage"]:
        return "updateChatDraftMessage"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "draft_message": self.draft_message,
            "positions": self.positions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatDraftMessage", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.draft_message = data.get("draft_message", None)
            data_class.positions = data.get("positions", None)

        return data_class


class UpdateChatEmojiStatus(TlObject, Update):
    r"""Chat emoji status has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        emoji_status (:class:`"types.EmojiStatus"`):
            The new chat emoji status; may be null

    """

    def __init__(self, chat_id: int = 0, emoji_status: EmojiStatus = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.emoji_status: Union[EmojiStatus, None] = emoji_status
        r"""The new chat emoji status; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatEmojiStatus"]:
        return "updateChatEmojiStatus"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "emoji_status": self.emoji_status,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatEmojiStatus", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.emoji_status = data.get("emoji_status", None)

        return data_class


class UpdateChatMessageSender(TlObject, Update):
    r"""The message sender that is selected to send messages in a chat has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_sender_id (:class:`"types.MessageSender"`):
            New value of message\_sender\_id; may be null if the user can't change message sender

    """

    def __init__(
        self, chat_id: int = 0, message_sender_id: MessageSender = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_sender_id: Union[MessageSenderUser, MessageSenderChat, None] = (
            message_sender_id
        )
        r"""New value of message\_sender\_id; may be null if the user can't change message sender"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatMessageSender"]:
        return "updateChatMessageSender"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_sender_id": self.message_sender_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatMessageSender", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_sender_id = data.get("message_sender_id", None)

        return data_class


class UpdateChatMessageAutoDeleteTime(TlObject, Update):
    r"""The message auto\-delete or self\-destruct timer setting for a chat was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_auto_delete_time (:class:`int`):
            New value of message\_auto\_delete\_time

    """

    def __init__(self, chat_id: int = 0, message_auto_delete_time: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_auto_delete_time: int = int(message_auto_delete_time)
        r"""New value of message\_auto\_delete\_time"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatMessageAutoDeleteTime"]:
        return "updateChatMessageAutoDeleteTime"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_auto_delete_time": self.message_auto_delete_time,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatMessageAutoDeleteTime", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_auto_delete_time = int(
                data.get("message_auto_delete_time", 0)
            )

        return data_class


class UpdateChatNotificationSettings(TlObject, Update):
    r"""Notification settings for a chat were changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        notification_settings (:class:`"types.ChatNotificationSettings"`):
            The new notification settings

    """

    def __init__(
        self, chat_id: int = 0, notification_settings: ChatNotificationSettings = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.notification_settings: Union[ChatNotificationSettings, None] = (
            notification_settings
        )
        r"""The new notification settings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatNotificationSettings"]:
        return "updateChatNotificationSettings"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "notification_settings": self.notification_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatNotificationSettings", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.notification_settings = data.get("notification_settings", None)

        return data_class


class UpdateChatPendingJoinRequests(TlObject, Update):
    r"""The chat pending join requests were changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        pending_join_requests (:class:`"types.ChatJoinRequestsInfo"`):
            The new data about pending join requests; may be null

    """

    def __init__(
        self, chat_id: int = 0, pending_join_requests: ChatJoinRequestsInfo = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.pending_join_requests: Union[ChatJoinRequestsInfo, None] = (
            pending_join_requests
        )
        r"""The new data about pending join requests; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatPendingJoinRequests"]:
        return "updateChatPendingJoinRequests"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "pending_join_requests": self.pending_join_requests,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatPendingJoinRequests", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.pending_join_requests = data.get("pending_join_requests", None)

        return data_class


class UpdateChatReplyMarkup(TlObject, Update):
    r"""The default chat reply markup was changed\. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        reply_markup_message_id (:class:`int`):
            Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat

    """

    def __init__(self, chat_id: int = 0, reply_markup_message_id: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.reply_markup_message_id: int = int(reply_markup_message_id)
        r"""Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatReplyMarkup"]:
        return "updateChatReplyMarkup"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "reply_markup_message_id": self.reply_markup_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatReplyMarkup", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.reply_markup_message_id = int(
                data.get("reply_markup_message_id", 0)
            )

        return data_class


class UpdateChatBackground(TlObject, Update):
    r"""The chat background was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        background (:class:`"types.ChatBackground"`):
            The new chat background; may be null if background was reset to default

    """

    def __init__(self, chat_id: int = 0, background: ChatBackground = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.background: Union[ChatBackground, None] = background
        r"""The new chat background; may be null if background was reset to default"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatBackground"]:
        return "updateChatBackground"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "background": self.background,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatBackground", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.background = data.get("background", None)

        return data_class


class UpdateChatTheme(TlObject, Update):
    r"""The chat theme was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        theme_name (:class:`str`):
            The new name of the chat theme; may be empty if theme was reset to default

    """

    def __init__(self, chat_id: int = 0, theme_name: str = "") -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.theme_name: Union[str, None] = theme_name
        r"""The new name of the chat theme; may be empty if theme was reset to default"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatTheme"]:
        return "updateChatTheme"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "theme_name": self.theme_name,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatTheme", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.theme_name = data.get("theme_name", "")

        return data_class


class UpdateChatUnreadMentionCount(TlObject, Update):
    r"""The chat unread\_mention\_count has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        unread_mention_count (:class:`int`):
            The number of unread mention messages left in the chat

    """

    def __init__(self, chat_id: int = 0, unread_mention_count: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.unread_mention_count: int = int(unread_mention_count)
        r"""The number of unread mention messages left in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatUnreadMentionCount"]:
        return "updateChatUnreadMentionCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "unread_mention_count": self.unread_mention_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatUnreadMentionCount", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.unread_mention_count = int(data.get("unread_mention_count", 0))

        return data_class


class UpdateChatUnreadReactionCount(TlObject, Update):
    r"""The chat unread\_reaction\_count has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        unread_reaction_count (:class:`int`):
            The number of messages with unread reactions left in the chat

    """

    def __init__(self, chat_id: int = 0, unread_reaction_count: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.unread_reaction_count: int = int(unread_reaction_count)
        r"""The number of messages with unread reactions left in the chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatUnreadReactionCount"]:
        return "updateChatUnreadReactionCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "unread_reaction_count": self.unread_reaction_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatUnreadReactionCount", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.unread_reaction_count = int(data.get("unread_reaction_count", 0))

        return data_class


class UpdateChatVideoChat(TlObject, Update):
    r"""A chat video chat state has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        video_chat (:class:`"types.VideoChat"`):
            New value of video\_chat

    """

    def __init__(self, chat_id: int = 0, video_chat: VideoChat = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.video_chat: Union[VideoChat, None] = video_chat
        r"""New value of video\_chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatVideoChat"]:
        return "updateChatVideoChat"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "video_chat": self.video_chat,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatVideoChat", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.video_chat = data.get("video_chat", None)

        return data_class


class UpdateChatDefaultDisableNotification(TlObject, Update):
    r"""The value of the default disable\_notification parameter, used when a message is sent to the chat, was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        default_disable_notification (:class:`bool`):
            The new default\_disable\_notification value

    """

    def __init__(
        self, chat_id: int = 0, default_disable_notification: bool = False
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.default_disable_notification: bool = bool(default_disable_notification)
        r"""The new default\_disable\_notification value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatDefaultDisableNotification"]:
        return "updateChatDefaultDisableNotification"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "default_disable_notification": self.default_disable_notification,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UpdateChatDefaultDisableNotification", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.default_disable_notification = data.get(
                "default_disable_notification", False
            )

        return data_class


class UpdateChatHasProtectedContent(TlObject, Update):
    r"""A chat content was allowed or restricted for saving

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        has_protected_content (:class:`bool`):
            New value of has\_protected\_content

    """

    def __init__(self, chat_id: int = 0, has_protected_content: bool = False) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.has_protected_content: bool = bool(has_protected_content)
        r"""New value of has\_protected\_content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatHasProtectedContent"]:
        return "updateChatHasProtectedContent"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "has_protected_content": self.has_protected_content,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatHasProtectedContent", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.has_protected_content = data.get("has_protected_content", False)

        return data_class


class UpdateChatIsTranslatable(TlObject, Update):
    r"""Translation of chat messages was enabled or disabled

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        is_translatable (:class:`bool`):
            New value of is\_translatable

    """

    def __init__(self, chat_id: int = 0, is_translatable: bool = False) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.is_translatable: bool = bool(is_translatable)
        r"""New value of is\_translatable"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatIsTranslatable"]:
        return "updateChatIsTranslatable"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "is_translatable": self.is_translatable,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatIsTranslatable", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.is_translatable = data.get("is_translatable", False)

        return data_class


class UpdateChatIsMarkedAsUnread(TlObject, Update):
    r"""A chat was marked as unread or was read

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        is_marked_as_unread (:class:`bool`):
            New value of is\_marked\_as\_unread

    """

    def __init__(self, chat_id: int = 0, is_marked_as_unread: bool = False) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.is_marked_as_unread: bool = bool(is_marked_as_unread)
        r"""New value of is\_marked\_as\_unread"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatIsMarkedAsUnread"]:
        return "updateChatIsMarkedAsUnread"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "is_marked_as_unread": self.is_marked_as_unread,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatIsMarkedAsUnread", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.is_marked_as_unread = data.get("is_marked_as_unread", False)

        return data_class


class UpdateChatViewAsTopics(TlObject, Update):
    r"""A chat default appearance has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        view_as_topics (:class:`bool`):
            New value of view\_as\_topics

    """

    def __init__(self, chat_id: int = 0, view_as_topics: bool = False) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.view_as_topics: bool = bool(view_as_topics)
        r"""New value of view\_as\_topics"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatViewAsTopics"]:
        return "updateChatViewAsTopics"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "view_as_topics": self.view_as_topics,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatViewAsTopics", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.view_as_topics = data.get("view_as_topics", False)

        return data_class


class UpdateChatBlockList(TlObject, Update):
    r"""A chat was blocked or unblocked

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        block_list (:class:`"types.BlockList"`):
            Block list to which the chat is added; may be null if none

    """

    def __init__(self, chat_id: int = 0, block_list: BlockList = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.block_list: Union[BlockListMain, BlockListStories, None] = block_list
        r"""Block list to which the chat is added; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatBlockList"]:
        return "updateChatBlockList"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "block_list": self.block_list,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatBlockList", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.block_list = data.get("block_list", None)

        return data_class


class UpdateChatHasScheduledMessages(TlObject, Update):
    r"""A chat's has\_scheduled\_messages field has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        has_scheduled_messages (:class:`bool`):
            New value of has\_scheduled\_messages

    """

    def __init__(self, chat_id: int = 0, has_scheduled_messages: bool = False) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.has_scheduled_messages: bool = bool(has_scheduled_messages)
        r"""New value of has\_scheduled\_messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatHasScheduledMessages"]:
        return "updateChatHasScheduledMessages"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "has_scheduled_messages": self.has_scheduled_messages,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatHasScheduledMessages", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.has_scheduled_messages = data.get(
                "has_scheduled_messages", False
            )

        return data_class


class UpdateChatFolders(TlObject, Update):
    r"""The list of chat folders or a chat folder has changed

    Parameters:
        chat_folders (:class:`List["types.ChatFolderInfo"]`):
            The new list of chat folders

        main_chat_list_position (:class:`int`):
            Position of the main chat list among chat folders, 0\-based

        are_tags_enabled (:class:`bool`):
            True, if folder tags are enabled

    """

    def __init__(
        self,
        chat_folders: List[ChatFolderInfo] = None,
        main_chat_list_position: int = 0,
        are_tags_enabled: bool = False,
    ) -> None:
        self.chat_folders: List[ChatFolderInfo] = chat_folders or []
        r"""The new list of chat folders"""
        self.main_chat_list_position: int = int(main_chat_list_position)
        r"""Position of the main chat list among chat folders, 0\-based"""
        self.are_tags_enabled: bool = bool(are_tags_enabled)
        r"""True, if folder tags are enabled"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatFolders"]:
        return "updateChatFolders"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_folders": self.chat_folders,
            "main_chat_list_position": self.main_chat_list_position,
            "are_tags_enabled": self.are_tags_enabled,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatFolders", None]:
        if data:
            data_class = cls()
            data_class.chat_folders = data.get("chat_folders", None)
            data_class.main_chat_list_position = int(
                data.get("main_chat_list_position", 0)
            )
            data_class.are_tags_enabled = data.get("are_tags_enabled", False)

        return data_class


class UpdateChatOnlineMemberCount(TlObject, Update):
    r"""The number of online group members has changed\. This update with non\-zero number of online group members is sent only for currently opened chats\. There is no guarantee that it is sent just after the number of online users has changed

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat

        online_member_count (:class:`int`):
            New number of online members in the chat, or 0 if unknown

    """

    def __init__(self, chat_id: int = 0, online_member_count: int = 0) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat"""
        self.online_member_count: int = int(online_member_count)
        r"""New number of online members in the chat, or 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatOnlineMemberCount"]:
        return "updateChatOnlineMemberCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "online_member_count": self.online_member_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatOnlineMemberCount", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.online_member_count = int(data.get("online_member_count", 0))

        return data_class


class UpdateSavedMessagesTopic(TlObject, Update):
    r"""Basic information about a Saved Messages topic has changed\. This update is guaranteed to come before the topic identifier is returned to the application

    Parameters:
        topic (:class:`"types.SavedMessagesTopic"`):
            New data about the topic

    """

    def __init__(self, topic: SavedMessagesTopic = None) -> None:
        self.topic: Union[SavedMessagesTopic, None] = topic
        r"""New data about the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSavedMessagesTopic"]:
        return "updateSavedMessagesTopic"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "topic": self.topic}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSavedMessagesTopic", None]:
        if data:
            data_class = cls()
            data_class.topic = data.get("topic", None)

        return data_class


class UpdateSavedMessagesTopicCount(TlObject, Update):
    r"""Number of Saved Messages topics has changed

    Parameters:
        topic_count (:class:`int`):
            Approximate total number of Saved Messages topics

    """

    def __init__(self, topic_count: int = 0) -> None:
        self.topic_count: int = int(topic_count)
        r"""Approximate total number of Saved Messages topics"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSavedMessagesTopicCount"]:
        return "updateSavedMessagesTopicCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "topic_count": self.topic_count}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSavedMessagesTopicCount", None]:
        if data:
            data_class = cls()
            data_class.topic_count = int(data.get("topic_count", 0))

        return data_class


class UpdateQuickReplyShortcut(TlObject, Update):
    r"""Basic information about a quick reply shortcut has changed\. This update is guaranteed to come before the quick shortcut name is returned to the application

    Parameters:
        shortcut (:class:`"types.QuickReplyShortcut"`):
            New data about the shortcut

    """

    def __init__(self, shortcut: QuickReplyShortcut = None) -> None:
        self.shortcut: Union[QuickReplyShortcut, None] = shortcut
        r"""New data about the shortcut"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateQuickReplyShortcut"]:
        return "updateQuickReplyShortcut"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "shortcut": self.shortcut}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateQuickReplyShortcut", None]:
        if data:
            data_class = cls()
            data_class.shortcut = data.get("shortcut", None)

        return data_class


class UpdateQuickReplyShortcutDeleted(TlObject, Update):
    r"""A quick reply shortcut and all its messages were deleted

    Parameters:
        shortcut_id (:class:`int`):
            The identifier of the deleted shortcut

    """

    def __init__(self, shortcut_id: int = 0) -> None:
        self.shortcut_id: int = int(shortcut_id)
        r"""The identifier of the deleted shortcut"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateQuickReplyShortcutDeleted"]:
        return "updateQuickReplyShortcutDeleted"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "shortcut_id": self.shortcut_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateQuickReplyShortcutDeleted", None]:
        if data:
            data_class = cls()
            data_class.shortcut_id = int(data.get("shortcut_id", 0))

        return data_class


class UpdateQuickReplyShortcuts(TlObject, Update):
    r"""The list of quick reply shortcuts has changed

    Parameters:
        shortcut_ids (:class:`List[int]`):
            The new list of identifiers of quick reply shortcuts

    """

    def __init__(self, shortcut_ids: List[int] = None) -> None:
        self.shortcut_ids: List[int] = shortcut_ids or []
        r"""The new list of identifiers of quick reply shortcuts"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateQuickReplyShortcuts"]:
        return "updateQuickReplyShortcuts"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "shortcut_ids": self.shortcut_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateQuickReplyShortcuts", None]:
        if data:
            data_class = cls()
            data_class.shortcut_ids = data.get("shortcut_ids", None)

        return data_class


class UpdateQuickReplyShortcutMessages(TlObject, Update):
    r"""The list of quick reply shortcut messages has changed

    Parameters:
        shortcut_id (:class:`int`):
            The identifier of the shortcut

        messages (:class:`List["types.QuickReplyMessage"]`):
            The new list of quick reply messages for the shortcut in order from the first to the last sent

    """

    def __init__(
        self, shortcut_id: int = 0, messages: List[QuickReplyMessage] = None
    ) -> None:
        self.shortcut_id: int = int(shortcut_id)
        r"""The identifier of the shortcut"""
        self.messages: List[QuickReplyMessage] = messages or []
        r"""The new list of quick reply messages for the shortcut in order from the first to the last sent"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateQuickReplyShortcutMessages"]:
        return "updateQuickReplyShortcutMessages"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "shortcut_id": self.shortcut_id,
            "messages": self.messages,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateQuickReplyShortcutMessages", None]:
        if data:
            data_class = cls()
            data_class.shortcut_id = int(data.get("shortcut_id", 0))
            data_class.messages = data.get("messages", None)

        return data_class


class UpdateForumTopicInfo(TlObject, Update):
    r"""Basic information about a topic in a forum chat was changed

    Parameters:
        info (:class:`"types.ForumTopicInfo"`):
            New information about the topic

    """

    def __init__(self, info: ForumTopicInfo = None) -> None:
        self.info: Union[ForumTopicInfo, None] = info
        r"""New information about the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateForumTopicInfo"]:
        return "updateForumTopicInfo"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "info": self.info}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateForumTopicInfo", None]:
        if data:
            data_class = cls()
            data_class.info = data.get("info", None)

        return data_class


class UpdateForumTopic(TlObject, Update):
    r"""Information about a topic in a forum chat was changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_thread_id (:class:`int`):
            Message thread identifier of the topic

        is_pinned (:class:`bool`):
            True, if the topic is pinned in the topic list

        last_read_outbox_message_id (:class:`int`):
            Identifier of the last read outgoing message

        notification_settings (:class:`"types.ChatNotificationSettings"`):
            Notification settings for the topic

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_thread_id: int = 0,
        is_pinned: bool = False,
        last_read_outbox_message_id: int = 0,
        notification_settings: ChatNotificationSettings = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_thread_id: int = int(message_thread_id)
        r"""Message thread identifier of the topic"""
        self.is_pinned: bool = bool(is_pinned)
        r"""True, if the topic is pinned in the topic list"""
        self.last_read_outbox_message_id: int = int(last_read_outbox_message_id)
        r"""Identifier of the last read outgoing message"""
        self.notification_settings: Union[ChatNotificationSettings, None] = (
            notification_settings
        )
        r"""Notification settings for the topic"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateForumTopic"]:
        return "updateForumTopic"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_thread_id": self.message_thread_id,
            "is_pinned": self.is_pinned,
            "last_read_outbox_message_id": self.last_read_outbox_message_id,
            "notification_settings": self.notification_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateForumTopic", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_thread_id = int(data.get("message_thread_id", 0))
            data_class.is_pinned = data.get("is_pinned", False)
            data_class.last_read_outbox_message_id = int(
                data.get("last_read_outbox_message_id", 0)
            )
            data_class.notification_settings = data.get("notification_settings", None)

        return data_class


class UpdateScopeNotificationSettings(TlObject, Update):
    r"""Notification settings for some type of chats were updated

    Parameters:
        scope (:class:`"types.NotificationSettingsScope"`):
            Types of chats for which notification settings were updated

        notification_settings (:class:`"types.ScopeNotificationSettings"`):
            The new notification settings

    """

    def __init__(
        self,
        scope: NotificationSettingsScope = None,
        notification_settings: ScopeNotificationSettings = None,
    ) -> None:
        self.scope: Union[
            NotificationSettingsScopePrivateChats,
            NotificationSettingsScopeGroupChats,
            NotificationSettingsScopeChannelChats,
            None,
        ] = scope
        r"""Types of chats for which notification settings were updated"""
        self.notification_settings: Union[ScopeNotificationSettings, None] = (
            notification_settings
        )
        r"""The new notification settings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateScopeNotificationSettings"]:
        return "updateScopeNotificationSettings"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "scope": self.scope,
            "notification_settings": self.notification_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateScopeNotificationSettings", None]:
        if data:
            data_class = cls()
            data_class.scope = data.get("scope", None)
            data_class.notification_settings = data.get("notification_settings", None)

        return data_class


class UpdateReactionNotificationSettings(TlObject, Update):
    r"""Notification settings for reactions were updated

    Parameters:
        notification_settings (:class:`"types.ReactionNotificationSettings"`):
            The new notification settings

    """

    def __init__(
        self, notification_settings: ReactionNotificationSettings = None
    ) -> None:
        self.notification_settings: Union[ReactionNotificationSettings, None] = (
            notification_settings
        )
        r"""The new notification settings"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateReactionNotificationSettings"]:
        return "updateReactionNotificationSettings"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "notification_settings": self.notification_settings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateReactionNotificationSettings", None]:
        if data:
            data_class = cls()
            data_class.notification_settings = data.get("notification_settings", None)

        return data_class


class UpdateNotification(TlObject, Update):
    r"""A notification was changed

    Parameters:
        notification_group_id (:class:`int`):
            Unique notification group identifier

        notification (:class:`"types.Notification"`):
            Changed notification

    """

    def __init__(
        self, notification_group_id: int = 0, notification: Notification = None
    ) -> None:
        self.notification_group_id: int = int(notification_group_id)
        r"""Unique notification group identifier"""
        self.notification: Union[Notification, None] = notification
        r"""Changed notification"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNotification"]:
        return "updateNotification"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "notification_group_id": self.notification_group_id,
            "notification": self.notification,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNotification", None]:
        if data:
            data_class = cls()
            data_class.notification_group_id = int(data.get("notification_group_id", 0))
            data_class.notification = data.get("notification", None)

        return data_class


class UpdateNotificationGroup(TlObject, Update):
    r"""A list of active notifications in a notification group has changed

    Parameters:
        notification_group_id (:class:`int`):
            Unique notification group identifier

        type (:class:`"types.NotificationGroupType"`):
            New type of the notification group

        chat_id (:class:`int`):
            Identifier of a chat to which all notifications in the group belong

        notification_settings_chat_id (:class:`int`):
            Chat identifier, which notification settings must be applied to the added notifications

        notification_sound_id (:class:`int`):
            Identifier of the notification sound to be played; 0 if sound is disabled

        total_count (:class:`int`):
            Total number of unread notifications in the group, can be bigger than number of active notifications

        added_notifications (:class:`List["types.Notification"]`):
            List of added group notifications, sorted by notification identifier

        removed_notification_ids (:class:`List[int]`):
            Identifiers of removed group notifications, sorted by notification identifier

    """

    def __init__(
        self,
        notification_group_id: int = 0,
        type: NotificationGroupType = None,
        chat_id: int = 0,
        notification_settings_chat_id: int = 0,
        notification_sound_id: int = 0,
        total_count: int = 0,
        added_notifications: List[Notification] = None,
        removed_notification_ids: List[int] = None,
    ) -> None:
        self.notification_group_id: int = int(notification_group_id)
        r"""Unique notification group identifier"""
        self.type: Union[
            NotificationGroupTypeMessages,
            NotificationGroupTypeMentions,
            NotificationGroupTypeSecretChat,
            NotificationGroupTypeCalls,
            None,
        ] = type
        r"""New type of the notification group"""
        self.chat_id: int = int(chat_id)
        r"""Identifier of a chat to which all notifications in the group belong"""
        self.notification_settings_chat_id: int = int(notification_settings_chat_id)
        r"""Chat identifier, which notification settings must be applied to the added notifications"""
        self.notification_sound_id: int = int(notification_sound_id)
        r"""Identifier of the notification sound to be played; 0 if sound is disabled"""
        self.total_count: int = int(total_count)
        r"""Total number of unread notifications in the group, can be bigger than number of active notifications"""
        self.added_notifications: List[Notification] = added_notifications or []
        r"""List of added group notifications, sorted by notification identifier"""
        self.removed_notification_ids: List[int] = removed_notification_ids or []
        r"""Identifiers of removed group notifications, sorted by notification identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNotificationGroup"]:
        return "updateNotificationGroup"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "notification_group_id": self.notification_group_id,
            "type": self.type,
            "chat_id": self.chat_id,
            "notification_settings_chat_id": self.notification_settings_chat_id,
            "notification_sound_id": self.notification_sound_id,
            "total_count": self.total_count,
            "added_notifications": self.added_notifications,
            "removed_notification_ids": self.removed_notification_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNotificationGroup", None]:
        if data:
            data_class = cls()
            data_class.notification_group_id = int(data.get("notification_group_id", 0))
            data_class.type = data.get("type", None)
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.notification_settings_chat_id = int(
                data.get("notification_settings_chat_id", 0)
            )
            data_class.notification_sound_id = int(data.get("notification_sound_id", 0))
            data_class.total_count = int(data.get("total_count", 0))
            data_class.added_notifications = data.get("added_notifications", None)
            data_class.removed_notification_ids = data.get(
                "removed_notification_ids", None
            )

        return data_class


class UpdateActiveNotifications(TlObject, Update):
    r"""Contains active notifications that were shown on previous application launches\. This update is sent only if the message database is used\. In that case it comes once before any updateNotification and updateNotificationGroup update

    Parameters:
        groups (:class:`List["types.NotificationGroup"]`):
            Lists of active notification groups

    """

    def __init__(self, groups: List[NotificationGroup] = None) -> None:
        self.groups: List[NotificationGroup] = groups or []
        r"""Lists of active notification groups"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateActiveNotifications"]:
        return "updateActiveNotifications"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "groups": self.groups}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateActiveNotifications", None]:
        if data:
            data_class = cls()
            data_class.groups = data.get("groups", None)

        return data_class


class UpdateHavePendingNotifications(TlObject, Update):
    r"""Describes whether there are some pending notification updates\. Can be used to prevent application from killing, while there are some pending notifications

    Parameters:
        have_delayed_notifications (:class:`bool`):
            True, if there are some delayed notification updates, which will be sent soon

        have_unreceived_notifications (:class:`bool`):
            True, if there can be some yet unreceived notifications, which are being fetched from the server

    """

    def __init__(
        self,
        have_delayed_notifications: bool = False,
        have_unreceived_notifications: bool = False,
    ) -> None:
        self.have_delayed_notifications: bool = bool(have_delayed_notifications)
        r"""True, if there are some delayed notification updates, which will be sent soon"""
        self.have_unreceived_notifications: bool = bool(have_unreceived_notifications)
        r"""True, if there can be some yet unreceived notifications, which are being fetched from the server"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateHavePendingNotifications"]:
        return "updateHavePendingNotifications"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "have_delayed_notifications": self.have_delayed_notifications,
            "have_unreceived_notifications": self.have_unreceived_notifications,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateHavePendingNotifications", None]:
        if data:
            data_class = cls()
            data_class.have_delayed_notifications = data.get(
                "have_delayed_notifications", False
            )
            data_class.have_unreceived_notifications = data.get(
                "have_unreceived_notifications", False
            )

        return data_class


class UpdateDeleteMessages(TlObject, Update):
    r"""Some messages were deleted

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_ids (:class:`List[int]`):
            Identifiers of the deleted messages

        is_permanent (:class:`bool`):
            True, if the messages are permanently deleted by a user \(as opposed to just becoming inaccessible\)

        from_cache (:class:`bool`):
            True, if the messages are deleted only from the cache and can possibly be retrieved again in the future

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_ids: List[int] = None,
        is_permanent: bool = False,
        from_cache: bool = False,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_ids: List[int] = message_ids or []
        r"""Identifiers of the deleted messages"""
        self.is_permanent: bool = bool(is_permanent)
        r"""True, if the messages are permanently deleted by a user \(as opposed to just becoming inaccessible\)"""
        self.from_cache: bool = bool(from_cache)
        r"""True, if the messages are deleted only from the cache and can possibly be retrieved again in the future"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateDeleteMessages"]:
        return "updateDeleteMessages"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_ids": self.message_ids,
            "is_permanent": self.is_permanent,
            "from_cache": self.from_cache,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateDeleteMessages", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_ids = data.get("message_ids", None)
            data_class.is_permanent = data.get("is_permanent", False)
            data_class.from_cache = data.get("from_cache", False)

        return data_class


class UpdateChatAction(TlObject, Update):
    r"""A message sender activity in the chat has changed

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_thread_id (:class:`int`):
            If not 0, the message thread identifier in which the action was performed

        sender_id (:class:`"types.MessageSender"`):
            Identifier of a message sender performing the action

        action (:class:`"types.ChatAction"`):
            The action

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_thread_id: int = 0,
        sender_id: MessageSender = None,
        action: ChatAction = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_thread_id: int = int(message_thread_id)
        r"""If not 0, the message thread identifier in which the action was performed"""
        self.sender_id: Union[MessageSenderUser, MessageSenderChat, None] = sender_id
        r"""Identifier of a message sender performing the action"""
        self.action: Union[
            ChatActionTyping,
            ChatActionRecordingVideo,
            ChatActionUploadingVideo,
            ChatActionRecordingVoiceNote,
            ChatActionUploadingVoiceNote,
            ChatActionUploadingPhoto,
            ChatActionUploadingDocument,
            ChatActionChoosingSticker,
            ChatActionChoosingLocation,
            ChatActionChoosingContact,
            ChatActionStartPlayingGame,
            ChatActionRecordingVideoNote,
            ChatActionUploadingVideoNote,
            ChatActionWatchingAnimations,
            ChatActionCancel,
            None,
        ] = action
        r"""The action"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatAction"]:
        return "updateChatAction"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_thread_id": self.message_thread_id,
            "sender_id": self.sender_id,
            "action": self.action,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatAction", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_thread_id = int(data.get("message_thread_id", 0))
            data_class.sender_id = data.get("sender_id", None)
            data_class.action = data.get("action", None)

        return data_class


class UpdateUserStatus(TlObject, Update):
    r"""The user went online or offline

    Parameters:
        user_id (:class:`int`):
            User identifier

        status (:class:`"types.UserStatus"`):
            New status of the user

    """

    def __init__(self, user_id: int = 0, status: UserStatus = None) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.status: Union[
            UserStatusEmpty,
            UserStatusOnline,
            UserStatusOffline,
            UserStatusRecently,
            UserStatusLastWeek,
            UserStatusLastMonth,
            None,
        ] = status
        r"""New status of the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateUserStatus"]:
        return "updateUserStatus"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user_id": self.user_id, "status": self.status}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateUserStatus", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.status = data.get("status", None)

        return data_class


class UpdateUser(TlObject, Update):
    r"""Some data of a user has changed\. This update is guaranteed to come before the user identifier is returned to the application

    Parameters:
        user (:class:`"types.User"`):
            New data about the user

    """

    def __init__(self, user: User = None) -> None:
        self.user: Union[User, None] = user
        r"""New data about the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateUser"]:
        return "updateUser"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "user": self.user}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateUser", None]:
        if data:
            data_class = cls()
            data_class.user = data.get("user", None)

        return data_class


class UpdateBasicGroup(TlObject, Update):
    r"""Some data of a basic group has changed\. This update is guaranteed to come before the basic group identifier is returned to the application

    Parameters:
        basic_group (:class:`"types.BasicGroup"`):
            New data about the group

    """

    def __init__(self, basic_group: BasicGroup = None) -> None:
        self.basic_group: Union[BasicGroup, None] = basic_group
        r"""New data about the group"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateBasicGroup"]:
        return "updateBasicGroup"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "basic_group": self.basic_group}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateBasicGroup", None]:
        if data:
            data_class = cls()
            data_class.basic_group = data.get("basic_group", None)

        return data_class


class UpdateSupergroup(TlObject, Update):
    r"""Some data of a supergroup or a channel has changed\. This update is guaranteed to come before the supergroup identifier is returned to the application

    Parameters:
        supergroup (:class:`"types.Supergroup"`):
            New data about the supergroup

    """

    def __init__(self, supergroup: Supergroup = None) -> None:
        self.supergroup: Union[Supergroup, None] = supergroup
        r"""New data about the supergroup"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSupergroup"]:
        return "updateSupergroup"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "supergroup": self.supergroup}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSupergroup", None]:
        if data:
            data_class = cls()
            data_class.supergroup = data.get("supergroup", None)

        return data_class


class UpdateSecretChat(TlObject, Update):
    r"""Some data of a secret chat has changed\. This update is guaranteed to come before the secret chat identifier is returned to the application

    Parameters:
        secret_chat (:class:`"types.SecretChat"`):
            New data about the secret chat

    """

    def __init__(self, secret_chat: SecretChat = None) -> None:
        self.secret_chat: Union[SecretChat, None] = secret_chat
        r"""New data about the secret chat"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSecretChat"]:
        return "updateSecretChat"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "secret_chat": self.secret_chat}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSecretChat", None]:
        if data:
            data_class = cls()
            data_class.secret_chat = data.get("secret_chat", None)

        return data_class


class UpdateUserFullInfo(TlObject, Update):
    r"""Some data in userFullInfo has been changed

    Parameters:
        user_id (:class:`int`):
            User identifier

        user_full_info (:class:`"types.UserFullInfo"`):
            New full information about the user

    """

    def __init__(self, user_id: int = 0, user_full_info: UserFullInfo = None) -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.user_full_info: Union[UserFullInfo, None] = user_full_info
        r"""New full information about the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateUserFullInfo"]:
        return "updateUserFullInfo"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "user_full_info": self.user_full_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateUserFullInfo", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.user_full_info = data.get("user_full_info", None)

        return data_class


class UpdateBasicGroupFullInfo(TlObject, Update):
    r"""Some data in basicGroupFullInfo has been changed

    Parameters:
        basic_group_id (:class:`int`):
            Identifier of a basic group

        basic_group_full_info (:class:`"types.BasicGroupFullInfo"`):
            New full information about the group

    """

    def __init__(
        self, basic_group_id: int = 0, basic_group_full_info: BasicGroupFullInfo = None
    ) -> None:
        self.basic_group_id: int = int(basic_group_id)
        r"""Identifier of a basic group"""
        self.basic_group_full_info: Union[BasicGroupFullInfo, None] = (
            basic_group_full_info
        )
        r"""New full information about the group"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateBasicGroupFullInfo"]:
        return "updateBasicGroupFullInfo"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "basic_group_id": self.basic_group_id,
            "basic_group_full_info": self.basic_group_full_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateBasicGroupFullInfo", None]:
        if data:
            data_class = cls()
            data_class.basic_group_id = int(data.get("basic_group_id", 0))
            data_class.basic_group_full_info = data.get("basic_group_full_info", None)

        return data_class


class UpdateSupergroupFullInfo(TlObject, Update):
    r"""Some data in supergroupFullInfo has been changed

    Parameters:
        supergroup_id (:class:`int`):
            Identifier of the supergroup or channel

        supergroup_full_info (:class:`"types.SupergroupFullInfo"`):
            New full information about the supergroup

    """

    def __init__(
        self, supergroup_id: int = 0, supergroup_full_info: SupergroupFullInfo = None
    ) -> None:
        self.supergroup_id: int = int(supergroup_id)
        r"""Identifier of the supergroup or channel"""
        self.supergroup_full_info: Union[SupergroupFullInfo, None] = (
            supergroup_full_info
        )
        r"""New full information about the supergroup"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSupergroupFullInfo"]:
        return "updateSupergroupFullInfo"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "supergroup_id": self.supergroup_id,
            "supergroup_full_info": self.supergroup_full_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSupergroupFullInfo", None]:
        if data:
            data_class = cls()
            data_class.supergroup_id = int(data.get("supergroup_id", 0))
            data_class.supergroup_full_info = data.get("supergroup_full_info", None)

        return data_class


class UpdateServiceNotification(TlObject, Update):
    r"""A service notification from the server was received\. Upon receiving this the application must show a popup with the content of the notification

    Parameters:
        type (:class:`str`):
            Notification type\. If type begins with \"AUTH\_KEY\_DROP\_\", then two buttons \"Cancel\" and \"Log out\" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method

        content (:class:`"types.MessageContent"`):
            Notification content

    """

    def __init__(self, type: str = "", content: MessageContent = None) -> None:
        self.type: Union[str, None] = type
        r"""Notification type\. If type begins with \"AUTH\_KEY\_DROP\_\", then two buttons \"Cancel\" and \"Log out\" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method"""
        self.content: Union[
            MessageText,
            MessageAnimation,
            MessageAudio,
            MessageDocument,
            MessagePaidMedia,
            MessagePhoto,
            MessageSticker,
            MessageVideo,
            MessageVideoNote,
            MessageVoiceNote,
            MessageExpiredPhoto,
            MessageExpiredVideo,
            MessageExpiredVideoNote,
            MessageExpiredVoiceNote,
            MessageLocation,
            MessageVenue,
            MessageContact,
            MessageAnimatedEmoji,
            MessageDice,
            MessageGame,
            MessagePoll,
            MessageStory,
            MessageInvoice,
            MessageCall,
            MessageVideoChatScheduled,
            MessageVideoChatStarted,
            MessageVideoChatEnded,
            MessageInviteVideoChatParticipants,
            MessageBasicGroupChatCreate,
            MessageSupergroupChatCreate,
            MessageChatChangeTitle,
            MessageChatChangePhoto,
            MessageChatDeletePhoto,
            MessageChatAddMembers,
            MessageChatJoinByLink,
            MessageChatJoinByRequest,
            MessageChatDeleteMember,
            MessageChatUpgradeTo,
            MessageChatUpgradeFrom,
            MessagePinMessage,
            MessageScreenshotTaken,
            MessageChatSetBackground,
            MessageChatSetTheme,
            MessageChatSetMessageAutoDeleteTime,
            MessageChatBoost,
            MessageForumTopicCreated,
            MessageForumTopicEdited,
            MessageForumTopicIsClosedToggled,
            MessageForumTopicIsHiddenToggled,
            MessageSuggestProfilePhoto,
            MessageCustomServiceAction,
            MessageGameScore,
            MessagePaymentSuccessful,
            MessagePaymentSuccessfulBot,
            MessagePaymentRefunded,
            MessageGiftedPremium,
            MessagePremiumGiftCode,
            MessageGiveawayCreated,
            MessageGiveaway,
            MessageGiveawayCompleted,
            MessageGiveawayWinners,
            MessageGiftedStars,
            MessageGiveawayPrizeStars,
            MessageGift,
            MessageUpgradedGift,
            MessageRefundedUpgradedGift,
            MessagePaidMessagesRefunded,
            MessagePaidMessagePriceChanged,
            MessageContactRegistered,
            MessageUsersShared,
            MessageChatShared,
            MessageBotWriteAccessAllowed,
            MessageWebAppDataSent,
            MessageWebAppDataReceived,
            MessagePassportDataSent,
            MessagePassportDataReceived,
            MessageProximityAlertTriggered,
            MessageUnsupported,
            None,
        ] = content
        r"""Notification content"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateServiceNotification"]:
        return "updateServiceNotification"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "type": self.type, "content": self.content}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateServiceNotification", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", "")
            data_class.content = data.get("content", None)

        return data_class


class UpdateFile(TlObject, Update):
    r"""Information about a file was updated

    Parameters:
        file (:class:`"types.File"`):
            New data about the file

    """

    def __init__(self, file: File = None) -> None:
        self.file: Union[File, None] = file
        r"""New data about the file"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFile"]:
        return "updateFile"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file": self.file}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFile", None]:
        if data:
            data_class = cls()
            data_class.file = data.get("file", None)

        return data_class


class UpdateFileGenerationStart(TlObject, Update):
    r"""The file generation process needs to be started by the application\. Use setFileGenerationProgress and finishFileGeneration to generate the file

    Parameters:
        generation_id (:class:`int`):
            Unique identifier for the generation process

        original_path (:class:`str`):
            The original path specified by the application in inputFileGenerated

        destination_path (:class:`str`):
            The path to a file that must be created and where the new file must be generated by the application\. If the application has no access to the path, it can use writeGeneratedFilePart to generate the file

        conversion (:class:`str`):
            If the conversion is \"\#url\#\" than original\_path contains an HTTP/HTTPS URL of a file that must be downloaded by the application\. Otherwise, this is the conversion specified by the application in inputFileGenerated

    """

    def __init__(
        self,
        generation_id: int = 0,
        original_path: str = "",
        destination_path: str = "",
        conversion: str = "",
    ) -> None:
        self.generation_id: int = int(generation_id)
        r"""Unique identifier for the generation process"""
        self.original_path: Union[str, None] = original_path
        r"""The original path specified by the application in inputFileGenerated"""
        self.destination_path: Union[str, None] = destination_path
        r"""The path to a file that must be created and where the new file must be generated by the application\. If the application has no access to the path, it can use writeGeneratedFilePart to generate the file"""
        self.conversion: Union[str, None] = conversion
        r"""If the conversion is \"\#url\#\" than original\_path contains an HTTP/HTTPS URL of a file that must be downloaded by the application\. Otherwise, this is the conversion specified by the application in inputFileGenerated"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFileGenerationStart"]:
        return "updateFileGenerationStart"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "generation_id": self.generation_id,
            "original_path": self.original_path,
            "destination_path": self.destination_path,
            "conversion": self.conversion,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFileGenerationStart", None]:
        if data:
            data_class = cls()
            data_class.generation_id = int(data.get("generation_id", 0))
            data_class.original_path = data.get("original_path", "")
            data_class.destination_path = data.get("destination_path", "")
            data_class.conversion = data.get("conversion", "")

        return data_class


class UpdateFileGenerationStop(TlObject, Update):
    r"""File generation is no longer needed

    Parameters:
        generation_id (:class:`int`):
            Unique identifier for the generation process

    """

    def __init__(self, generation_id: int = 0) -> None:
        self.generation_id: int = int(generation_id)
        r"""Unique identifier for the generation process"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFileGenerationStop"]:
        return "updateFileGenerationStop"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "generation_id": self.generation_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFileGenerationStop", None]:
        if data:
            data_class = cls()
            data_class.generation_id = int(data.get("generation_id", 0))

        return data_class


class UpdateFileDownloads(TlObject, Update):
    r"""The state of the file download list has changed

    Parameters:
        total_size (:class:`int`):
            Total size of files in the file download list, in bytes

        total_count (:class:`int`):
            Total number of files in the file download list

        downloaded_size (:class:`int`):
            Total downloaded size of files in the file download list, in bytes

    """

    def __init__(
        self, total_size: int = 0, total_count: int = 0, downloaded_size: int = 0
    ) -> None:
        self.total_size: int = int(total_size)
        r"""Total size of files in the file download list, in bytes"""
        self.total_count: int = int(total_count)
        r"""Total number of files in the file download list"""
        self.downloaded_size: int = int(downloaded_size)
        r"""Total downloaded size of files in the file download list, in bytes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFileDownloads"]:
        return "updateFileDownloads"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "total_size": self.total_size,
            "total_count": self.total_count,
            "downloaded_size": self.downloaded_size,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFileDownloads", None]:
        if data:
            data_class = cls()
            data_class.total_size = int(data.get("total_size", 0))
            data_class.total_count = int(data.get("total_count", 0))
            data_class.downloaded_size = int(data.get("downloaded_size", 0))

        return data_class


class UpdateFileAddedToDownloads(TlObject, Update):
    r"""A file was added to the file download list\. This update is sent only after file download list is loaded for the first time

    Parameters:
        file_download (:class:`"types.FileDownload"`):
            The added file download

        counts (:class:`"types.DownloadedFileCounts"`):
            New number of being downloaded and recently downloaded files found

    """

    def __init__(
        self, file_download: FileDownload = None, counts: DownloadedFileCounts = None
    ) -> None:
        self.file_download: Union[FileDownload, None] = file_download
        r"""The added file download"""
        self.counts: Union[DownloadedFileCounts, None] = counts
        r"""New number of being downloaded and recently downloaded files found"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFileAddedToDownloads"]:
        return "updateFileAddedToDownloads"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "file_download": self.file_download,
            "counts": self.counts,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFileAddedToDownloads", None]:
        if data:
            data_class = cls()
            data_class.file_download = data.get("file_download", None)
            data_class.counts = data.get("counts", None)

        return data_class


class UpdateFileDownload(TlObject, Update):
    r"""A file download was changed\. This update is sent only after file download list is loaded for the first time

    Parameters:
        file_id (:class:`int`):
            File identifier

        complete_date (:class:`int`):
            Point in time \(Unix timestamp\) when the file downloading was completed; 0 if the file downloading isn't completed

        is_paused (:class:`bool`):
            True, if downloading of the file is paused

        counts (:class:`"types.DownloadedFileCounts"`):
            New number of being downloaded and recently downloaded files found

    """

    def __init__(
        self,
        file_id: int = 0,
        complete_date: int = 0,
        is_paused: bool = False,
        counts: DownloadedFileCounts = None,
    ) -> None:
        self.file_id: int = int(file_id)
        r"""File identifier"""
        self.complete_date: int = int(complete_date)
        r"""Point in time \(Unix timestamp\) when the file downloading was completed; 0 if the file downloading isn't completed"""
        self.is_paused: bool = bool(is_paused)
        r"""True, if downloading of the file is paused"""
        self.counts: Union[DownloadedFileCounts, None] = counts
        r"""New number of being downloaded and recently downloaded files found"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFileDownload"]:
        return "updateFileDownload"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "file_id": self.file_id,
            "complete_date": self.complete_date,
            "is_paused": self.is_paused,
            "counts": self.counts,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFileDownload", None]:
        if data:
            data_class = cls()
            data_class.file_id = int(data.get("file_id", 0))
            data_class.complete_date = int(data.get("complete_date", 0))
            data_class.is_paused = data.get("is_paused", False)
            data_class.counts = data.get("counts", None)

        return data_class


class UpdateFileRemovedFromDownloads(TlObject, Update):
    r"""A file was removed from the file download list\. This update is sent only after file download list is loaded for the first time

    Parameters:
        file_id (:class:`int`):
            File identifier

        counts (:class:`"types.DownloadedFileCounts"`):
            New number of being downloaded and recently downloaded files found

    """

    def __init__(self, file_id: int = 0, counts: DownloadedFileCounts = None) -> None:
        self.file_id: int = int(file_id)
        r"""File identifier"""
        self.counts: Union[DownloadedFileCounts, None] = counts
        r"""New number of being downloaded and recently downloaded files found"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFileRemovedFromDownloads"]:
        return "updateFileRemovedFromDownloads"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "file_id": self.file_id, "counts": self.counts}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFileRemovedFromDownloads", None]:
        if data:
            data_class = cls()
            data_class.file_id = int(data.get("file_id", 0))
            data_class.counts = data.get("counts", None)

        return data_class


class UpdateApplicationVerificationRequired(TlObject, Update):
    r"""A request can't be completed unless application verification is performed; for official mobile applications only\. The method setApplicationVerificationToken must be called once the verification is completed or failed

    Parameters:
        verification_id (:class:`int`):
            Unique identifier for the verification process

        nonce (:class:`str`):
            Unique base64url\-encoded nonce for the classic Play Integrity verification \(https://developer\.android\.com/google/play/integrity/classic\) for Android, or a unique string to compare with verify\_nonce field from a push notification for iOS

        cloud_project_number (:class:`int`):
            Cloud project number to pass to the Play Integrity API on Android

    """

    def __init__(
        self, verification_id: int = 0, nonce: str = "", cloud_project_number: int = 0
    ) -> None:
        self.verification_id: int = int(verification_id)
        r"""Unique identifier for the verification process"""
        self.nonce: Union[str, None] = nonce
        r"""Unique base64url\-encoded nonce for the classic Play Integrity verification \(https://developer\.android\.com/google/play/integrity/classic\) for Android, or a unique string to compare with verify\_nonce field from a push notification for iOS"""
        self.cloud_project_number: int = int(cloud_project_number)
        r"""Cloud project number to pass to the Play Integrity API on Android"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateApplicationVerificationRequired"]:
        return "updateApplicationVerificationRequired"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "verification_id": self.verification_id,
            "nonce": self.nonce,
            "cloud_project_number": self.cloud_project_number,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UpdateApplicationVerificationRequired", None]:
        if data:
            data_class = cls()
            data_class.verification_id = int(data.get("verification_id", 0))
            data_class.nonce = data.get("nonce", "")
            data_class.cloud_project_number = int(data.get("cloud_project_number", 0))

        return data_class


class UpdateApplicationRecaptchaVerificationRequired(TlObject, Update):
    r"""A request can't be completed unless reCAPTCHA verification is performed; for official mobile applications only\. The method setApplicationVerificationToken must be called once the verification is completed or failed

    Parameters:
        verification_id (:class:`int`):
            Unique identifier for the verification process

        action (:class:`str`):
            The action for the check

        recaptcha_key_id (:class:`str`):
            Identifier of the reCAPTCHA key

    """

    def __init__(
        self, verification_id: int = 0, action: str = "", recaptcha_key_id: str = ""
    ) -> None:
        self.verification_id: int = int(verification_id)
        r"""Unique identifier for the verification process"""
        self.action: Union[str, None] = action
        r"""The action for the check"""
        self.recaptcha_key_id: Union[str, None] = recaptcha_key_id
        r"""Identifier of the reCAPTCHA key"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateApplicationRecaptchaVerificationRequired"]:
        return "updateApplicationRecaptchaVerificationRequired"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "verification_id": self.verification_id,
            "action": self.action,
            "recaptcha_key_id": self.recaptcha_key_id,
        }

    @classmethod
    def from_dict(
        cls, data: dict
    ) -> Union["UpdateApplicationRecaptchaVerificationRequired", None]:
        if data:
            data_class = cls()
            data_class.verification_id = int(data.get("verification_id", 0))
            data_class.action = data.get("action", "")
            data_class.recaptcha_key_id = data.get("recaptcha_key_id", "")

        return data_class


class UpdateCall(TlObject, Update):
    r"""New call was created or information about a call was updated

    Parameters:
        call (:class:`"types.Call"`):
            New data about a call

    """

    def __init__(self, call: Call = None) -> None:
        self.call: Union[Call, None] = call
        r"""New data about a call"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateCall"]:
        return "updateCall"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "call": self.call}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateCall", None]:
        if data:
            data_class = cls()
            data_class.call = data.get("call", None)

        return data_class


class UpdateGroupCall(TlObject, Update):
    r"""Information about a group call was updated

    Parameters:
        group_call (:class:`"types.GroupCall"`):
            New data about a group call

    """

    def __init__(self, group_call: GroupCall = None) -> None:
        self.group_call: Union[GroupCall, None] = group_call
        r"""New data about a group call"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateGroupCall"]:
        return "updateGroupCall"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "group_call": self.group_call}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateGroupCall", None]:
        if data:
            data_class = cls()
            data_class.group_call = data.get("group_call", None)

        return data_class


class UpdateGroupCallParticipant(TlObject, Update):
    r"""Information about a group call participant was changed\. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined

    Parameters:
        group_call_id (:class:`int`):
            Identifier of group call

        participant (:class:`"types.GroupCallParticipant"`):
            New data about a participant

    """

    def __init__(
        self, group_call_id: int = 0, participant: GroupCallParticipant = None
    ) -> None:
        self.group_call_id: int = int(group_call_id)
        r"""Identifier of group call"""
        self.participant: Union[GroupCallParticipant, None] = participant
        r"""New data about a participant"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateGroupCallParticipant"]:
        return "updateGroupCallParticipant"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "group_call_id": self.group_call_id,
            "participant": self.participant,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateGroupCallParticipant", None]:
        if data:
            data_class = cls()
            data_class.group_call_id = int(data.get("group_call_id", 0))
            data_class.participant = data.get("participant", None)

        return data_class


class UpdateNewCallSignalingData(TlObject, Update):
    r"""New call signaling data arrived

    Parameters:
        call_id (:class:`int`):
            The call identifier

        data (:class:`bytes`):
            The data

    """

    def __init__(self, call_id: int = 0, data: bytes = b"") -> None:
        self.call_id: int = int(call_id)
        r"""The call identifier"""
        self.data: Union[bytes, None] = data
        r"""The data"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewCallSignalingData"]:
        return "updateNewCallSignalingData"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "call_id": self.call_id, "data": self.data}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewCallSignalingData", None]:
        if data:
            data_class = cls()
            data_class.call_id = int(data.get("call_id", 0))
            data_class.data = b64decode(data.get("data", b""))

        return data_class


class UpdateUserPrivacySettingRules(TlObject, Update):
    r"""Some privacy setting rules have been changed

    Parameters:
        setting (:class:`"types.UserPrivacySetting"`):
            The privacy setting

        rules (:class:`"types.UserPrivacySettingRules"`):
            New privacy rules

    """

    def __init__(
        self, setting: UserPrivacySetting = None, rules: UserPrivacySettingRules = None
    ) -> None:
        self.setting: Union[
            UserPrivacySettingShowStatus,
            UserPrivacySettingShowProfilePhoto,
            UserPrivacySettingShowLinkInForwardedMessages,
            UserPrivacySettingShowPhoneNumber,
            UserPrivacySettingShowBio,
            UserPrivacySettingShowBirthdate,
            UserPrivacySettingAllowChatInvites,
            UserPrivacySettingAllowCalls,
            UserPrivacySettingAllowPeerToPeerCalls,
            UserPrivacySettingAllowFindingByPhoneNumber,
            UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages,
            UserPrivacySettingAutosaveGifts,
            UserPrivacySettingAllowUnpaidMessages,
            None,
        ] = setting
        r"""The privacy setting"""
        self.rules: Union[UserPrivacySettingRules, None] = rules
        r"""New privacy rules"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateUserPrivacySettingRules"]:
        return "updateUserPrivacySettingRules"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "setting": self.setting, "rules": self.rules}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateUserPrivacySettingRules", None]:
        if data:
            data_class = cls()
            data_class.setting = data.get("setting", None)
            data_class.rules = data.get("rules", None)

        return data_class


class UpdateUnreadMessageCount(TlObject, Update):
    r"""Number of unread messages in a chat list has changed\. This update is sent only if the message database is used

    Parameters:
        chat_list (:class:`"types.ChatList"`):
            The chat list with changed number of unread messages

        unread_count (:class:`int`):
            Total number of unread messages

        unread_unmuted_count (:class:`int`):
            Total number of unread messages in unmuted chats

    """

    def __init__(
        self,
        chat_list: ChatList = None,
        unread_count: int = 0,
        unread_unmuted_count: int = 0,
    ) -> None:
        self.chat_list: Union[ChatListMain, ChatListArchive, ChatListFolder, None] = (
            chat_list
        )
        r"""The chat list with changed number of unread messages"""
        self.unread_count: int = int(unread_count)
        r"""Total number of unread messages"""
        self.unread_unmuted_count: int = int(unread_unmuted_count)
        r"""Total number of unread messages in unmuted chats"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateUnreadMessageCount"]:
        return "updateUnreadMessageCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_list": self.chat_list,
            "unread_count": self.unread_count,
            "unread_unmuted_count": self.unread_unmuted_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateUnreadMessageCount", None]:
        if data:
            data_class = cls()
            data_class.chat_list = data.get("chat_list", None)
            data_class.unread_count = int(data.get("unread_count", 0))
            data_class.unread_unmuted_count = int(data.get("unread_unmuted_count", 0))

        return data_class


class UpdateUnreadChatCount(TlObject, Update):
    r"""Number of unread chats, i\.e\. with unread messages or marked as unread, has changed\. This update is sent only if the message database is used

    Parameters:
        chat_list (:class:`"types.ChatList"`):
            The chat list with changed number of unread messages

        total_count (:class:`int`):
            Approximate total number of chats in the chat list

        unread_count (:class:`int`):
            Total number of unread chats

        unread_unmuted_count (:class:`int`):
            Total number of unread unmuted chats

        marked_as_unread_count (:class:`int`):
            Total number of chats marked as unread

        marked_as_unread_unmuted_count (:class:`int`):
            Total number of unmuted chats marked as unread

    """

    def __init__(
        self,
        chat_list: ChatList = None,
        total_count: int = 0,
        unread_count: int = 0,
        unread_unmuted_count: int = 0,
        marked_as_unread_count: int = 0,
        marked_as_unread_unmuted_count: int = 0,
    ) -> None:
        self.chat_list: Union[ChatListMain, ChatListArchive, ChatListFolder, None] = (
            chat_list
        )
        r"""The chat list with changed number of unread messages"""
        self.total_count: int = int(total_count)
        r"""Approximate total number of chats in the chat list"""
        self.unread_count: int = int(unread_count)
        r"""Total number of unread chats"""
        self.unread_unmuted_count: int = int(unread_unmuted_count)
        r"""Total number of unread unmuted chats"""
        self.marked_as_unread_count: int = int(marked_as_unread_count)
        r"""Total number of chats marked as unread"""
        self.marked_as_unread_unmuted_count: int = int(marked_as_unread_unmuted_count)
        r"""Total number of unmuted chats marked as unread"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateUnreadChatCount"]:
        return "updateUnreadChatCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_list": self.chat_list,
            "total_count": self.total_count,
            "unread_count": self.unread_count,
            "unread_unmuted_count": self.unread_unmuted_count,
            "marked_as_unread_count": self.marked_as_unread_count,
            "marked_as_unread_unmuted_count": self.marked_as_unread_unmuted_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateUnreadChatCount", None]:
        if data:
            data_class = cls()
            data_class.chat_list = data.get("chat_list", None)
            data_class.total_count = int(data.get("total_count", 0))
            data_class.unread_count = int(data.get("unread_count", 0))
            data_class.unread_unmuted_count = int(data.get("unread_unmuted_count", 0))
            data_class.marked_as_unread_count = int(
                data.get("marked_as_unread_count", 0)
            )
            data_class.marked_as_unread_unmuted_count = int(
                data.get("marked_as_unread_unmuted_count", 0)
            )

        return data_class


class UpdateStory(TlObject, Update):
    r"""A story was changed

    Parameters:
        story (:class:`"types.Story"`):
            The new information about the story

    """

    def __init__(self, story: Story = None) -> None:
        self.story: Union[Story, None] = story
        r"""The new information about the story"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStory"]:
        return "updateStory"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "story": self.story}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStory", None]:
        if data:
            data_class = cls()
            data_class.story = data.get("story", None)

        return data_class


class UpdateStoryDeleted(TlObject, Update):
    r"""A story became inaccessible

    Parameters:
        story_sender_chat_id (:class:`int`):
            Identifier of the chat that posted the story

        story_id (:class:`int`):
            Story identifier

    """

    def __init__(self, story_sender_chat_id: int = 0, story_id: int = 0) -> None:
        self.story_sender_chat_id: int = int(story_sender_chat_id)
        r"""Identifier of the chat that posted the story"""
        self.story_id: int = int(story_id)
        r"""Story identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStoryDeleted"]:
        return "updateStoryDeleted"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_sender_chat_id": self.story_sender_chat_id,
            "story_id": self.story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStoryDeleted", None]:
        if data:
            data_class = cls()
            data_class.story_sender_chat_id = int(data.get("story_sender_chat_id", 0))
            data_class.story_id = int(data.get("story_id", 0))

        return data_class


class UpdateStorySendSucceeded(TlObject, Update):
    r"""A story has been successfully sent

    Parameters:
        story (:class:`"types.Story"`):
            The sent story

        old_story_id (:class:`int`):
            The previous temporary story identifier

    """

    def __init__(self, story: Story = None, old_story_id: int = 0) -> None:
        self.story: Union[Story, None] = story
        r"""The sent story"""
        self.old_story_id: int = int(old_story_id)
        r"""The previous temporary story identifier"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStorySendSucceeded"]:
        return "updateStorySendSucceeded"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story": self.story,
            "old_story_id": self.old_story_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStorySendSucceeded", None]:
        if data:
            data_class = cls()
            data_class.story = data.get("story", None)
            data_class.old_story_id = int(data.get("old_story_id", 0))

        return data_class


class UpdateStorySendFailed(TlObject, Update):
    r"""A story failed to send\. If the story sending is canceled, then updateStoryDeleted will be received instead of this update

    Parameters:
        story (:class:`"types.Story"`):
            The failed to send story

        error (:class:`"types.Error"`):
            The cause of the story sending failure

        error_type (:class:`"types.CanSendStoryResult"`):
            Type of the error; may be null if unknown

    """

    def __init__(
        self,
        story: Story = None,
        error: Error = None,
        error_type: CanSendStoryResult = None,
    ) -> None:
        self.story: Union[Story, None] = story
        r"""The failed to send story"""
        self.error: Union[Error, None] = error
        r"""The cause of the story sending failure"""
        self.error_type: Union[
            CanSendStoryResultOk,
            CanSendStoryResultPremiumNeeded,
            CanSendStoryResultBoostNeeded,
            CanSendStoryResultActiveStoryLimitExceeded,
            CanSendStoryResultWeeklyLimitExceeded,
            CanSendStoryResultMonthlyLimitExceeded,
            None,
        ] = error_type
        r"""Type of the error; may be null if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStorySendFailed"]:
        return "updateStorySendFailed"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story": self.story,
            "error": self.error,
            "error_type": self.error_type,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStorySendFailed", None]:
        if data:
            data_class = cls()
            data_class.story = data.get("story", None)
            data_class.error = data.get("error", None)
            data_class.error_type = data.get("error_type", None)

        return data_class


class UpdateChatActiveStories(TlObject, Update):
    r"""The list of active stories posted by a specific chat has changed

    Parameters:
        active_stories (:class:`"types.ChatActiveStories"`):
            The new list of active stories

    """

    def __init__(self, active_stories: ChatActiveStories = None) -> None:
        self.active_stories: Union[ChatActiveStories, None] = active_stories
        r"""The new list of active stories"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatActiveStories"]:
        return "updateChatActiveStories"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "active_stories": self.active_stories}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatActiveStories", None]:
        if data:
            data_class = cls()
            data_class.active_stories = data.get("active_stories", None)

        return data_class


class UpdateStoryListChatCount(TlObject, Update):
    r"""Number of chats in a story list has changed

    Parameters:
        story_list (:class:`"types.StoryList"`):
            The story list

        chat_count (:class:`int`):
            Approximate total number of chats with active stories in the list

    """

    def __init__(self, story_list: StoryList = None, chat_count: int = 0) -> None:
        self.story_list: Union[StoryListMain, StoryListArchive, None] = story_list
        r"""The story list"""
        self.chat_count: int = int(chat_count)
        r"""Approximate total number of chats with active stories in the list"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStoryListChatCount"]:
        return "updateStoryListChatCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "story_list": self.story_list,
            "chat_count": self.chat_count,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStoryListChatCount", None]:
        if data:
            data_class = cls()
            data_class.story_list = data.get("story_list", None)
            data_class.chat_count = int(data.get("chat_count", 0))

        return data_class


class UpdateStoryStealthMode(TlObject, Update):
    r"""Story stealth mode settings have changed

    Parameters:
        active_until_date (:class:`int`):
            Point in time \(Unix timestamp\) until stealth mode is active; 0 if it is disabled

        cooldown_until_date (:class:`int`):
            Point in time \(Unix timestamp\) when stealth mode can be enabled again; 0 if there is no active cooldown

    """

    def __init__(
        self, active_until_date: int = 0, cooldown_until_date: int = 0
    ) -> None:
        self.active_until_date: int = int(active_until_date)
        r"""Point in time \(Unix timestamp\) until stealth mode is active; 0 if it is disabled"""
        self.cooldown_until_date: int = int(cooldown_until_date)
        r"""Point in time \(Unix timestamp\) when stealth mode can be enabled again; 0 if there is no active cooldown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStoryStealthMode"]:
        return "updateStoryStealthMode"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "active_until_date": self.active_until_date,
            "cooldown_until_date": self.cooldown_until_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStoryStealthMode", None]:
        if data:
            data_class = cls()
            data_class.active_until_date = int(data.get("active_until_date", 0))
            data_class.cooldown_until_date = int(data.get("cooldown_until_date", 0))

        return data_class


class UpdateOption(TlObject, Update):
    r"""An option changed its value

    Parameters:
        name (:class:`str`):
            The option name

        value (:class:`"types.OptionValue"`):
            The new option value

    """

    def __init__(self, name: str = "", value: OptionValue = None) -> None:
        self.name: Union[str, None] = name
        r"""The option name"""
        self.value: Union[
            OptionValueBoolean,
            OptionValueEmpty,
            OptionValueInteger,
            OptionValueString,
            None,
        ] = value
        r"""The new option value"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateOption"]:
        return "updateOption"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "name": self.name, "value": self.value}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateOption", None]:
        if data:
            data_class = cls()
            data_class.name = data.get("name", "")
            data_class.value = data.get("value", None)

        return data_class


class UpdateStickerSet(TlObject, Update):
    r"""A sticker set has changed

    Parameters:
        sticker_set (:class:`"types.StickerSet"`):
            The sticker set

    """

    def __init__(self, sticker_set: StickerSet = None) -> None:
        self.sticker_set: Union[StickerSet, None] = sticker_set
        r"""The sticker set"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStickerSet"]:
        return "updateStickerSet"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sticker_set": self.sticker_set}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStickerSet", None]:
        if data:
            data_class = cls()
            data_class.sticker_set = data.get("sticker_set", None)

        return data_class


class UpdateInstalledStickerSets(TlObject, Update):
    r"""The list of installed sticker sets was updated

    Parameters:
        sticker_type (:class:`"types.StickerType"`):
            Type of the affected stickers

        sticker_set_ids (:class:`List[int]`):
            The new list of installed ordinary sticker sets

    """

    def __init__(
        self, sticker_type: StickerType = None, sticker_set_ids: List[int] = None
    ) -> None:
        self.sticker_type: Union[
            StickerTypeRegular, StickerTypeMask, StickerTypeCustomEmoji, None
        ] = sticker_type
        r"""Type of the affected stickers"""
        self.sticker_set_ids: List[int] = sticker_set_ids or []
        r"""The new list of installed ordinary sticker sets"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateInstalledStickerSets"]:
        return "updateInstalledStickerSets"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker_type": self.sticker_type,
            "sticker_set_ids": self.sticker_set_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateInstalledStickerSets", None]:
        if data:
            data_class = cls()
            data_class.sticker_type = data.get("sticker_type", None)
            data_class.sticker_set_ids = data.get("sticker_set_ids", None)

        return data_class


class UpdateTrendingStickerSets(TlObject, Update):
    r"""The list of trending sticker sets was updated or some of them were viewed

    Parameters:
        sticker_type (:class:`"types.StickerType"`):
            Type of the affected stickers

        sticker_sets (:class:`"types.TrendingStickerSets"`):
            The prefix of the list of trending sticker sets with the newest trending sticker sets

    """

    def __init__(
        self, sticker_type: StickerType = None, sticker_sets: TrendingStickerSets = None
    ) -> None:
        self.sticker_type: Union[
            StickerTypeRegular, StickerTypeMask, StickerTypeCustomEmoji, None
        ] = sticker_type
        r"""Type of the affected stickers"""
        self.sticker_sets: Union[TrendingStickerSets, None] = sticker_sets
        r"""The prefix of the list of trending sticker sets with the newest trending sticker sets"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateTrendingStickerSets"]:
        return "updateTrendingStickerSets"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sticker_type": self.sticker_type,
            "sticker_sets": self.sticker_sets,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateTrendingStickerSets", None]:
        if data:
            data_class = cls()
            data_class.sticker_type = data.get("sticker_type", None)
            data_class.sticker_sets = data.get("sticker_sets", None)

        return data_class


class UpdateRecentStickers(TlObject, Update):
    r"""The list of recently used stickers was updated

    Parameters:
        is_attached (:class:`bool`):
            True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated

        sticker_ids (:class:`List[int]`):
            The new list of file identifiers of recently used stickers

    """

    def __init__(
        self, is_attached: bool = False, sticker_ids: List[int] = None
    ) -> None:
        self.is_attached: bool = bool(is_attached)
        r"""True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated"""
        self.sticker_ids: List[int] = sticker_ids or []
        r"""The new list of file identifiers of recently used stickers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateRecentStickers"]:
        return "updateRecentStickers"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_attached": self.is_attached,
            "sticker_ids": self.sticker_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateRecentStickers", None]:
        if data:
            data_class = cls()
            data_class.is_attached = data.get("is_attached", False)
            data_class.sticker_ids = data.get("sticker_ids", None)

        return data_class


class UpdateFavoriteStickers(TlObject, Update):
    r"""The list of favorite stickers was updated

    Parameters:
        sticker_ids (:class:`List[int]`):
            The new list of file identifiers of favorite stickers

    """

    def __init__(self, sticker_ids: List[int] = None) -> None:
        self.sticker_ids: List[int] = sticker_ids or []
        r"""The new list of file identifiers of favorite stickers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFavoriteStickers"]:
        return "updateFavoriteStickers"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "sticker_ids": self.sticker_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFavoriteStickers", None]:
        if data:
            data_class = cls()
            data_class.sticker_ids = data.get("sticker_ids", None)

        return data_class


class UpdateSavedAnimations(TlObject, Update):
    r"""The list of saved animations was updated

    Parameters:
        animation_ids (:class:`List[int]`):
            The new list of file identifiers of saved animations

    """

    def __init__(self, animation_ids: List[int] = None) -> None:
        self.animation_ids: List[int] = animation_ids or []
        r"""The new list of file identifiers of saved animations"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSavedAnimations"]:
        return "updateSavedAnimations"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "animation_ids": self.animation_ids}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSavedAnimations", None]:
        if data:
            data_class = cls()
            data_class.animation_ids = data.get("animation_ids", None)

        return data_class


class UpdateSavedNotificationSounds(TlObject, Update):
    r"""The list of saved notification sounds was updated\. This update may not be sent until information about a notification sound was requested for the first time

    Parameters:
        notification_sound_ids (:class:`List[int]`):
            The new list of identifiers of saved notification sounds

    """

    def __init__(self, notification_sound_ids: List[int] = None) -> None:
        self.notification_sound_ids: List[int] = notification_sound_ids or []
        r"""The new list of identifiers of saved notification sounds"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSavedNotificationSounds"]:
        return "updateSavedNotificationSounds"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "notification_sound_ids": self.notification_sound_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSavedNotificationSounds", None]:
        if data:
            data_class = cls()
            data_class.notification_sound_ids = data.get("notification_sound_ids", None)

        return data_class


class UpdateDefaultBackground(TlObject, Update):
    r"""The default background has changed

    Parameters:
        for_dark_theme (:class:`bool`):
            True, if default background for dark theme has changed

        background (:class:`"types.Background"`):
            The new default background; may be null

    """

    def __init__(
        self, for_dark_theme: bool = False, background: Background = None
    ) -> None:
        self.for_dark_theme: bool = bool(for_dark_theme)
        r"""True, if default background for dark theme has changed"""
        self.background: Union[Background, None] = background
        r"""The new default background; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateDefaultBackground"]:
        return "updateDefaultBackground"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "for_dark_theme": self.for_dark_theme,
            "background": self.background,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateDefaultBackground", None]:
        if data:
            data_class = cls()
            data_class.for_dark_theme = data.get("for_dark_theme", False)
            data_class.background = data.get("background", None)

        return data_class


class UpdateChatThemes(TlObject, Update):
    r"""The list of available chat themes has changed

    Parameters:
        chat_themes (:class:`List["types.ChatTheme"]`):
            The new list of chat themes

    """

    def __init__(self, chat_themes: List[ChatTheme] = None) -> None:
        self.chat_themes: List[ChatTheme] = chat_themes or []
        r"""The new list of chat themes"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatThemes"]:
        return "updateChatThemes"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_themes": self.chat_themes}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatThemes", None]:
        if data:
            data_class = cls()
            data_class.chat_themes = data.get("chat_themes", None)

        return data_class


class UpdateAccentColors(TlObject, Update):
    r"""The list of supported accent colors has changed

    Parameters:
        colors (:class:`List["types.AccentColor"]`):
            Information about supported colors; colors with identifiers 0 \(red\), 1 \(orange\), 2 \(purple/violet\), 3 \(green\), 4 \(cyan\), 5 \(blue\), 6 \(pink\) must always be supported and aren't included in the list\. The exact colors for the accent colors with identifiers 0\-6 must be taken from the app theme

        available_accent_color_ids (:class:`List[int]`):
            The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor\. The colors must be shown in the specified order

    """

    def __init__(
        self,
        colors: List[AccentColor] = None,
        available_accent_color_ids: List[int] = None,
    ) -> None:
        self.colors: List[AccentColor] = colors or []
        r"""Information about supported colors; colors with identifiers 0 \(red\), 1 \(orange\), 2 \(purple/violet\), 3 \(green\), 4 \(cyan\), 5 \(blue\), 6 \(pink\) must always be supported and aren't included in the list\. The exact colors for the accent colors with identifiers 0\-6 must be taken from the app theme"""
        self.available_accent_color_ids: List[int] = available_accent_color_ids or []
        r"""The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor\. The colors must be shown in the specified order"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateAccentColors"]:
        return "updateAccentColors"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "colors": self.colors,
            "available_accent_color_ids": self.available_accent_color_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateAccentColors", None]:
        if data:
            data_class = cls()
            data_class.colors = data.get("colors", None)
            data_class.available_accent_color_ids = data.get(
                "available_accent_color_ids", None
            )

        return data_class


class UpdateProfileAccentColors(TlObject, Update):
    r"""The list of supported accent colors for user profiles has changed

    Parameters:
        colors (:class:`List["types.ProfileAccentColor"]`):
            Information about supported colors

        available_accent_color_ids (:class:`List[int]`):
            The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor\. The colors must be shown in the specified order

    """

    def __init__(
        self,
        colors: List[ProfileAccentColor] = None,
        available_accent_color_ids: List[int] = None,
    ) -> None:
        self.colors: List[ProfileAccentColor] = colors or []
        r"""Information about supported colors"""
        self.available_accent_color_ids: List[int] = available_accent_color_ids or []
        r"""The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor\. The colors must be shown in the specified order"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateProfileAccentColors"]:
        return "updateProfileAccentColors"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "colors": self.colors,
            "available_accent_color_ids": self.available_accent_color_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateProfileAccentColors", None]:
        if data:
            data_class = cls()
            data_class.colors = data.get("colors", None)
            data_class.available_accent_color_ids = data.get(
                "available_accent_color_ids", None
            )

        return data_class


class UpdateLanguagePackStrings(TlObject, Update):
    r"""Some language pack strings have been updated

    Parameters:
        localization_target (:class:`str`):
            Localization target to which the language pack belongs

        language_pack_id (:class:`str`):
            Identifier of the updated language pack

        strings (:class:`List["types.LanguagePackString"]`):
            List of changed language pack strings; empty if all strings have changed

    """

    def __init__(
        self,
        localization_target: str = "",
        language_pack_id: str = "",
        strings: List[LanguagePackString] = None,
    ) -> None:
        self.localization_target: Union[str, None] = localization_target
        r"""Localization target to which the language pack belongs"""
        self.language_pack_id: Union[str, None] = language_pack_id
        r"""Identifier of the updated language pack"""
        self.strings: List[LanguagePackString] = strings or []
        r"""List of changed language pack strings; empty if all strings have changed"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateLanguagePackStrings"]:
        return "updateLanguagePackStrings"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "localization_target": self.localization_target,
            "language_pack_id": self.language_pack_id,
            "strings": self.strings,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateLanguagePackStrings", None]:
        if data:
            data_class = cls()
            data_class.localization_target = data.get("localization_target", "")
            data_class.language_pack_id = data.get("language_pack_id", "")
            data_class.strings = data.get("strings", None)

        return data_class


class UpdateConnectionState(TlObject, Update):
    r"""The connection state has changed\. This update must be used only to show a human\-readable description of the connection state

    Parameters:
        state (:class:`"types.ConnectionState"`):
            The new connection state

    """

    def __init__(self, state: ConnectionState = None) -> None:
        self.state: Union[
            ConnectionStateWaitingForNetwork,
            ConnectionStateConnectingToProxy,
            ConnectionStateConnecting,
            ConnectionStateUpdating,
            ConnectionStateReady,
            None,
        ] = state
        r"""The new connection state"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateConnectionState"]:
        return "updateConnectionState"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "state": self.state}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateConnectionState", None]:
        if data:
            data_class = cls()
            data_class.state = data.get("state", None)

        return data_class


class UpdateFreezeState(TlObject, Update):
    r"""The freeze state of the current user's account has changed

    Parameters:
        is_frozen (:class:`bool`):
            True, if the account is frozen

        freezing_date (:class:`int`):
            Point in time \(Unix timestamp\) when the account was frozen; 0 if the account isn't frozen

        deletion_date (:class:`int`):
            Point in time \(Unix timestamp\) when the account will be deleted and can't be unfrozen; 0 if the account isn't frozen

        appeal_link (:class:`str`):
            The link to open to send an appeal to unfreeze the account

    """

    def __init__(
        self,
        is_frozen: bool = False,
        freezing_date: int = 0,
        deletion_date: int = 0,
        appeal_link: str = "",
    ) -> None:
        self.is_frozen: bool = bool(is_frozen)
        r"""True, if the account is frozen"""
        self.freezing_date: int = int(freezing_date)
        r"""Point in time \(Unix timestamp\) when the account was frozen; 0 if the account isn't frozen"""
        self.deletion_date: int = int(deletion_date)
        r"""Point in time \(Unix timestamp\) when the account will be deleted and can't be unfrozen; 0 if the account isn't frozen"""
        self.appeal_link: Union[str, None] = appeal_link
        r"""The link to open to send an appeal to unfreeze the account"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateFreezeState"]:
        return "updateFreezeState"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "is_frozen": self.is_frozen,
            "freezing_date": self.freezing_date,
            "deletion_date": self.deletion_date,
            "appeal_link": self.appeal_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateFreezeState", None]:
        if data:
            data_class = cls()
            data_class.is_frozen = data.get("is_frozen", False)
            data_class.freezing_date = int(data.get("freezing_date", 0))
            data_class.deletion_date = int(data.get("deletion_date", 0))
            data_class.appeal_link = data.get("appeal_link", "")

        return data_class


class UpdateTermsOfService(TlObject, Update):
    r"""New terms of service must be accepted by the user\. If the terms of service are declined, then the deleteAccount method must be called with the reason \"Decline ToS update\"

    Parameters:
        terms_of_service_id (:class:`str`):
            Identifier of the terms of service

        terms_of_service (:class:`"types.TermsOfService"`):
            The new terms of service

    """

    def __init__(
        self, terms_of_service_id: str = "", terms_of_service: TermsOfService = None
    ) -> None:
        self.terms_of_service_id: Union[str, None] = terms_of_service_id
        r"""Identifier of the terms of service"""
        self.terms_of_service: Union[TermsOfService, None] = terms_of_service
        r"""The new terms of service"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateTermsOfService"]:
        return "updateTermsOfService"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "terms_of_service_id": self.terms_of_service_id,
            "terms_of_service": self.terms_of_service,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateTermsOfService", None]:
        if data:
            data_class = cls()
            data_class.terms_of_service_id = data.get("terms_of_service_id", "")
            data_class.terms_of_service = data.get("terms_of_service", None)

        return data_class


class UpdateUnconfirmedSession(TlObject, Update):
    r"""The first unconfirmed session has changed

    Parameters:
        session (:class:`"types.UnconfirmedSession"`):
            The unconfirmed session; may be null if none

    """

    def __init__(self, session: UnconfirmedSession = None) -> None:
        self.session: Union[UnconfirmedSession, None] = session
        r"""The unconfirmed session; may be null if none"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateUnconfirmedSession"]:
        return "updateUnconfirmedSession"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "session": self.session}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateUnconfirmedSession", None]:
        if data:
            data_class = cls()
            data_class.session = data.get("session", None)

        return data_class


class UpdateAttachmentMenuBots(TlObject, Update):
    r"""The list of bots added to attachment or side menu has changed

    Parameters:
        bots (:class:`List["types.AttachmentMenuBot"]`):
            The new list of bots\. The bots must not be shown on scheduled messages screen

    """

    def __init__(self, bots: List[AttachmentMenuBot] = None) -> None:
        self.bots: List[AttachmentMenuBot] = bots or []
        r"""The new list of bots\. The bots must not be shown on scheduled messages screen"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateAttachmentMenuBots"]:
        return "updateAttachmentMenuBots"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "bots": self.bots}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateAttachmentMenuBots", None]:
        if data:
            data_class = cls()
            data_class.bots = data.get("bots", None)

        return data_class


class UpdateWebAppMessageSent(TlObject, Update):
    r"""A message was sent by an opened Web App, so the Web App needs to be closed

    Parameters:
        web_app_launch_id (:class:`int`):
            Identifier of Web App launch

    """

    def __init__(self, web_app_launch_id: int = 0) -> None:
        self.web_app_launch_id: int = int(web_app_launch_id)
        r"""Identifier of Web App launch"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateWebAppMessageSent"]:
        return "updateWebAppMessageSent"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "web_app_launch_id": self.web_app_launch_id}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateWebAppMessageSent", None]:
        if data:
            data_class = cls()
            data_class.web_app_launch_id = int(data.get("web_app_launch_id", 0))

        return data_class


class UpdateActiveEmojiReactions(TlObject, Update):
    r"""The list of active emoji reactions has changed

    Parameters:
        emojis (:class:`List[str]`):
            The new list of active emoji reactions

    """

    def __init__(self, emojis: List[str] = None) -> None:
        self.emojis: List[str] = emojis or []
        r"""The new list of active emoji reactions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateActiveEmojiReactions"]:
        return "updateActiveEmojiReactions"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emojis": self.emojis}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateActiveEmojiReactions", None]:
        if data:
            data_class = cls()
            data_class.emojis = data.get("emojis", None)

        return data_class


class UpdateAvailableMessageEffects(TlObject, Update):
    r"""The list of available message effects has changed

    Parameters:
        reaction_effect_ids (:class:`List[int]`):
            The new list of available message effects from emoji reactions

        sticker_effect_ids (:class:`List[int]`):
            The new list of available message effects from Premium stickers

    """

    def __init__(
        self,
        reaction_effect_ids: List[int] = None,
        sticker_effect_ids: List[int] = None,
    ) -> None:
        self.reaction_effect_ids: List[int] = reaction_effect_ids or []
        r"""The new list of available message effects from emoji reactions"""
        self.sticker_effect_ids: List[int] = sticker_effect_ids or []
        r"""The new list of available message effects from Premium stickers"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateAvailableMessageEffects"]:
        return "updateAvailableMessageEffects"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "reaction_effect_ids": self.reaction_effect_ids,
            "sticker_effect_ids": self.sticker_effect_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateAvailableMessageEffects", None]:
        if data:
            data_class = cls()
            data_class.reaction_effect_ids = data.get("reaction_effect_ids", None)
            data_class.sticker_effect_ids = data.get("sticker_effect_ids", None)

        return data_class


class UpdateDefaultReactionType(TlObject, Update):
    r"""The type of default reaction has changed

    Parameters:
        reaction_type (:class:`"types.ReactionType"`):
            The new type of the default reaction

    """

    def __init__(self, reaction_type: ReactionType = None) -> None:
        self.reaction_type: Union[
            ReactionTypeEmoji, ReactionTypeCustomEmoji, ReactionTypePaid, None
        ] = reaction_type
        r"""The new type of the default reaction"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateDefaultReactionType"]:
        return "updateDefaultReactionType"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "reaction_type": self.reaction_type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateDefaultReactionType", None]:
        if data:
            data_class = cls()
            data_class.reaction_type = data.get("reaction_type", None)

        return data_class


class UpdateDefaultPaidReactionType(TlObject, Update):
    r"""The type of default paid reaction has changed

    Parameters:
        type (:class:`"types.PaidReactionType"`):
            The new type of the default paid reaction

    """

    def __init__(self, type: PaidReactionType = None) -> None:
        self.type: Union[
            PaidReactionTypeRegular,
            PaidReactionTypeAnonymous,
            PaidReactionTypeChat,
            None,
        ] = type
        r"""The new type of the default paid reaction"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateDefaultPaidReactionType"]:
        return "updateDefaultPaidReactionType"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "type": self.type}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateDefaultPaidReactionType", None]:
        if data:
            data_class = cls()
            data_class.type = data.get("type", None)

        return data_class


class UpdateSavedMessagesTags(TlObject, Update):
    r"""Tags used in Saved Messages or a Saved Messages topic have changed

    Parameters:
        saved_messages_topic_id (:class:`int`):
            Identifier of Saved Messages topic which tags were changed; 0 if tags for the whole chat has changed

        tags (:class:`"types.SavedMessagesTags"`):
            The new tags

    """

    def __init__(
        self, saved_messages_topic_id: int = 0, tags: SavedMessagesTags = None
    ) -> None:
        self.saved_messages_topic_id: int = int(saved_messages_topic_id)
        r"""Identifier of Saved Messages topic which tags were changed; 0 if tags for the whole chat has changed"""
        self.tags: Union[SavedMessagesTags, None] = tags
        r"""The new tags"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSavedMessagesTags"]:
        return "updateSavedMessagesTags"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "saved_messages_topic_id": self.saved_messages_topic_id,
            "tags": self.tags,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSavedMessagesTags", None]:
        if data:
            data_class = cls()
            data_class.saved_messages_topic_id = int(
                data.get("saved_messages_topic_id", 0)
            )
            data_class.tags = data.get("tags", None)

        return data_class


class UpdateActiveLiveLocationMessages(TlObject, Update):
    r"""The list of messages with active live location that need to be updated by the application has changed\. The list is persistent across application restarts only if the message database is used

    Parameters:
        messages (:class:`List["types.Message"]`):
            The list of messages with active live locations

    """

    def __init__(self, messages: List[Message] = None) -> None:
        self.messages: List[Message] = messages or []
        r"""The list of messages with active live locations"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateActiveLiveLocationMessages"]:
        return "updateActiveLiveLocationMessages"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "messages": self.messages}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateActiveLiveLocationMessages", None]:
        if data:
            data_class = cls()
            data_class.messages = data.get("messages", None)

        return data_class


class UpdateOwnedStarCount(TlObject, Update):
    r"""The number of Telegram Stars owned by the current user has changed

    Parameters:
        star_amount (:class:`"types.StarAmount"`):
            The new amount of owned Telegram Stars

    """

    def __init__(self, star_amount: StarAmount = None) -> None:
        self.star_amount: Union[StarAmount, None] = star_amount
        r"""The new amount of owned Telegram Stars"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateOwnedStarCount"]:
        return "updateOwnedStarCount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "star_amount": self.star_amount}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateOwnedStarCount", None]:
        if data:
            data_class = cls()
            data_class.star_amount = data.get("star_amount", None)

        return data_class


class UpdateChatRevenueAmount(TlObject, Update):
    r"""The revenue earned from sponsored messages in a chat has changed\. If chat revenue screen is opened, then getChatRevenueTransactions may be called to fetch new transactions

    Parameters:
        chat_id (:class:`int`):
            Identifier of the chat

        revenue_amount (:class:`"types.ChatRevenueAmount"`):
            New amount of earned revenue

    """

    def __init__(
        self, chat_id: int = 0, revenue_amount: ChatRevenueAmount = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat"""
        self.revenue_amount: Union[ChatRevenueAmount, None] = revenue_amount
        r"""New amount of earned revenue"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatRevenueAmount"]:
        return "updateChatRevenueAmount"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "revenue_amount": self.revenue_amount,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatRevenueAmount", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.revenue_amount = data.get("revenue_amount", None)

        return data_class


class UpdateStarRevenueStatus(TlObject, Update):
    r"""The Telegram Star revenue earned by a bot or a chat has changed\. If Telegram Star transaction screen of the chat is opened, then getStarTransactions may be called to fetch new transactions

    Parameters:
        owner_id (:class:`"types.MessageSender"`):
            Identifier of the owner of the Telegram Stars

        status (:class:`"types.StarRevenueStatus"`):
            New Telegram Star revenue status

    """

    def __init__(
        self, owner_id: MessageSender = None, status: StarRevenueStatus = None
    ) -> None:
        self.owner_id: Union[MessageSenderUser, MessageSenderChat, None] = owner_id
        r"""Identifier of the owner of the Telegram Stars"""
        self.status: Union[StarRevenueStatus, None] = status
        r"""New Telegram Star revenue status"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateStarRevenueStatus"]:
        return "updateStarRevenueStatus"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "owner_id": self.owner_id,
            "status": self.status,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateStarRevenueStatus", None]:
        if data:
            data_class = cls()
            data_class.owner_id = data.get("owner_id", None)
            data_class.status = data.get("status", None)

        return data_class


class UpdateSpeechRecognitionTrial(TlObject, Update):
    r"""The parameters of speech recognition without Telegram Premium subscription has changed

    Parameters:
        max_media_duration (:class:`int`):
            The maximum allowed duration of media for speech recognition without Telegram Premium subscription, in seconds

        weekly_count (:class:`int`):
            The total number of allowed speech recognitions per week; 0 if none

        left_count (:class:`int`):
            Number of left speech recognition attempts this week

        next_reset_date (:class:`int`):
            Point in time \(Unix timestamp\) when the weekly number of tries will reset; 0 if unknown

    """

    def __init__(
        self,
        max_media_duration: int = 0,
        weekly_count: int = 0,
        left_count: int = 0,
        next_reset_date: int = 0,
    ) -> None:
        self.max_media_duration: int = int(max_media_duration)
        r"""The maximum allowed duration of media for speech recognition without Telegram Premium subscription, in seconds"""
        self.weekly_count: int = int(weekly_count)
        r"""The total number of allowed speech recognitions per week; 0 if none"""
        self.left_count: int = int(left_count)
        r"""Number of left speech recognition attempts this week"""
        self.next_reset_date: int = int(next_reset_date)
        r"""Point in time \(Unix timestamp\) when the weekly number of tries will reset; 0 if unknown"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSpeechRecognitionTrial"]:
        return "updateSpeechRecognitionTrial"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "max_media_duration": self.max_media_duration,
            "weekly_count": self.weekly_count,
            "left_count": self.left_count,
            "next_reset_date": self.next_reset_date,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSpeechRecognitionTrial", None]:
        if data:
            data_class = cls()
            data_class.max_media_duration = int(data.get("max_media_duration", 0))
            data_class.weekly_count = int(data.get("weekly_count", 0))
            data_class.left_count = int(data.get("left_count", 0))
            data_class.next_reset_date = int(data.get("next_reset_date", 0))

        return data_class


class UpdateDiceEmojis(TlObject, Update):
    r"""The list of supported dice emojis has changed

    Parameters:
        emojis (:class:`List[str]`):
            The new list of supported dice emojis

    """

    def __init__(self, emojis: List[str] = None) -> None:
        self.emojis: List[str] = emojis or []
        r"""The new list of supported dice emojis"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateDiceEmojis"]:
        return "updateDiceEmojis"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "emojis": self.emojis}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateDiceEmojis", None]:
        if data:
            data_class = cls()
            data_class.emojis = data.get("emojis", None)

        return data_class


class UpdateAnimatedEmojiMessageClicked(TlObject, Update):
    r"""Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen\. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        sticker (:class:`"types.Sticker"`):
            The animated sticker to be played

    """

    def __init__(
        self, chat_id: int = 0, message_id: int = 0, sticker: Sticker = None
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.sticker: Union[Sticker, None] = sticker
        r"""The animated sticker to be played"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateAnimatedEmojiMessageClicked"]:
        return "updateAnimatedEmojiMessageClicked"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "sticker": self.sticker,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateAnimatedEmojiMessageClicked", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.sticker = data.get("sticker", None)

        return data_class


class UpdateAnimationSearchParameters(TlObject, Update):
    r"""The parameters of animation search through getOption\(\"animation\_search\_bot\_username\"\) bot has changed

    Parameters:
        provider (:class:`str`):
            Name of the animation search provider

        emojis (:class:`List[str]`):
            The new list of emojis suggested for searching

    """

    def __init__(self, provider: str = "", emojis: List[str] = None) -> None:
        self.provider: Union[str, None] = provider
        r"""Name of the animation search provider"""
        self.emojis: List[str] = emojis or []
        r"""The new list of emojis suggested for searching"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateAnimationSearchParameters"]:
        return "updateAnimationSearchParameters"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "provider": self.provider,
            "emojis": self.emojis,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateAnimationSearchParameters", None]:
        if data:
            data_class = cls()
            data_class.provider = data.get("provider", "")
            data_class.emojis = data.get("emojis", None)

        return data_class


class UpdateSuggestedActions(TlObject, Update):
    r"""The list of suggested to the user actions has changed

    Parameters:
        added_actions (:class:`List["types.SuggestedAction"]`):
            Added suggested actions

        removed_actions (:class:`List["types.SuggestedAction"]`):
            Removed suggested actions

    """

    def __init__(
        self,
        added_actions: List[SuggestedAction] = None,
        removed_actions: List[SuggestedAction] = None,
    ) -> None:
        self.added_actions: List[SuggestedAction] = added_actions or []
        r"""Added suggested actions"""
        self.removed_actions: List[SuggestedAction] = removed_actions or []
        r"""Removed suggested actions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSuggestedActions"]:
        return "updateSuggestedActions"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "added_actions": self.added_actions,
            "removed_actions": self.removed_actions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSuggestedActions", None]:
        if data:
            data_class = cls()
            data_class.added_actions = data.get("added_actions", None)
            data_class.removed_actions = data.get("removed_actions", None)

        return data_class


class UpdateSpeedLimitNotification(TlObject, Update):
    r"""Download or upload file speed for the user was limited, but it can be restored by subscription to Telegram Premium\. The notification can be postponed until a being downloaded or uploaded file is visible to the user\. Use getOption\(\"premium\_download\_speedup\"\) or getOption\(\"premium\_upload\_speedup\"\) to get expected speedup after subscription to Telegram Premium

    Parameters:
        is_upload (:class:`bool`):
            True, if upload speed was limited; false, if download speed was limited

    """

    def __init__(self, is_upload: bool = False) -> None:
        self.is_upload: bool = bool(is_upload)
        r"""True, if upload speed was limited; false, if download speed was limited"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateSpeedLimitNotification"]:
        return "updateSpeedLimitNotification"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "is_upload": self.is_upload}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateSpeedLimitNotification", None]:
        if data:
            data_class = cls()
            data_class.is_upload = data.get("is_upload", False)

        return data_class


class UpdateContactCloseBirthdays(TlObject, Update):
    r"""The list of contacts that had birthdays recently or will have birthday soon has changed

    Parameters:
        close_birthday_users (:class:`List["types.CloseBirthdayUser"]`):
            List of contact users with close birthday

    """

    def __init__(self, close_birthday_users: List[CloseBirthdayUser] = None) -> None:
        self.close_birthday_users: List[CloseBirthdayUser] = close_birthday_users or []
        r"""List of contact users with close birthday"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateContactCloseBirthdays"]:
        return "updateContactCloseBirthdays"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "close_birthday_users": self.close_birthday_users,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateContactCloseBirthdays", None]:
        if data:
            data_class = cls()
            data_class.close_birthday_users = data.get("close_birthday_users", None)

        return data_class


class UpdateAutosaveSettings(TlObject, Update):
    r"""Autosave settings for some type of chats were updated

    Parameters:
        scope (:class:`"types.AutosaveSettingsScope"`):
            Type of chats for which autosave settings were updated

        settings (:class:`"types.ScopeAutosaveSettings"`):
            The new autosave settings; may be null if the settings are reset to default

    """

    def __init__(
        self,
        scope: AutosaveSettingsScope = None,
        settings: ScopeAutosaveSettings = None,
    ) -> None:
        self.scope: Union[
            AutosaveSettingsScopePrivateChats,
            AutosaveSettingsScopeGroupChats,
            AutosaveSettingsScopeChannelChats,
            AutosaveSettingsScopeChat,
            None,
        ] = scope
        r"""Type of chats for which autosave settings were updated"""
        self.settings: Union[ScopeAutosaveSettings, None] = settings
        r"""The new autosave settings; may be null if the settings are reset to default"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateAutosaveSettings"]:
        return "updateAutosaveSettings"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "scope": self.scope, "settings": self.settings}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateAutosaveSettings", None]:
        if data:
            data_class = cls()
            data_class.scope = data.get("scope", None)
            data_class.settings = data.get("settings", None)

        return data_class


class UpdateBusinessConnection(TlObject, Update):
    r"""A business connection has changed; for bots only

    Parameters:
        connection (:class:`"types.BusinessConnection"`):
            New data about the connection

    """

    def __init__(self, connection: BusinessConnection = None) -> None:
        self.connection: Union[BusinessConnection, None] = connection
        r"""New data about the connection"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateBusinessConnection"]:
        return "updateBusinessConnection"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "connection": self.connection}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateBusinessConnection", None]:
        if data:
            data_class = cls()
            data_class.connection = data.get("connection", None)

        return data_class


class UpdateNewBusinessMessage(TlObject, Update):
    r"""A new message was added to a business account; for bots only

    Parameters:
        connection_id (:class:`str`):
            Unique identifier of the business connection

        message (:class:`"types.BusinessMessage"`):
            The new message

    """

    def __init__(
        self, connection_id: str = "", message: BusinessMessage = None
    ) -> None:
        self.connection_id: Union[str, None] = connection_id
        r"""Unique identifier of the business connection"""
        self.message: Union[BusinessMessage, None] = message
        r"""The new message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewBusinessMessage"]:
        return "updateNewBusinessMessage"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "connection_id": self.connection_id,
            "message": self.message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewBusinessMessage", None]:
        if data:
            data_class = cls()
            data_class.connection_id = data.get("connection_id", "")
            data_class.message = data.get("message", None)

        return data_class


class UpdateBusinessMessageEdited(TlObject, Update):
    r"""A message in a business account was edited; for bots only

    Parameters:
        connection_id (:class:`str`):
            Unique identifier of the business connection

        message (:class:`"types.BusinessMessage"`):
            The edited message

    """

    def __init__(
        self, connection_id: str = "", message: BusinessMessage = None
    ) -> None:
        self.connection_id: Union[str, None] = connection_id
        r"""Unique identifier of the business connection"""
        self.message: Union[BusinessMessage, None] = message
        r"""The edited message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateBusinessMessageEdited"]:
        return "updateBusinessMessageEdited"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "connection_id": self.connection_id,
            "message": self.message,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateBusinessMessageEdited", None]:
        if data:
            data_class = cls()
            data_class.connection_id = data.get("connection_id", "")
            data_class.message = data.get("message", None)

        return data_class


class UpdateBusinessMessagesDeleted(TlObject, Update):
    r"""Messages in a business account were deleted; for bots only

    Parameters:
        connection_id (:class:`str`):
            Unique identifier of the business connection

        chat_id (:class:`int`):
            Identifier of a chat in the business account in which messages were deleted

        message_ids (:class:`List[int]`):
            Unique message identifiers of the deleted messages

    """

    def __init__(
        self, connection_id: str = "", chat_id: int = 0, message_ids: List[int] = None
    ) -> None:
        self.connection_id: Union[str, None] = connection_id
        r"""Unique identifier of the business connection"""
        self.chat_id: int = int(chat_id)
        r"""Identifier of a chat in the business account in which messages were deleted"""
        self.message_ids: List[int] = message_ids or []
        r"""Unique message identifiers of the deleted messages"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateBusinessMessagesDeleted"]:
        return "updateBusinessMessagesDeleted"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "connection_id": self.connection_id,
            "chat_id": self.chat_id,
            "message_ids": self.message_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateBusinessMessagesDeleted", None]:
        if data:
            data_class = cls()
            data_class.connection_id = data.get("connection_id", "")
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_ids = data.get("message_ids", None)

        return data_class


class UpdateNewInlineQuery(TlObject, Update):
    r"""A new incoming inline query; for bots only

    Parameters:
        id (:class:`int`):
            Unique query identifier

        sender_user_id (:class:`int`):
            Identifier of the user who sent the query

        user_location (:class:`"types.Location"`):
            User location; may be null

        chat_type (:class:`"types.ChatType"`):
            The type of the chat from which the query originated; may be null if unknown

        query (:class:`str`):
            Text of the query

        offset (:class:`str`):
            Offset of the first entry to return

    """

    def __init__(
        self,
        id: int = 0,
        sender_user_id: int = 0,
        user_location: Location = None,
        chat_type: ChatType = None,
        query: str = "",
        offset: str = "",
    ) -> None:
        self.id: int = int(id)
        r"""Unique query identifier"""
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user who sent the query"""
        self.user_location: Union[Location, None] = user_location
        r"""User location; may be null"""
        self.chat_type: Union[
            ChatTypePrivate,
            ChatTypeBasicGroup,
            ChatTypeSupergroup,
            ChatTypeSecret,
            None,
        ] = chat_type
        r"""The type of the chat from which the query originated; may be null if unknown"""
        self.query: Union[str, None] = query
        r"""Text of the query"""
        self.offset: Union[str, None] = offset
        r"""Offset of the first entry to return"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewInlineQuery"]:
        return "updateNewInlineQuery"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_user_id": self.sender_user_id,
            "user_location": self.user_location,
            "chat_type": self.chat_type,
            "query": self.query,
            "offset": self.offset,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewInlineQuery", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_user_id = int(data.get("sender_user_id", 0))
            data_class.user_location = data.get("user_location", None)
            data_class.chat_type = data.get("chat_type", None)
            data_class.query = data.get("query", "")
            data_class.offset = data.get("offset", "")

        return data_class


class UpdateNewChosenInlineResult(TlObject, Update):
    r"""The user has chosen a result of an inline query; for bots only

    Parameters:
        sender_user_id (:class:`int`):
            Identifier of the user who sent the query

        user_location (:class:`"types.Location"`):
            User location; may be null

        query (:class:`str`):
            Text of the query

        result_id (:class:`str`):
            Identifier of the chosen result

        inline_message_id (:class:`str`):
            Identifier of the sent inline message, if known

    """

    def __init__(
        self,
        sender_user_id: int = 0,
        user_location: Location = None,
        query: str = "",
        result_id: str = "",
        inline_message_id: str = "",
    ) -> None:
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user who sent the query"""
        self.user_location: Union[Location, None] = user_location
        r"""User location; may be null"""
        self.query: Union[str, None] = query
        r"""Text of the query"""
        self.result_id: Union[str, None] = result_id
        r"""Identifier of the chosen result"""
        self.inline_message_id: Union[str, None] = inline_message_id
        r"""Identifier of the sent inline message, if known"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewChosenInlineResult"]:
        return "updateNewChosenInlineResult"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "sender_user_id": self.sender_user_id,
            "user_location": self.user_location,
            "query": self.query,
            "result_id": self.result_id,
            "inline_message_id": self.inline_message_id,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewChosenInlineResult", None]:
        if data:
            data_class = cls()
            data_class.sender_user_id = int(data.get("sender_user_id", 0))
            data_class.user_location = data.get("user_location", None)
            data_class.query = data.get("query", "")
            data_class.result_id = data.get("result_id", "")
            data_class.inline_message_id = data.get("inline_message_id", "")

        return data_class


class UpdateNewCallbackQuery(TlObject, Update, CallbackQueryBoundMethods):
    r"""A new incoming callback query; for bots only

    Parameters:
        id (:class:`int`):
            Unique query identifier

        sender_user_id (:class:`int`):
            Identifier of the user who sent the query

        chat_id (:class:`int`):
            Identifier of the chat where the query was sent

        message_id (:class:`int`):
            Identifier of the message from which the query originated

        chat_instance (:class:`int`):
            Identifier that uniquely corresponds to the chat to which the message was sent

        payload (:class:`"types.CallbackQueryPayload"`):
            Query payload

    """

    def __init__(
        self,
        id: int = 0,
        sender_user_id: int = 0,
        chat_id: int = 0,
        message_id: int = 0,
        chat_instance: int = 0,
        payload: CallbackQueryPayload = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique query identifier"""
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user who sent the query"""
        self.chat_id: int = int(chat_id)
        r"""Identifier of the chat where the query was sent"""
        self.message_id: int = int(message_id)
        r"""Identifier of the message from which the query originated"""
        self.chat_instance: int = int(chat_instance)
        r"""Identifier that uniquely corresponds to the chat to which the message was sent"""
        self.payload: Union[
            CallbackQueryPayloadData,
            CallbackQueryPayloadDataWithPassword,
            CallbackQueryPayloadGame,
            None,
        ] = payload
        r"""Query payload"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewCallbackQuery"]:
        return "updateNewCallbackQuery"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_user_id": self.sender_user_id,
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "chat_instance": self.chat_instance,
            "payload": self.payload,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewCallbackQuery", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_user_id = int(data.get("sender_user_id", 0))
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.chat_instance = int(data.get("chat_instance", 0))
            data_class.payload = data.get("payload", None)

        return data_class


class UpdateNewInlineCallbackQuery(TlObject, Update):
    r"""A new incoming callback query from a message sent via a bot; for bots only

    Parameters:
        id (:class:`int`):
            Unique query identifier

        sender_user_id (:class:`int`):
            Identifier of the user who sent the query

        inline_message_id (:class:`str`):
            Identifier of the inline message from which the query originated

        chat_instance (:class:`int`):
            An identifier uniquely corresponding to the chat a message was sent to

        payload (:class:`"types.CallbackQueryPayload"`):
            Query payload

    """

    def __init__(
        self,
        id: int = 0,
        sender_user_id: int = 0,
        inline_message_id: str = "",
        chat_instance: int = 0,
        payload: CallbackQueryPayload = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique query identifier"""
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user who sent the query"""
        self.inline_message_id: Union[str, None] = inline_message_id
        r"""Identifier of the inline message from which the query originated"""
        self.chat_instance: int = int(chat_instance)
        r"""An identifier uniquely corresponding to the chat a message was sent to"""
        self.payload: Union[
            CallbackQueryPayloadData,
            CallbackQueryPayloadDataWithPassword,
            CallbackQueryPayloadGame,
            None,
        ] = payload
        r"""Query payload"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewInlineCallbackQuery"]:
        return "updateNewInlineCallbackQuery"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_user_id": self.sender_user_id,
            "inline_message_id": self.inline_message_id,
            "chat_instance": self.chat_instance,
            "payload": self.payload,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewInlineCallbackQuery", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_user_id = int(data.get("sender_user_id", 0))
            data_class.inline_message_id = data.get("inline_message_id", "")
            data_class.chat_instance = int(data.get("chat_instance", 0))
            data_class.payload = data.get("payload", None)

        return data_class


class UpdateNewBusinessCallbackQuery(TlObject, Update):
    r"""A new incoming callback query from a business message; for bots only

    Parameters:
        id (:class:`int`):
            Unique query identifier

        sender_user_id (:class:`int`):
            Identifier of the user who sent the query

        connection_id (:class:`str`):
            Unique identifier of the business connection

        message (:class:`"types.BusinessMessage"`):
            The message from the business account from which the query originated

        chat_instance (:class:`int`):
            An identifier uniquely corresponding to the chat a message was sent to

        payload (:class:`"types.CallbackQueryPayload"`):
            Query payload

    """

    def __init__(
        self,
        id: int = 0,
        sender_user_id: int = 0,
        connection_id: str = "",
        message: BusinessMessage = None,
        chat_instance: int = 0,
        payload: CallbackQueryPayload = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique query identifier"""
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user who sent the query"""
        self.connection_id: Union[str, None] = connection_id
        r"""Unique identifier of the business connection"""
        self.message: Union[BusinessMessage, None] = message
        r"""The message from the business account from which the query originated"""
        self.chat_instance: int = int(chat_instance)
        r"""An identifier uniquely corresponding to the chat a message was sent to"""
        self.payload: Union[
            CallbackQueryPayloadData,
            CallbackQueryPayloadDataWithPassword,
            CallbackQueryPayloadGame,
            None,
        ] = payload
        r"""Query payload"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewBusinessCallbackQuery"]:
        return "updateNewBusinessCallbackQuery"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_user_id": self.sender_user_id,
            "connection_id": self.connection_id,
            "message": self.message,
            "chat_instance": self.chat_instance,
            "payload": self.payload,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewBusinessCallbackQuery", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_user_id = int(data.get("sender_user_id", 0))
            data_class.connection_id = data.get("connection_id", "")
            data_class.message = data.get("message", None)
            data_class.chat_instance = int(data.get("chat_instance", 0))
            data_class.payload = data.get("payload", None)

        return data_class


class UpdateNewShippingQuery(TlObject, Update):
    r"""A new incoming shipping query; for bots only\. Only for invoices with flexible price

    Parameters:
        id (:class:`int`):
            Unique query identifier

        sender_user_id (:class:`int`):
            Identifier of the user who sent the query

        invoice_payload (:class:`str`):
            Invoice payload

        shipping_address (:class:`"types.Address"`):
            User shipping address

    """

    def __init__(
        self,
        id: int = 0,
        sender_user_id: int = 0,
        invoice_payload: str = "",
        shipping_address: Address = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique query identifier"""
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user who sent the query"""
        self.invoice_payload: Union[str, None] = invoice_payload
        r"""Invoice payload"""
        self.shipping_address: Union[Address, None] = shipping_address
        r"""User shipping address"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewShippingQuery"]:
        return "updateNewShippingQuery"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_user_id": self.sender_user_id,
            "invoice_payload": self.invoice_payload,
            "shipping_address": self.shipping_address,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewShippingQuery", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_user_id = int(data.get("sender_user_id", 0))
            data_class.invoice_payload = data.get("invoice_payload", "")
            data_class.shipping_address = data.get("shipping_address", None)

        return data_class


class UpdateNewPreCheckoutQuery(TlObject, Update):
    r"""A new incoming pre\-checkout query; for bots only\. Contains full information about a checkout

    Parameters:
        id (:class:`int`):
            Unique query identifier

        sender_user_id (:class:`int`):
            Identifier of the user who sent the query

        currency (:class:`str`):
            Currency for the product price

        total_amount (:class:`int`):
            Total price for the product, in the smallest units of the currency

        invoice_payload (:class:`bytes`):
            Invoice payload

        shipping_option_id (:class:`str`):
            Identifier of a shipping option chosen by the user; may be empty if not applicable

        order_info (:class:`"types.OrderInfo"`):
            Information about the order; may be null

    """

    def __init__(
        self,
        id: int = 0,
        sender_user_id: int = 0,
        currency: str = "",
        total_amount: int = 0,
        invoice_payload: bytes = b"",
        shipping_option_id: str = "",
        order_info: OrderInfo = None,
    ) -> None:
        self.id: int = int(id)
        r"""Unique query identifier"""
        self.sender_user_id: int = int(sender_user_id)
        r"""Identifier of the user who sent the query"""
        self.currency: Union[str, None] = currency
        r"""Currency for the product price"""
        self.total_amount: int = int(total_amount)
        r"""Total price for the product, in the smallest units of the currency"""
        self.invoice_payload: Union[bytes, None] = invoice_payload
        r"""Invoice payload"""
        self.shipping_option_id: Union[str, None] = shipping_option_id
        r"""Identifier of a shipping option chosen by the user; may be empty if not applicable"""
        self.order_info: Union[OrderInfo, None] = order_info
        r"""Information about the order; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewPreCheckoutQuery"]:
        return "updateNewPreCheckoutQuery"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "sender_user_id": self.sender_user_id,
            "currency": self.currency,
            "total_amount": self.total_amount,
            "invoice_payload": self.invoice_payload,
            "shipping_option_id": self.shipping_option_id,
            "order_info": self.order_info,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewPreCheckoutQuery", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.sender_user_id = int(data.get("sender_user_id", 0))
            data_class.currency = data.get("currency", "")
            data_class.total_amount = int(data.get("total_amount", 0))
            data_class.invoice_payload = b64decode(data.get("invoice_payload", b""))
            data_class.shipping_option_id = data.get("shipping_option_id", "")
            data_class.order_info = data.get("order_info", None)

        return data_class


class UpdateNewCustomEvent(TlObject, Update):
    r"""A new incoming event; for bots only

    Parameters:
        event (:class:`str`):
            A JSON\-serialized event

    """

    def __init__(self, event: str = "") -> None:
        self.event: Union[str, None] = event
        r"""A JSON\-serialized event"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewCustomEvent"]:
        return "updateNewCustomEvent"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "event": self.event}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewCustomEvent", None]:
        if data:
            data_class = cls()
            data_class.event = data.get("event", "")

        return data_class


class UpdateNewCustomQuery(TlObject, Update):
    r"""A new incoming query; for bots only

    Parameters:
        id (:class:`int`):
            The query identifier

        data (:class:`str`):
            JSON\-serialized query data

        timeout (:class:`int`):
            Query timeout

    """

    def __init__(self, id: int = 0, data: str = "", timeout: int = 0) -> None:
        self.id: int = int(id)
        r"""The query identifier"""
        self.data: Union[str, None] = data
        r"""JSON\-serialized query data"""
        self.timeout: int = int(timeout)
        r"""Query timeout"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewCustomQuery"]:
        return "updateNewCustomQuery"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "id": self.id,
            "data": self.data,
            "timeout": self.timeout,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewCustomQuery", None]:
        if data:
            data_class = cls()
            data_class.id = int(data.get("id", 0))
            data_class.data = data.get("data", "")
            data_class.timeout = int(data.get("timeout", 0))

        return data_class


class UpdatePoll(TlObject, Update):
    r"""A poll was updated; for bots only

    Parameters:
        poll (:class:`"types.Poll"`):
            New data about the poll

    """

    def __init__(self, poll: Poll = None) -> None:
        self.poll: Union[Poll, None] = poll
        r"""New data about the poll"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updatePoll"]:
        return "updatePoll"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "poll": self.poll}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdatePoll", None]:
        if data:
            data_class = cls()
            data_class.poll = data.get("poll", None)

        return data_class


class UpdatePollAnswer(TlObject, Update):
    r"""A user changed the answer to a poll; for bots only

    Parameters:
        poll_id (:class:`int`):
            Unique poll identifier

        voter_id (:class:`"types.MessageSender"`):
            Identifier of the message sender that changed the answer to the poll

        option_ids (:class:`List[int]`):
            0\-based identifiers of answer options, chosen by the user

    """

    def __init__(
        self,
        poll_id: int = 0,
        voter_id: MessageSender = None,
        option_ids: List[int] = None,
    ) -> None:
        self.poll_id: int = int(poll_id)
        r"""Unique poll identifier"""
        self.voter_id: Union[MessageSenderUser, MessageSenderChat, None] = voter_id
        r"""Identifier of the message sender that changed the answer to the poll"""
        self.option_ids: List[int] = option_ids or []
        r"""0\-based identifiers of answer options, chosen by the user"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updatePollAnswer"]:
        return "updatePollAnswer"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "poll_id": self.poll_id,
            "voter_id": self.voter_id,
            "option_ids": self.option_ids,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdatePollAnswer", None]:
        if data:
            data_class = cls()
            data_class.poll_id = int(data.get("poll_id", 0))
            data_class.voter_id = data.get("voter_id", None)
            data_class.option_ids = data.get("option_ids", None)

        return data_class


class UpdateChatMember(TlObject, Update):
    r"""User rights changed in a chat; for bots only

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        actor_user_id (:class:`int`):
            Identifier of the user, changing the rights

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the user rights were changed

        invite_link (:class:`"types.ChatInviteLink"`):
            If user has joined the chat using an invite link, the invite link; may be null

        via_join_request (:class:`bool`):
            True, if the user has joined the chat after sending a join request and being approved by an administrator

        via_chat_folder_invite_link (:class:`bool`):
            True, if the user has joined the chat using an invite link for a chat folder

        old_chat_member (:class:`"types.ChatMember"`):
            Previous chat member

        new_chat_member (:class:`"types.ChatMember"`):
            New chat member

    """

    def __init__(
        self,
        chat_id: int = 0,
        actor_user_id: int = 0,
        date: int = 0,
        invite_link: ChatInviteLink = None,
        via_join_request: bool = False,
        via_chat_folder_invite_link: bool = False,
        old_chat_member: ChatMember = None,
        new_chat_member: ChatMember = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.actor_user_id: int = int(actor_user_id)
        r"""Identifier of the user, changing the rights"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the user rights were changed"""
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""If user has joined the chat using an invite link, the invite link; may be null"""
        self.via_join_request: bool = bool(via_join_request)
        r"""True, if the user has joined the chat after sending a join request and being approved by an administrator"""
        self.via_chat_folder_invite_link: bool = bool(via_chat_folder_invite_link)
        r"""True, if the user has joined the chat using an invite link for a chat folder"""
        self.old_chat_member: Union[ChatMember, None] = old_chat_member
        r"""Previous chat member"""
        self.new_chat_member: Union[ChatMember, None] = new_chat_member
        r"""New chat member"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatMember"]:
        return "updateChatMember"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "actor_user_id": self.actor_user_id,
            "date": self.date,
            "invite_link": self.invite_link,
            "via_join_request": self.via_join_request,
            "via_chat_folder_invite_link": self.via_chat_folder_invite_link,
            "old_chat_member": self.old_chat_member,
            "new_chat_member": self.new_chat_member,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatMember", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.actor_user_id = int(data.get("actor_user_id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.invite_link = data.get("invite_link", None)
            data_class.via_join_request = data.get("via_join_request", False)
            data_class.via_chat_folder_invite_link = data.get(
                "via_chat_folder_invite_link", False
            )
            data_class.old_chat_member = data.get("old_chat_member", None)
            data_class.new_chat_member = data.get("new_chat_member", None)

        return data_class


class UpdateNewChatJoinRequest(TlObject, Update):
    r"""A user sent a join request to a chat; for bots only

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        request (:class:`"types.ChatJoinRequest"`):
            Join request

        user_chat_id (:class:`int`):
            Chat identifier of the private chat with the user

        invite_link (:class:`"types.ChatInviteLink"`):
            The invite link, which was used to send join request; may be null

    """

    def __init__(
        self,
        chat_id: int = 0,
        request: ChatJoinRequest = None,
        user_chat_id: int = 0,
        invite_link: ChatInviteLink = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.request: Union[ChatJoinRequest, None] = request
        r"""Join request"""
        self.user_chat_id: int = int(user_chat_id)
        r"""Chat identifier of the private chat with the user"""
        self.invite_link: Union[ChatInviteLink, None] = invite_link
        r"""The invite link, which was used to send join request; may be null"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateNewChatJoinRequest"]:
        return "updateNewChatJoinRequest"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "request": self.request,
            "user_chat_id": self.user_chat_id,
            "invite_link": self.invite_link,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateNewChatJoinRequest", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.request = data.get("request", None)
            data_class.user_chat_id = int(data.get("user_chat_id", 0))
            data_class.invite_link = data.get("invite_link", None)

        return data_class


class UpdateChatBoost(TlObject, Update):
    r"""A chat boost has changed; for bots only

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        boost (:class:`"types.ChatBoost"`):
            New information about the boost

    """

    def __init__(self, chat_id: int = 0, boost: ChatBoost = None) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.boost: Union[ChatBoost, None] = boost
        r"""New information about the boost"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateChatBoost"]:
        return "updateChatBoost"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "chat_id": self.chat_id, "boost": self.boost}

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateChatBoost", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.boost = data.get("boost", None)

        return data_class


class UpdateMessageReaction(TlObject, Update):
    r"""User changed its reactions on a message with public reactions; for bots only

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        actor_id (:class:`"types.MessageSender"`):
            Identifier of the user or chat that changed reactions

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the reactions were changed

        old_reaction_types (:class:`List["types.ReactionType"]`):
            Old list of chosen reactions

        new_reaction_types (:class:`List["types.ReactionType"]`):
            New list of chosen reactions

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_id: int = 0,
        actor_id: MessageSender = None,
        date: int = 0,
        old_reaction_types: List[ReactionType] = None,
        new_reaction_types: List[ReactionType] = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.actor_id: Union[MessageSenderUser, MessageSenderChat, None] = actor_id
        r"""Identifier of the user or chat that changed reactions"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the reactions were changed"""
        self.old_reaction_types: List[ReactionType] = old_reaction_types or []
        r"""Old list of chosen reactions"""
        self.new_reaction_types: List[ReactionType] = new_reaction_types or []
        r"""New list of chosen reactions"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageReaction"]:
        return "updateMessageReaction"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "actor_id": self.actor_id,
            "date": self.date,
            "old_reaction_types": self.old_reaction_types,
            "new_reaction_types": self.new_reaction_types,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageReaction", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.actor_id = data.get("actor_id", None)
            data_class.date = int(data.get("date", 0))
            data_class.old_reaction_types = data.get("old_reaction_types", None)
            data_class.new_reaction_types = data.get("new_reaction_types", None)

        return data_class


class UpdateMessageReactions(TlObject, Update):
    r"""Reactions added to a message with anonymous reactions have changed; for bots only

    Parameters:
        chat_id (:class:`int`):
            Chat identifier

        message_id (:class:`int`):
            Message identifier

        date (:class:`int`):
            Point in time \(Unix timestamp\) when the reactions were changed

        reactions (:class:`List["types.MessageReaction"]`):
            The list of reactions added to the message

    """

    def __init__(
        self,
        chat_id: int = 0,
        message_id: int = 0,
        date: int = 0,
        reactions: List[MessageReaction] = None,
    ) -> None:
        self.chat_id: int = int(chat_id)
        r"""Chat identifier"""
        self.message_id: int = int(message_id)
        r"""Message identifier"""
        self.date: int = int(date)
        r"""Point in time \(Unix timestamp\) when the reactions were changed"""
        self.reactions: List[MessageReaction] = reactions or []
        r"""The list of reactions added to the message"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updateMessageReactions"]:
        return "updateMessageReactions"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "chat_id": self.chat_id,
            "message_id": self.message_id,
            "date": self.date,
            "reactions": self.reactions,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdateMessageReactions", None]:
        if data:
            data_class = cls()
            data_class.chat_id = int(data.get("chat_id", 0))
            data_class.message_id = int(data.get("message_id", 0))
            data_class.date = int(data.get("date", 0))
            data_class.reactions = data.get("reactions", None)

        return data_class


class UpdatePaidMediaPurchased(TlObject, Update):
    r"""Paid media were purchased by a user; for bots only

    Parameters:
        user_id (:class:`int`):
            User identifier

        payload (:class:`str`):
            Bot\-specified payload for the paid media

    """

    def __init__(self, user_id: int = 0, payload: str = "") -> None:
        self.user_id: int = int(user_id)
        r"""User identifier"""
        self.payload: Union[str, None] = payload
        r"""Bot\-specified payload for the paid media"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updatePaidMediaPurchased"]:
        return "updatePaidMediaPurchased"

    def getClass(self) -> Literal["Update"]:
        return "Update"

    def to_dict(self) -> dict:
        return {
            "@type": self.getType(),
            "user_id": self.user_id,
            "payload": self.payload,
        }

    @classmethod
    def from_dict(cls, data: dict) -> Union["UpdatePaidMediaPurchased", None]:
        if data:
            data_class = cls()
            data_class.user_id = int(data.get("user_id", 0))
            data_class.payload = data.get("payload", "")

        return data_class


class Updates(TlObject):
    r"""Contains a list of updates

    Parameters:
        updates (:class:`List["types.Update"]`):
            List of updates

    """

    def __init__(self, updates: List[Update] = None) -> None:
        self.updates: List[Update] = updates or []
        r"""List of updates"""

    def __str__(self):
        return str(pytdbot.utils.obj_to_json(self, indent=4))

    def getType(self) -> Literal["updates"]:
        return "updates"

    def getClass(self) -> Literal["Updates"]:
        return "Updates"

    def to_dict(self) -> dict:
        return {"@type": self.getType(), "updates": self.updates}

    @classmethod
    def from_dict(cls, data: dict) -> Union["Updates", None]:
        if data:
            data_class = cls()
            data_class.updates = data.get("updates", None)

        return data_class
